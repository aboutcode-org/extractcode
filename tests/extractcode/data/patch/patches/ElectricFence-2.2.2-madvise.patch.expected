[('ElectricFence-2.2.2/page.c.jj',
  'ElectricFence-2.2.2/page.c',
  '--- ElectricFence-2.2.2/page.c.jj\n+++ ElectricFence-2.2.2/page.c\n@@ -160,8 +160,9 @@ Page_DenyAccess(void * address, size_t s\nvoid\nPage_Delete(void * address, size_t size)\n{\n-\tif ( munmap((caddr_t)address, size) < 0 )\n-\t\tPage_DenyAccess(address, size);\n+\tPage_DenyAccess(address, size);\n+\t/* Tell the kernel we will never need it again.  */\n+\tmadvise(address, size, MADV_DONTNEED);\n}\n\n#if defined(_SC_PAGESIZE)'),
 ('ElectricFence-2.2.2/efence.c.jj',
  'ElectricFence-2.2.2/efence.c',
  '--- ElectricFence-2.2.2/efence.c.jj\n+++ ElectricFence-2.2.2/efence.c\n@@ -626,10 +626,7 @@ memalign(size_t alignment, size_t userSi\naddress += internalSize - bytesPerPage;\n\n/* Set up the "dead" page. */\n-\t\tif ( EF_PROTECT_FREE )\n-\t\t\tPage_Delete(address, bytesPerPage);\n-\t\telse\n-\t\t\tPage_DenyAccess(address, bytesPerPage);\n+\t\tPage_Delete(address, bytesPerPage);\n\n/* Figure out what address to give the user. */\naddress -= userSize;\n@@ -643,11 +640,8 @@ memalign(size_t alignment, size_t userSi\naddress = (char *)fullSlot->internalAddress;\n\n/* Set up the "dead" page. */\n-\t\tif ( EF_PROTECT_FREE )\n-\t\t\tPage_Delete(address, bytesPerPage);\n-\t\telse\n-\t\t\tPage_DenyAccess(address, bytesPerPage);\n-\n+\t\tPage_Delete(address, bytesPerPage);\n+\naddress += bytesPerPage;\n\n/* Set up the "live" page. */\n@@ -777,10 +771,7 @@ free(void * address)\n* in the hope that the swap space attached to those pages will be\n* released as well.\n*/\n-\tif ( EF_PROTECT_FREE )\n-\t    Page_Delete(slot->internalAddress, slot->internalSize);\n-\telse\n-\t    Page_DenyAccess(slot->internalAddress, slot->internalSize);\n+\tPage_Delete(slot->internalAddress, slot->internalSize);\n\npreviousSlot = slotForInternalAddressPreviousTo(slot->internalAddress);\nnextSlot = slotForInternalAddress(')]