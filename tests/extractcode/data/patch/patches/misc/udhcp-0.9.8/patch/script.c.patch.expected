[('udhcp-0.9.8.orig/script.c',
  'udhcp-0.9.8/script.c',
  'Index: udhcp-0.9.8/script.c\n===================================================================\n--- udhcp-0.9.8.orig/script.c\n+++ udhcp-0.9.8/script.c\n@@ -41,6 +41,7 @@\nstatic int max_option_length[] = {\n[OPTION_IP] =\t\tsizeof("255.255.255.255 "),\n[OPTION_IP_PAIR] =\tsizeof("255.255.255.255 ") * 2,\n+\t[OPTION_ROUTE] =\tsizeof("255.255.255.255 ") * 3,\n[OPTION_STRING] =\t1,\n[OPTION_BOOLEAN] =\tsizeof("yes "),\n[OPTION_U8] =\t\tsizeof("255 "),\n@@ -59,7 +60,32 @@ static int upper_length(int length, stru\n\n\nstatic int sprintip(char *dest, char *pre, unsigned char *ip) {\n-\treturn sprintf(dest, "%s%d.%d.%d.%d ", pre, ip[0], ip[1], ip[2], ip[3]);\n+\treturn sprintf(dest, "%s%d.%d.%d.%d", pre, ip[0], ip[1], ip[2], ip[3]);\n+}\n+\n+\n+static int sprintroute(char *dest, unsigned char *route) {\n+ \tint dest_length = (route[0] >> 3) + !!(route[0] & 7);\n+ \tunsigned char* router = route + dest_length + 1;\n+ \tunsigned char ip[4];\n+ \tunsigned char netmask[4];\n+ \tunsigned int* temp = (unsigned int*)netmask;\n+ \tint i;\n+ \tfor (i = 0; i < 4; ++i) {\n+ \t\tif (i < dest_length) {\n+ \t\t\tip[i] = route[i + 1];\n+ \t\t} else {\n+ \t\t\tip[i] = 0;\n+ \t\t}\n+ \t\tnetmask[i] = 0;\n+ \t}\n+ \tfor (i = 0; i < route[0]; ++i) {\n+ \t\t*temp |= (1L << i);\n+ \t}\n+ \treturn sprintf(dest, "%d.%d.%d.%d/%d.%d.%d.%d/%d.%d.%d.%d ",\n+ \t\t       ip[0], ip[1], ip[2], ip[3],\n+ \t\t       router[0], router[1], router[2], router[3],\n+ \t\t       netmask[0], netmask[1], netmask[2], netmask[3]);\n}\n\n\n@@ -83,9 +109,15 @@ static void fill_options(char *dest, uns\ndest += sprintip(dest, "", option);\n*(dest++) = \'/\';\noption += 4;\n+\t\t\tlen -= 4;\noptlen = 4;\ncase OPTION_IP:\t/* Works regardless of host byte order. */\ndest += sprintip(dest, "", option);\n+\t\t\t*(dest++) = \' \';\n+ \t\t\tbreak;\n+\t\tcase OPTION_ROUTE:\n+\t\t\tdest += sprintroute(dest, option);\n+\t\t\toptlen = 1 + (option[0] >> 3) + !!(option[0] & 7) + 4;\nbreak;\ncase OPTION_BOOLEAN:\ndest += sprintf(dest, *option ? "yes " : "no ");\n@@ -118,6 +150,8 @@ static void fill_options(char *dest, uns\nlen -= optlen;\nif (len <= 0) break;\n}\n+\t/* Remove last space */\n+\t*(dest - 1) = \'\\0\';\n}\n\n\n@@ -147,9 +181,27 @@ static char **fill_envp(struct dhcpMessa\nif (packet == NULL)\nnum_options = 0;\nelse {\n-\t\tfor (i = 0; options[i].code; i++)\n-\t\t\tif (get_option(packet, options[i].code))\n-\t\t\t\tnum_options++;\n+\t\tfor (i = 0; options[i].code; i++) {\n+                        if ((temp = get_option(packet, options[i].code))) {\n+                                if (options[i].code == 43) {\n+                                        u_int8_t total_length = *(temp - 1);\n+                                        while (total_length > 0) {\n+                                                temp++;\n+                                                u_int8_t option_length = *temp++;\n+                                                if (option_length > total_length) {\n+                                                        LOG(LOG_WARNING, "option 43 field too long.");\n+                                                        break;\n+                                                }\n+                                                total_length -= option_length + 2;\n+                                                temp += option_length;\n+                                                num_options++;\n+                                        }\n+                                }\n+                                else {\n+                                        num_options++;\n+                                }\n+                        }\n+                }\nif (packet->siaddr) num_options++;\nif ((temp = get_option(packet, DHCP_OPTION_OVER)))\nover = *temp;\n@@ -157,24 +209,57 @@ static char **fill_envp(struct dhcpMessa\nif (!(over & SNAME_FIELD) && packet->sname[0]) num_options++;\n}\n\n-\tenvp = xmalloc((num_options + 5) * sizeof(char *));\n+\tenvp = xmalloc((num_options + 6) * sizeof(char *));\nenvp[0] = xmalloc(sizeof("interface=") + strlen(client_config.interface));\nsprintf(envp[0], "interface=%s", client_config.interface);\nenvp[1] = find_env("PATH", "PATH=/bin:/usr/bin:/sbin:/usr/sbin");\nenvp[2] = find_env("HOME", "HOME=/");\n\n+\tj = 3;\n+\tif (client_config.address_renewal_behaviour) {\n+\t  envp[j] = xmalloc(sizeof("address_renewal_behaviour=0"));\n+\t  sprintf(envp[j++], "address_renewal_behaviour=%d", client_config.address_renewal_behaviour);\n+\t}\n+\nif (packet == NULL) {\n-\t\tenvp[3] = NULL;\n+\t\tenvp[j] = NULL;\nreturn envp;\n}\n\n-\tenvp[3] = xmalloc(sizeof("ip=255.255.255.255"));\n-\tsprintip(envp[3], "ip=", (unsigned char *) &packet->yiaddr);\n-\tfor (i = 0, j = 4; options[i].code; i++) {\n+\tenvp[j] = xmalloc(sizeof("ip=255.255.255.255"));\n+\tsprintip(envp[j++], "ip=", (unsigned char *) &packet->yiaddr);\n+\tfor (i = 0; options[i].code; i++) {\nif ((temp = get_option(packet, options[i].code))) {\n-\t\t\tenvp[j] = xmalloc(upper_length(temp[OPT_LEN - 2], &options[i]) + strlen(options[i].name) + 2);\n-\t\t\tfill_options(envp[j], temp, &options[i]);\n-\t\t\tj++;\n+                        if (options[i].code == 43) {\n+                                u_int8_t total_length = *(temp - 1);\n+                                while (total_length > 0) {\n+                                        u_int8_t code = *temp++;\n+                                        u_int8_t option_length = *temp++;\n+                                        if (option_length > total_length) {\n+                                                LOG(LOG_WARNING, "option 43 field too long.");\n+                                                break;\n+                                        }\n+                                        envp[j] = xmalloc(13 + option_length + 1);\n+                                        char* dest = envp[j];\n+                                        dest += sprintf(dest, "option43_%03u=", code);\n+                                        memcpy(dest, temp, option_length);\n+                                        dest[option_length] = \'\\0\';\n+                                        temp += option_length;\n+                                        total_length -= option_length + 2;\n+                                        j++;\n+                                }\n+                        }\n+                        else if (options[i].code == 125) {\n+                          // skip exporting this to env. Already\n+                          // parsed in parse_gatewayidentity in clientpacket.c\n+                          // j++; // Fixed BUGZ:12095, should not increase j for skip exporting.\n+                        }\n+                        else {\n+                                envp[j] = xmalloc(upper_length(temp[OPT_LEN - 2],\n+                                                               &options[i]) + strlen(options[i].name) + 2);\n+                                fill_options(envp[j], temp, &options[i]);\n+                                j++;\n+                        }\n}\n}\nif (packet->siaddr) {')]