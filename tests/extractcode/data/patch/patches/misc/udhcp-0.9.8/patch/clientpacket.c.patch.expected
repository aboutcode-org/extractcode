[('udhcp-0.9.8.orig/clientpacket.c',
  'udhcp-0.9.8/clientpacket.c',
  'Index: udhcp-0.9.8/clientpacket.c\n===================================================================\n--- udhcp-0.9.8.orig/clientpacket.c\n+++ udhcp-0.9.8/clientpacket.c\n@@ -18,7 +18,8 @@\n* along with this program; if not, write to the Free Software\n* Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n*/\n-\n+\n+#include <stdio.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <features.h>\n@@ -39,7 +40,7 @@\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n-\n+#include <libgen.h>\n\n#include "dhcpd.h"\n#include "packet.h"\n@@ -47,6 +48,26 @@\n#include "dhcpc.h"\n#include "debug.h"\n\n+#include "clientpacket.h"\n+\n+#define DEVICE_SN TESTDIR "/proc/usp/3"\n+#define GATEWAY_MANUFACTURER TESTDIR "/flash/common/gwmanufactureroui"\n+#define GATEWAY_SERIALNUMBER TESTDIR "/flash/common/gwserialnumber"\n+#define GATEWAY_PRODUCTCLASS TESTDIR "/flash/common/gwproductclass"\n+\n+#define SUBOPT_DEVICE_MANUFACTURER_OUI 1\n+#define SUBOPT_DEVICE_SERIAL_NUMBER 2\n+#define SUBOPT_DEVICE_PRODUCT_CLASS 3\n+#define SUBOPT_GATEWAY_MANUFACTURER_OUI 4\n+#define SUBOPT_GATEWAY_SERIAL_NUMBER 5\n+#define SUBOPT_GATEWAY_PRODUCT_CLASS 6\n+\n+#define SUBOPT_CODE 0\n+#define SUBOPT_LEN 1\n+#define SUBOPT_DATA 2\n+#define SUBOPT_HDRLEN 2\n+\n+#define ENTERPRISE_ADSL_FORUM 3561\n\n/* Create a random xid */\nunsigned long random_xid(void)\n@@ -65,7 +86,7 @@ unsigned long random_xid(void)\nif (fd >= 0) close(fd);\nsrand(seed);\ninitialized++;\n-\t}\n+\t}\nreturn rand();\n}\n\n@@ -73,18 +94,43 @@ unsigned long random_xid(void)\n/* initialize a packet with the proper defaults */\nstatic void init_packet(struct dhcpMessage *packet, char type)\n{\n-\tstruct vendor  {\n-\t\tchar vendor, length;\n-\t\tchar str[sizeof("udhcp "VERSION)];\n-\t} vendor_id = { DHCP_VENDOR,  sizeof("udhcp "VERSION) - 1, "udhcp "VERSION};\n-\ninit_header(packet, type);\nmemcpy(packet->chaddr, client_config.arp, 6);\nadd_option_string(packet->options, client_config.clientid);\n+\tif (client_config.userclientid) add_user_class_option(packet->options, client_config.userclientid);\nif (client_config.hostname) add_option_string(packet->options, client_config.hostname);\n-\tadd_option_string(packet->options, (unsigned char *) &vendor_id);\n}\n\n+void sort_request_route_option(u_int8_t *reqOptions, int reqOptionsLen)\n+{\n+\t// The Classless Static Routes option code MUST appear in the parameter\n+  // request list prior to both the Router option code and the Static\n+  // Routes option code, if present.[RFC 3442]\n+\tint rp, srp, crp, i;\n+\tu_int8_t temp;\n+\n+\trp = srp = crp = -1;\n+\tfor (i = 0; i<reqOptionsLen; i++)\n+\t{\n+\t\tif (reqOptions[i] == 0x3)\n+\t\t\trp = i;\n+\t\tif (reqOptions[i] == 0x21)\n+\t\t\tsrp = i;\n+\t\tif (reqOptions[i] == 0x79)\n+\t\t\tcrp = i;\n+\t}\n+\n+\tif((rp >= 0) && (crp >= 0)) {\n+\t\ttemp = reqOptions[rp];\n+    reqOptions[rp] = reqOptions[crp];\n+    reqOptions[crp] = temp;\n+\t}\n+\telse if((srp >= 0) && (crp >= 0)) {\n+\t\ttemp = reqOptions[srp];\n+    reqOptions[srp] = reqOptions[crp];\n+    reqOptions[crp] = temp;\n+\t}\n+}\n\n/* Add a paramater request list for stubborn DHCP servers. Pull the data\n* from the struct in options.c. Don\'t do bounds checking here because it\n@@ -98,21 +144,27 @@ static void add_requests(struct dhcpMess\nfor (i = 0; options[i].code; i++)\nif (options[i].flags & OPTION_REQ)\npacket->options[end + OPT_DATA + len++] = options[i].code;\n+\tsort_request_route_option((u_int8_t *)(packet->options + end + OPT_DATA), len);\npacket->options[end + OPT_LEN] = len;\npacket->options[end + OPT_DATA + len] = DHCP_END;\n\n}\n\n-\n/* Broadcast a DHCP discover packet to the network, with an optionally requested IP */\nint send_discover(unsigned long xid, unsigned long requested)\n{\nstruct dhcpMessage packet;\n-\n+\ninit_packet(&packet, DHCPDISCOVER);\npacket.xid = xid;\nif (requested)\nadd_simple_option(packet.options, DHCP_REQUESTED_IP, requested);\n+\tif (client_config.leasetime) {\n+\t  add_simple_option(packet.options, DHCP_LEASE_TIME,\n+\t\t\t    client_config.leasetime);\n+\t}\n+        add_simple_option(packet.options, DHCP_MAX_SIZE, htons(sizeof(struct udp_dhcp_packet)));\n+        add_deviceidentity(&packet);\n\nadd_requests(&packet);\nLOG(LOG_DEBUG, "Sending discover...");\n@@ -132,6 +184,12 @@ int send_selecting(unsigned long xid, un\n\nadd_simple_option(packet.options, DHCP_REQUESTED_IP, requested);\nadd_simple_option(packet.options, DHCP_SERVER_ID, server);\n+\tif (client_config.leasetime) {\n+\t  add_simple_option(packet.options, DHCP_LEASE_TIME,\n+\t\t\t    client_config.leasetime);\n+\t}\n+        add_simple_option(packet.options, DHCP_MAX_SIZE, htons(sizeof(struct udp_dhcp_packet)));\n+        add_deviceidentity(&packet);\n\nadd_requests(&packet);\naddr.s_addr = requested;\n@@ -140,6 +198,36 @@ int send_selecting(unsigned long xid, un\nSERVER_PORT, MAC_BCAST_ADDR, client_config.ifindex);\n}\n\n+/* Broadcasts a DHCP decline message */\n+int send_decline(unsigned long xid, unsigned long server, unsigned long requested)\n+{\n+\tstruct dhcpMessage packet;\n+\tstruct in_addr addr;\n+\n+        /* as decline message doesn\'t need user class, vender id and other options,\n+           just init header and end */\n+        init_header(&packet, DHCPDECLINE);\n+        memcpy(packet.chaddr, client_config.arp, 6);\n+        if (client_config.hostname) add_option_string(packet.options, client_config.hostname);\n+\tpacket.xid = xid;\n+\n+\tadd_simple_option(packet.options, DHCP_REQUESTED_IP, requested);\n+\tadd_simple_option(packet.options, DHCP_SERVER_ID, server);\n+\n+        int end = end_option(packet.options);\n+        int i, len = 0;\n+        for (i = 0; options[i].code; i++)\n+                if (options[i].flags & OPTION_REQ)\n+                        packet.options[end + OPT_DATA + len++] = options[i].code;\n+        sort_request_route_option((u_int8_t *)(packet.options + end + OPT_DATA), len);\n+        packet.options[end + OPT_LEN] = len;\n+        packet.options[end + OPT_DATA + len] = DHCP_END;\n+\n+\taddr.s_addr = requested;\n+\tLOG(LOG_DEBUG, "Sending decline for %s...", inet_ntoa(addr));\n+\treturn raw_packet(&packet, INADDR_ANY, CLIENT_PORT, INADDR_BROADCAST,\n+\t\t\t\tSERVER_PORT, MAC_BCAST_ADDR, client_config.ifindex);\n+}\n\n/* Unicasts or broadcasts a DHCP renew message */\nint send_renew(unsigned long xid, unsigned long server, unsigned long ciaddr)\n@@ -151,6 +239,9 @@ int send_renew(unsigned long xid, unsign\npacket.xid = xid;\npacket.ciaddr = ciaddr;\n\n+        add_simple_option(packet.options, DHCP_MAX_SIZE, htons(sizeof(struct udp_dhcp_packet)));\n+        add_deviceidentity(&packet);\n+\nadd_requests(&packet);\nLOG(LOG_DEBUG, "Sending renew...");\nif (server)\n@@ -219,7 +310,7 @@ int get_raw_packet(struct dhcpMessage *p\n/* check IP checksum */\ncheck = packet.ip.check;\npacket.ip.check = 0;\n-\tif (check != checksum(&(packet.ip), sizeof(packet.ip))) {\n+\tif (check && check != checksum(&(packet.ip), sizeof(packet.ip))) {\nDEBUG(LOG_INFO, "bad IP header checksum, ignoring");\nreturn -1;\n}\n@@ -251,3 +342,270 @@ int get_raw_packet(struct dhcpMessage *p\n\n}\n\n+int add_suboption(unsigned char* buffer, u_int8_t code, u_int8_t len, u_int8_t* data)\n+{\n+  buffer[SUBOPT_CODE] = code;\n+  buffer[SUBOPT_LEN] = len;\n+  memcpy(buffer + SUBOPT_DATA, data, len);\n+  return len + 2;\n+}\n+\n+int add_enterprise_number(unsigned char* buffer, u_int32_t number)\n+{\n+  buffer[0] = (number >> 24) & 0xff;\n+  buffer[1] = (number >> 16) & 0xff;\n+  buffer[2] = (number >> 8) & 0xff;\n+  buffer[3] = number & 0xff;\n+  return 4;\n+}\n+\n+void stbid_set_manufactureroui(STBIdentity* stbid, const char* value)\n+{\n+  if (stbid->ManufacturerOUI != NULL) {\n+    free(stbid->ManufacturerOUI);\n+  }\n+  if (value != NULL) {\n+    stbid->ManufacturerOUI = strdup(value);\n+  }\n+}\n+\n+void stbid_init(STBIdentity* stbid)\n+{\n+  stbid->SerialNumber = NULL;\n+  stbid->ProductClass = NULL;\n+  stbid->ManufacturerOUI = NULL;\n+}\n+\n+void stbid_set_productclass(STBIdentity* stbid, const char* value)\n+{\n+  if (stbid->ProductClass != NULL) {\n+    free(stbid->ProductClass);\n+  }\n+  stbid->ProductClass = strdup(value);\n+}\n+\n+void stbid_set_serialnumber(STBIdentity* stbid, const char* value)\n+{\n+  if (stbid->SerialNumber != NULL) {\n+    free(stbid->SerialNumber);\n+  }\n+  stbid->SerialNumber = strdup(value);\n+}\n+\n+void stbid_free(STBIdentity* stbid)\n+{\n+  if (stbid->SerialNumber != NULL) {\n+    free(stbid->SerialNumber);\n+    stbid->SerialNumber = NULL;\n+  }\n+  if (stbid->ProductClass != NULL) {\n+    free(stbid->ProductClass);\n+    stbid->ProductClass = NULL;\n+  }\n+  if (stbid->ManufacturerOUI != NULL) {\n+    free(stbid->ManufacturerOUI);\n+    stbid->ManufacturerOUI = NULL;\n+  }\n+}\n+\n+void add_deviceidentity(struct dhcpMessage *packet)\n+{\n+  STBIdentity devIdentity;\n+  stbid_init(&devIdentity);\n+  get_deviceidentity(&devIdentity);\n+\n+  u_int8_t buffer[1024];\n+  int pos = 0;\n+  pos += add_enterprise_number(buffer, ENTERPRISE_ADSL_FORUM);\n+  int lenPos = pos;\n+  pos += 1; // space for data length\n+  int dataPos = pos;\n+  pos += add_suboption(buffer + pos,\n+                       SUBOPT_DEVICE_MANUFACTURER_OUI,\n+                       strlen(devIdentity.ManufacturerOUI),\n+                       (u_int8_t*)devIdentity.ManufacturerOUI);\n+  pos += add_suboption(buffer + pos,\n+                       SUBOPT_DEVICE_SERIAL_NUMBER,\n+                       strlen(devIdentity.SerialNumber),\n+                       (u_int8_t*)devIdentity.SerialNumber);\n+  pos += add_suboption(buffer + pos,\n+                       SUBOPT_DEVICE_PRODUCT_CLASS,\n+                       strlen(devIdentity.ProductClass),\n+                       (u_int8_t*)devIdentity.ProductClass);\n+  buffer[lenPos] = pos - dataPos;\n+  int totalLen = pos;\n+\n+  add_option(packet->options, DHCP_VENDOR_SPECIFIC, buffer, totalLen);\n+  return;\n+}\n+\n+int parse_enterprise_number(unsigned char* buffer, u_int32_t* value)\n+{\n+  *value = (buffer[0] << 24) + (buffer[1] << 16) + (buffer[2] << 8) + buffer[3];\n+  return 4;\n+}\n+\n+int parse_suboption(unsigned char* buffer, u_int8_t* code, u_int8_t** data, u_int8_t* dataLen)\n+{\n+  *code = buffer[SUBOPT_CODE];\n+  int len = buffer[SUBOPT_LEN];\n+  *data = xmalloc(len);\n+  memcpy(*data, buffer + SUBOPT_DATA, len);\n+  *dataLen = len;\n+  return len + SUBOPT_HDRLEN;\n+}\n+\n+char *makestring(u_int8_t* data, size_t n)\n+{\n+  char *buf = xmalloc(n+1);\n+  memcpy(buf, data, n);\n+  buf[n] = \'\\0\';\n+  return buf;\n+}\n+\n+void parse_gatewayidentity(unsigned char *buffer)\n+{\n+  int pos = 0;\n+  u_int32_t enterpriseNumber;\n+  pos += parse_enterprise_number(buffer + pos, &enterpriseNumber);\n+\n+  if(enterpriseNumber != ENTERPRISE_ADSL_FORUM){\n+    DEBUG(LOG_ERR,\n+          "This option 125 is not defined by ADSL forum (!= %d)",\n+          ENTERPRISE_ADSL_FORUM);\n+    return;\n+  }\n+  int totalLen = buffer[pos];\n+  pos += 1; // total length\n+\n+  STBIdentity gatewayIdentity;\n+  stbid_init(&gatewayIdentity);\n+  stbid_set_manufactureroui(&gatewayIdentity, "");\n+  stbid_set_serialnumber(&gatewayIdentity, "");\n+  stbid_set_productclass(&gatewayIdentity, "");\n+\n+  int dataPos = pos;\n+  while((pos - dataPos) < totalLen) {\n+    u_int8_t* data;\n+    u_int8_t code;\n+    u_int8_t dataLen;\n+    int len = parse_suboption(buffer + pos, &code, &data, &dataLen);\n+    pos += len;\n+    char* value = makestring(data, dataLen);\n+    switch(code) {\n+    case SUBOPT_GATEWAY_MANUFACTURER_OUI:\n+      stbid_set_manufactureroui(&gatewayIdentity, value);\n+      break;\n+    case SUBOPT_GATEWAY_SERIAL_NUMBER:\n+      stbid_set_serialnumber(&gatewayIdentity, value);\n+      break;\n+    case SUBOPT_GATEWAY_PRODUCT_CLASS:\n+      stbid_set_productclass(&gatewayIdentity, value);\n+      break;\n+    default:\n+      DEBUG(LOG_ERR, "Unknown suboption code from gateway: %d", code);\n+    }\n+    free(value);\n+  }\n+\n+  if (0 == strcmp("", gatewayIdentity.ManufacturerOUI)) {\n+    DEBUG(LOG_WARNING, "Missing ManufacturerOUI from gateway");\n+  }\n+\n+  if (0 == strcmp("", gatewayIdentity.SerialNumber)) {\n+    DEBUG(LOG_WARNING, "Missing SerialNumber from gateway");\n+  }\n+\n+  if (0 == strcmp("", gatewayIdentity.ProductClass)) {\n+    DEBUG(LOG_WARNING, "Missing ProductClass from gateway");\n+  }\n+\n+  set_gatewayidentity(&gatewayIdentity);\n+\n+  stbid_free(&gatewayIdentity);\n+}\n+\n+int get_deviceidentity(STBIdentity* devIdentity)\n+{\n+  // ManufacturerOUI should be read from infoservice (const.oui)\n+  stbid_set_manufactureroui(devIdentity, "0024A1");\n+  stbid_set_productclass(devIdentity, "STBFTTH");\n+  stbid_set_serialnumber(devIdentity, "");\n+\n+  FILE *fp = NULL;\n+\n+  const int MAXCHAR=512;\n+  char buf[MAXCHAR];\n+  if ((fp = fopen(DEVICE_SN, "r+")) == NULL) {\n+    DEBUG(LOG_ERR, "Device serial number does not exist (\\"%s\\").", DEVICE_SN);\n+    return -1;\n+  }\n+  else {\n+    if(fgets(buf,MAXCHAR,fp) == NULL) {\n+      fclose(fp);\n+      return -1;\n+    }\n+    fclose(fp);\n+\n+    // Only use first line if several lines\n+    char* newline = strchr(buf, \'\\n\');\n+    if (newline != NULL) {\n+      *newline = \'\\0\';\n+    }\n+    stbid_set_serialnumber(devIdentity, buf);\n+  }\n+  return 0;\n+}\n+\n+static int CheckAndCreateDir(char * filePath)\n+{\n+  int returnValue = 0;\n+  char * filePathCopy = strdup(filePath);\n+  char * dirPath = dirname(filePathCopy);\n+\n+  if (access(dirPath, F_OK) != 0) {\n+    if (mkdir(dirPath, 0777) != 0) {\n+      DEBUG(LOG_ERR, "Failed to create \\"%s\\", %s", dirPath, strerror(errno));\n+      returnValue = -1;\n+    }\n+  }\n+\n+  free(filePathCopy);\n+  return returnValue;\n+}\n+\n+static int SaveToFlash(char* filepath, char* filedata)\n+{\n+  if (CheckAndCreateDir(filepath) != 0) {\n+    return -1;\n+  }\n+\n+  FILE *fp;\n+   if ((fp = fopen(filepath, "w+")) == NULL) {\n+     DEBUG(LOG_ERR, "Failed to open \\"%s\\", check that the directory exists",\n+           filepath);\n+    return -1;\n+  }\n+  else {\n+    if(fputs(filedata,fp) == EOF) {\n+      DEBUG(LOG_WARNING,"Fail to write to flash file (\\"%s\\")",\n+            filepath);\n+      fclose(fp);\n+      return -1;\n+    }\n+  }\n+  fclose(fp);\n+  return 0;\n+}\n+\n+int set_gatewayidentity(STBIdentity* gwIdentity)\n+{\n+  int result=0;\n+  result += SaveToFlash(GATEWAY_MANUFACTURER,gwIdentity->ManufacturerOUI);\n+  result += SaveToFlash(GATEWAY_SERIALNUMBER,gwIdentity->SerialNumber);\n+  result += SaveToFlash(GATEWAY_PRODUCTCLASS,gwIdentity->ProductClass);\n+#if !defined(__TARGET__) || __TARGET__ != VIPHOST\n+  sync();\n+#endif\n+  return result;\n+}')]