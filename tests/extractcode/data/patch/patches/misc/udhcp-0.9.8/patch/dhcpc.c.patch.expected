[('udhcp-0.9.8.orig/dhcpc.c',
  'udhcp-0.9.8/dhcpc.c',
  'Index: udhcp-0.9.8/dhcpc.c\n===================================================================\n--- udhcp-0.9.8.orig/dhcpc.c\n+++ udhcp-0.9.8/dhcpc.c\n@@ -1,3 +1,4 @@\n+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*- */\n/* dhcpc.c\n*\n* udhcp DHCP client\n@@ -23,6 +24,7 @@\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/file.h>\n+#include <sys/sysinfo.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <stdlib.h>\n@@ -35,6 +37,8 @@\n#include <sys/ioctl.h>\n#include <net/if.h>\n#include <errno.h>\n+#include <netdb.h>\n+#include <arpa/inet.h>\n\n#include "dhcpd.h"\n#include "dhcpc.h"\n@@ -45,9 +49,10 @@\n#include "socket.h"\n#include "debug.h"\n#include "pidfile.h"\n+#include "arpping.h"\n\nstatic int state;\n-static unsigned long requested_ip; /* = 0 */\n+static unsigned long requested_ip = 0;\nstatic unsigned long server_addr;\nstatic unsigned long timeout;\nstatic int packet_num; /* = 0 */\n@@ -59,11 +64,19 @@ static int signal_pipe[2];\n#define LISTEN_RAW 2\nstatic int listen_mode;\n\n-#define DEFAULT_SCRIPT\t"/usr/share/udhcpc/default.script"\n+#define DEFAULT_SCRIPT\t"/etc/udhcpc.script"\n+\n+#define EXIT_CODE_FAILED_DISCOVER 100\n+#define EXIT_CODE_FAILED_REQUEST 101\n+#define EXIT_CODE_EXPIRED_LEASE 102\n\nstruct client_config_t client_config = {\n/* Default options. */\nabort_if_no_lease: 0,\n+        abort_if_failed_request: 0,\n+        abort_if_expired_lease: 0,\n+        no_deconfig_on_expire: 0,\n+        process_zero_source_packet: 0,\nforeground: 0,\nquit_after_lease: 0,\nbackground_if_no_lease: 0,\n@@ -71,36 +84,63 @@ struct client_config_t client_config = {\npidfile: NULL,\nscript: DEFAULT_SCRIPT,\nclientid: NULL,\n+        userclientid: NULL,\nhostname: NULL,\nifindex: 0,\n+        start_init_reboot: 0,\n+        start_renew: 0,\n+        address_renewal_behaviour: 0,\n+        leasetime: 0,\narp: "\\0\\0\\0\\0\\0\\0",\t\t/* appease gcc-3.0 */\n};\n\n#ifndef BB_VER\nstatic void show_usage(void)\n{\n-\tprintf(\n+\tfprintf(stdout,\n"Usage: udhcpc [OPTIONS]\\n\\n"\n-"  -c, --clientid=CLIENTID         Client identifier\\n"\n-"  -H, --hostname=HOSTNAME         Client hostname\\n"\n-"  -h                              Alias for -H\\n"\n-"  -f, --foreground                Do not fork after getting lease\\n"\n-"  -b, --background                Fork to background if lease cannot be\\n"\n-"                                  immediately negotiated.\\n"\n-"  -i, --interface=INTERFACE       Interface to use (default: eth0)\\n"\n-"  -n, --now                       Exit with failure if lease cannot be\\n"\n-"                                  immediately negotiated.\\n"\n-"  -p, --pidfile=file              Store process ID of daemon in file\\n"\n-"  -q, --quit                      Quit after obtaining lease\\n"\n-"  -r, --request=IP                IP address to request (default: none)\\n"\n-"  -s, --script=file               Run file at dhcp events (default:\\n"\n-"                                  " DEFAULT_SCRIPT ")\\n"\n-"  -v, --version                   Display version\\n"\n-\t);\n+"  -c, --clientid=CLIENTID          Client identifier\\n"\n+"  -u, --userclientid=USER_ID       User Class identifier\\n"\n+"  -H, --hostname=HOSTNAME          Client hostname\\n"\n+"  -h                               Alias for -H\\n"\n+"  -f, --foreground                 Do not fork after getting lease\\n"\n+"  -b, --background                 Fork to background if lease cannot be\\n"\n+"                                   immediately negotiated.\\n"\n+"  -i, --interface=INTERFACE        Interface to use (default: eth0)\\n"\n+"  -n, --exit-on-failed-discover    Exit with failure code %d if lease cannot\\n"\n+"                                   be immediately negotiated.\\n"\n+"  -p, --pidfile=file               Store process ID of daemon in file\\n"\n+"  -q, --quit                       Quit after obtaining lease\\n"\n+"  -r, --request=IP                 IP address to request (default: none)\\n"\n+"  -l, --leasetime=TIME             IP address to request (default: none)\\n"\n+"  -s, --script=file                Run file at dhcp events (default:\\n"\n+"                                   " DEFAULT_SCRIPT ")\\n"\n+"  -v, --version                    Display version\\n"\n+"  -e                               Start in INIT-REBOOT state\\n"\n+"  -w, --renew=DHCPSERVER           Start with renewing lease, instead of\\n"\n+"                                   discover\\n"\n+"                                   Requires IP address of DHCP server\\n"\n+"      --exit-on-failed-request     Exit with failure code %d if request fails\\n"\n+"      --exit-on-expired-lease      Exit with failure code %d if lease expires\\n"\n+"      --no-deconfig-on-expire      Do not run deconfig script when lease\\n"\n+"                                   expires\\n"\n+"      --process-zero-source-packet Process ACKs with zero source IP-address.\\n"\n+"                                   This is a compatibility option for certain\\n"\n+"                                   DHCP relay agents, and is disabled by\\n"\n+"                                   default because it makes DoS attacks\\n"\n+"                                   easier.\\n",\n+                EXIT_CODE_FAILED_DISCOVER, EXIT_CODE_FAILED_REQUEST,\n+                EXIT_CODE_EXPIRED_LEASE);\nexit(0);\n}\n#endif\n\n+long uptime(void)\n+{\n+        struct sysinfo info;\n+        sysinfo(&info);\n+        return info.uptime;\n+}\n\n/* just a little helper */\nstatic void change_mode(int new_mode)\n@@ -132,6 +172,7 @@ static void perform_renew(void)\nstate = INIT_SELECTING;\nbreak;\ncase INIT_SELECTING:\n+                break;\n}\n\n/* start things over */\n@@ -155,7 +196,10 @@ static void perform_release(void)\ntemp_addr.s_addr = requested_ip;\nLOG(LOG_INFO, "Unicasting a release of %s to %s",\ninet_ntoa(temp_addr), buffer);\n-\t\tsend_release(server_addr, requested_ip); /* unicast */\n+                if (send_release(server_addr, requested_ip) == -1) { /* unicast */\n+                        LOG(LOG_WARNING, "Unable to send DHCPRELEASE - %s",\n+                            strerror(errno));\n+                }\nrun_script(NULL, "deconfig");\n}\nLOG(LOG_INFO, "Entering released state");\n@@ -169,6 +213,7 @@ static void perform_release(void)\n/* Exit and cleanup */\nstatic void exit_client(int retval)\n{\n+        LOG(LOG_INFO, "Exiting with code %d", retval);\npidfile_delete(client_config.pidfile);\nCLOSE_LOG();\nexit(retval);\n@@ -199,7 +244,6 @@ static void background(void)\npidfile_write_release(pid_fd);\n}\n\n-\n#ifdef COMBINED_BINARY\nint udhcpc_main(int argc, char *argv[])\n#else\n@@ -208,7 +252,7 @@ int main(int argc, char *argv[])\n{\nunsigned char *temp, *message;\nunsigned long t1 = 0, t2 = 0, xid = 0;\n-\tunsigned long start = 0, lease;\n+\tunsigned long start = 0, lease = 0;\nfd_set rfds;\nint retval;\nstruct timeval tv;\n@@ -216,23 +260,33 @@ int main(int argc, char *argv[])\nstruct dhcpMessage packet;\nstruct in_addr temp_addr;\nint pid_fd;\n-\ttime_t now;\n+\tlong now;\nint max_fd;\nint sig;\n+       int numOfDiscoverMsg = 0;\n+\tint arpret;\n\nstatic struct option arg_options[] = {\n{"clientid",\trequired_argument,\t0, \'c\'},\n+\t\t{"userclientid", required_argument,\t0, \'u\'},\n{"foreground",\tno_argument,\t\t0, \'f\'},\n{"background",\tno_argument,\t\t0, \'b\'},\n{"hostname",\trequired_argument,\t0, \'H\'},\n{"hostname",    required_argument,      0, \'h\'},\n{"interface",\trequired_argument,\t0, \'i\'},\n-\t\t{"now", \tno_argument,\t\t0, \'n\'},\n+\t\t{"exit-on-failed-discover", no_argument,0, \'n\'},\n{"pidfile",\trequired_argument,\t0, \'p\'},\n{"quit",\tno_argument,\t\t0, \'q\'},\n{"request",\trequired_argument,\t0, \'r\'},\n+                {"leasetime",\trequired_argument,\t0, \'l\'},\n{"script",\trequired_argument,\t0, \'s\'},\n{"version",\tno_argument,\t\t0, \'v\'},\n+                {"init-reboot",\tno_argument,\t\t0, \'e\'},\n+\t\t{"renew",\trequired_argument,\t0, \'w\'},\n+                {"exit-on-failed-request", no_argument, 0, 10},\n+                {"exit-on-expired-lease", no_argument,  0, 11},\n+                {"no-deconfig-on-expire", no_argument,  0, 12},\n+                {"process-zero-source-packet", no_argument,  0, 13},\n{"help",\tno_argument,\t\t0, \'?\'},\n{0, 0, 0, 0}\n};\n@@ -240,19 +294,47 @@ int main(int argc, char *argv[])\n/* get options */\nwhile (1) {\nint option_index = 0;\n-\t\tc = getopt_long(argc, argv, "c:fbH:h:i:np:qr:s:v", arg_options, &option_index);\n+                c = getopt_long(argc, argv, "c:u:fbH:h:i:l:np:qr:s:vew:z", arg_options, &option_index);\nif (c == -1) break;\n\nswitch (c) {\n+                case 10:\n+                        LOG(LOG_INFO, "Will abort if request fails.");\n+                        client_config.abort_if_failed_request = 1;\n+                        break;\n+                case 11:\n+                        LOG(LOG_INFO, "Will abort if lease expires.");\n+                        client_config.abort_if_expired_lease = 1;\n+                        break;\n+                case 12:\n+                        LOG(LOG_INFO, "Will not run deconfig script when lease expires.");\n+                        client_config.no_deconfig_on_expire = 1;\n+                        break;\n+                case 13:\n+                        LOG(LOG_INFO, "WARNING: Will process zero source packets!");\n+                        client_config.process_zero_source_packet = 1;\n+                        break;\ncase \'c\':\nlen = strlen(optarg) > 255 ? 255 : strlen(optarg);\nif (client_config.clientid) free(client_config.clientid);\nclient_config.clientid = xmalloc(len + 2);\n+#ifdef KBOX\n+\t\t\tclient_config.clientid[OPT_CODE] = DHCP_VENDOR;\n+#else\nclient_config.clientid[OPT_CODE] = DHCP_CLIENT_ID;\n+#endif\nclient_config.clientid[OPT_LEN] = len;\nclient_config.clientid[OPT_DATA] = \'\\0\';\nstrncpy(client_config.clientid + OPT_DATA, optarg, len);\nbreak;\n+\t\tcase \'u\':\n+\t\t\tlen = strlen(optarg) > 255 ? 255 : strlen(optarg);\n+\t\t\tif (client_config.userclientid) free(client_config.userclientid);\n+\t\t\tclient_config.userclientid = xmalloc(len + 2);\n+\t\t\tclient_config.userclientid[OPT_CODE] = DHCP_USER_CLASS_ID;\n+\t\t\tclient_config.userclientid[OPT_LEN] = len;\n+\t\t\tstrncpy(client_config.userclientid + OPT_DATA, optarg, len);\n+\t\t\tbreak;\ncase \'f\':\nclient_config.foreground = 1;\nbreak;\n@@ -272,6 +354,7 @@ int main(int argc, char *argv[])\nclient_config.interface =  optarg;\nbreak;\ncase \'n\':\n+                        LOG(LOG_INFO, "Will abort if discover fails.");\nclient_config.abort_if_no_lease = 1;\nbreak;\ncase \'p\':\n@@ -283,6 +366,9 @@ int main(int argc, char *argv[])\ncase \'r\':\nrequested_ip = inet_addr(optarg);\nbreak;\n+                case \'l\':\n+\t\t\tclient_config.leasetime = htonl(atoi(optarg));\n+\t\t\tbreak;\ncase \'s\':\nclient_config.script = optarg;\nbreak;\n@@ -290,6 +376,27 @@ int main(int argc, char *argv[])\nprintf("udhcpcd, version %s\\n\\n", VERSION);\nexit_client(0);\nbreak;\n+                case \'e\':\n+                        client_config.start_init_reboot = 1;\n+                        break;\n+                case \'w\':\n+                        {\n+                                server_addr = inet_addr(optarg);\n+                                DEBUG(LOG_DEBUG, "Server address: %s (%lx)", optarg, server_addr);\n+                                if (server_addr == INADDR_NONE) {\n+                                        LOG(LOG_WARNING, "Unable to parse DHCP server address.");\n+                                        server_addr = 0;\n+                                }\n+                                else if (server_addr == 0) {\n+                                        client_config.start_renew = 1;\n+                                        LOG(LOG_INFO, "Server address zero. Going to renew state, but broadcast instead of unicast.");\n+                                }\n+                                else {\n+                                        client_config.start_renew = 1;\n+                                        LOG(LOG_INFO, "Using DHCP server %s", optarg);\n+                                }\n+                        }\n+                        break;\ndefault:\nshow_usage();\n}\n@@ -301,8 +408,16 @@ int main(int argc, char *argv[])\npid_fd = pidfile_acquire(client_config.pidfile);\npidfile_write_release(pid_fd);\n\n+        unsigned long* addr = NULL;\n+\n+#ifdef KBOX\n+        // Leaving this for now\n+        if (requested_ip == 0) {\n+          addr = &requested_ip;\n+        }\n+#endif  // KBOX\nif (read_interface(client_config.interface, &client_config.ifindex,\n-\t\t\t   NULL, client_config.arp) < 0)\n+\t\t\t   &addr, client_config.arp) < 0)\nexit_client(1);\n\nif (!client_config.clientid) {\n@@ -317,15 +432,54 @@ int main(int argc, char *argv[])\nsocketpair(AF_UNIX, SOCK_STREAM, 0, signal_pipe);\nsignal(SIGUSR1, signal_handler);\nsignal(SIGUSR2, signal_handler);\n+#ifdef KBOX\n+\tsignal(SIGHUP, signal_handler);\n+#endif\nsignal(SIGTERM, signal_handler);\n\n-\tstate = INIT_SELECTING;\n-\trun_script(NULL, "deconfig");\n-\tchange_mode(LISTEN_RAW);\n+        if (client_config.start_init_reboot && client_config.start_renew) {\n+                LOG(LOG_ERR, "Can not use both -e and -w at the same time");\n+                exit_client(0);\n+        }\n+\n+        if (client_config.start_init_reboot || client_config.start_renew) {\n+                char hostname[128];\n+                gethostname(hostname, sizeof(hostname));\n+                struct hostent* he = gethostbyname(hostname);\n+                struct in_addr* ia = (struct in_addr*)he->h_addr;\n+                requested_ip = ia->s_addr;\n+        }\n+\n+        if (client_config.start_renew) {\n+                state = RENEWING;\n+                xid = random_xid();\n+                lease = 60;\n+                start = uptime();\n+                t1 = lease / 2;\n+                t2 = (lease * 0x7) >> 3;\n+                DEBUG(LOG_DEBUG, "Setting state RENEWING. xid=%lx", xid);\n+                if (client_config.process_zero_source_packet) {\n+                        change_mode(LISTEN_RAW);\n+                } else {\n+                        change_mode(LISTEN_KERNEL);\n+                }\n+                run_script(NULL, "prerenew");\n+        }\n+        else if (client_config.start_init_reboot) {\n+                state = INIT_REBOOTING;\n+                change_mode(LISTEN_RAW);\n+                LOG(LOG_INFO, "Setting state INIT_REBOOTING.");\n+        }\n+        else {\n+                state = INIT_SELECTING;\n+                change_mode(LISTEN_RAW);\n+        }\n+\n+        timeout = uptime() - 10;\n\nfor (;;) {\n\n-\t\ttv.tv_sec = timeout - time(0);\n+\t\ttv.tv_sec = timeout - uptime();\ntv.tv_usec = 0;\nFD_ZERO(&rfds);\n\n@@ -348,10 +502,33 @@ int main(int argc, char *argv[])\nretval = select(max_fd + 1, &rfds, NULL, NULL, &tv);\n} else retval = 0; /* If we already timed out, fall through */\n\n-\t\tnow = time(0);\n+\t\tnow = uptime();\nif (retval == 0) {\n/* timeout dropped to zero */\nswitch (state) {\n+                        case INIT_REBOOTING:\n+                                if (packet_num < 3) {\n+                                        if (packet_num == 0)\n+                                                xid = random_xid();\n+\n+                                        /* send request packet */\n+                                        send_selecting(xid, 0, requested_ip); /* broadcast */\n+                                        LOG(LOG_DEBUG, "DHCP: Sent renew from INIT-REBOOT (%d/3)", packet_num + 1);\n+                                        timeout = now + ((packet_num == 2) ? 10 : 2);\n+                                        packet_num++;\n+                                } else {\n+                                        /* timed out. exit or go to init state? */\n+                                        if (client_config.abort_if_failed_request) {\n+                                                LOG(LOG_INFO, "No lease after %d request attempts, exiting.", packet_num);\n+                                                exit_client(EXIT_CODE_FAILED_REQUEST);\n+                                        }\n+                                        /* go back to init state */\n+                                        state = INIT_SELECTING;\n+                                        timeout = now;\n+                                        packet_num = 0;\n+                                        change_mode(LISTEN_RAW);\n+                                }\n+                                break;\ncase INIT_SELECTING:\nif (packet_num < 3) {\nif (packet_num == 0)\n@@ -359,17 +536,25 @@ int main(int argc, char *argv[])\n\n/* send discover packet */\nsend_discover(xid, requested_ip); /* broadcast */\n+                                        LOG(LOG_DEBUG, "DHCP: Sent discover (%d/3)", packet_num + 1);\n\ntimeout = now + ((packet_num == 2) ? 4 : 2);\npacket_num++;\n+          if(numOfDiscoverMsg >= 0)\n+            numOfDiscoverMsg++;\n} else {\nif (client_config.background_if_no_lease) {\n-\t\t\t\t\t\tLOG(LOG_INFO, "No lease, forking to background.");\n+\t\t\t\t\t\tLOG(LOG_INFO, "No lease after %d discover attempts, forking to background.", packet_num);\nbackground();\n} else if (client_config.abort_if_no_lease) {\n-\t\t\t\t\t\tLOG(LOG_INFO, "No lease, failing.");\n-\t\t\t\t\t\texit_client(1);\n+                                                LOG(LOG_INFO, "No lease after %d discover attempts, exiting.", packet_num);\n+\t\t\t\t\t\texit_client(EXIT_CODE_FAILED_DISCOVER);\n}\n+          if(numOfDiscoverMsg >= 3){\n+            run_script(NULL, "deconfig");\n+            numOfDiscoverMsg = -1;\n+          }\n+\n/* wait to try again */\npacket_num = 0;\ntimeout = now + 60;\n@@ -378,15 +563,24 @@ int main(int argc, char *argv[])\ncase RENEW_REQUESTED:\ncase REQUESTING:\nif (packet_num < 3) {\n-\t\t\t\t\t/* send request packet */\n-\t\t\t\t\tif (state == RENEW_REQUESTED)\n+                                        /* send request packet */\n+\t\t\t\t\tif (state == RENEW_REQUESTED) {\nsend_renew(xid, server_addr, requested_ip); /* unicast */\n-\t\t\t\t\telse send_selecting(xid, server_addr, requested_ip); /* broadcast */\n+                                                LOG(LOG_DEBUG, "DHCP: Sent renew (%d/3)", packet_num + 1);\n+                                        } else {\n+                                                send_selecting(xid, server_addr, requested_ip); /* broadcast */\n+                                                LOG(LOG_DEBUG, "DHCP: Sent request (%d/3)", packet_num + 1);\n+                                        }\n\ntimeout = now + ((packet_num == 2) ? 10 : 2);\npacket_num++;\n} else {\n-\t\t\t\t\t/* timed out, go back to init state */\n+                                        /* timed out. exit or go to init state? */\n+                                        if (client_config.abort_if_failed_request) {\n+                                                LOG(LOG_INFO, "No lease after %d request attempts, exiting.", packet_num);\n+                                                exit_client(EXIT_CODE_FAILED_REQUEST);\n+                                        }\n+\t\t\t\t\t/* go back to init state */\nif (state == RENEW_REQUESTED) run_script(NULL, "deconfig");\nstate = INIT_SELECTING;\ntimeout = now;\n@@ -397,37 +591,62 @@ int main(int argc, char *argv[])\ncase BOUND:\n/* Lease is starting to run out, time to enter renewing state */\nstate = RENEWING;\n-\t\t\t\tchange_mode(LISTEN_KERNEL);\n+                                if (client_config.process_zero_source_packet) {\n+                                        change_mode(LISTEN_RAW);\n+                                } else {\n+                                        change_mode(LISTEN_KERNEL);\n+                                }\nDEBUG(LOG_INFO, "Entering renew state");\n/* fall right through */\ncase RENEWING:\n-\t\t\t\t/* Either set a new T1, or enter REBINDING state */\n-\t\t\t\tif ((t2 - t1) <= (lease / 14400 + 1)) {\n-\t\t\t\t\t/* timed out, enter rebinding state */\n-\t\t\t\t\tstate = REBINDING;\n-\t\t\t\t\ttimeout = now + (t2 - t1);\n-\t\t\t\t\tDEBUG(LOG_INFO, "Entering rebinding state");\n-\t\t\t\t} else {\n-\t\t\t\t\t/* send a request packet */\n-\t\t\t\t\tsend_renew(xid, server_addr, requested_ip); /* unicast */\n-\n-\t\t\t\t\tt1 = (t2 - t1) / 2 + t1;\n-\t\t\t\t\ttimeout = t1 + start;\n+                                run_script(NULL, "prerenew");\n+                                if (client_config.address_renewal_behaviour) {\n+                                        LOG(LOG_DEBUG, "Sending DHCPRELEASE now since MYRIO.address_renewal_behaviour = 1");\n+                                        perform_release();\n+                                        run_script(NULL, "deconfig");\n+\t\t\t\t\tstate = INIT_SELECTING;\n+\t\t\t\t\ttimeout = now;\n+\t\t\t\t\trequested_ip = 0;\n+\t\t\t\t\tpacket_num = 0;\n+\t\t\t\t\tchange_mode(LISTEN_RAW);\n+\t\t\t\t\tsleep(3); /* avoid excessive network traffic */\n+                                } else {\n+                                        /* Either set a new T1, or enter REBINDING state */\n+                                        if ((t2 - t1) <= (lease / 14400 + 1)) {\n+                                                /* timed out, enter rebinding state */\n+                                                state = REBINDING;\n+                                                timeout = now + (t2 - t1);\n+                                                DEBUG(LOG_INFO, "Entering rebinding state");\n+                                        } else {\n+                                                /* send a request packet */\n+                                                send_renew(xid, server_addr, requested_ip); /* unicast */\n+                                                LOG(LOG_DEBUG, "DHCP: Sent unicast renew");\n+\n+                                                t1 = (t2 - t1) / 2 + t1;\n+                                                timeout = t1 + start;\n+                                        }\n}\nbreak;\ncase REBINDING:\n/* Either set a new T2, or enter INIT state */\nif ((lease - t2) <= (lease / 14400 + 1)) {\n-\t\t\t\t\t/* timed out, enter init state */\n-\t\t\t\t\tstate = INIT_SELECTING;\n-\t\t\t\t\tLOG(LOG_INFO, "Lease lost, entering init state");\n-\t\t\t\t\trun_script(NULL, "deconfig");\n-\t\t\t\t\ttimeout = now;\n+                                        if (!client_config.no_deconfig_on_expire) {\n+                                                run_script(NULL, "deconfig");\n+                                        }\n+                                        if (client_config.abort_if_expired_lease) {\n+                                                LOG(LOG_INFO, "Lease lost, exiting.");\n+                                                exit_client(EXIT_CODE_EXPIRED_LEASE);\n+                                        }\n+                                        /* timed out, enter init state */\n+                                        state = INIT_SELECTING;\n+                                        LOG(LOG_INFO, "Lease lost, entering init state");\n+                                        timeout = now;\npacket_num = 0;\nchange_mode(LISTEN_RAW);\n} else {\n/* send a request packet */\nsend_renew(xid, 0, requested_ip); /* broadcast */\n+                                        LOG(LOG_DEBUG, "DHCP: Sent broadcast renew");\n\nt2 = (lease - t2) / 2 + t2;\ntimeout = t2 + start;\n@@ -468,6 +687,8 @@ int main(int argc, char *argv[])\nif (*message == DHCPOFFER) {\nif ((temp = get_option(&packet, DHCP_SERVER_ID))) {\nmemcpy(&server_addr, temp, 4);\n+                                                temp_addr.s_addr = server_addr;\n+                                                DEBUG(LOG_INFO, "Server ID %s retrieved from DHCPOFFER", inet_ntoa(temp_addr));\nxid = packet.xid;\nrequested_ip = packet.yiaddr;\n\n@@ -476,15 +697,45 @@ int main(int argc, char *argv[])\ntimeout = now;\npacket_num = 0;\n} else {\n-\t\t\t\t\t\tDEBUG(LOG_ERR, "No server ID in message");\n+\t\t\t\t\t\tDEBUG(LOG_ERR, "No server ID in DHCPOFFER");\n+\t\t\t\t\t}\n+\t\t\t\t\tunsigned char* option125= get_option(&packet, DHCP_VENDOR_SPECIFIC);\n+\t\t\t\t\tif(option125){\n+\t\t\t\t\t\tparse_gatewayidentity(option125);\n}\n}\nbreak;\n+                        case INIT_REBOOTING:\ncase RENEW_REQUESTED:\ncase REQUESTING:\ncase RENEWING:\ncase REBINDING:\nif (*message == DHCPACK) {\n+                                        unsigned char* option43 = get_option(&packet, DHCP_VENDOR_INFORMATION);\n+                                        if (option43) {\n+                                                int i = 0;\n+                                                // This operation is safe since get_option returns (unsigned char*) p + 2.\n+                                                int option43_len = *(option43-1);\n+                                                if ((*(option43) >= \'0\') &&\n+                                                    (*(option43) <= \'9\')) {\n+                                                        // This is a IP-address. Classic style DHCP.\n+                                                        option43_len = 0;\n+                                                }\n+                                                unsigned char *foo = xmalloc(option43_len + 1);\n+                                                memset(foo, 0, option43_len);\n+                                                strncpy(foo, option43, option43_len);\n+                                                i = 0;\n+                                                while (i < option43_len) {\n+                                                        if (*(option43 + i) == 100) { /* As in hw/common.h. */\n+                                                                client_config.address_renewal_behaviour = *(option43 + i + 2);\n+                                                                LOG(LOG_INFO, "address_renewal_behaviour = %d",\n+                                                                      client_config.address_renewal_behaviour);\n+                                                                break;\n+                                                        } else {\n+                                                                i += *(option43 + 1 + i) + 2;\n+                                                        }\n+                                                }\n+                                        }\nif (!(temp = get_option(&packet, DHCP_LEASE_TIME))) {\nLOG(LOG_ERR, "No lease time with ACK, using 1 hour lease");\nlease = 60 * 60;\n@@ -492,9 +743,17 @@ int main(int argc, char *argv[])\nmemcpy(&lease, temp, 4);\nlease = ntohl(lease);\n}\n+\n+\t\t\t\t\tunsigned char* option125= get_option(&packet, DHCP_VENDOR_SPECIFIC);\n+\t\t\t\t\tif(option125){\n+\t\t\t\t\t\tparse_gatewayidentity(option125);\n+\t\t\t\t\t}\n\n/* enter bound state */\nt1 = lease / 2;\n+                                        if (client_config.leasetime > 0) {\n+                                                client_config.leasetime = htonl(lease);\n+                                        }\n\n/* little fixed point for n * .875 */\nt2 = (lease * 0x7) >> 3;\n@@ -506,43 +765,74 @@ int main(int argc, char *argv[])\nrequested_ip = packet.yiaddr;\nrun_script(&packet,\n((state == RENEWING || state == REBINDING) ? "renew" : "bound"));\n+                                        run_script(NULL, "postrenew");\n\nstate = BOUND;\n-\t\t\t\t\tchange_mode(LISTEN_NONE);\n+                                        change_mode(LISTEN_KERNEL);\nif (client_config.quit_after_lease)\nexit_client(0);\nif (!client_config.foreground)\nbackground();\n\n+\t\t\t\t\t// After the client receives a lease from the DHCP server, it will send an ARP for\n+\t\t\t\t\t// the IP address it has been assigned. If any other client replies to that ARP,\n+\t\t\t\t\t// the address is already in use. In this case,the client will issue a DHCP DECLINE to the DHCP server.\n+\t\t\t\t\tarpret = arpping(requested_ip, requested_ip, client_config.arp, client_config.interface);\n+\t\t\t\t\tLOG(LOG_INFO, "arpping, req ip:%s, ret:%d", inet_ntoa(temp_addr), arpret);//liuhf\n+\t\t\t\t\tif(arpret == 0){\n+\t\t\t\t\t\tsend_decline(packet.xid, server_addr, requested_ip);\n+\t\t\t\t\t\tLOG(LOG_INFO, "send_decline, xid:%ld", packet.xid);//liuhf\n+\t\t\t\t\t\trun_script(NULL, "deconfig");\n+\t\t\t\t\t\tstate = INIT_SELECTING;\n+\t\t\t\t\t\ttimeout = now;\n+\t\t\t\t\t\trequested_ip = 0;\n+\t\t\t\t\t\tpacket_num = 0;\n+\t\t\t\t\t\tchange_mode(LISTEN_RAW);\n+\t\t\t\t\t\tsleep(10); /* The client should wait a\n+      minimum of ten seconds before restarting the configuration process\n+      to avoid excessive network traffic in case of looping. see RFC 1531 */\n+\t\t\t\t\t}\n} else if (*message == DHCPNAK) {\n/* return to init state */\nLOG(LOG_INFO, "Received DHCP NAK");\nrun_script(&packet, "nak");\n-\t\t\t\t\tif (state != REQUESTING)\n-\t\t\t\t\t\trun_script(NULL, "deconfig");\n+\t\t\t\t\trun_script(NULL, "deconfig");\nstate = INIT_SELECTING;\ntimeout = now;\nrequested_ip = 0;\npacket_num = 0;\nchange_mode(LISTEN_RAW);\nsleep(3); /* avoid excessive network traffic */\n-\t\t\t\t}\n+\t\t\t\t}\n+                        case BOUND:\n+                                if (*message == DHCPFORCERENEW) {\n+                                        LOG(LOG_INFO, "Received DHCP FORCERENEW");\n+                                        run_script(NULL, "prerenew");\n+                                        perform_renew();\n+                                }\nbreak;\n-\t\t\t/* case BOUND, RELEASED: - ignore all packets */\n+\t\t\t/* case RELEASED: - ignore all packets */\n}\n} else if (retval > 0 && FD_ISSET(signal_pipe[0], &rfds)) {\n-\t\t\tif (read(signal_pipe[0], &sig, sizeof(signal)) < 0) {\n+\t\t\tif (read(signal_pipe[0], &sig, sizeof(sig)) < 0) {\nDEBUG(LOG_ERR, "Could not read signal: %s",\nstrerror(errno));\ncontinue; /* probably just EINTR */\n}\nswitch (sig) {\ncase SIGUSR1:\n+                                run_script(NULL, "prerenew");\nperform_renew();\nbreak;\ncase SIGUSR2:\nperform_release();\nbreak;\n+#ifdef KBOX\n+\t\t\tcase SIGHUP:\n+\t\t\t\tLOG(LOG_INFO, "Received SIGHUP");\n+\t\t\t\texit_client(0);\n+\t\t\t\tbreak;\n+#endif\ncase SIGTERM:\nLOG(LOG_INFO, "Received SIGTERM");\nexit_client(0);')]