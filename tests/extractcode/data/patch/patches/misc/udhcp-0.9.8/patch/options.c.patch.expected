[('udhcp-0.9.8.orig/options.c',
  'udhcp-0.9.8/options.c',
  'Index: udhcp-0.9.8/options.c\n===================================================================\n--- udhcp-0.9.8.orig/options.c\n+++ udhcp-0.9.8/options.c\n@@ -30,19 +30,34 @@ struct dhcp_option options[] = {\n{"bootsize",\tOPTION_U16,\t\t\t\t0x0d},\n{"domain",\tOPTION_STRING | OPTION_REQ,\t\t0x0f},\n{"swapsvr",\tOPTION_IP,\t\t\t\t0x10},\n-\t{"rootpath",\tOPTION_STRING,\t\t\t\t0x11},\n+\t{"rootpath",\tOPTION_STRING | OPTION_REQ,\t\t\t\t0x11},\n{"ipttl",\tOPTION_U8,\t\t\t\t0x17},\n{"mtu",\t\tOPTION_U16,\t\t\t\t0x1a},\n{"broadcast",\tOPTION_IP | OPTION_REQ,\t\t\t0x1c},\n+\t{"sroutes",\tOPTION_IP_PAIR | OPTION_LIST | OPTION_REQ, 0x21},\n{"ntpsrv",\tOPTION_IP | OPTION_LIST,\t\t0x2a},\n+\t{"vciopt",\tOPTION_STRING | OPTION_REQ,\t        0x2b},\n{"wins",\tOPTION_IP | OPTION_LIST,\t\t0x2c},\n{"requestip",\tOPTION_IP,\t\t\t\t0x32},\n{"lease",\tOPTION_U32,\t\t\t\t0x33},\n{"dhcptype",\tOPTION_U8,\t\t\t\t0x35},\n{"serverid",\tOPTION_IP,\t\t\t\t0x36},\n{"message",\tOPTION_STRING,\t\t\t\t0x38},\n+    {"maxsize",   OPTION_U16,         0x39},\n+    {"dhcp_t1",   OPTION_U32 | OPTION_REQ,         0x3a},\n+    {"dhcp_t2",   OPTION_U32 | OPTION_REQ,         0x3b},\n+    {"nisplusd",  OPTION_STRING | OPTION_REQ, 0x40},\n{"tftp",\tOPTION_STRING,\t\t\t\t0x42},\n{"bootfile",\tOPTION_STRING,\t\t\t\t0x43},\n+\t{"uciopt",\tOPTION_STRING,\t                        0x4d},\n+\t{"timezone",\tOPTION_STRING | OPTION_REQ,\t\t0x58},\n+\t{"sroutes",     OPTION_ROUTE | OPTION_LIST | OPTION_REQ, 0x79},\n+\t{"infocast",\tOPTION_STRING | OPTION_REQ,\t\t0x80},\n+\t{"vivendor",\tOPTION_STRING | OPTION_REQ, \t\t0x7d},\n+\t{"option240",   OPTION_STRING | OPTION_REQ,             240},\n+\t{"option241",   OPTION_STRING | OPTION_REQ,             241},\n+\t{"option242",   OPTION_STRING | OPTION_REQ,             242},\n+\t{"option243",   OPTION_STRING | OPTION_REQ,             243},\n{"",\t\t0x00,\t\t\t\t0x00}\n};\n\n@@ -50,6 +65,7 @@ struct dhcp_option options[] = {\nint option_lengths[] = {\n[OPTION_IP] =\t\t4,\n[OPTION_IP_PAIR] =\t8,\n+\t[OPTION_ROUTE] =\t5,\n[OPTION_BOOLEAN] =\t1,\n[OPTION_STRING] =\t1,\n[OPTION_U8] =\t\t1,\n@@ -69,7 +85,7 @@ unsigned char *get_option(struct dhcpMes\n\noptionptr = packet->options;\ni = 0;\n-\tlength = 308;\n+\tlength = IN_OPTIONS_LENGTH;\nwhile (!done) {\nif (i >= length) {\nLOG(LOG_WARNING, "bogus packet, option fields too long.");\n@@ -135,7 +151,7 @@ int add_option_string(unsigned char *opt\nint end = end_option(optionptr);\n\n/* end position + string length + option code/length + end option */\n-\tif (end + string[OPT_LEN] + 2 + 1 >= 308) {\n+\tif (end + string[OPT_LEN] + 2 + 1 >= OUT_OPTIONS_LENGTH) {\nLOG(LOG_ERR, "Option 0x%02x did not fit into the packet!", string[OPT_CODE]);\nreturn 0;\n}\n@@ -145,6 +161,79 @@ int add_option_string(unsigned char *opt\nreturn string[OPT_LEN] + 2;\n}\n\n+int add_user_class_option(unsigned char *optionptr, unsigned char *data)\n+{\n+\tint option_value_len = 0;\n+\tunsigned char *user_class_value = NULL;\n+\tchar *tokenPtr = NULL;\n+\tint end = end_option(optionptr);\n+  unsigned char *option_value_ptr = optionptr + end + OPT_DATA;\n+\n+\t//strtok places a NULL terminator in front of the token,\n+\t//we must backup the orignal user class option data.\n+  user_class_value = (unsigned char*) xmalloc(data[OPT_LEN]+1);\n+  if (user_class_value == NULL) {\n+    return 0;\n+  }\n+\tmemcpy(user_class_value, data + OPT_DATA, data[OPT_LEN]);\n+\tuser_class_value[data[OPT_LEN]] = \'\\0\';\n+\n+\t/* end position + string length + option code/length+miniLen + end option */\n+\tif (end + data[OPT_LEN] + 2 + 2 + 1 >= OUT_OPTIONS_LENGTH) {\n+\t\tLOG(LOG_ERR, "User class option 0x%02x did not fit into the packet!", data[OPT_CODE]);\n+\t\tfree(user_class_value);\n+\t\treturn 0;\n+\t}\n+\tDEBUG(LOG_INFO, "Adding user class option 0x%02x\\noptionvalue:%s\\n", data[OPT_CODE],user_class_value);\n+\n+\ttokenPtr = strtok((char*)user_class_value,",");\n+\tif(tokenPtr == NULL){\n+\t  //If any instances of User Class Data are present, the minimum value of\n+\t  //Len is two (Len = UC_Len_1 + 1 = 1 + 1 = 2)\n+\t\toption_value_ptr[option_value_len] = 1;\n+\t\toption_value_len ++;\n+\t\toption_value_ptr[option_value_len] = 0;\n+\t\toption_value_len ++;\n+\t}\n+\twhile(tokenPtr!=NULL)\n+\t{\n+    //The length of the option as specified in Len must be the sum of\n+\t\t//the lengths of each of the class names plus m:\n+\t\t//Len= UC_Len_1 + UC_Len_2 + ... + UC_Len_m + m\n+\t\toption_value_ptr[option_value_len] = strlen(tokenPtr);\n+\t\toption_value_len ++;\n+\t\tmemcpy(option_value_ptr + option_value_len, tokenPtr, strlen(tokenPtr));\n+\t\toption_value_len += strlen(tokenPtr);\n+\t\tDEBUG(LOG_INFO, "totalLen:%d sub option Len:%d  value:%s\\n", option_value_len, strlen(tokenPtr),tokenPtr);\n+\n+\t\ttokenPtr=strtok(NULL,",");\n+\t}\n+\tDEBUG(LOG_INFO, "totalLen:%d\\n", option_value_len);\n+\toptionptr[end + OPT_CODE] = data[OPT_CODE];\n+\toptionptr[end + OPT_LEN] = option_value_len;\n+\toptionptr[end + option_value_len + 2] = DHCP_END;\n+\tfree(user_class_value);\n+\treturn option_value_len + 2;\n+}\n+\n+/* add an option to a packet */\n+int add_option(unsigned char *optionptr, unsigned char code, u_int8_t* data, u_int8_t datalen)\n+{\n+\tunsigned char *option;\n+\tint result = 0;\n+        option = (unsigned char*) xmalloc(datalen+2);\n+        if (option == NULL) {\n+          return 0;\n+        }\n+\toption[OPT_CODE] = code;\n+\toption[OPT_LEN] = datalen;\n+\n+\tmemcpy(option + OPT_DATA, data, datalen);\n+\tresult = add_option_string(optionptr, option);\n+        free(option);\n+        return result;\n+}\n+\n\n/* add a one to four byte option to a packet */\nint add_simple_option(unsigned char *optionptr, unsigned char code, u_int32_t data)')]