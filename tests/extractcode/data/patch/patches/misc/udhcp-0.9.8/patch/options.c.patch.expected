[
  [
    "udhcp-0.9.8.orig/options.c", 
    "udhcp-0.9.8/options.c", 
    [
      "Index: udhcp-0.9.8/options.c", 
      "===================================================================", 
      "--- udhcp-0.9.8.orig/options.c", 
      "+++ udhcp-0.9.8/options.c", 
      "@@ -30,19 +30,34 @@ struct dhcp_option options[] = {", 
      "{\"bootsize\",\tOPTION_U16,\t\t\t\t0x0d},", 
      "{\"domain\",\tOPTION_STRING | OPTION_REQ,\t\t0x0f},", 
      "{\"swapsvr\",\tOPTION_IP,\t\t\t\t0x10},", 
      "-\t{\"rootpath\",\tOPTION_STRING,\t\t\t\t0x11},", 
      "+\t{\"rootpath\",\tOPTION_STRING | OPTION_REQ,\t\t\t\t0x11},", 
      "{\"ipttl\",\tOPTION_U8,\t\t\t\t0x17},", 
      "{\"mtu\",\t\tOPTION_U16,\t\t\t\t0x1a},", 
      "{\"broadcast\",\tOPTION_IP | OPTION_REQ,\t\t\t0x1c},", 
      "+\t{\"sroutes\",\tOPTION_IP_PAIR | OPTION_LIST | OPTION_REQ, 0x21},", 
      "{\"ntpsrv\",\tOPTION_IP | OPTION_LIST,\t\t0x2a},", 
      "+\t{\"vciopt\",\tOPTION_STRING | OPTION_REQ,\t        0x2b},", 
      "{\"wins\",\tOPTION_IP | OPTION_LIST,\t\t0x2c},", 
      "{\"requestip\",\tOPTION_IP,\t\t\t\t0x32},", 
      "{\"lease\",\tOPTION_U32,\t\t\t\t0x33},", 
      "{\"dhcptype\",\tOPTION_U8,\t\t\t\t0x35},", 
      "{\"serverid\",\tOPTION_IP,\t\t\t\t0x36},", 
      "{\"message\",\tOPTION_STRING,\t\t\t\t0x38},", 
      "+    {\"maxsize\",   OPTION_U16,         0x39},", 
      "+    {\"dhcp_t1\",   OPTION_U32 | OPTION_REQ,         0x3a},", 
      "+    {\"dhcp_t2\",   OPTION_U32 | OPTION_REQ,         0x3b},", 
      "+    {\"nisplusd\",  OPTION_STRING | OPTION_REQ, 0x40},", 
      "{\"tftp\",\tOPTION_STRING,\t\t\t\t0x42},", 
      "{\"bootfile\",\tOPTION_STRING,\t\t\t\t0x43},", 
      "+\t{\"uciopt\",\tOPTION_STRING,\t                        0x4d},", 
      "+\t{\"timezone\",\tOPTION_STRING | OPTION_REQ,\t\t0x58},", 
      "+\t{\"sroutes\",     OPTION_ROUTE | OPTION_LIST | OPTION_REQ, 0x79},", 
      "+\t{\"infocast\",\tOPTION_STRING | OPTION_REQ,\t\t0x80},", 
      "+\t{\"vivendor\",\tOPTION_STRING | OPTION_REQ, \t\t0x7d},", 
      "+\t{\"option240\",   OPTION_STRING | OPTION_REQ,             240},", 
      "+\t{\"option241\",   OPTION_STRING | OPTION_REQ,             241},", 
      "+\t{\"option242\",   OPTION_STRING | OPTION_REQ,             242},", 
      "+\t{\"option243\",   OPTION_STRING | OPTION_REQ,             243},", 
      "{\"\",\t\t0x00,\t\t\t\t0x00}", 
      "};", 
      "", 
      "@@ -50,6 +65,7 @@ struct dhcp_option options[] = {", 
      "int option_lengths[] = {", 
      "[OPTION_IP] =\t\t4,", 
      "[OPTION_IP_PAIR] =\t8,", 
      "+\t[OPTION_ROUTE] =\t5,", 
      "[OPTION_BOOLEAN] =\t1,", 
      "[OPTION_STRING] =\t1,", 
      "[OPTION_U8] =\t\t1,", 
      "@@ -69,7 +85,7 @@ unsigned char *get_option(struct dhcpMes", 
      "", 
      "optionptr = packet->options;", 
      "i = 0;", 
      "-\tlength = 308;", 
      "+\tlength = IN_OPTIONS_LENGTH;", 
      "while (!done) {", 
      "if (i >= length) {", 
      "LOG(LOG_WARNING, \"bogus packet, option fields too long.\");", 
      "@@ -135,7 +151,7 @@ int add_option_string(unsigned char *opt", 
      "int end = end_option(optionptr);", 
      "", 
      "/* end position + string length + option code/length + end option */", 
      "-\tif (end + string[OPT_LEN] + 2 + 1 >= 308) {", 
      "+\tif (end + string[OPT_LEN] + 2 + 1 >= OUT_OPTIONS_LENGTH) {", 
      "LOG(LOG_ERR, \"Option 0x%02x did not fit into the packet!\", string[OPT_CODE]);", 
      "return 0;", 
      "}", 
      "@@ -145,6 +161,79 @@ int add_option_string(unsigned char *opt", 
      "return string[OPT_LEN] + 2;", 
      "}", 
      "", 
      "+int add_user_class_option(unsigned char *optionptr, unsigned char *data)", 
      "+{", 
      "+\tint option_value_len = 0;", 
      "+\tunsigned char *user_class_value = NULL;", 
      "+\tchar *tokenPtr = NULL;", 
      "+\tint end = end_option(optionptr);", 
      "+  unsigned char *option_value_ptr = optionptr + end + OPT_DATA;", 
      "+", 
      "+\t//strtok places a NULL terminator in front of the token,", 
      "+\t//we must backup the orignal user class option data.", 
      "+  user_class_value = (unsigned char*) xmalloc(data[OPT_LEN]+1);", 
      "+  if (user_class_value == NULL) {", 
      "+    return 0;", 
      "+  }", 
      "+\tmemcpy(user_class_value, data + OPT_DATA, data[OPT_LEN]);", 
      "+\tuser_class_value[data[OPT_LEN]] = '\\0';", 
      "+", 
      "+\t/* end position + string length + option code/length+miniLen + end option */", 
      "+\tif (end + data[OPT_LEN] + 2 + 2 + 1 >= OUT_OPTIONS_LENGTH) {", 
      "+\t\tLOG(LOG_ERR, \"User class option 0x%02x did not fit into the packet!\", data[OPT_CODE]);", 
      "+\t\tfree(user_class_value);", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+\tDEBUG(LOG_INFO, \"Adding user class option 0x%02x\\noptionvalue:%s\\n\", data[OPT_CODE],user_class_value);", 
      "+", 
      "+\ttokenPtr = strtok((char*)user_class_value,\",\");", 
      "+\tif(tokenPtr == NULL){", 
      "+\t  //If any instances of User Class Data are present, the minimum value of", 
      "+\t  //Len is two (Len = UC_Len_1 + 1 = 1 + 1 = 2)", 
      "+\t\toption_value_ptr[option_value_len] = 1;", 
      "+\t\toption_value_len ++;", 
      "+\t\toption_value_ptr[option_value_len] = 0;", 
      "+\t\toption_value_len ++;", 
      "+\t}", 
      "+\twhile(tokenPtr!=NULL)", 
      "+\t{", 
      "+    //The length of the option as specified in Len must be the sum of", 
      "+\t\t//the lengths of each of the class names plus m:", 
      "+\t\t//Len= UC_Len_1 + UC_Len_2 + ... + UC_Len_m + m", 
      "+\t\toption_value_ptr[option_value_len] = strlen(tokenPtr);", 
      "+\t\toption_value_len ++;", 
      "+\t\tmemcpy(option_value_ptr + option_value_len, tokenPtr, strlen(tokenPtr));", 
      "+\t\toption_value_len += strlen(tokenPtr);", 
      "+\t\tDEBUG(LOG_INFO, \"totalLen:%d sub option Len:%d  value:%s\\n\", option_value_len, strlen(tokenPtr),tokenPtr);", 
      "+", 
      "+\t\ttokenPtr=strtok(NULL,\",\");", 
      "+\t}", 
      "+\tDEBUG(LOG_INFO, \"totalLen:%d\\n\", option_value_len);", 
      "+\toptionptr[end + OPT_CODE] = data[OPT_CODE];", 
      "+\toptionptr[end + OPT_LEN] = option_value_len;", 
      "+\toptionptr[end + option_value_len + 2] = DHCP_END;", 
      "+\tfree(user_class_value);", 
      "+\treturn option_value_len + 2;", 
      "+}", 
      "+", 
      "+/* add an option to a packet */", 
      "+int add_option(unsigned char *optionptr, unsigned char code, u_int8_t* data, u_int8_t datalen)", 
      "+{", 
      "+\tunsigned char *option;", 
      "+\tint result = 0;", 
      "+        option = (unsigned char*) xmalloc(datalen+2);", 
      "+        if (option == NULL) {", 
      "+          return 0;", 
      "+        }", 
      "+\toption[OPT_CODE] = code;", 
      "+\toption[OPT_LEN] = datalen;", 
      "+", 
      "+\tmemcpy(option + OPT_DATA, data, datalen);", 
      "+\tresult = add_option_string(optionptr, option);", 
      "+        free(option);", 
      "+        return result;", 
      "+}", 
      "+", 
      "", 
      "/* add a one to four byte option to a packet */", 
      "int add_simple_option(unsigned char *optionptr, unsigned char code, u_int32_t data)"
    ]
  ]
]