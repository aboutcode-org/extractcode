[('src.orig/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.cpp',
  'src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.cpp',
  'Index: src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.cpp\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.cpp\n+++ src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.cpp\n@@ -30,32 +30,41 @@\n#include "FloatRect.h"\n#include "ImageObserver.h"\n#include "IntRect.h"\n+#include "MIMETypeRegistry.h"\n#include "PlatformString.h"\n#include "Timer.h"\n+#include "SystemTime.h"\n#include <wtf/Vector.h>\n-#include "MIMETypeRegistry.h"\n\nnamespace WebCore {\n\n// Animated images >5MB are considered large enough that we\'ll only hang on to\n// one frame at a time.\nconst unsigned cLargeAnimationCutoff = 5242880;\n+static int frameBytes(const IntSize& frameSize)\n+{\n+    return frameSize.width() * frameSize.height() * 4;\n+}\n\nBitmapImage::BitmapImage(ImageObserver* observer, bool accelerated)\n: Image(observer)\n, m_currentFrame(0)\n, m_frames(0)\n, m_frameTimer(0)\n-    , m_repetitionCount(0)\n+    , m_repetitionCount(cAnimationNone)\n+    , m_repetitionCountStatus(Unknown)\n, m_repetitionsComplete(0)\n+    , m_desiredFrameStartTime(0)\n, m_isSolidColor(false)\n-    , m_animatingImageType(true)\n+    , m_checkedForSolidColor(false)\n, m_animationFinished(false)\n, m_allDataReceived(false)\n, m_haveSize(false)\n, m_sizeAvailable(false)\n, m_decodedSize(0)\n+    , m_haveFrameCount(false)\n, m_accelerated(accelerated)\n+    , m_frameCount(0)\n{\ninitPlatformData();\n}\n@@ -99,18 +108,22 @@ void BitmapImage::destroyDecodedData(boo\n}\n}\n\n+\n+void BitmapImage::destroyDecodedDataIfNecessary(bool destroyAll)\n+{\n+    // Animated images >5MB are considered large enough that we\'ll only hang on\n+    // to one frame at a time.\n+    static const unsigned cLargeAnimationCutoff = 5242880;\n+    if (frameCount() * frameBytes(m_size) > cLargeAnimationCutoff)\n+        destroyDecodedData(destroyAll);\n+}\n+\n+\nvoid BitmapImage::cacheFrame(size_t index)\n{\nsize_t numFrames = frameCount();\nASSERT(m_decodedSize == 0 || numFrames > 1);\n\n-    if (!m_frames.size() && shouldAnimate()) {\n-        // Snag the repetition count.\n-        m_repetitionCount = m_source.repetitionCount();\n-        if (m_repetitionCount == cAnimationNone)\n-            m_animatingImageType = false;\n-    }\n-\nif (m_frames.size() < numFrames)\nm_frames.grow(numFrames);\n\n@@ -118,7 +131,8 @@ void BitmapImage::cacheFrame(size_t inde\nif (numFrames == 1 && m_frames[index].m_frame)\ncheckForSolidColor();\n\n-    if (shouldAnimate())\n+    m_frames[index].m_isComplete = m_source.frameIsCompleteAtIndex(index);\n+    if (repetitionCount(false) != cAnimationNone)\nm_frames[index].m_duration = m_source.frameDurationAtIndex(index);\nm_frames[index].m_hasAlpha = m_source.frameHasAlphaAtIndex(index);\n\n@@ -147,6 +161,9 @@ bool BitmapImage::dataChanged(bool allDa\nm_allDataReceived = allDataReceived;\nm_source.setData(m_data.get(), allDataReceived, m_accelerated);\n\n+    // Clear the frame count.\n+    m_haveFrameCount = false;\n+\n// Image properties will not be available until the first frame of the file\n// reaches kCGImageStatusIncomplete.\nreturn isSizeAvailable();\n@@ -154,7 +171,11 @@ bool BitmapImage::dataChanged(bool allDa\n\nsize_t BitmapImage::frameCount()\n{\n-    return m_source.frameCount();\n+    if (!m_haveFrameCount) {\n+        m_haveFrameCount = true;\n+        m_frameCount = m_source.frameCount();\n+    }\n+    return m_frameCount;\n}\n\nbool BitmapImage::isSizeAvailable()\n@@ -178,6 +199,17 @@ NativeImagePtr BitmapImage::frameAtIndex\nreturn m_frames[index].m_frame;\n}\n\n+bool BitmapImage::frameIsCompleteAtIndex(size_t index)\n+{\n+    if (index >= frameCount())\n+        return true;\n+\n+    if (index >= m_frames.size() || !m_frames[index].m_frame)\n+        cacheFrame(index);\n+\n+    return m_frames[index].m_isComplete;\n+}\n+\nfloat BitmapImage::frameDurationAtIndex(size_t index)\n{\nif (index >= frameCount())\n@@ -200,22 +232,118 @@ bool BitmapImage::frameHasAlphaAtIndex(s\nreturn m_frames[index].m_hasAlpha;\n}\n\n+int BitmapImage::repetitionCount(bool imageKnownToBeComplete)\n+{\n+    if ((m_repetitionCountStatus == Unknown) || ((m_repetitionCountStatus == Uncertain) && imageKnownToBeComplete)) {\n+        // Snag the repetition count.  If |imageKnownToBeComplete| is false, the\n+        // repetition count may not be accurate yet for GIFs; in this case the\n+        // decoder will default to cAnimationLoopOnce, and we\'ll try and read\n+        // the count again once the whole image is decoded.\n+        m_repetitionCount = m_source.repetitionCount();\n+        m_repetitionCountStatus = (imageKnownToBeComplete || m_repetitionCount == cAnimationNone) ? Certain : Uncertain;\n+    }\n+    return m_repetitionCount;\n+}\n+\nbool BitmapImage::shouldAnimate()\n{\n-    return (m_animatingImageType && !m_animationFinished && imageObserver());\n+    return (repetitionCount(false) != cAnimationNone && !m_animationFinished && imageObserver());\n}\n\n-void BitmapImage::startAnimation()\n+void BitmapImage::startAnimation(bool catchUpIfNecessary)\n{\nif (m_frameTimer || !shouldAnimate() || frameCount() <= 1)\nreturn;\n\n-    // Don\'t advance the animation until the current frame has completely loaded.\n-    if (!m_source.frameIsCompleteAtIndex(m_currentFrame))\n+    // Determine time for next frame to start.  By ignoring paint and timer lag\n+    // in this calculation, we make the animation appear to run at its desired\n+    // rate regardless of how fast it\'s being repainted.\n+    const double currentDuration = frameDurationAtIndex(m_currentFrame);\n+    const double time = currentTime();\n+    if (m_desiredFrameStartTime == 0) {\n+        m_desiredFrameStartTime = time + currentDuration;\n+    } else {\n+        m_desiredFrameStartTime += currentDuration;\n+\n+        // When an animated image is more than five minutes out of date, the\n+        // user probably doesn\'t care about resyncing and we could burn a lot of\n+        // time looping through frames below.  Just reset the timings.\n+        const double cAnimationResyncCutoff = 5 * 60;\n+        if ((time - m_desiredFrameStartTime) > cAnimationResyncCutoff)\n+            m_desiredFrameStartTime = time + currentDuration;\n+    }\n+\n+    // Don\'t advance the animation to an incomplete frame.\n+    size_t nextFrame = (m_currentFrame + 1) % frameCount();\n+    if (!m_allDataReceived && !frameIsCompleteAtIndex(nextFrame))\n+        return;\n+\n+    // Don\'t advance past the last frame if we haven\'t decoded the whole image\n+    // yet and our repetition count is potentially unset.  The repetition count\n+    // in a GIF can potentially come after all the rest of the image data, so\n+    // wait on it.\n+    if (!m_allDataReceived && repetitionCount(false) == cAnimationLoopOnce && m_currentFrame >= (frameCount() - 1))\nreturn;\n\n-    m_frameTimer = new Timer<BitmapImage>(this, &BitmapImage::advanceAnimation);\n-    m_frameTimer->startOneShot(frameDurationAtIndex(m_currentFrame));\n+    // The image may load more slowly than it\'s supposed to animate, so that by\n+    // the time we reach the end of the first repetition, we\'re well behind.\n+    // Clamp the desired frame start time in this case, so that we don\'t skip\n+    // frames (or whole iterations) trying to "catch up".  This is a tradeoff:\n+    // It guarantees users see the whole animation the second time through and\n+    // don\'t miss any repetitions, and is closer to what other browsers do; on\n+    // the other hand, it makes animations "less accurate" for pages that try to\n+    // sync an image and some other resource (e.g. audio), especially if users\n+    // switch tabs (and thus stop drawing the animation, which will pause it)\n+    // during that initial loop, then switch back later.\n+    if (nextFrame == 0 && m_repetitionsComplete == 0 && m_desiredFrameStartTime < time)\n+      m_desiredFrameStartTime = time;\n+\n+    if (!catchUpIfNecessary || time < m_desiredFrameStartTime) {\n+        // Haven\'t yet reached time for next frame to start; delay until then.\n+        m_frameTimer = new Timer<BitmapImage>(this, &BitmapImage::advanceAnimation);\n+        m_frameTimer->startOneShot(std::max(m_desiredFrameStartTime - time, 0.));\n+    } else {\n+        // We\'ve already reached or passed the time for the next frame to start.\n+        // See if we\'ve also passed the time for frames after that to start, in\n+        // case we need to skip some frames entirely.  Remember not to advance\n+        // to an incomplete frame.\n+        for (size_t frameAfterNext = (nextFrame + 1) % frameCount(); frameIsCompleteAtIndex(frameAfterNext); frameAfterNext = (nextFrame + 1) % frameCount()) {\n+            // Should we skip the next frame?\n+            double frameAfterNextStartTime = m_desiredFrameStartTime + frameDurationAtIndex(nextFrame);\n+            if (time < frameAfterNextStartTime)\n+                break;\n+\n+            // Yes; skip over it without notifying our observers.\n+            if (!internalAdvanceAnimation(true))\n+                return;\n+            m_desiredFrameStartTime = frameAfterNextStartTime;\n+            nextFrame = frameAfterNext;\n+        }\n+\n+        // Draw the next frame immediately.  Note that m_desiredFrameStartTime\n+        // may be in the past, meaning the next time through this function we\'ll\n+        // kick off the next advancement sooner than this frame\'s duration would\n+        // suggest.\n+        if (internalAdvanceAnimation(false)) {\n+            // The image region has been marked dirty, but once we return to our\n+            // caller, draw() will clear it, and nothing will cause the\n+            // animation to advance again.  We need to start the timer for the\n+            // next frame running, or the animation can hang.  (Compare this\n+            // with when advanceAnimation() is called, and the region is dirtied\n+            // while draw() is not in the callstack, meaning draw() gets called\n+            // to update the region and thus startAnimation() is reached again.)\n+            // NOTE: For large images with slow or heavily-loaded systems,\n+            // throwing away data as we go (see destroyDecodedData()) means we\n+            // can spend so much time re-decoding data above that by the time we\n+            // reach here we\'re behind again.  If we let startAnimation() run\n+            // the catch-up code again, we can get long delays without painting\n+            // as we race the timer, or even infinite recursion.  In this\n+            // situation the best we can do is to simply change frames as fast\n+            // as possible, so force startAnimation() to set a zero-delay timer\n+            // and bail out if we\'re not caught up.\n+            startAnimation(false);\n+        }\n+    }\n}\n\nvoid BitmapImage::stopAnimation()\n@@ -231,53 +359,57 @@ void BitmapImage::resetAnimation()\nstopAnimation();\nm_currentFrame = 0;\nm_repetitionsComplete = 0;\n+    m_desiredFrameStartTime = 0;\nm_animationFinished = false;\n-    int frameSize = m_size.width() * m_size.height() * 4;\n\n// For extremely large animations, when the animation is reset, we just throw everything away.\n-    if (frameCount() * frameSize > cLargeAnimationCutoff)\n-        destroyDecodedData();\n+    destroyDecodedDataIfNecessary(true);\n+}\n+\n+void BitmapImage::advanceAnimation(Timer<BitmapImage>*)\n+{\n+    internalAdvanceAnimation(false);\n+    // At this point the image region has been marked dirty, and if it\'s\n+    // onscreen, we\'ll soon make a call to draw(), which will call\n+    // startAnimation() again to keep the animation moving.\n}\n\n-void BitmapImage::advanceAnimation(Timer<BitmapImage>* timer)\n+bool BitmapImage::internalAdvanceAnimation(bool skippingFrames)\n{\n// Stop the animation.\nstopAnimation();\n\n// See if anyone is still paying attention to this animation.  If not, we don\'t\n// advance and will remain suspended at the current frame until the animation is resumed.\n-    if (imageObserver()->shouldPauseAnimation(this))\n-        return;\n+    if (!skippingFrames && imageObserver()->shouldPauseAnimation(this))\n+        return false;\n\n-    m_currentFrame++;\n+    ++m_currentFrame;\n+    bool advancedAnimation = true;\n+    bool destroyAll = false;\nif (m_currentFrame >= frameCount()) {\n-        m_repetitionsComplete += 1;\n-        if (m_repetitionCount && m_repetitionsComplete >= m_repetitionCount) {\n+        ++m_repetitionsComplete;\n+\n+        // Get the repetition count again.  If we weren\'t able to get a\n+        // repetition count before, we should have decoded the whole image by\n+        // now, so it should now be available.\n+        if (repetitionCount(true) && m_repetitionsComplete >= m_repetitionCount) {\nm_animationFinished = true;\n-            m_currentFrame--;\n-            return;\n+            m_desiredFrameStartTime = 0;\n+            --m_currentFrame;\n+            advancedAnimation = false;\n+        } else {\n+            m_currentFrame = 0;\n+            destroyAll = true;\n}\n-        m_currentFrame = 0;\n}\n+    destroyDecodedDataIfNecessary(destroyAll);\n\n-    // Notify our observer that the animation has advanced.\n-    imageObserver()->animationAdvanced(this);\n-\n-    // For large animated images, go ahead and throw away frames as we go to save\n-    // footprint.\n-    int frameSize = m_size.width() * m_size.height() * 4;\n-    if (frameCount() * frameSize > cLargeAnimationCutoff) {\n-        // Destroy all of our frames and just redecode every time.\n-        destroyDecodedData();\n-\n-        // Go ahead and decode the next frame.\n-        frameAtIndex(m_currentFrame);\n-    }\n-\n-    // We do not advance the animation explicitly.  We rely on a subsequent draw of the image\n-    // to force a request for the next frame via startAnimation().  This allows images that move offscreen while\n-    // scrolling to stop animating (thus saving memory from additional decoded frames and\n-    // CPU time spent doing the decoding).\n+    // We need to draw this frame if we advanced to it while not skipping, or if\n+    // while trying to skip frames we hit the last frame and thus had to stop.\n+    if (skippingFrames != advancedAnimation)\n+        imageObserver()->animationAdvanced(this);\n+    return advancedAnimation;\n}\n\n}'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.h',
  'src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.h\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.h\n+++ src/3rdParty/webkit/work/WebCore/platform/graphics/BitmapImage.h\n@@ -66,6 +66,7 @@ template <typename T> class Timer;\nstruct FrameData : Noncopyable {\nFrameData()\n: m_frame(0)\n+        , m_isComplete(false)\n, m_duration(0)\n, m_hasAlpha(true)\n{\n@@ -79,6 +80,7 @@ struct FrameData : Noncopyable {\nvoid clear();\n\nNativeImagePtr m_frame;\n+    bool m_isComplete;\nfloat m_duration;\nbool m_hasAlpha;\n};\n@@ -96,6 +98,10 @@ public:\nBitmapImage(ImageObserver* = 0, bool accelerated = false);\n~BitmapImage();\n\n+    virtual bool isBitmapImage() const { return true; }\n+\n+    virtual bool hasSingleSecurityOrigin() const { return true; }\n+\nvirtual IntSize size() const;\nvirtual bool isAccelerated() const { return m_accelerated; }\n\n@@ -130,7 +136,14 @@ public:\n\nvirtual NativeImagePtr nativeImageForCurrentFrame() { return frameAtIndex(currentFrame()); }\n\n-private:\n+protected:\n+    enum RepetitionCountStatus {\n+      Unknown,    // We haven\'t checked the source\'s repetition count.\n+      Uncertain,  // We have a repetition count, but it might be wrong (some GIFs have a count after the image data, and will report "loop once" until all data has been decoded).\n+      Certain,    // The repetition count is known to be correct.\n+    };\n+\n+//private:\n#if PLATFORM(WIN)\nvirtual void drawFrameMatchingSourceSize(GraphicsContext*, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator);\n#endif\n@@ -142,6 +155,7 @@ private:\nsize_t currentFrame() const { return m_currentFrame; }\nsize_t frameCount();\nNativeImagePtr frameAtIndex(size_t);\n+    bool frameIsCompleteAtIndex(size_t);\nfloat frameDurationAtIndex(size_t);\nbool frameHasAlphaAtIndex(size_t);\n\n@@ -151,23 +165,43 @@ private:\n// Called to invalidate all our cached data.  If an image is loading incrementally, we only\n// invalidate the last cached frame.\nvirtual void destroyDecodedData(bool incremental = false);\n+    // If the image is large enough, calls destroyDecodedData() and passes\n+    // |destroyAll| along.\n+    void destroyDecodedDataIfNecessary(bool destroyAll);\n\n// Whether or not size is available yet.\nbool isSizeAvailable();\n\n// Animation.\n+    int repetitionCount(bool imageKnownToBeComplete);  // |imageKnownToBeComplete| should be set if the caller knows the entire image has been decoded.\nbool shouldAnimate();\n-    virtual void startAnimation();\n+    virtual void startAnimation(bool catchUpIfNecessary = true);\nvoid advanceAnimation(Timer<BitmapImage>*);\n-\n+\n+    // Function that does the real work of advancing the animation.  When\n+    // skippingFrames is true, we\'re in the middle of a loop trying to skip over\n+    // a bunch of animation frames, so we should not do things like decode each\n+    // one or notify our observers.\n+    // Returns whether the animation was advanced.\n+    bool internalAdvanceAnimation(bool skippingFrames);\n+\n// Handle platform-specific data\nvoid initPlatformData();\nvoid invalidatePlatformData();\n\n// Checks to see if the image is a 1x1 solid color.  We optimize these images and just do a fill rect instead.\n+    // This check should happen regardless whether m_checkedForSolidColor is already set, as the frame may have\n+    // changed.\nvoid checkForSolidColor();\n\n-    virtual bool mayFillWithSolidColor() const { return m_isSolidColor && m_currentFrame == 0; }\n+    virtual bool mayFillWithSolidColor()\n+    {\n+        if (!m_checkedForSolidColor && frameCount() > 0) {\n+            checkForSolidColor();\n+            ASSERT(m_checkedForSolidColor);\n+        }\n+        return m_isSolidColor && m_currentFrame == 0;\n+    }\nvirtual Color solidColor() const { return m_solidColor; }\n\nImageSource m_source;\n@@ -177,8 +211,10 @@ private:\nVector<FrameData> m_frames; // An array of the cached frames of the animation. We have to ref frames to pin them in the cache.\n\nTimer<BitmapImage>* m_frameTimer;\n-    int m_repetitionCount; // How many total animation loops we should do.\n+    int m_repetitionCount; // How many total animation loops we should do.  This will be cAnimationNone if this image type is incapable of animation.\n+    RepetitionCountStatus m_repetitionCountStatus;\nint m_repetitionsComplete;  // How many repetitions we\'ve finished.\n+    double m_desiredFrameStartTime;  // The system time at which we hope to see the next call to startAnimation().\n\n#if PLATFORM(MAC)\nmutable RetainPtr<NSImage> m_nsImage; // A cached NSImage of frame 0. Only built lazily if someone actually queries for one.\n@@ -187,8 +223,8 @@ private:\n\nColor m_solidColor;  // If we\'re a 1x1 solid color, this is the color to use to fill.\nbool m_isSolidColor;  // Whether or not we are a 1x1 solid image.\n+    bool m_checkedForSolidColor; // Whether we\'ve checked the frame for solid color.\n\n-    bool m_animatingImageType;  // Whether or not we\'re an image type that is capable of animating (GIF).\nbool m_animationFinished;  // Whether or not we\'ve completed the entire animation.\n\nbool m_allDataReceived;  // Whether or not we\'ve received all our data.\n@@ -202,6 +238,8 @@ private:\nQPixmap *m_pixmap;\n#endif\n\n+    mutable bool m_haveFrameCount;\n+    size_t m_frameCount;\n};\n\n}'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/graphics/Image.h',
  'src/3rdParty/webkit/work/WebCore/platform/graphics/Image.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/graphics/Image.h\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/graphics/Image.h\n+++ src/3rdParty/webkit/work/WebCore/platform/graphics/Image.h\n@@ -102,9 +102,9 @@ public:\n\nSharedBuffer* data() { return m_data.get(); }\n\n-    // It may look unusual that there is no start animation call as public API.  This is because\n-    // we start and stop animating lazily.  Animation begins whenever someone draws the image.  It will\n-    // automatically pause once all observers no longer want to render the image anywhere.\n+    // Animation begins whenever someone draws the image, so startAnimation() is not normally called.\n+    // It will automatically pause once all observers no longer want to render the image anywhere.\n+    virtual void startAnimation(bool /*catchUpIfNecessary*/ = true) { }\nvirtual void stopAnimation() {}\nvirtual void resetAnimation() {}\n\n@@ -137,7 +137,7 @@ public:\nprotected:\nstatic void fillWithSolidColor(GraphicsContext* ctxt, const FloatRect& dstRect, const Color& color, CompositeOperator op);\n\n-private:\n+//private:\n#if PLATFORM(WIN)\nvirtual void drawFrameMatchingSourceSize(GraphicsContext*, const FloatRect& dstRect, const IntSize& srcSize, CompositeOperator) { }\n#endif\n@@ -149,8 +149,6 @@ private:\nvirtual bool mayFillWithSolidColor() const { return false; }\nvirtual Color solidColor() const { return Color(); }\n\n-    virtual void startAnimation() { }\n-\nvirtual void drawPattern(GraphicsContext*, const FloatRect& srcRect, const AffineTransform& patternTransform,\nconst FloatPoint& phase, CompositeOperator, const FloatRect& destRect);\n#if PLATFORM(CG)'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp',
  'src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp',
  'Index: src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp\n+++ src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.cpp\n@@ -150,11 +150,25 @@ int GIFImageDecoder::frameCount()\n// The number of repetitions to perform for an animation loop.\nint GIFImageDecoder::repetitionCount() const\n{\n-    // We don\'t have to do any decoding to determine this, since the loop count was determined after\n-    // the initial query for size.\n-    if (m_reader)\n-        return m_reader->repetitionCount();\n-    return cAnimationNone;\n+    // This value can arrive at any point in the image data stream.  Most GIFs\n+    // in the wild declare it near the beginning of the file, so it usually is\n+    // set by the time we\'ve decoded the size, but (depending on the GIF and the\n+    // packets sent back by the webserver) not always.  Our caller is\n+    // responsible for waiting until image decoding has finished to ask this if\n+    // it needs an authoritative answer.  In the meantime, we should default to\n+    // "loop once".\n+    if (m_reader) {\n+        // Added wrinkle: ImageSource::clear() may destroy the reader, making\n+        // the result from the reader _less_ authoritative on future calls.  To\n+        // detect this, the reader returns cLoopCountNotSeen (-2) instead of\n+        // cAnimationLoopOnce (-1) when its current incarnation hasn\'t actually\n+        // seen a loop count yet; in this case we return our previously-cached\n+        // value.\n+        const int repetitionCount = m_reader->repetitionCount();\n+        if (repetitionCount != cLoopCountNotSeen)\n+            m_repetitionCount = repetitionCount;\n+    }\n+    return m_repetitionCount;\n}\n\nRGBA32Buffer* GIFImageDecoder::frameBufferAtIndex(size_t index)\n@@ -400,6 +414,8 @@ void GIFImageDecoder::frameComplete(unsi\n\nvoid GIFImageDecoder::gifComplete()\n{\n+    if (m_reader)\n+        m_repetitionCount = m_reader->repetitionCount();\ndelete m_reader;\nm_reader = 0;\n}'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageReader.h',
  'src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageReader.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageReader.h\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageReader.h\n+++ src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageReader.h\n@@ -47,6 +47,8 @@\n#define MAX_COLORS           256\n#define MAX_HOLD_SIZE        256\n\n+const int cLoopCountNotSeen = -2;\n+\n/* gif2.h\nThe interface for the GIF87/89a decoder.\n*/\n@@ -187,7 +189,7 @@ struct GIFImageReader {\nscreen_bgcolor = version = 0;\nscreen_width = screen_height = 0;\nglobal_colormap_size = images_decoded = images_count = 0;\n-        loop_count = -1;\n+        loop_count = cLoopCountNotSeen;\ncount = 0;\n}\n'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.h',
  'src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.h\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.h\n+++ src/3rdParty/webkit/work/WebCore/platform/image-decoders/gif/GIFImageDecoder.h\n@@ -79,6 +79,7 @@ private:\n\nbool m_frameCountValid;\nbool m_currentBufferSawAlpha;\n+    mutable int m_repetitionCount;\nmutable GIFImageDecoderPrivate* m_reader;\n};\n')]