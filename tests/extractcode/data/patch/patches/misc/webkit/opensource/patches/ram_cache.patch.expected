[('src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleEkioh.cpp',
  'src/Browser/WebCore/platform/network/ekioh/ResourceHandleEkioh.cpp',
  'Index: src/Browser/WebCore/platform/network/ekioh/ResourceHandleEkioh.cpp\n===================================================================\n--- src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleEkioh.cpp\n+++ src/Browser/WebCore/platform/network/ekioh/ResourceHandleEkioh.cpp\n@@ -195,7 +195,8 @@ namespace {\n// Informational - ignore\nreturn;\n}\n-    else if (context.m_responseCode >= 300 && context.m_responseCode < 400) {\n+    else if (context.m_responseCode >= 300 && context.m_responseCode < 400 &&\n+             context.m_responseCode != 304) {\n// HTTP Redirect\nreturn;\n}\n@@ -324,101 +325,342 @@ void ResourceHandle::loadResourceSynchro\n#else\n// NOTE: Code based on asynchronous implementation in\n//       Browser/WebCore/platform/network/ekioh/ResourceHandleManager.cpp\n-void ResourceHandle::loadResourceSynchronously(const ResourceRequest& request, ResourceError& e, ResourceResponse& r, Vector<char>& data, Frame* frame)\n+void ResourceHandle::loadResourceSynchronously(const ResourceRequest& request,\n+                                               ResourceError& e,\n+                                               ResourceResponse& r,\n+                                               Vector<char>& data,\n+                                               Frame* frame)\n{\n-  static const int invalidURL = 786;\n-  static const int badProtocolOrPort = 770;\n-  static char errorBuffer[CURL_ERROR_SIZE];\n-\n-  if (!request.url().isValid()) {\n-    e = ResourceError("url", invalidURL,\n-                      request.url().deprecatedString(), "Invalid URL");\n-    return;\n-  }\n-\n-  if (!isPortAllowed(request)) {\n-    e = ResourceError("url", badProtocolOrPort,\n-                      request.url().deprecatedString(), "Port not allowed");\n-    return;\n-  }\n-\n-  CURLcode curlStatus = CURLE_OK;\n-  CURL* curlHandle = curl_easy_init();\n-  CallbackContext context(curlHandle, data, r);\n-  CURLSH* shareHandle = ResourceHandleManager::instance()->getCurlShareHandle();\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_ERRORBUFFER, errorBuffer));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, writeCallback));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, &context));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HEADERFUNCTION, headerCallback));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HEADERDATA, &context));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_FOLLOWLOCATION, 1));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPAUTH, CURLAUTH_ANY));\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_SHARE, shareHandle));\n-  if (access(CA_BUNDLE_FILE, R_OK) == 0) {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAINFO, CA_BUNDLE_FILE));\n-  } else {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAINFO, NULL));\n-  }\n-  if (access(CA_PATH, R_OK) == 0) {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAPATH, CA_PATH));\n-  } else {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAPATH, NULL));\n-  }\n-  // enable gzip and deflate through Accept-Encoding:\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_ENCODING, ""));\n+    static const int invalidURL = 786;\n+    static const int badProtocolOrPort = 770;\n+    static char errorBuffer[CURL_ERROR_SIZE];\n+\n+    if (!request.url().isValid()) {\n+        e = ResourceError("url", invalidURL,\n+                          request.url().deprecatedString(), "Invalid URL");\n+        return;\n+    }\n\n-  CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_URL,\n-                             request.url().deprecatedString().ascii()));\n+    if (!isPortAllowed(request)) {\n+        e = ResourceError("url", badProtocolOrPort,\n+                          request.url().deprecatedString(), "Port not allowed");\n+        return;\n+    }\n\n-  ResourceHandleManager::setProxy(request, curlHandle);\n+    CachedResponse* cacheEntry = NULL;\n\n-  struct curl_slist* headers = 0;\n-\n-  if (request.httpHeaderFields().size() > 0) {\n-    HTTPHeaderMap customHeaders = request.httpHeaderFields();\n-    HTTPHeaderMap::const_iterator end = customHeaders.end();\n-    for (HTTPHeaderMap::const_iterator it = customHeaders.begin(); it != end; ++it) {\n-      String key = it->first;\n-      String value = it->second;\n-      String headerString = key + ": " + value;\n-      CString headerCString = headerString.latin1();\n-      DBG(" custom header %s\\n", headerCString.data());\n-      headers = curl_slist_append(headers, headerCString.data());\n+    // Check if a cache purge is forced from client side\n+    CacheControl cc;\n+    HTTPHeaderMap requestHeaders = request.httpHeaderFields();\n+    if (requestHeaders.contains("Cache-Control")) {\n+        String ccString = request.httpHeaderFields().get("Cache-Control");\n+        networkcache()->parseCacheControl(&cc, ccString.latin1().data());\n}\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPHEADER, headers));\n-  }\n-  CString postData;\n-  if (request.httpMethod() == "GET") {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPGET, true));\n-  }\n-  else if (request.httpMethod() == "POST") {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POST, true));\n-    postData = request.httpBody()->flattenToString().latin1();\n-    DBG(" post data is \'%s\'\\n", postData.data());\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POSTFIELDS, postData.data()));\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POSTFIELDSIZE, postData.length()));\n-  }\n-  else if ("PUT" == request.httpMethod()) {\n-    DBG("**** UNIMPLEMENTED - PUT ****");\n-    goto cleanup;\n-  }\n-  else if ("HEAD" == request.httpMethod()) {\n-    CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_NOBODY, true));\n-  }\n\n-  curlStatus = curl_easy_perform(curlHandle);\n-  if (curlStatus != CURLE_OK) {\n-    e = ResourceError("curl", curlStatus,\n-                      request.url().deprecatedString(), errorBuffer);\n-    goto cleanup;\n-  }\n+    // Check for existing cache entry by URL\n+    cacheEntry = networkcache()->getEntry(request.url().prettyURL());\n\n- cleanup:\n-  curl_slist_free_all(headers);\n+    bool shouldCache = true;\n+    if (cacheEntry) {\n+        // Check cache entry validity to see if the request\n+        // should be made conditional\n+\n+        // If expirationdate < time(NULL)\n+        //     If Etag or Last-modified\n+        //         Send conditional request\n+        //     Else\n+        //         Remove entry, new request\n+        // If not GET request\n+        //     New uncacheable request\n+        // If client side nocache\n+        //     Remove entry, new uncacheable request\n+\n+        // Check with cache policy from ResourceRequest as well?\n+\n+        time_t expirationdate = cacheEntry->response.expirationDate();\n+\n+        DBG("Cache entry information: \\n"\n+            "responsedate: %ld\\ntime(): %ld\\ntime-responsedate: %ld\\n"\n+            "expirationdate: %ld\\nserverdate: %ld\\n"\n+            "expirationdate-serverdate:%ld\\nExpired? %s\\n"\n+            "Conditional? %s\\n",\n+            cacheEntry->responseDate(),\n+            time(NULL),\n+            (time(NULL)-cacheEntry->responseDate()),\n+            expirationdate,\n+            cacheEntry->serverDate(),\n+            (expirationdate-cacheEntry->serverDate()),\n+            (time(NULL)-(cacheEntry->responseDate()) >\n+             expirationdate-cacheEntry->serverDate()) ? "Yes" : "No",\n+            cacheEntry->isConditional() ? "Yes" : "No");\n+\n+        // Conditional requests from higher level cache needs to be handled.\n+        // This code assumes that higher level cache data will never be\n+        // more recent than the data in the network cache.\n+        if (requestHeaders.contains("If-None-Match")) {\n+            if (cacheEntry->response.httpHeaderField("Etag") ==\n+                request.httpHeaderField("If-None-Match")) {\n+                r.setHTTPStatusCode(304);\n+                return;\n+            }\n+        }\n+        else if (requestHeaders.contains("If-Modified-Since")) {\n+            if (curl_getdate(request.httpHeaderField(\n+                               "If-Modified-Since").latin1().data(), NULL) >=\n+                cacheEntry->responseDate()) {\n+                r.setHTTPStatusCode(304);\n+                return;\n+            }\n+        }\n+\n+        if ("GET" != request.httpMethod()) {\n+            DBG("Adding new nocache entry even though cache entry exists.\\n");\n+            // Keep the old entry, but add a new entry to nocache\n+            shouldCache = false;\n+            cacheEntry = NULL;\n+        }\n+        else if (((time(NULL) - cacheEntry->responseDate()) >\n+                  expirationdate-cacheEntry->serverDate())) {\n+            DBG("Entry expired, %s\\n", cacheEntry->entryURL().utf8().data());\n+            // Cache entry has expired\n+            if (cacheEntry->hasClients()) {\n+                // Cache entry is already being updated\n+                // Start a new separate transfer\n+                shouldCache = false;\n+                cacheEntry = NULL;\n+            } else {\n+                if (cacheEntry->response.httpHeaderFields().contains("Etag")) {\n+                    cacheEntry->setConditional(true);\n+                    String header = "If-None-Match: ";\n+                    header +=\n+                        cacheEntry->response.httpHeaderField("Etag");\n+                    cacheEntry->setConditionalHeader(header);\n+                    cacheEntry->setComplete(false);\n+                }\n+                else if (cacheEntry->response.\n+                         httpHeaderFields().contains("Last-Modified")) {\n+                    cacheEntry->setConditional(true);\n+                    String header = "If-Modified-Since: ";\n+                    header +=\n+                        cacheEntry->response.httpHeaderField("Last-Modified");\n+                    cacheEntry->setConditionalHeader(header);\n+                    cacheEntry->setComplete(false);\n+                }\n+                else {\n+                    DBG("Purging expired cache entry. %s\\n",\n+                        cacheEntry->entryURL().utf8().data());\n+                    // Purge entry from cache\n+                    cacheEntry->lruRemove();\n+                    networkcache()->removeEntry(cacheEntry->entryURL());\n+                    cacheEntry = NULL;\n+                }\n+            }\n+        }\n+        else if (cc.nocache) {\n+            DBG("Purging cache entry due to no-cache directive. %s\\n",\n+                cacheEntry->entryURL().utf8().data());\n+            // Purge entry from cache\n+            cacheEntry->lruRemove();\n+            networkcache()->removeEntry(cacheEntry->entryURL());\n+            shouldCache = false;\n+            cacheEntry = NULL;\n+        }\n+    }\n+\n+    if (cacheEntry && cacheEntry->complete() && !cacheEntry->isConditional()) {\n+        DBG("URL in cache (%p)%s\\n", cacheEntry,\n+            cacheEntry->entryURL().utf8().data());\n+        cacheEntry->lruRemove();\n+        cacheEntry->lruAdd();\n+        r = cacheEntry->response;\n+        DBG("Copying %d bytes of data from (%p).\\n",\n+            cacheEntry->size(), cacheEntry->data());\n+        data.insert(0,cacheEntry->data(), cacheEntry->size());\n+        return;\n+    }\n+    else {\n+        CURLcode curlStatus = CURLE_OK;\n+        CURL* curlHandle = curl_easy_init();\n+        CallbackContext context(curlHandle, data, r);\n+        CURLSH* shareHandle = ResourceHandleManager::instance()->getCurlShareHandle();\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_ERRORBUFFER, errorBuffer));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_WRITEFUNCTION, writeCallback));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_WRITEDATA, &context));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HEADERFUNCTION, headerCallback));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HEADERDATA, &context));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_FOLLOWLOCATION, 1));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPAUTH, CURLAUTH_ANY));\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_SHARE, shareHandle));\n+        if (access(CA_BUNDLE_FILE, R_OK) == 0) {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAINFO, CA_BUNDLE_FILE));\n+        } else {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAINFO, NULL));\n+        }\n+        if (access(CA_PATH, R_OK) == 0) {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAPATH, CA_PATH));\n+        } else {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_CAPATH, NULL));\n+        }\n+        // enable gzip and deflate through Accept-Encoding:\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_ENCODING, ""));\n+\n+        CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_URL,\n+                                   request.url().deprecatedString().ascii()));\n+\n+        ResourceHandleManager::setProxy(request, curlHandle);\n+\n+\n+        struct curl_slist* headers = 0;\n+        if (cacheEntry && cacheEntry->isConditional()) {\n+            // Add conditional request\n+            headers = curl_slist_append(\n+                headers, cacheEntry->conditionalHeader().latin1().data());\n+        }\n+        if (request.httpHeaderFields().size() > 0 ||\n+            (cacheEntry && cacheEntry->isConditional())) {\n+            HTTPHeaderMap customHeaders = request.httpHeaderFields();\n+            HTTPHeaderMap::const_iterator end = customHeaders.end();\n+            for (HTTPHeaderMap::const_iterator it = customHeaders.begin();\n+                 it != end;\n+                 ++it) {\n+                String key = it->first;\n+                String value = it->second;\n+                if ((key == "If-Modified-Since") ||\n+                    (key == "If-None-Match")) continue;\n+                String headerString = key + ": " + value;\n+                CString headerCString = headerString.latin1();\n+                DBG(" custom header %s\\n", headerCString.data());\n+                headers = curl_slist_append(headers, headerCString.data());\n+            }\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPHEADER, headers));\n+        }\n+        CString postData;\n+        if (request.httpMethod() == "GET") {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_HTTPGET, true));\n+        }\n+        else if (request.httpMethod() == "POST") {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POST, true));\n+            postData = request.httpBody()->flattenToString().latin1();\n+            DBG(" post data is \'%s\'\\n", postData.data());\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POSTFIELDS,\n+                                       postData.data()));\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_POSTFIELDSIZE,\n+                                       postData.length()));\n+        }\n+        else if ("PUT" == request.httpMethod()) {\n+            DBG("**** UNIMPLEMENTED - PUT ****");\n+            curl_slist_free_all(headers);\n+            return;\n+        }\n+        else if ("HEAD" == request.httpMethod()) {\n+            CURL_CALL(curl_easy_setopt(curlHandle, CURLOPT_NOBODY, true));\n+        }\n+\n+        curlStatus = curl_easy_perform(curlHandle);\n+        if (curlStatus != CURLE_OK) {\n+            e = ResourceError("curl", curlStatus,\n+                              request.url().deprecatedString(), errorBuffer);\n+        }\n+\n+        curl_slist_free_all(headers);\n+\n+        if (cacheEntry) {\n+            // Conditional request\n+            if (context.m_responseCode == 304) {\n+                // Not modified, return cached response/data\n+                r = cacheEntry->response;\n+                char *cacheData = cacheEntry->data();\n+                data.insert(0,cacheEntry->data(), cacheEntry->size());\n+                cacheEntry->lruRemove();\n+                cacheEntry->lruAdd();\n+                cacheEntry->setConditional(false);\n+                cacheEntry->setComplete(true);\n+                return;\n+            } else {\n+                // Modified, update cache with response/data\n+                cacheEntry->willRevalidate();\n+                cacheEntry->lruRemove();\n+                cacheEntry->setConditional(false);\n+            }\n+        } else if (shouldCache) {\n+            cacheEntry = new CachedResponse(request.url().prettyURL());\n+        }\n+\n+        if (shouldCache) {\n+            String value;\n+            cacheEntry->response = r;\n+\n+            if ((value = r.httpHeaderField("Date")) != "") {\n+                cacheEntry->setServerDate(\n+                    curl_getdate(value.latin1().data(), NULL));\n+                cacheEntry->setResponseDate(time(NULL));\n+                if (cacheEntry->cacheControl.maxage > 0)\n+                    cacheEntry->response.setExpirationDate(\n+                        cacheEntry->serverDate() +\n+                        cacheEntry->cacheControl.maxage);\n+            }\n+\n+            // Check for cache directives\n+            if ((value = r.httpHeaderField("Cache-Control")) != "") {\n+                networkcache()->parseCacheControl(&(cacheEntry->cacheControl),\n+                                                  value.latin1().data());\n+                if (cacheEntry->cacheControl.nocache) {\n+                    // Don\'t create an entry\n+                    delete cacheEntry;\n+                    return;\n+                }\n+                if (cacheEntry->cacheControl.maxage > 0) {\n+                    DBG("max age sets expiration date to %d.\\n",\n+                        cacheEntry->serverDate() +\n+                        cacheEntry->cacheControl.maxage);\n+                    cacheEntry->response.setExpirationDate(\n+                        cacheEntry->serverDate() +\n+                        cacheEntry->cacheControl.maxage);\n+                }\n+            }\n+\n+            // Don\'t cache https by default\n+            if (!cacheEntry->cacheControl.ispublic &&\n+                request.url().protocol() == "https") {\n+                // Don\'t create an entry\n+                delete cacheEntry;\n+                return;\n+            }\n+\n+            if ((value = r.httpHeaderField("Expires")) != "") {\n+                if (cacheEntry->cacheControl.maxage == 0) {\n+                    DBG("expires sets expiration date to %d.\\n",\n+                        curl_getdate(value.latin1().data(), NULL));\n+                    cacheEntry->response.setExpirationDate(\n+                        curl_getdate(value.latin1().data(), NULL));\n+                }\n+            }\n+\n+            if ((value = r.httpHeaderField("Last-Modified")) != "") {\n+                cacheEntry->response.setLastModifiedDate(\n+                    curl_getdate(value.latin1().data(), NULL));\n+            }\n+\n+            if (cacheEntry->response.expirationDate() < 1) {\n+                DBG( "Setting default max age.\\n");\n+                cacheEntry->response.setExpirationDate(\n+                    cacheEntry->serverDate() +\n+                    networkcache()->defaultMaxAge());\n+            }\n+\n+            if (!networkcache()->contains(cacheEntry->entryURL()))\n+                networkcache()->addEntry(cacheEntry);\n+            cacheEntry->lruAdd();\n+            DBG( "Adding %d bytes of data from (%p) to %s entry.\\n",\n+                 data.size(), data.data(),\n+                 cacheEntry->entryURL().utf8().data());\n+            cacheEntry->addData(data.data(), data.size());\n+            cacheEntry->setComplete(true);\n+        }\n+    }\n}\n#endif\n\n-\nvoid ResourceHandle::setDefersLoading(bool defers)\n{\nnotImplemented();'),
 ('src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleManager525.cpp',
  'src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager525.cpp',
  'Index: src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager525.cpp\n===================================================================\n--- src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleManager525.cpp\n+++ src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager525.cpp\n@@ -55,6 +55,9 @@\n#include "EKHttpCookie.h"\n#include "EKHttpCookieDB.h"\n\n+#include "NetworkCache.h"\n+#include "MIMETypeRegistry.h"\n+\n#include <errno.h>\n\n#define USE_CURL_REDIRECT 1\n@@ -77,7 +80,7 @@ static int updateSocketStatusCallback(\nvoid *userp,\nvoid *socketp);\n\n-static void receivedResponse(ResourceHandle* job);\n+static void receivedResponse(CachedResponse* cacheEntry);\n\nResourceHandleManager* ResourceHandleManager::instance()\n{\n@@ -206,9 +209,6 @@ void ResourceHandleManager::updateSocket\nTRACE("s=%p fd=%d act=%x", s, sockfd, action);\nif (s == 0) {\ns = new CurlSocket(*this, sockfd);\n-        if (s == 0)\n-            return;\n-\ncurl_multi_assign(m_multiHandle, sockfd, s);\n}\n\n@@ -263,19 +263,18 @@ void ResourceHandleManager::setTimeout()\n// called with data after all headers have been processed via headerCallback\nstatic size_t writeCallback(void* ptr, size_t size, size_t nmemb, void* obj)\n{\n-    ResourceHandle* job = static_cast<ResourceHandle*>(obj);\n-    ResourceHandleInternal* d = job->getInternal();\n+    CachedResponse* cacheEntry = static_cast<CachedResponse*>(obj);\n\nsize_t totalSize = size * nmemb;\n\n// Get HTTP status code\nlong responseCode;\n-    curl_easy_getinfo(d->m_handle, CURLINFO_RESPONSE_CODE, &responseCode);\n+    curl_easy_getinfo(cacheEntry->handle(), CURLINFO_RESPONSE_CODE, &responseCode);\n\n-    if (!d->m_response.responseFired()) {\n+    if (!cacheEntry->response.responseFired()) {\n// Can\'t rely on header reception to trigger response firing, as won\'t\n// be any headers for file: urls.\n-        receivedResponse(job);\n+        receivedResponse(cacheEntry);\n\nif (responseCode >= 300 && responseCode < 400) {\n// Discard any body data that arrives after a redirect.\n@@ -283,15 +282,15 @@ static size_t writeCallback(void* ptr, s\n}\n}\n\n-    DBG("job %p: rec %lu\\n", job, nmemb * size);\n+    DBG("job %p: rec %lu\\n", cacheEntry, nmemb * size);\n\n-    if (!d->client())\n+    if (!cacheEntry)\n{\nDBG("discarding: no client\\n");\n}\nelse\n{\n-        d->client()->didReceiveData(job, static_cast<char*>(ptr), totalSize, 0);\n+\t\tcacheEntry->addData(static_cast<char*>(ptr), totalSize);\n}\n\nreturn totalSize;\n@@ -301,10 +300,10 @@ static size_t writeCallback(void* ptr, s\n// multiple times for a given response.\nstatic size_t headerCallback(char* ptr, size_t size, size_t nmemb, void* obj)\n{\n-    ResourceHandle* job = static_cast<ResourceHandle*>(obj);\n-    ResourceHandleInternal* d = job->getInternal();\n-    DBG("job %p: hdrrec %lu\\n", job, nmemb * size);\n+    CachedResponse* cacheEntry = static_cast<CachedResponse*>(obj);\nint totalSize = size * nmemb;\n+    ResourceHandle* job = cacheEntry->firstClient();\n+    ResourceHandleInternal* d = job->getInternal();\n\nString header(ptr, totalSize);\nDBG(" %s\\n", header.deprecatedString().ascii());\n@@ -312,9 +311,11 @@ static size_t headerCallback(char* ptr,\n// The empty line following the headers is delivered to this callback too,\n// so make sure we\'ve really got a header.\nint separatorIndex = header.find(\':\');\n+    String name = header.left(separatorIndex);\n+    String value = header.substring(separatorIndex + 1).stripWhiteSpace();\nif (separatorIndex != -1)\n{\n-        d->m_response.setHTTPHeaderField(\n+        cacheEntry->response.setHTTPHeaderField(\nheader.left(separatorIndex),\nheader.substring(separatorIndex + 1).stripWhiteSpace());\n\n@@ -330,44 +331,123 @@ static size_t headerCallback(char* ptr,\nekioh::EKString cookieStr(ptr + sizeof("Set-Cookie: ") - 1,\ntotalSize - sizeof("Set-Cookie: ") - 1);\n\n-            ekioh::EKUrl url(d->m_url.utf8().data());\n+            ekioh::EKUrl url(cookieUrl.string().utf8().data());\nekioh::EKHttpCookie cookie(url);\nif (cookie.parseString(cookieStr))\n-                ekioh::EKHttpCookieDB::instance().addCookie(cookie);\n+                ekioh::EKHttpCookieDB::instance().addCookie(cookie, false);\n}\n}\nelse if (header == "\\r\\n") {\n-        receivedResponse(job);\n+        receivedResponse(cacheEntry);\n}\n\n+    if (name == "Date") {\n+        cacheEntry->setServerDate(curl_getdate(value.latin1().data(), NULL));\n+        cacheEntry->setResponseDate(time(NULL));\n+        if (cacheEntry->cacheControl.maxage > 0)\n+            cacheEntry->response.setExpirationDate(\n+                cacheEntry->serverDate()+cacheEntry->cacheControl.maxage);\n+    }\n+    else if (name == "Cache-Control") {\n+        networkcache()->parseCacheControl(&(cacheEntry->cacheControl),\n+                                          value.latin1().data());\n+        if (cacheEntry->cacheControl.nocache) {\n+            // Split into two objects\n+            // Note that all clients are viewed as requesting\n+            // the URL simultanously so one is picked arbitarily\n+            // to represent the first request\n+            ResourceHandle* nocacheClient = cacheEntry->firstClient();\n+            networkcache()->makeNocacheEntry(nocacheClient,\n+                                             cacheEntry);\n+\n+            // Entries in the nocache list should not be on the LRU list\n+            cacheEntry->lruRemove();\n+            // Temporarily remove first client\n+            cacheEntry->removeClient(nocacheClient);\n+\n+            ResourceHandleSet* clients = cacheEntry->getClients();\n+\n+            // Re-add other clients\n+            ResourceHandleSet::const_iterator end = clients->end();\n+            for (ResourceHandleSet::const_iterator it = clients->begin();\n+                it != end;\n+                ++it) {\n+                    ResourceHandleManager::instance()->add(*it);\n+                }\n+                // cacheEntry is now in the nocache-list, re-add client\n+                cacheEntry->clearClients();\n+                cacheEntry->addClient(nocacheClient);\n+            }\n+            if (cacheEntry->cacheControl.maxage > 0) {\n+                cacheEntry->response.setExpirationDate(\n+                    cacheEntry->serverDate()+cacheEntry->cacheControl.maxage);\n+            }\n+            if (cacheEntry->cacheControl.ispublic &&\n+                !cacheEntry->cacheControl.nocache &&\n+                !networkcache()->contains(cacheEntry->entryURL())) {\n+                networkcache()->makeCacheEntry(cacheEntry);\n+                cacheEntry->lruAdd();\n+            }\n+    }\n+    else if (name == "Expires") {\n+        if (cacheEntry->cacheControl.maxage == 0) {\n+            cacheEntry->response.setExpirationDate(\n+                    curl_getdate(value.latin1().data(), NULL));\n+            }\n+       }\n+       else if (name == "Last-Modified") {\n+            cacheEntry->response.setLastModifiedDate(\n+                curl_getdate(value.latin1().data(), NULL));\n+       }\n+\nreturn totalSize;\n}\n\n// Called once for each request once we know we\'ve got all the headers\n-static void receivedResponse(ResourceHandle* job)\n+static void receivedResponse(CachedResponse* cacheEntry)\n{\n-    ResourceHandleInternal* d = job->getInternal();\n-\n-    ASSERT(!d->m_response.responseFired());\n-\ndouble contentLength = 0;\nString contentType;\nString encoding;\n\n// Get content length\n-    curl_easy_getinfo(d->m_handle, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLength);\n+    curl_easy_getinfo(cacheEntry->handle(), CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLength);\n\n// Get content type\nchar *contentTypeCString = NULL;\n-    if (curl_easy_getinfo(d->m_handle, CURLINFO_CONTENT_TYPE, &contentTypeCString) == 0)\n+    if (curl_easy_getinfo(cacheEntry->handle(), CURLINFO_CONTENT_TYPE, &contentTypeCString) == 0)\ncontentType = contentTypeCString;\n\n// Get HTTP status code\nlong responseCode;\n-    curl_easy_getinfo(d->m_handle, CURLINFO_RESPONSE_CODE, &responseCode);\n+    curl_easy_getinfo(cacheEntry->handle(), CURLINFO_RESPONSE_CODE, &responseCode);\n+\n+    if (cacheEntry->response.url().isLocalFile()) {\n+        // If we get here with a local file, it was found\n+        responseCode = 200;\n+    }\n\n-    DBG("job %p: response %ld url=%s content-length=%lf\\n",\n-            job, responseCode, d->m_url.ascii(), contentLength);\n+    if (cacheEntry->isConditional()) {\n+        if (responseCode == 304) {\n+            DBG("Conditional request, not modified. %s\\n",\n+            cacheEntry->entryURL().utf8().data());\n+            // Not modified\n+            cacheEntry->didReceiveNotModified();\n+            return;\n+        }\n+        else {\n+            DBG("Conditional request, was modified. %s\\n",\n+            cacheEntry->entryURL().utf8().data());\n+            cacheEntry->willRevalidate();\n+        }\n+    }\n+\n+    if (!cacheEntry->response.expirationDate()) {\n+        cacheEntry->response.setExpirationDate(\n+            cacheEntry->serverDate()+networkcache()->defaultMaxAge());\n+    }\n+\n+    cacheEntry->response.setHTTPStatusCode(responseCode);\n\nif (responseCode >= 100 && responseCode < 200) {\n// Informational - ignore\n@@ -378,48 +458,39 @@ static void receivedResponse(ResourceHan\n// to tell WebCore about it. CURLINFO_REDIRECT_URL and\n// CURLINFO_EFFECTIVE_URL don\'t contain the URL we need at this point,\n// so construct it ourselves\n-        String location = d->m_response.httpHeaderField("location");\n+\t\tString location = cacheEntry->response.httpHeaderField("location");\n\nif (location.isEmpty())\n;\n-        else if (!d->client())\n-            ;\nelse {\n-            KURL newUrl(job->request().url(), location.deprecatedString());\n-            ResourceRequest redirectedRequest = job->request();\n-            redirectedRequest.setURL(newUrl);\n-            DBG("redirected: newUrl=%.*s\\n", location.utf8().length(), location.utf8().data());\n-            d->client()->willSendRequest(job, redirectedRequest, d->m_response);\n-        }\n-        return;\n-    }\n-\n-\n-    if (!d->client()) {\n-        DBG(" no client\\n");\n-        return;\n+ \t\t\tcacheEntry->redirect(location);\n+ \t\t\tnetworkcache()->makeNocacheEntry(cacheEntry->firstClient(),\n+ \t\t\t\t\t\t\t\t\t\t\t cacheEntry);\n+ \t\t\tcacheEntry->lruRemove();\n+ \t\t}\n+ \t\treturn;\n}\n\nchar* url = 0;\n-    curl_easy_getinfo(d->m_handle, CURLINFO_EFFECTIVE_URL, &url);\n+    curl_easy_getinfo(cacheEntry->handle(), CURLINFO_EFFECTIVE_URL, &url);\nDBG(" effective-url=%s\\n", url);\n-    d->m_response.setUrl(KURL(url));\n+    cacheEntry->response.setUrl(KURL(url));\n\n-    d->m_response.setHTTPStatusCode(responseCode);\n+    cacheEntry->response.setHTTPStatusCode(responseCode);\n\n-    d->m_response.setExpectedContentLength((long long) contentLength);\n+    cacheEntry->response.setExpectedContentLength((long long) contentLength);\n\n-    d->m_response.setMimeType(extractMIMETypeFromMediaType(contentType));\n+    cacheEntry->response.setMimeType(\n+        extractMIMETypeFromMediaType(contentType));\n\n-    d->m_response.setTextEncodingName(\n+    cacheEntry->response.setTextEncodingName(\nextractCharsetFromMediaType(contentType));\n\n-    d->m_response.setSuggestedFilename(filenameFromHTTPContentDisposition(\n-                d->m_response.httpHeaderField("Content-Disposition")));\n+    cacheEntry->response.setSuggestedFilename(\n+        filenameFromHTTPContentDisposition(\n+            cacheEntry->response.httpHeaderField("Content-Disposition")));\n\n-    d->client()->didReceiveResponse(job, d->m_response);\n-\n-    d->m_response.setResponseFired(true);\n+    cacheEntry->didReceiveResponse();\n}\n\nvoid ResourceHandleManager::setCurlMethod(CURL* handle, const String& method)\n@@ -543,20 +614,174 @@ void ResourceHandleManager::add(Resource\nreturn;\n}\n\n-    if (m_runningJobs < MAX_NUM_JOBS)\n-        startJob(job);\n+    CachedResponse* cacheEntry = NULL;\n+\n+    // Check if a cache purge is forced from client side\n+    CacheControl cc;\n+    HTTPHeaderMap requestHeaders = job->request().httpHeaderFields();\n+    if (requestHeaders.contains("Cache-Control")) {\n+        String ccString = job->request().httpHeaderFields().get("Cache-Control");\n+        networkcache()->parseCacheControl(&cc, ccString.latin1().data());\n+    }\n+\n+    // Check for existing cache entry by URL\n+    cacheEntry = networkcache()->getEntry(job->request().url().prettyURL());\n+\n+    bool shouldCache = true;\n+    if (cacheEntry) {\n+        // Check cache entry validity to see if the request\n+        // should be made conditional\n+\n+        // If expirationdate < time(NULL)\n+        //     If Etag or Last-modified\n+        //         Send conditional request\n+        //     Else\n+        //         Remove entry, new request\n+        // If not GET request\n+        //     New uncacheable request\n+        // If client side nocache\n+        //     Remove entry, new uncacheable request\n+\n+        // Check with cache policy from ResourceRequest as well?\n+\n+        time_t expirationdate = cacheEntry->response.expirationDate();\n+\n+        DBG("Cache entry information: \\n"\n+            "responsedate: %ld\\ntime(): %ld\\ntime-responsedate: %ld\\n"\n+            "expirationdate: %ld\\nserverdate: %ld\\nexpirationdate-serverdate:%ld\\nExpired? %s\\n"\n+            "Conditional? %s\\n",\n+            cacheEntry->responseDate(),\n+            time(NULL),\n+            (time(NULL)-cacheEntry->responseDate()),\n+            expirationdate,\n+            cacheEntry->serverDate(),\n+            (expirationdate-cacheEntry->serverDate()),\n+            (time(NULL)-(cacheEntry->responseDate()) > (expirationdate-cacheEntry->serverDate()))?"Yes":"No",\n+            cacheEntry->isConditional()?"Yes":"No");\n+\n+        // Conditional requests from higher level cache needs to be handled.\n+        // This code assumes that higher level cache data will never be\n+        // more recent than the data in the network cache.\n+        if (requestHeaders.contains("If-None-Match")) {\n+            if (cacheEntry->response.httpHeaderField("Etag") ==\n+                job->request().httpHeaderField("If-None-Match")) {\n+                networkcache()->addNotModifiedJob(job);\n+                return;\n+            }\n+        }\n+        else if (requestHeaders.contains("If-Modified-Since")) {\n+            if (curl_getdate(job->request().httpHeaderField(\n+                               "If-Modified-Since").latin1().data(), NULL) >=\n+                cacheEntry->responseDate()) {\n+                networkcache()->addNotModifiedJob(job);\n+                return;\n+            }\n+        }\n+\n+        if ("GET" != job->request().httpMethod()) {\n+            DBG("Adding new nocache entry even though cache entry exists.\\n");\n+            // Keep the old entry, but add a new entry to nocache\n+            shouldCache = false;\n+            cacheEntry = NULL;\n+        }\n+        else if ((time(NULL)-cacheEntry->responseDate() >\n+                  expirationdate-cacheEntry->serverDate()) &&\n+                 !cacheEntry->isConditional() && // Waiting for revalidation\n+                 cacheEntry->response.responseFired() // Waiting for response\n+                 ) {\n+            DBG("Entry expired, %s\\n", cacheEntry->entryURL().utf8().data());\n+            // Cache entry has expired\n+            if (cacheEntry->response.httpHeaderFields().contains("Etag")) {\n+                cacheEntry->setConditional(true);\n+                String header = "If-None-Match: ";\n+                header +=\n+                    cacheEntry->response.httpHeaderField("Etag");\n+                cacheEntry->setConditionalHeader(header);\n+                cacheEntry->setComplete(false);\n+                m_pendingJobs.append(cacheEntry);\n+            }\n+            else if (cacheEntry->response.httpHeaderFields().contains("Last-Modified")) {\n+                cacheEntry->setConditional(true);\n+                String header = "If-Modified-Since: ";\n+                header +=\n+                    cacheEntry->response.httpHeaderField("Last-Modified");\n+                cacheEntry->setConditionalHeader(header);\n+                cacheEntry->setComplete(false);\n+                m_pendingJobs.append(cacheEntry);\n+            }\n+            else {\n+                DBG("Purging expired cache entry. %s\\n",\n+                    cacheEntry->entryURL().utf8().data());\n+                // Purge entry from cache\n+                cacheEntry->lruRemove();\n+                networkcache()->removeEntry(cacheEntry->entryURL());\n+                cacheEntry = NULL;\n+            }\n+        }\n+        else if (cc.nocache) {\n+            DBG("Purging cache entry due to no-cache directive. %s\\n",\n+                cacheEntry->entryURL().utf8().data());\n+            // Purge entry from cache\n+            cacheEntry->lruRemove();\n+            networkcache()->removeEntry(cacheEntry->entryURL());\n+            shouldCache = false;\n+            cacheEntry = NULL;\n+        }\n+    }\n+\n+    if (!cacheEntry) {\n+        // Create a cache entry\n+        cacheEntry = new CachedResponse(job->request().url().prettyURL());\n+\n+        if (!shouldCache ||\n+            cc.nocache ||\n+            "GET" != job->request().httpMethod() ||\n+            job->request().url().protocol() == "https") {\n+\n+            DBG("URL not in nocache, adding (%p)%s\\n", cacheEntry,\n+                job->request().url().prettyURL().utf8().data());\n+            networkcache()->addNocacheEntry(job,cacheEntry);\n+        }\n+        else {\n+            DBG("URL not in cache, adding (%p)%s\\n", cacheEntry,\n+                job->request().url().prettyURL().utf8().data());\n+            networkcache()->addEntry(cacheEntry);\n+            cacheEntry->lruAdd();\n+        }\n+\n+        DBG("Queueing cacheEntry, m_runningJobs is %d, MAX_NUM_JOBS is %d.\\n",\n+            m_runningJobs, MAX_NUM_JOBS);\n+        m_pendingJobs.append(cacheEntry);\n+        cacheEntry->addClient(job);\n+    }\nelse {\n-        DBG("job %p: queueing %s\\n", job, job->request().url().deprecatedString().ascii());\n-        m_pendingJobs.append(job);\n+        DBG("URL in cache (%p)%s\\n", cacheEntry,\n+            cacheEntry->entryURL().utf8().data());\n+        cacheEntry->lruRemove();\n+        cacheEntry->lruAdd();\n+        cacheEntry->addClient(job);\n}\n+\n+    startJob();\n+\n+    //networkcache()->printLRUList();\n}\n\n-void ResourceHandleManager::startJob(ResourceHandle* job)\n+void ResourceHandleManager::startJob()\n{\n// TODO should we just create a pool of easy handles initially and then\n// reuse them? Discussions on curl mailing list imply connection cache\n// is at multi handle level rather than easy handle level when using\n// multi api, so would this have any benefit?\n+    CachedResponse* cacheEntry = m_pendingJobs.getFirst();\n+\n+    if (!(cacheEntry && (m_runningJobs < MAX_NUM_JOBS))) {\n+        return;\n+    }\n+\n+    m_pendingJobs.removeRef(cacheEntry);\n+\n+    ResourceHandle* job = cacheEntry->firstClient();\nResourceHandleInternal* d = job->getInternal();\n\nint secureMode = atoi(getenv("http_secure_mode"));\n@@ -574,68 +799,80 @@ void ResourceHandleManager::startJob(Res\nif (protocol.lower() == "http") {\nfprintf(stderr, "Http secure mode is set to %d\\n", secureMode);\nfprintf(stderr, "normal http access is not allowed\\n");\n-        job->cancel();\n+        cacheEntry->cancel();\nreturn;\n}\n}\n\n-    d->m_handle = curl_easy_init();\n-    curl_easy_setopt(d->m_handle, CURLOPT_PRIVATE, job);\n-    curl_easy_setopt(d->m_handle, CURLOPT_ERRORBUFFER, m_curlErrorBuffer);\n-    curl_easy_setopt(d->m_handle, CURLOPT_WRITEFUNCTION, writeCallback);\n-    curl_easy_setopt(d->m_handle, CURLOPT_WRITEDATA, job);\n-    curl_easy_setopt(d->m_handle, CURLOPT_HEADERFUNCTION, headerCallback);\n-    curl_easy_setopt(d->m_handle, CURLOPT_WRITEHEADER, job);\n-    curl_easy_setopt(d->m_handle, CURLOPT_FOLLOWLOCATION, 1);\n-    curl_easy_setopt(d->m_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n-    curl_easy_setopt(d->m_handle, CURLOPT_SHARE, m_shareHandle);\n-    //curl_easy_setopt(d->m_handle, CURLOPT_SSL_VERIFYPEER, 0);\n+    cacheEntry->setHandle(curl_easy_init());\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_PRIVATE, cacheEntry);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_ERRORBUFFER, m_curlErrorBuffer);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_WRITEFUNCTION, writeCallback);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_WRITEDATA, cacheEntry);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_HEADERFUNCTION, headerCallback);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_WRITEHEADER, cacheEntry);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_FOLLOWLOCATION, 1);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_SHARE, m_shareHandle);\n+    //curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSL_VERIFYPEER, 0);\nif (!m_caFile.isNull())\n-        curl_easy_setopt(d->m_handle, CURLOPT_CAINFO, m_caFile.data());\n+        curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAINFO, m_caFile.data());\nif (!m_caPath.isNull())\n-        curl_easy_setopt(d->m_handle, CURLOPT_CAPATH, m_caPath.data());\n+        curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAPATH, m_caPath.data());\n// enable gzip and deflate through Accept-Encoding:\n-    curl_easy_setopt(d->m_handle, CURLOPT_ENCODING, "");\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_ENCODING, "");\n+\n+    DeprecatedString url = cacheEntry->entryURL().deprecatedString();\n+    KURL kurl(url);\n+\n+    if (kurl.isLocalFile()) {\n+        DeprecatedString query = kurl.query();\n+        // Remove any query part sent to a local file.\n+        if (!query.isEmpty())\n+          url = url.left(url.find(query));\n+        // Determine the MIME type based on the path.\n+        d->m_response.setMimeType(MIMETypeRegistry::getMIMETypeForPath(String(url)));\n+    }\n\n// url must remain valid through the request\n-    d->m_url = job->request().url().deprecatedString();\n-    curl_easy_setopt(d->m_handle, CURLOPT_URL, d->m_url.ascii());\n+    cacheEntry->response.setUrl(url);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_URL, url.latin1());\n\n// fprintf(stderr, "Enabling curl verbose (may break logging)\\n");\n-    // curl_easy_setopt(d->m_handle, CURLOPT_VERBOSE, 1);\n+    // curl_easy_setopt(cacheEntry->handle(), CURLOPT_VERBOSE, 1);\n\n// https setting\n-    curl_easy_setopt(d->m_handle, CURLOPT_SSL_VERIFYHOST, 0);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSL_VERIFYHOST, 0);\nif (access(CA_BUNDLE_FILE, R_OK) == 0) {\n-      curl_easy_setopt(d->m_handle, CURLOPT_CAINFO, CA_BUNDLE_FILE);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAINFO, CA_BUNDLE_FILE);\n} else {\n-      curl_easy_setopt(d->m_handle, CURLOPT_CAINFO, NULL);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAINFO, NULL);\n}\nif (access(CA_PATH, R_OK) == 0) {\n-      curl_easy_setopt(d->m_handle, CURLOPT_CAPATH, CA_PATH);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAPATH, CA_PATH);\n} else {\n-      curl_easy_setopt(d->m_handle, CURLOPT_CAPATH, NULL);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_CAPATH, NULL);\n}\nif (access(CERT_FILE, R_OK) == 0) {\n-      curl_easy_setopt(d->m_handle, CURLOPT_SSLCERT, CERT_FILE);\n-      curl_easy_setopt(d->m_handle, CURLOPT_SSLCERTTYPE, "DER");\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSLCERT, CERT_FILE);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSLCERTTYPE, "DER");\n}\nif (access(KEY_FILE, R_OK) == 0) {\n-      curl_easy_setopt(d->m_handle, CURLOPT_SSLKEY, KEY_FILE);\n-      curl_easy_setopt(d->m_handle, CURLOPT_SSLKEYTYPE, "DER");\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSLKEY, KEY_FILE);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSLKEYTYPE, "DER");\n}\nif (secureMode == 2) {\n// https with mutual authentication only\n-      curl_easy_setopt(d->m_handle, CURLOPT_SSL_CIPHER_LIST, CIPHER_LIST);\n-      curl_easy_setopt(d->m_handle, CURLOPT_PROTOCOLS, CURLPROTO_HTTPS);\n-      //curl_easy_setopt(d->m_handle, CURLOPT_SSL_VERIFYPEER, 1L);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSL_CIPHER_LIST, CIPHER_LIST);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_PROTOCOLS, CURLPROTO_HTTPS);\n+      //curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSL_VERIFYPEER, 1L);\n}\nelse if (secureMode == 1) {\n// https with server side certificate is ok\n-      //curl_easy_setopt(d->m_handle, CURLOPT_SSL_VERIFYPEER, 0);\n+      //curl_easy_setopt(cacheEntry->handle(), CURLOPT_SSL_VERIFYPEER, 0);\n}\n\n-    setProxy(job->request(), d->m_handle);\n+    setProxy(cacheEntry);\n\nKURL cookieUrl;\nif (d->m_url.isEmpty()) {\n@@ -647,55 +884,63 @@ void ResourceHandleManager::startJob(Res\n\nString cs = cookies(0, cookieUrl);\nif (cs.length() > 0) {\n-      curl_easy_setopt(d->m_handle, CURLOPT_COOKIE, cs.deprecatedString().ascii());\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_COOKIE, cs.deprecatedString().ascii());\n}\n\n-    if (job->request().httpHeaderFields().size() > 0) {\n-        struct curl_slist* headers = 0;\n+    struct curl_slist* headers = 0;\n+    if (cacheEntry->isConditional()) {\n+        // Add conditional request\n+        headers = curl_slist_append(headers,\n+                                    cacheEntry->conditionalHeader().latin1().data());\n+    }\n+    if (job->request().httpHeaderFields().size() > 0 ||\n+        cacheEntry->isConditional()) {\nHTTPHeaderMap customHeaders = job->request().httpHeaderFields();\nHTTPHeaderMap::const_iterator end = customHeaders.end();\nfor (HTTPHeaderMap::const_iterator it = customHeaders.begin(); it != end; ++it) {\nString key = it->first;\nString value = it->second;\n+            if ((key == "If-Modified-Since") ||\n+                (key == "If-None-Match"))\n+              continue;\nString headerString = key + ": " + value;\nCString headerCString = headerString.latin1();\nDBG(" custom header %s\\n", headerCString.data());\nheaders = curl_slist_append(headers, headerCString.data());\n}\n-        curl_easy_setopt(d->m_handle, CURLOPT_HTTPHEADER, headers);\n+        curl_easy_setopt(cacheEntry->handle(), CURLOPT_HTTPHEADER, headers);\nd->m_customHeaders = headers;\n}\n\n-    setCurlMethod(d->m_handle, job->request().httpMethod());\n+    setCurlMethod(cacheEntry->handle(), job->request().httpMethod());\n\nif ("POST" == job->request().httpMethod()) {\nDBG("POST %ld items\\n", job->request().httpBody()->elements().size());\nd->m_postData = job->request().httpBody()->flattenToString().latin1();\nDBG(" data is \'%s\'\\n", d->m_postData.data());\n-        curl_easy_setopt(d->m_handle, CURLOPT_POSTFIELDS, d->m_postData.data());\n-        curl_easy_setopt(d->m_handle, CURLOPT_POSTFIELDSIZE, d->m_postData.length());\n-\n+        curl_easy_setopt(cacheEntry->handle(), CURLOPT_POSTFIELDS, d->m_postData.data());\n+        curl_easy_setopt(cacheEntry->handle(), CURLOPT_POSTFIELDSIZE, d->m_postData.length());\n}\nelse if ("PUT" == job->request().httpMethod()) {\nDBG("**** UNIMPLEMENTED - PUT ****");\n//setupPUT(job);\n}\nelse if ("HEAD" == job->request().httpMethod())\n-        curl_easy_setopt(d->m_handle, CURLOPT_NOBODY, TRUE);\n+      curl_easy_setopt(cacheEntry->handle(), CURLOPT_NOBODY, TRUE);\n\n-    m_runningJobs++;\n-    CURLMcode curlrc = curl_multi_add_handle(m_multiHandle, d->m_handle);\n+    CURLMcode curlrc = curl_multi_add_handle(m_multiHandle, cacheEntry->handle());\n// don\'t call perform, because events must be async\n// timeout will occur and do curl_multi_perform\nif (curlrc != 0 && curlrc != CURLM_CALL_MULTI_PERFORM) {\n-        DBG("Error %d starting job %s\\n", curlrc, job->request().url().deprecatedString().ascii());\n-        job->cancel();\n+        cacheEntry->cancel();\nreturn;\n}\n\n// As of curl 7.16.3, adding a new easy handle to a multi handle makes curl\n// request an immediate timeout, which it uses to kick things off.\nDBG("job %p: started %s, cc=%d\\n", job, job->request().url().deprecatedString().ascii(), curlrc);\n+\n+    m_runningJobs++;\n}\n\nvoid ResourceHandleManager::setProxy(const ResourceRequest& request, CURL* curlHandle)\n@@ -749,6 +994,57 @@ void ResourceHandleManager::setProxy(con\nEKString::freeCString(cProxyString);\n}\n\n+void ResourceHandleManager::setProxy(CachedResponse* cacheEntry)\n+{\n+    using namespace ekioh;\n+\n+    EKProxyManager* proxyManager = EKPlatformPublic::instance()->getProxyManager();\n+    if (proxyManager == 0)\n+        return;\n+\n+    CString urlString(cacheEntry->entryURL().utf8());\n+    EKString ekUrlString(urlString.data(), urlString.length());\n+\n+    EKUrl ekUrl(ekUrlString);\n+\n+   uint16_t proxyPort;\n+   EKString proxyUsername;\n+   EKString proxyPassword;\n+   EKString proxyHost = proxyManager->getProxy(\n+           ekUrl, proxyPort, proxyUsername, proxyPassword);\n+\n+   if (proxyHost.getLength() == 0) {\n+     return;\n+   }\n+\n+   // Curl 7.18.3 doesn\'t have programatical way to set all the individual\n+   // proxy components (username, password etc.) so we have to construct\n+   // a proxy string from the components.\n+   EKString proxyString;\n+   if (proxyUsername.getLength() != 0) {\n+       proxyString = proxyUsername;\n+   }\n+   if (proxyPassword.getLength() != 0) {\n+       proxyString = proxyString + ":";\n+       proxyString = proxyString + proxyPassword;\n+   }\n+   if (proxyString.getLength() != 0) {\n+       proxyString = proxyString + "@";\n+   }\n+   proxyString = proxyString + proxyHost;\n+   if (proxyPort != 0) {\n+       char portString[6];\n+       snprintf(portString, sizeof(portString), "%hu", proxyPort);\n+       proxyString = proxyString + ":";\n+       proxyString = proxyString + EKString(portString);\n+   }\n+\n+    char* cProxyString = proxyString.toCString();\n+    fprintf(stderr, "proxy: \'%s\'\\n", cProxyString);\n+    curl_easy_setopt(cacheEntry->handle(), CURLOPT_PROXY, cProxyString);\n+    EKString::freeCString(cProxyString);\n+}\n+\n// Process socket data / timeouts\nvoid ResourceHandleManager::socketAction(curl_socket_t sockfd, int ev_mask)\n{\n@@ -792,36 +1088,57 @@ void ResourceHandleManager::processFinis\n// find the node which has same d->m_handle as completed transfer\nCURL* handle = msg->easy_handle;\nASSERT(handle);\n-        ResourceHandle* job;\n-        curl_easy_getinfo(handle, CURLINFO_PRIVATE, &job);\n-        ASSERT(job);\n-        if (!job)\n+        CachedResponse* cacheEntry;\n+        curl_easy_getinfo(handle, CURLINFO_PRIVATE, &cacheEntry);\n+        ASSERT(cacheEntry);\n+        if (!cacheEntry)\ncontinue;\n\n-        ResourceHandleInternal* d = job->getInternal();\n-        ASSERT(handle == d->m_handle);\n+        ASSERT(handle == cacheEntry->handle());\n+\n+        if (cacheEntry->cancelled()) {\n+            removeFromCache(cacheEntry);\n+            continue;\n+        }\n\nlong responseCode;\n-        curl_easy_getinfo(d->m_handle, CURLINFO_RESPONSE_CODE, &responseCode);\n-        DBG("job %p: response=%ld\\n", job, responseCode);\n+        curl_easy_getinfo(cacheEntry->handle(), CURLINFO_RESPONSE_CODE, &responseCode);\n\n-        if ("POST" == job->request().httpMethod()) {\n-            DBG(" post data was \'%s\'\\n", d->m_postData.data());\n-        }\n+//        if ("POST" == job->request().httpMethod()) {\n+//            DBG(" post data was \'%s\'\\n", d->m_postData.data());\n+//        }\n\n-        DBG("job %p: done %s result=%d\\n", job, job->request().url().deprecatedString().ascii(), msg->data.result);\n+        DBG("job %p: done %s result=%d\\n", cacheEntry, cacheEntry->response.url().deprecatedString().ascii(), msg->data.result);\n\nif (CURLE_OK == msg->data.result) {\n-            if (d->client())\n-                d->client()->didFinishLoading(job);\n+            DBG("processFinishedJobs(), removing handle(%p), job(%p).\\n",\n+                cacheEntry->handle(), cacheEntry->firstClient());\n+            // Remove from curl\n+            if (cacheEntry->handle()) {\n+                m_runningJobs--;\n+                curl_multi_remove_handle(m_multiHandle,\n+                                         cacheEntry->handle());\n+                curl_easy_cleanup(cacheEntry->handle());\n+                cacheEntry->setHandle(NULL);\n+            }\n+            cacheEntry->didFinishLoading();\n+            removeFromCache(cacheEntry);\n}\nelse {\nchar* url = 0;\n-            curl_easy_getinfo(d->m_handle, CURLINFO_EFFECTIVE_URL, &url);\n+            curl_easy_getinfo(cacheEntry->handle(), CURLINFO_EFFECTIVE_URL, &url);\nconst char* errorMsg = curl_easy_strerror(msg->data.result);\nDBG("Curl ERROR for url=\'%s\', error: \'%s\'\\n", url, errorMsg);\n-            if (d->client())\n-                d->client()->didFail(job, ResourceError("", msg->data.result, url, errorMsg));\n+            // Remove from curl\n+            if (cacheEntry->handle()) {\n+                m_runningJobs--;\n+                curl_multi_remove_handle(m_multiHandle,\n+                                         cacheEntry->handle());\n+                curl_easy_cleanup(cacheEntry->handle());\n+                cacheEntry->setHandle(NULL);\n+            }\n+            cacheEntry->didFail(ResourceError("", msg->data.result, url, errorMsg));\n+            removeFromCache(cacheEntry);\n}\n\n// The callback to the client causes the ResourceHandle to be deleted,\n@@ -829,39 +1146,63 @@ void ResourceHandleManager::processFinis\n// that here.\n}\n\n-    while (m_runningJobs < MAX_NUM_JOBS)\n-    {\n-        ResourceHandle* job = m_pendingJobs.getFirst();\n-        if (job == 0)\n-            break;\n-\n-        m_pendingJobs.removeFirst();\n-        startJob(job);\n-    }\n+    startJob();\n}\n\nvoid ResourceHandleManager::cancel(ResourceHandle* job)\n{\nDBG("job %p: %s %s jobs=%d\\n", job, __func__, job->request().url().deprecatedString().ascii(), m_runningJobs);\n-    if (job->request().url().protocol() == "data")\n-        ;\n-    else if (!m_pendingJobs.removeRef(job))\n-        removeFromCurl(job);\n+    if (job->request().url().protocol() != "data") {\n+        CachedResponse* cacheEntry = networkcache()->getEntry(job);\n+        if (cacheEntry) {\n+\t    removeFromCache(job, cacheEntry);\n+        }\n+        else {\n+            networkcache()->removeNotModifiedJob(job);\n+        }\n+    }\n}\n\n-void ResourceHandleManager::removeFromCurl(ResourceHandle* job)\n+void ResourceHandleManager::removeFromCache(CachedResponse* cacheEntry)\n{\n-    ResourceHandleInternal* d = job->getInternal();\n-    DBG("job %p: remove handle=%p numJobs=%d\\n", job, d->m_handle, m_runningJobs);\n-    //ASSERT(d->m_handle);\n-    if (!d->m_handle)\n-        return;\n-\n-    curl_multi_remove_handle(m_multiHandle, d->m_handle);\n-    curl_easy_cleanup(d->m_handle);\n-    d->m_handle = 0;\n-    m_runningJobs--;\n+    // Get a copy of the resource handle set since removeFromCache may delete\n+    // the CachedResponse.\n+    ResourceHandleSet handles = *cacheEntry->getClients();\n+\n+    for (ResourceHandleSet::iterator iter = handles.begin(); iter != handles.end(); ++iter) {\n+        removeFromCache((*iter), cacheEntry);\n+    }\n}\n\n+void ResourceHandleManager::removeFromCache(ResourceHandle* job,\n+                                            CachedResponse* cacheEntry)\n+{\n+    // Remove job from entry\n+    cacheEntry->removeClient(job);\n+\n+    // Check if this was the last client\n+    if (!cacheEntry->hasClients()) {\n+        if (!m_pendingJobs.removeRef(cacheEntry)) {\n+            // If job was started, remove it from curl\n+            if (cacheEntry->handle()) {\n+                m_runningJobs--;\n+                curl_multi_remove_handle(m_multiHandle,\n+                                         cacheEntry->handle());\n+                curl_easy_cleanup(cacheEntry->handle());\n+                cacheEntry->setHandle(NULL);\n+            }\n+        }\n+\n+        // If entry was not in cache list, remove entry\n+        if (networkcache()->nocacheContains(job)) {\n+            networkcache()->removeEntry(job);\n+        }\n+        else if (!cacheEntry->complete()) {\n+            // If job was canceled before transfer completed, remove entry\n+            cacheEntry->lruRemove();\n+            networkcache()->removeEntry(cacheEntry->entryURL());\n+        }\n+    }\n+}\n\n} // namespace WebCore'),
 ('src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleManager.h',
  'src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager.h',
  'Index: src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager.h\n===================================================================\n--- src.orig/Browser/WebCore/platform/network/ekioh/ResourceHandleManager.h\n+++ src/Browser/WebCore/platform/network/ekioh/ResourceHandleManager.h\n@@ -11,6 +11,7 @@\n\n#include "EKSocketCollection.h"\n#include "EKTimer.h"\n+#include "CachedResponse.h"\n#include "EKTimerListener.h"\n\nnamespace ekioh {\n@@ -24,7 +25,6 @@ class CurlSocket;\nclass ResourceHandle;\nclass KURL;\nclass String;\n-class ResourceRequest;\n\nclass ResourceHandleManager : public ekioh::EKTimerListener, ekioh::EKSocketClient\n{\n@@ -53,12 +53,15 @@ private:\n~ResourceHandleManager();\nstatic void destroy();\n\n-    void removeFromCurl(ResourceHandle* job);\n+    void removeFromCache(CachedResponse* cacheEntry);\n+    void removeFromCache(ResourceHandle* job, CachedResponse* cacheEntry);\nvirtual void timerCallback(const ekioh::EKTimer &timer, uint32_t now);\n-    void startJob(ResourceHandle* job);\n+    void startJob();\n+    void setProxy(CachedResponse* cacheEntry);\nvoid processFinishedJobs();\nvoid processDataUrl(ResourceHandle *job);\n\n+\nprivate:\nstatic ResourceHandleManager *m_instance;\n\n@@ -67,7 +70,7 @@ private:\nCURLM  *m_multiHandle;\nCURLSH *m_shareHandle;\n\n-    DeprecatedPtrList<ResourceHandle> m_pendingJobs;\n+    DeprecatedPtrList<CachedResponse> m_pendingJobs;\n\nCString m_caFile;\nCString m_caPath;'),
 ('dev/null',
  'src/Browser/WebCore/platform/network/ekioh/CachedResponse.cpp',
  'Index: src/Browser/WebCore/platform/network/ekioh/CachedResponse.cpp\n===================================================================\n--- dev/null\n+++ src/Browser/WebCore/platform/network/ekioh/CachedResponse.cpp\n@@ -0,0 +1,282 @@\n+/* CachedResponse.cpp\n+ *\n+ * Copyright (c) 2009 Motorola Inc. All rights reserved.\n+ *\n+ */\n+\n+#include "NotImplemented.h"\n+#include "EKTimer.h"\n+#include "EKTimerListener.h"\n+\n+#include "CachedResponse.h"\n+#include "ResourceHandleInternal.h"\n+#include "ResourceHandleClient.h"\n+#include <cstdio>\n+#include <cassert>\n+\n+namespace WebCore {\n+\n+static inline bool doCallback(ResourceHandleInternal* d)\n+{\n+  return (d != NULL) && d->client() && !d->m_cancelled;\n+}\n+\n+CachedResponse::CachedResponse(const String& entryURL)\n+: m_data(NULL)\n+, m_size(0)\n+, m_complete(false)\n+, m_conditional(false)\n+, m_handle(NULL)\n+, lruNext(NULL)\n+, lruPrev(NULL)\n+, m_entryURL(entryURL)\n+, timer(NULL)\n+, m_serverDate(0)\n+, m_responseDate(0)\n+{\n+}\n+\n+CachedResponse::~CachedResponse()\n+{\n+\tdelete timer;\n+\tdelete [] m_data;\n+}\n+\n+void CachedResponse::willRevalidate()\n+{\n+\t// Should \'response\' contents be cleared?\n+\tdelete [] m_data;\n+\tm_data = NULL;\n+\tm_size = 0;\n+\tm_complete = false;\n+\tm_conditional = false;\n+\tresponse.setResponseFired(false);\n+}\n+\n+void CachedResponse::addData(char *data, size_t size)\n+{\n+    if (networkcache()->contains(m_entryURL)) {\n+        char *newBuffer = new char[m_size+size];\n+        // Copy existing data\n+\t\tmemcpy(newBuffer, m_data, m_size);\n+\t\t// Copy added data\n+\t\tmemcpy(newBuffer+m_size, data, size);\n+\t\tdelete [] m_data;\n+\t\tm_data = newBuffer;\n+\t\tm_size += size;\n+\t\t// Tell cache about increased size\n+\t\tnetworkcache()->adjustSize(this, size);\n+    }\n+\n+\t// Propagate data to clients\n+    ResourceHandleSet::const_iterator end = m_clients.end();\n+    for (ResourceHandleSet::const_iterator it = m_clients.begin(); it != end; ++it) {\n+\t\tif (*it) {\n+\t\t\tResourceHandleInternal* d = (*it)->getInternal();\n+\t\t\tif (doCallback(d))\n+\t\t\t  d->client()->didReceiveData(*it, data, size, m_size);\n+\t\t}\n+\t}\n+}\n+\n+void CachedResponse::addClient(ResourceHandle* client)\n+{\n+\tif (!m_complete)\n+\t\tm_clients.insert(client);\n+\n+\tif (!isConditional()) {\n+\t\tif (response.responseFired()) {\n+\t\t\tResourceHandleInternal* d = client->getInternal();\n+\t\t\tif (d->client()) {\n+\t\t\t\td->m_response = response;\n+\t\t\t\td->client()->didReceiveResponse(client, d->m_response);\n+\t\t\t\tif (m_size > 0) {\n+\t\t\t\t\td->client()->didReceiveData(client, m_data, m_size, m_size);\n+\t\t\t\t}\n+\t\t\t\tif (m_complete) {\n+\t\t\t\t\tm_cachedClients.insert(client);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (!m_cachedClients.empty() && !timer)\n+\t\t\ttimer = new CachedJob(this);\n+\t}\n+}\n+\n+void CachedResponse::setExpirationDate(const String& dateString)\n+{\n+\tresponse.setExpirationDate(curl_getdate(dateString.latin1().data(), NULL));\n+}\n+\n+void CachedResponse::didFinishCached()\n+{\n+\tDBG("%s\\n", __func__);\n+\twhile (!m_cachedClients.empty()) {\n+\t\tResourceHandle* client = *(m_cachedClients.begin());\n+\t\tResourceHandleInternal* d = client->getInternal();\n+\t\tif (!doCallback(d)) {\n+\t\t  //\n+\t\t}\n+\t\telse {\n+\t\t\td->client()->didReceiveResponse(client, d->m_response);\n+\t\t\td->client()->didFinishLoading(client);\n+\t\t}\n+\t\tm_cachedClients.erase(client);\n+\t}\n+}\n+\n+void CachedResponse::removeClient(ResourceHandle* client)\n+{\n+\tm_clients.erase(client);\n+\tm_cachedClients.erase(client);\n+}\n+\n+void CachedResponse::clearClients()\n+{\n+\tm_clients.clear();\n+\tm_cachedClients.clear();\n+}\n+\n+bool CachedResponse::hasClients()\n+{\n+\treturn ((m_clients.size() + m_cachedClients.size()) > 0);\n+}\n+\n+void CachedResponse::lruAdd()\n+{\n+\tCachedResponse *cr = networkcache()->lruFirst();\n+\tif (cr) {\n+\t\tcr->lruNext = this;\n+\t\tlruPrev = cr;\n+\t} else {\n+\t\tnetworkcache()->setLruLast(this);\n+\t\tlruPrev = NULL;\n+\t}\n+\tnetworkcache()->setLruFirst(this);\n+\tlruNext = NULL;\n+}\n+\n+void CachedResponse::lruRemove()\n+{\n+\t// Check if this is the last entry\n+\tif (lruPrev) {\n+\t\tlruPrev->lruNext = lruNext;\n+\t}\n+\telse {\n+\t\tnetworkcache()->setLruLast(lruNext);\n+\t}\n+\t// Check if this is the first entry\n+\tif (lruNext) {\n+\t\tlruNext->lruPrev = lruPrev;\n+\t}\n+\telse {\n+\t\tnetworkcache()->setLruFirst(lruPrev);\n+\t}\n+}\n+\n+void CachedResponse::didReceiveResponse()\n+{\n+\tresponse.setResponseFired(true);\n+\n+\t// Propagate response to clients\n+\tResourceHandleSet::const_iterator end = m_clients.end();\n+\tfor (ResourceHandleSet::const_iterator it = m_clients.begin(); it != end; ++it) {\n+\t\tResourceHandleInternal* d = (*it)->getInternal();\n+\t\tif (doCallback(d)) {\n+\t\t\td->m_response = response;\n+\t\t\td->client()->didReceiveResponse(*it, d->m_response);\n+\t\t}\n+\t}\n+}\n+\n+void CachedResponse::didReceiveNotModified()\n+{\n+\tm_complete = true;\n+\tm_conditional = false;\n+\n+ \t// Move clients to m_cachedClients list\n+ \tResourceHandleSet::const_iterator end = m_clients.end();\n+ \tfor (ResourceHandleSet::const_iterator it = m_clients.begin(); it != end; ++it) {\n+\t\tResourceHandleInternal* d = (*it)->getInternal();\n+\t\tif (doCallback(d)) {\n+\t\t\td->m_response = response;\n+\t\t\td->client()->didReceiveResponse(*it, d->m_response);\n+\t\t\td->client()->didReceiveData(*it, m_data, m_size, m_size);\n+\t\t}\n+\t\tm_cachedClients.insert(*it);\n+ \t}\n+\n+\tif (!m_cachedClients.empty() && !timer)\n+\t  timer = new CachedJob(this);\n+}\n+\n+void CachedResponse::didFinishLoading()\n+{\n+\tsetComplete(true);\n+\n+\twhile (!m_clients.empty()) {\n+\t\tResourceHandle* client = firstClient();\n+\t\tResourceHandleInternal* d = client->getInternal();\n+\t\tif(d->client())\n+\t\t\td->client()->didFinishLoading(client);\n+\t\tm_clients.erase(client);\n+\t}\n+}\n+\n+void CachedResponse::didFail(const ResourceError& error)\n+{\n+\twhile (!m_clients.empty()) {\n+\t\tResourceHandle* client = firstClient();\n+\t\tResourceHandleInternal* d = client->getInternal();\n+\t\tif (doCallback(d))\n+\t\t\td->client()->didFail(client, error);\n+\t\tm_clients.erase(client);\n+\t}\n+}\n+\n+void CachedResponse::cancel()\n+{\n+\twhile (hasClients()) {\n+\t\tResourceHandle* client = firstClient();\n+\t\tclient->cancel();\n+\t}\n+}\n+\n+bool CachedResponse::cancelled()\n+{\n+\tResourceHandleSet::const_iterator end = m_clients.end();\n+\tfor (ResourceHandleSet::const_iterator it = m_clients.begin(); it != end; ++it) {\n+\t\tResourceHandleInternal* d = (*it)->getInternal();\n+\t\tif (!d->m_cancelled) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\treturn true;\n+}\n+\n+void CachedResponse::setCancelled(ResourceHandle* client)\n+{\n+\tResourceHandleInternal* d = client->getInternal();\n+\td->m_cancelled = true;\n+}\n+\n+\n+void CachedResponse::redirect(String location)\n+{\n+\tResourceHandleSet::const_iterator end = m_clients.end();\n+\tfor (ResourceHandleSet::const_iterator it = m_clients.begin();\n+\t\t it != end; ++it) {\n+\t\tResourceHandleInternal* d = (*it)->getInternal();\n+\t\tif(d->client()) {\n+\t\t\tKURL newUrl((*it)->request().url(),\n+\t\t\t\t\t\tlocation.deprecatedString());\n+\t\t\tResourceRequest redirectedRequest = (*it)->request();\n+\t\t\tredirectedRequest.setURL(newUrl);\n+\t\t\td->client()->willSendRequest(*it, redirectedRequest,\n+\t\t\t\t\t\t\t\t\t\t response);\n+\t\t}\n+\t}\n+}\n+\n+} // namespace WebCore'),
 ('dev/null',
  'src/Browser/WebCore/platform/network/ekioh/NetworkCache.cpp',
  'Index: src/Browser/WebCore/platform/network/ekioh/NetworkCache.cpp\n===================================================================\n--- dev/null\n+++ src/Browser/WebCore/platform/network/ekioh/NetworkCache.cpp\n@@ -0,0 +1,318 @@\n+/* NetworkCache.cpp\n+ *\n+ * Copyright (c) 2009 Motorola Inc. All rights reserved.\n+ *\n+ */\n+\n+#include "NotImplemented.h"\n+#include "NetworkCache.h"\n+#include "ResourceRequest.h"\n+#include "CString.h"\n+#include <cctype>\n+#include <cstdlib>\n+\n+namespace WebCore\n+{\n+\n+NetworkCache* networkcache()\n+{\n+    static NetworkCache* staticNetworkCache = new NetworkCache;\n+    return staticNetworkCache;\n+}\n+\n+NetworkCache::NetworkCache()\n+: m_size(0)\n+, m_maxSize(NC_INITIAL_MAX_SIZE)\n+, m_defaultMaxAge(NC_INITIAL_DEFAULT_MAX_AGE)\n+, m_lruFirst(NULL)\n+, m_lruLast(NULL)\n+{\n+}\n+\n+NetworkCache::~NetworkCache()\n+{\n+}\n+\n+// Fetch cache entry for response, returns NULL if no entry exists\n+CachedResponse* NetworkCache::getEntry(const String& url)\n+{\n+    return m_cache.get(url);\n+}\n+\n+bool NetworkCache::contains(const String& url)\n+{\n+    return m_cache.contains(url);\n+}\n+\n+bool NetworkCache::nocacheContains(ResourceHandle* client)\n+{\n+    return m_nocache.contains(client);\n+}\n+\n+// Add cache entry for response\n+void NetworkCache::addEntry(CachedResponse* cacheEntry)\n+{\n+\tDBG("NetworkCache::addEntry(), %s\\n", cacheEntry->entryURL().utf8().data());\n+\tDBG("Size now %d, adding %d\\n", m_size, cacheEntry->size());\n+\tif ((m_size+cacheEntry->size()) > m_maxSize) {\n+\t\tpruneCache();\n+\t}\n+\tm_size += cacheEntry->size();\n+    m_cache.set(cacheEntry->entryURL(), cacheEntry);\n+\t//printLRUList();\n+}\n+\n+CachedResponse* NetworkCache::getEntry(ResourceHandle* client)\n+{\n+\tCachedResponse* entry = m_nocache.get(client);\n+\tif (!entry)\n+\t\tentry = m_cache.get(client->request().url().prettyURL());\n+\treturn entry;\n+}\n+\n+// Add nocache entry for client/response\n+void NetworkCache::addNocacheEntry(ResourceHandle* client,\n+\t\t\t\t\t\t\t\t   CachedResponse* cacheEntry)\n+{\n+\tDBG("NetworkCache::addNoCacheEntry(), %s\\n",\n+\t\t\tcacheEntry->entryURL().utf8().data());\n+    m_nocache.set(client, cacheEntry);\n+}\n+\n+// Make a cached entry into a nocache entry for client/response\n+void NetworkCache::makeNocacheEntry(ResourceHandle* client,\n+\t\t\t\t\t\t\t\t\tCachedResponse* cacheEntry)\n+{\n+\tDBG("NetworkCache::makeNocacheEntry(), job(%p), handle(%p), url(%s)\\n",\n+\t\t\tclient,\n+\t\t\tcacheEntry->handle(),\n+\t\t\tcacheEntry->entryURL().utf8().data());\n+\t// Remove from cache list\n+\tm_size -= cacheEntry->size();\n+    m_cache.remove(cacheEntry->entryURL());\n+\t// Add to nocache list\n+    m_nocache.set(client, cacheEntry);\n+}\n+\n+// Make a nocache entry into a cache entry for client/response\n+void NetworkCache::makeCacheEntry(CachedResponse* cacheEntry)\n+{\n+\tDBG("NetworkCache::makeCacheEntry()\\n");\n+\t// Add to nocache list\n+    m_nocache.remove(cacheEntry->firstClient());\n+\t// Add to cache list\n+\tif ((m_size+cacheEntry->size()) > m_maxSize) {\n+\t\tpruneCache();\n+\t}\n+\tm_size += cacheEntry->size();\n+    m_cache.set(cacheEntry->entryURL(), cacheEntry);\n+}\n+\n+// Remove an entry\n+void NetworkCache::removeEntry(const String& url)\n+{\n+\tDBG("NetworkCache::removeEntry(), %s\\n", url.utf8().data());\n+\tif (!m_cache.contains(url))\n+\t  return;\n+\tCachedResponse* cacheEntry = m_cache.get(url);\n+ \tif (cacheEntry->hasClients()) {\n+ \t\tmakeNocacheEntry(cacheEntry->firstClient(), cacheEntry);\n+ \t}\n+ \telse {\n+\t\tm_size -= m_cache.get(url)->size();\n+\t\tm_cache.remove(url);\n+\t\tdelete cacheEntry;\n+ \t}\n+}\n+\n+// Remove an entry\n+void NetworkCache::removeEntry(ResourceHandle* client)\n+{\n+\tCachedResponse* cacheEntry = m_nocache.get(client);\n+\tif (cacheEntry) {\n+\t\tm_nocache.remove(client);\n+\t\tdelete cacheEntry;\n+\t}\n+\telse {\n+\t\tString url = client->request().url().string();\n+\t\tm_size -= m_cache.get(url)->size();\n+\t\tcacheEntry = m_cache.get(url);\n+\t\tif (cacheEntry) {\n+\t\t\tif (cacheEntry->hasClients()) {\n+\t\t\t\tmakeNocacheEntry(cacheEntry->firstClient(), cacheEntry);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tm_cache.remove(url);\n+\t\t\t\tdelete cacheEntry;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+// Prune cache entries according to LRU\n+void NetworkCache::pruneCache()\n+{\n+\tDBG("NetworkCache::pruneCache(), cache size: %.02fkB\\n",\n+\t\t   ((float)size())/1024);\n+\tCachedResponse* cacheEntry;\n+\tCachedResponse* cacheEntryNext;\n+\tcacheEntryNext = lruLast();\n+\twhile (m_size > (m_maxSize*NC_TRIM_PERCENTAGE) &&\n+\t\t   cacheEntryNext) {\n+\t  \tcacheEntry = cacheEntryNext;\n+\t\tcacheEntryNext = cacheEntry->lruNext;\n+\t\tcacheEntry->lruRemove();\n+\t\tremoveEntry(cacheEntry->entryURL());\n+\t}\n+\tDBG("Result after prune, cache size: %.02fkB\\n",\n+\t\t   ((float)size())/1024);\n+\t//printLRUList();\n+}\n+\n+void NetworkCache::adjustSize(CachedResponse* cacheEntry,\n+\t\t\t\t\t\t\t  size_t sizeIncrease)\n+{\n+\tif (m_cache.contains(cacheEntry->entryURL())) {\n+\t\tif ((m_size+sizeIncrease) > m_maxSize) {\n+\t\t\tpruneCache();\n+\t\t}\n+\t\tm_size += sizeIncrease;\n+\t\t//printLRUList();\n+\t}\n+}\n+\n+// Public convenience method for parsing Cache-Control header field\n+void NetworkCache::parseCacheControl(struct CacheControl* cc, const char *value)\n+{\n+\tDBG("NetworkCache::parseCacheControl()\\n");\n+\tconst char *dl, *du; // Directive lower and upper pointer\n+\tconst char *vl, *vu; // Value lower and upper pointer\n+\n+\tdl = vl = vu = du = value;\n+\n+\twhile ( *vu ) { // Check for string end\n+\t\t// Tokenize string\n+\t\twhile ( isblank(*dl) ) dl++; // Find directive start\n+\t\tdu = dl;\n+\t\twhile ( !isblank(*du) &&\n+\t\t\t\t(*du != \',\') &&\n+\t\t\t\t(*du != \'=\') &&\n+\t\t\t\t(*du != \'\\0\') ) du++; // Find directive end\n+\t\tvl = vu = du;\n+\t\tif (*du == \'=\') {\n+\t\t\tvl++;\n+\t\t\t// Parse value\n+\t\t\twhile ( isblank(*vl) ) vl++; // Find value start\n+\t\t\tif ( *vl == \'"\' ) { // Parse quoted-string\n+\t\t\t\tvu = ++vl;\n+\t\t\t\twhile ( *vu != \'"\' &&\n+\t\t\t\t\t\t(*vu != \'\\0\') ) vu++;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tvu = vl;\n+\t\t\t\twhile ( !isblank(*vu) &&\n+\t\t\t\t\t\t(*vu != \',\') &&\n+\t\t\t\t\t\t(*vu != \'\\0\') ) vu++;\n+\t\t\t}\n+\t\t}\n+\n+\t\t// At this stage, dl should point to directive string terminated by du\n+\t\t// and vl should point to directive value string terminated by vu\n+\n+\t\tint dlen = du - dl;\n+\t\t// Case sensitive comparisons according to RFC2616, section 4.2\n+\t\t// Test order is according to expected occurency\n+\t\tif ( !strncmp(dl, "no-cache", dlen) &&\n+\t\t\t dlen == 8 ) {\n+\t\t\tcc->nocache = true;\n+\t\t}\n+\t\telse if ( !strncmp(dl, "no-store", dlen) &&\n+\t\t\t\t  dlen == 8 ) {\n+\t\t\tcc->nostore = true;\n+\t\t}\n+\t\telse if ( !strncmp(dl, "max-age", dlen) &&\n+\t\t\t\t  dlen == 7 ) {\n+\t\t\tcc->maxage = 0;\n+\t\t\t// Since strntol doesn\'t exist in stdlib, this is done manually\n+\t\t\tif (vu-vl > 7) {\n+\t\t\t\tcc->maxage = 10000000;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tfor (int i = vu-vl-1; i>=0; i--,vl++) {\n+\t\t\t\t\tif ( !isdigit(*vl) ) {\n+\t\t\t\t\t\tcc->maxage = 0;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\t\t\t\t\tswitch (i) {\n+\t\t\t\t\tcase 0:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\');\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 1:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*10;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 2:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*100;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 3:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*1000;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 4:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*10000;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 5:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*100000;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 6:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*1000000;\n+\t\t\t\t\t  break;\n+\t\t\t\t\tcase 7:\n+\t\t\t\t\t  cc->maxage += (*vl - \'0\')*10000000;\n+\t\t\t\t\t  break;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\telse if ( !strncmp(dl, "public", dlen) &&\n+\t\t\t\t  dlen == 6 ) {\n+\t\t\tcc->ispublic = true;\n+\t\t}\n+\n+\t\tif ( *vu ) {\n+\t\t\tdl = du = vl = ++vu;\n+\t\t}\n+\t}\n+\n+\treturn;\n+}\n+\n+void NetworkCache::addNotModifiedJob(ResourceHandle *client)\n+{\n+\tm_notModifiedJobs.set(client, new NotModifiedJob(client));\n+}\n+\n+void NetworkCache::removeNotModifiedJob(ResourceHandle *client)\n+{\n+\tif (m_notModifiedJobs.contains(client)) {\n+\t  NotModifiedJob* timer = m_notModifiedJobs.get(client);\n+\t  delete timer;\n+\t  m_notModifiedJobs.remove(client);\n+\t}\n+}\n+\n+void NetworkCache::printLRUList()\n+{\n+ \tCachedResponse* lruprint = lruFirst();\n+\tint i = 0;\n+ \tfprintf(stderr,"==============LRU list===============\\n");\n+ \twhile (lruprint) {\n+\t\ti++;\n+ \t\tfprintf(stderr,"(%p)",lruprint);\n+\t\tfprintf(stderr,"%s ",lruprint->entryURL().utf8().data());\n+\t\tfprintf(stderr,"%s\\n",m_cache.contains(lruprint->entryURL())?"(in cache)":"(not in cache)");\n+ \t\tlruprint = lruprint->lruPrev;\n+ \t}\n+ \tfprintf(stderr,"=====================================\\n");\n+ \tfprintf(stderr,"Cache size: %.02fkB, LRU count: %d\\n", ((float)size())/1024, i);\n+}\n+\n+}'),
 ('dev/null',
  'src/3rdParty/webkit/work/WebCore/platform/network/ekioh/CachedResponse.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/network/ekioh/CachedResponse.h\n===================================================================\n--- dev/null\n+++ src/3rdParty/webkit/work/WebCore/platform/network/ekioh/CachedResponse.h\n@@ -0,0 +1,206 @@\n+/* CachedResponse.h\n+ *\n+ * Copyright (c) 2009 Motorola Inc. All rights reserved.\n+ *\n+ */\n+\n+\n+#ifndef CachedResponse_h\n+#define CachedResponse_h\n+\n+#include <cstring>\n+#include <set>\n+#include "HTTPHeaderMap.h"\n+#include "NetworkCache.h"\n+\n+#include "ResourceHandle.h"\n+\n+#include "EKTimer.h"\n+#include "EKTimerListener.h"\n+\n+#include <curl/curl.h>\n+\n+namespace WebCore {\n+\n+struct CacheControl {\n+\n+\ttime_t maxage;\n+\tbool ispublic;\n+\tbool nocache;\n+\tbool nostore;\n+\n+\t// These are not used, but are provided for\n+\t// future RFC2616 compatability\n+\ttime_t smaxage;\n+\ttime_t maxstale;\n+\ttime_t minfresh;\n+\tbool isprivate;\n+\tbool notransform;\n+\tbool onlyifcached;\n+\tbool mustrevalidate;\n+\tbool proxyrevalidate;\n+\t// Cache-control extensions ignored\n+\n+\tCacheControl()\n+\t  : maxage(0)\n+\t  , ispublic(false)\n+\t  , nocache(false)\n+\t  , nostore(false)\n+\t  , smaxage(0)\n+\t  , maxstale(0)\n+\t  , minfresh(0)\n+\t  , isprivate(false)\n+\t  , notransform(false)\n+\t  , onlyifcached(false)\n+\t  , mustrevalidate(false)\n+\t  , proxyrevalidate(false)\n+\t{};\n+};\n+\n+typedef std::set<ResourceHandle*> ResourceHandleSet;\n+\n+class CachedJob;\n+\n+class CachedResponse\n+{\n+friend class NetworkCache;\n+friend class CachedJob;\n+\n+private:\n+    HTTPHeaderMap m_headers;\n+    char* m_data;               // Pointer to response content data\n+\tsize_t m_size;\n+\tbool m_complete;            // Transfer complete\n+\tbool m_conditional;         // Cache generated conditional request\n+\tString m_conditionalHeader;\n+\tCURL* m_handle;\n+\tResourceHandleSet m_clients;\n+\tResourceHandleSet m_cachedClients;\n+\ttime_t m_serverDate;\n+\ttime_t m_responseDate;\n+\tString m_entryURL;\n+\n+\t// The timer is used to keep track of when cached\n+\t// data should be sent to waiting clients\n+\tvoid addTimer(CachedJob* timer);\n+\tvoid removeTimer(CachedJob* timer);\n+\n+protected:\n+\t// Linked list for LRU book keeping\n+\tCachedResponse* lruNext;\n+\tCachedResponse* lruPrev;\n+\tCachedJob* timer;\n+\n+public:\n+\t// Stored response from server\n+\tResourceResponse response;\n+\t// Cache control directives from response\n+\tCacheControl cacheControl;\n+\n+    CachedResponse(const String& entryURL);\n+    ~CachedResponse();\n+\n+\t// Methods for adding and removing ResourceHandle clients\n+\tvoid addClient(ResourceHandle* client);\n+\tvoid removeClient(ResourceHandle* client);\n+\tvoid clearClients();\n+\n+\t// Adds data to cache entry and propagates to clients\n+    void addData(char *data, size_t size);\n+\t// Sends finish to clients receiving cached data\n+\tvoid didFinishCached();\n+\n+\t// Propagates request events to clients\n+\tvoid didReceiveResponse();\n+\tvoid didReceiveHeader();\n+\tvoid didReceiveData();\n+\n+\tvoid didFinishLoading();\n+\tvoid didFail(const ResourceError& error);\n+\n+\tvoid redirect(String location);\n+\tvoid didReceiveNotModified();\n+\tvoid willRevalidate();\n+\n+\t// Handles cancel request\n+\tvoid cancel();\n+\n+\t// Get/set cancelled state.\n+\tbool cancelled();\n+\tvoid setCancelled(ResourceHandle* client);\n+\n+\t// LRU list methods\n+\tvoid lruAdd();\n+\tvoid lruRemove();\n+\n+\t// Allocated size for cache data\n+    size_t size() { return m_size; }\n+\t// Cache data\n+\t char* data() { return m_data; }\n+\n+\t// Access methods for client list\n+\tResourceHandleSet* getClients() { return &m_clients; }\n+\tResourceHandle* firstClient() { return *(m_clients.begin()); }\n+\tbool hasClients();\n+\n+\t// Curl handle for request transfer\n+    CURL* handle() { return m_handle; }\n+    void setHandle(CURL* handle) { m_handle = handle; }\n+\n+\t// Methods for setting up a conditional request\n+    void setConditional(bool value) { m_conditional = value; }\n+    void setConditionalHeader(String value) { m_conditionalHeader = value; }\n+    const String& conditionalHeader() { return m_conditionalHeader; }\n+    bool isConditional() { return m_conditional; }\n+\n+\t// Time from Date: header in server response\n+\ttime_t serverDate() { return m_serverDate; }\n+\tvoid setServerDate(time_t date) { m_serverDate = date; }\n+\t// Local time when server response was received\n+\ttime_t responseDate() { return m_responseDate; }\n+\tvoid setResponseDate(time_t date) { m_responseDate = date; }\n+\t// Expiration date for response\n+    void setExpirationDate(const String& dateString);\n+\n+\t// Complete means that the curl transfer has finished and succeded\n+\tbool complete() { return m_complete; }\n+\tvoid setComplete(bool val) { m_complete = val; }\n+\n+\t// Stored key URL for the cache entry\n+\tconst String& entryURL() { return m_entryURL; }\n+};\n+\n+// This class schedules the cached response for the ResourceHandle client.\n+// This is necessary since, ResourceHandleManager::add() must return before\n+// ResourceHandleClient::didReceiveResponse() can be called.\n+class CachedJob : public ekioh::EKTimerListener\n+{\n+public:\n+    CachedResponse *m_cacheEntry;\n+\n+    CachedJob(CachedResponse *cacheEntry)\n+        : EKTimerListener()\n+        , m_timer(*this)\n+\t\t, m_cacheEntry(cacheEntry)\n+    {\n+        m_timer.triggerIn(0);\n+    }\n+\tvoid disable()\n+\t{\n+\t\tm_timer.disable();\n+\t}\n+\n+private:\n+\tvoid timerCallback(const ekioh::EKTimer& timer, uint32_t now)\n+    {\n+\t\tm_cacheEntry->didFinishCached();\n+\t\tm_cacheEntry->timer = NULL;\n+\t\tdelete this;\n+    }\n+\n+    ekioh::EKTimer m_timer;\n+};\n+\n+}\n+\n+#endif'),
 ('dev/null',
  'src/3rdParty/webkit/work/WebCore/platform/network/ekioh/NetworkCache.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/network/ekioh/NetworkCache.h\n===================================================================\n--- dev/null\n+++ src/3rdParty/webkit/work/WebCore/platform/network/ekioh/NetworkCache.h\n@@ -0,0 +1,135 @@\n+/* NetworkCache.h\n+ *\n+ * Copyright (c) 2009 Motorola Inc. All rights reserved.\n+ *\n+ */\n+\n+#ifndef NetworkCache_h\n+#define NetworkCache_h\n+\n+#include <wtf/HashMap.h>\n+#include <cstring>\n+#include "ResourceHandle.h"\n+#include "CachedResponse.h"\n+#include "StringHash.h"\n+#include "PlatformString.h"\n+#include "ResourceHandleInternal.h"\n+#include "ResourceHandleClient.h"\n+\n+// Set initial max cache size to 128 MB\n+#define NC_INITIAL_MAX_SIZE 128*1024*1024 //bytes\n+//#define NC_INITIAL_MAX_SIZE 128*1024 // bytes\n+#define NC_INITIAL_DEFAULT_MAX_AGE 5*60 //seconds\n+//#define NC_DEFAULT_MAX_AGE 5 //seconds\n+#define NC_TRIM_PERCENTAGE 0.8f\n+\n+namespace WebCore\n+{\n+\n+class CachedResponse;\n+class NotModifiedJob;\n+\n+class NetworkCache\n+{\n+private:\n+    HashMap<String, CachedResponse*> m_cache;\n+    HashMap<ResourceHandle*, CachedResponse*> m_nocache;\n+    HashMap<ResourceHandle*, NotModifiedJob*> m_notModifiedJobs;\n+    size_t m_size;   // Currently allocated memory for response data\n+\tsize_t m_maxSize; // Max memory allocated for response data\n+\tsize_t m_defaultMaxAge; // Default expiration time\n+\tCachedResponse* m_lruFirst; // LRU entry\n+\tCachedResponse* m_lruLast;  // Entry with oldest use date\n+\n+public:\n+\tfriend NetworkCache* networkcache();\n+    NetworkCache();\n+    ~NetworkCache();\n+\n+\t// Get cache entry from cache list\n+    CachedResponse* getEntry(const String& url);\n+\t// This one may also return response from nocache list\n+\tCachedResponse* getEntry(ResourceHandle* client);\n+\n+\t// Methods for handling cache list\n+    void addEntry(CachedResponse *response);\n+\tvoid removeEntry(const String& url);\n+\tvoid adjustSize(CachedResponse* cacheEntry,\n+\t\t\t\t\tsize_t sizeIncrease);\n+\tbool contains(const String& url);\n+\tsize_t size() { return m_size; }\n+\n+\t// Methods for handling nocache list\n+    void addNocacheEntry(ResourceHandle* client,\n+\t\t\t\t\t\t CachedResponse* response);\n+    void removeEntry(ResourceHandle* client);\n+\tbool nocacheContains(ResourceHandle* client);\n+\n+\t// Move clients between cache and nocache\n+\tvoid makeNocacheEntry(ResourceHandle* client,\n+\t\t\t\t\t\t  CachedResponse* cacheEntry);\n+\tvoid makeCacheEntry(CachedResponse* cacheEntry);\n+\n+\t// Requests from higher level cache that receives 304 responses\n+    void addNotModifiedJob(ResourceHandle *client);\n+    void removeNotModifiedJob(ResourceHandle *client);\n+\n+\t// Methods for keeping a list of LRU entries\n+\tCachedResponse* lruFirst() { return m_lruFirst; }\n+\tvoid setLruFirst(CachedResponse* newResponse) { m_lruFirst = newResponse; }\n+\tCachedResponse* lruLast() { return m_lruLast; }\n+\tvoid setLruLast(CachedResponse* newResponse) { m_lruLast = newResponse; }\n+\n+\t// Remove items from cache to reduce allocated memory\n+    void pruneCache();\n+\n+\t// Convenience method for parsing Cache-Control headers\n+\tvoid parseCacheControl(struct CacheControl* cc, const char* value);\n+\n+\t// Parameters for cache behaviour\n+\tsize_t maxSize() { return m_maxSize; }\n+\tvoid setMaxSize(size_t maxSize) { m_maxSize = maxSize; }\n+\tint defaultMaxAge() { return m_defaultMaxAge; }\n+\tvoid setDefaultMaxAge(int maxAge) { m_defaultMaxAge = maxAge; }\n+\n+\t// Debug function\n+\tvoid printLRUList();\n+};\n+\n+NetworkCache* networkcache();\n+\n+// This class schedules a 304 not modified response for the ResourceHandle client.\n+// This is necessary since, ResourceHandleManager::add() must return before\n+// ResourceHandleClient::didReceiveResponse() can be called.\n+class NotModifiedJob : public ekioh::EKTimerListener\n+{\n+public:\n+\n+\tNotModifiedJob(ResourceHandle *job)\n+        : EKTimerListener()\n+        , m_timer(*this)\n+\t\t, job(job)\n+    {\n+        m_timer.triggerIn(0);\n+    }\n+\tvoid disable()\n+\t{\n+\t\tm_timer.disable();\n+\t}\n+\n+private:\n+\tvoid timerCallback(const ekioh::EKTimer& timer,  uint32_t now)\n+    {\n+\t  if (job->client() && job->getInternal()) {\n+\t\t  job->getInternal()->m_response.setHTTPStatusCode(304);\n+\t\t  job->client()->didReceiveResponse(job, job->getInternal()->m_response);\n+\t  }\n+\t  networkcache()->removeNotModifiedJob(job);\n+    }\n+\tResourceHandle *job;\n+    ekioh::EKTimer m_timer;\n+};\n+\n+}\n+\n+#endif'),
 ('src.orig/3rdParty/webkit/work/WebCore/platform/network/ResourceHandleInternal.h',
  'src/3rdParty/webkit/work/WebCore/platform/network/ResourceHandleInternal.h',
  'Index: src/3rdParty/webkit/work/WebCore/platform/network/ResourceHandleInternal.h\n===================================================================\n--- src.orig/3rdParty/webkit/work/WebCore/platform/network/ResourceHandleInternal.h\n+++ src/3rdParty/webkit/work/WebCore/platform/network/ResourceHandleInternal.h\n@@ -102,6 +102,7 @@ namespace WebCore {\n#if PLATFORM(EKIOH)\n, m_handle(0)\n, m_customHeaders(0)\n+            , m_cancelled(false)\n#endif\n#if USE(CURL)\n, m_handle(0)\n@@ -165,6 +166,7 @@ namespace WebCore {\nCString m_postData;\nstruct curl_slist* m_customHeaders;\nResourceResponse m_response;\n+        bool m_cancelled;\n#endif\n#if USE(CURL)\nCURL* m_handle;')]