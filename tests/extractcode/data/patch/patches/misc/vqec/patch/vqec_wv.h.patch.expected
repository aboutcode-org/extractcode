[('dev/null',
  'eva/vqec_wv.h',
  '--- dev/null\n+++ eva/vqec_wv.h\n@@ -0,0 +1,127 @@\n+/******************************************************************************\n+ *\n+ * Cisco Systems, Inc.\n+ *\n+ * Copyright (c) 2006-2009 by Cisco Systems, Inc.\n+ * All rights reserved.\n+ *\n+ ******************************************************************************\n+ *\n+ * File: vqec_wv.h\n+ *\n+ * Description: VQEC WideVine workaround API.\n+ *\n+ * Documents:\n+ *\n+ *****************************************************************************/\n+\n+#ifndef __VQEC_WV_H__\n+#define __VQEC_WV_H__\n+\n+#include <stdint.h>\n+\n+#ifdef __cplusplus\n+extern "C" {\n+#endif // __cplusplus\n+\n+#ifndef boolean\n+typedef int boolean;\n+#endif\n+\n+#ifndef FALSE\n+#define FALSE 0\n+#endif\n+\n+#ifndef TRUE\n+#define TRUE 1\n+#endif\n+\n+#ifndef VQEC_WV_MAX_CACHE_SIZE\n+#define VQEC_WV_MAX_CACHE_SIZE      64 * 1024\n+#define VQEC_WV_MAX_CACHE_THRESHOLD 1512 * 10\n+#define VQEC_WV_MAX_REPLAY          4\n+#endif\n+\n+#if 1\n+#define VQEC_WV_PRINTF(format,...)             \\\n+    printf("[VQEC_WV]" format "\\n", ##__VA_ARGS__);\n+#else\n+#define VQEC_WV_PRINTF(format,...)\n+#endif\n+\n+/**\n+ * various mpeg constants, definitions\n+ */\n+#define MPEG_TS_PKT_BYTES 188\n+#define MPEG_NULL_PID 0x1FFF\n+#define WVCAKREPLAY_MPEGTS_SYNC_BYTE(hdr) (*(uint8_t *)(hdr))\n+#define WVCAKREPLAY_MPEGTS_PUSI_BIT(hdr) ( *(((uint8_t *)(hdr)) + 1) & 0x40 )\n+#define WVCAKREPLAY_MPEGTS_PID(hdr)                                     \\\n+    ( (( *(((uint8_t *)(hdr)) + 1) & 0x1F) << 8) | *(((uint8_t *)(hdr)) + 2) )\n+#define WVCAKREPLAY_MPEGTS_SC(hdr) (( *(((uint8_t *)(hdr)) + 3) & 0xC0 ) >> 6)\n+struct mpeg_ts_packet\n+{\n+    uint8_t pkt_hdr[4];\n+    uint8_t data[MPEG_TS_PKT_BYTES - 4];\n+};\n+\n+/**\n+ * Call once on every new channel change, prior to calling other APIs documented\n+ * here.  Will reset read and write cache buffer pointers.\n+ */\n+void vqec_wv_cache_init(void);\n+\n+/**\n+ * Called when data is available from source.  This data has not yet been\n+ * touched by the CA agent.  This API should be fed data until it returns TRUE,\n+ * only then should the complete data buffer be passed on to the CA agent.\n+ *\n+ * @param[in] ptr  pointer to data that is to be consumed by the system\n+ * @param[in] len  length of the data\n+ * @return int  returns 0 if the cache is not full; otherwise returns the size\n+ *              of the cache\n+ */\n+int vqec_wv_cache_data(uint8_t *ptr,\n+                       size_t len);\n+\n+/**\n+ * Called after CA element has processed data but before it is sent to hardware.\n+ * This API requires that cache has been filled, otherwise no replay will be\n+ * attempted.  The audio and video PIDs for current channel change stream should\n+ * be provided.\n+ *\n+ * @param[in/out] data  pointer to data that, on input, has been processed by CA\n+ *                      element, and on output, may need to be replayed\n+ * @param[in] bytes  length of data\n+ * @param[in] videoPid  video PID to look for in cache\n+ * @param[in] audioPid  audio PID to look for in cache\n+ * @return int  Returns the amount of data needing to be replayed, if any\n+ */\n+int vqec_wv_replay(uint8_t *data,\n+                   size_t bytes,\n+                   unsigned short video_pid,\n+                   unsigned short audio_pid);\n+\n+/**\n+ *Read from cache data\n+ *@param[in] data  pointer to the data buffer\n+ *@param[in] bytes  length of data buffer\n+ */\n+int vqec_wv_cache_replay(uint8_t *data,\n+                         size_t bytes);\n+\n+/**\n+ *parameters are same with vqec_wv_replay. do_replay just check whether need to\n+ *send cache data\n+ */\n+boolean do_replay (uint8_t *post_play_buf,\n+                   uint32_t len,\n+                   uint16_t video_pid,\n+                   uint16_t audio_pid);\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif // __cplusplus\n+\n+#endif /* __VQEC_WV_H__ */')]