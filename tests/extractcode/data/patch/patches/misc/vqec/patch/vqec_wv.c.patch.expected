[('dev/null',
  'eva/vqec_wv.c',
  '--- dev/null\n+++ eva/vqec_wv.c\n@@ -0,0 +1,276 @@\n+/******************************************************************************\n+ *\n+ * Cisco Systems, Inc.\n+ *\n+ * Copyright (c) 2007-2009 by Cisco Systems, Inc.\n+ * All rights reserved.\n+ *\n+ ******************************************************************************\n+ *\n+ * File: vqec_wv.c\n+ *\n+ * Description: VQEC WideVine workaround functions.\n+ *\n+ * Documents:\n+ *\n+ *****************************************************************************/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include "vqec_wv.h"\n+\n+static uint8_t *cache_head, *wr_ptr, *rd_ptr;\n+static uint8_t cache[VQEC_WV_MAX_CACHE_SIZE];\n+static uint8_t replay_check_count;\n+\n+/**\n+ * Call once on every new channel change, prior to calling other APIs documented\n+ * here.  Will reset read and write cache buffer pointers.\n+ */\n+void vqec_wv_cache_init (void)\n+{\n+    VQEC_WV_PRINTF("vqec_wv_cache_init entered\\n");\n+\n+    cache_head = &cache[0];\n+    wr_ptr = cache_head;\n+    rd_ptr = cache_head;\n+    replay_check_count = 0;\n+\n+    VQEC_WV_PRINTF("vqec_wv_cache_init exited\\n");\n+}\n+\n+/**\n+ * Called when data is available from source.  This data has not yet been\n+ * touched by the CA agent.  This API should be fed data until it returns TRUE,\n+ * only then should the complete data buffer be passed on to the CA agent.\n+ *\n+ * @param[in] ptr  pointer to data that is to be consumed by the system\n+ * @param[in] len  length of the data\n+ * @return int  returns 0 if the cache is not full; otherwise returns the size\n+ *              of the cache\n+ */\n+int vqec_wv_cache_data (uint8_t *ptr, size_t len)\n+{\n+    int copy_len = 0;\n+    int ret = VQEC_WV_MAX_CACHE_SIZE;\n+\n+\n+    if (replay_check_count == 0) {\n+\n+        if ((len != 0) &&\n+            (ptr != NULL) &&\n+            (wr_ptr != (cache_head + VQEC_WV_MAX_CACHE_SIZE))) {\n+\n+            /* copy data pointed to by ptr into cache buffer, up to VQEC_WV_MAX_CACHE_SIZE and update wr_ptr */\n+            copy_len = (cache_head + VQEC_WV_MAX_CACHE_SIZE) - wr_ptr;\n+            if (copy_len > len) {\n+                copy_len = len;\n+            }\n+\n+            memcpy(wr_ptr, ptr, copy_len);\n+            wr_ptr += copy_len;\n+        }\n+\n+        if (wr_ptr < (cache_head + VQEC_WV_MAX_CACHE_THRESHOLD)) {\n+            ret = 0;\n+        }\n+\n+        VQEC_WV_PRINTF("vqec_wv_cache_data: ptr=%p, len=0x%x, ret=0x%x, wr_ptr=%p, rd_ptr=%p, copy_len=0x%x\\n",\n+                        ptr, (int)len, ret, wr_ptr, rd_ptr, copy_len);\n+\n+    }\n+\n+    return(ret);\n+}\n+\n+/**\n+ * Determines if the original cached data has any scrambled\n+ * TS packets. This may be used to bypass the widevine precheck\n+ * in case it continues to overwrite the video pid on successive\n+ * replay attempts.\n+ *\n+ * @return bool Returns true if the cached block has scrambled\n+ * TS packets, false otherwise.\n+ */\n+static boolean is_transport_scrambled (void)\n+{\n+    struct mpeg_ts_packet *pkt;\n+    boolean ret = FALSE;\n+\n+    pkt = (struct mpeg_ts_packet *)rd_ptr;\n+    while ((uint8_t *)(pkt + 1) <= (rd_ptr + (wr_ptr - rd_ptr))) {\n+        if (WVCAKREPLAY_MPEGTS_SC(pkt->pkt_hdr) != 0) {\n+            ret = TRUE;\n+            break;\n+        }\n+        pkt++;\n+    }\n+\n+    VQEC_WV_PRINTF("is_transport_scrambled: ret=%d\\n", (int)ret);\n+\n+    return (ret);\n+}\n+\n+\n+/**\n+ * Compares the cached data block to the data-block after it has been\n+ * played by the cam object. It will return true if the two copies are\n+ * semantically the same, i.e., no need to replay the block. It will return\n+ * false otherwise.\n+ *\n+ * @param[in] post_play_buf Input block after it has been handled by the cam.\n+ * @param[in] len Input block length.\n+ * @param[in] video_pid Video pid for the cached block.\n+ * @param[in] audio_pid Audio pid for the cached block.\n+ * @return boolean Returns true if the cached block should be replayed,\n+ * false otherwise. There are certain error conditions in which the method\n+ * will return false since no comparison basis can be established:\n+ *    (a) If there isn\'t any cached block in the object, or if the lengths\n+ *    are mismatched in which case no correlation can be established.\n+ *    (b) If both the audio and video pids are null.\n+ */\n+boolean do_replay (uint8_t *post_play_buf, uint32_t len,\n+                          uint16_t video_pid, uint16_t audio_pid)\n+{\n+    struct mpeg_ts_packet *pkt, *post_pkt;\n+    boolean ret = FALSE;\n+\n+    if (!(wr_ptr - rd_ptr) ||\n+        !len ||\n+        !post_play_buf ||\n+        len != (wr_ptr - rd_ptr)) {\n+\n+        VQEC_WV_PRINTF("do_replay error: buf=%p, len=0x%x, "\n+                       "video_pid=%d, audio_pid=%d,wr_ptr=%p, rd_ptr=%p\\n",\n+                       post_play_buf, len, video_pid, audio_pid, wr_ptr, rd_ptr);\n+        return(ret);\n+    }\n+\n+    pkt = (struct mpeg_ts_packet *)rd_ptr;\n+    post_pkt = (struct mpeg_ts_packet *)post_play_buf;\n+    while ((uint8_t *)(pkt + 1) <= (rd_ptr + len)) {\n+        if (WVCAKREPLAY_MPEGTS_PUSI_BIT(pkt->pkt_hdr) != 0) {\n+            if ((video_pid != MPEG_NULL_PID) &&\n+                (WVCAKREPLAY_MPEGTS_PID(pkt->pkt_hdr) == video_pid) &&\n+                (WVCAKREPLAY_MPEGTS_PID(post_pkt->pkt_hdr) != video_pid)) {\n+                ret = TRUE;\n+                break;\n+            } else if ((audio_pid != MPEG_NULL_PID) &&\n+                       (WVCAKREPLAY_MPEGTS_PID(pkt->pkt_hdr) == audio_pid) &&\n+                       (WVCAKREPLAY_MPEGTS_PID(post_pkt->pkt_hdr) != audio_pid)) {\n+                ret = TRUE;\n+                break;\n+            }\n+        }\n+        pkt++;\n+        post_pkt++;\n+    }\n+\n+    VQEC_WV_PRINTF("do_replay: ret=%d\\n", ret);\n+\n+    return (ret);\n+}\n+\n+\n+/**\n+ * Called after CA element has processed data but before it is sent to hardware.\n+ * This API requires that cache has been filled, otherwise no replay will be\n+ * attempted.  The audio and video PIDs for current channel change stream should\n+ * be provided.\n+ *\n+ * @param[in/out] data  pointer to data that, on input, has been processed by CA\n+ *                      element, and on output, may need to be replayed\n+ * @param[in] bytes  length of data\n+ * @param[in] videoPid  video PID to look for in cache\n+ * @param[in] audioPid  audio PID to look for in cache\n+ * @return int  Returns the amount of data needing to be replayed, if any\n+ */\n+int vqec_wv_replay (uint8_t *data,\n+                    size_t bytes,\n+                    unsigned short video_pid,\n+                    unsigned short audio_pid)\n+{\n+    int copy_len = 0;\n+    boolean replayed = FALSE;\n+\n+\n+    if ((replay_check_count < VQEC_WV_MAX_REPLAY)\n+        && (wr_ptr >= (cache_head + VQEC_WV_MAX_CACHE_THRESHOLD))) {\n+\n+        VQEC_WV_PRINTF("vqec_wv_replay entered: data=%p, bytes=0x%x, video_pid=%d, audio_pid=%d\\n",\n+                       data, bytes, audio_pid, video_pid);\n+\n+        if (do_replay(data, bytes, video_pid, audio_pid) == TRUE) {\n+            /*\n+             * Only replay last attempt if stream not scrambled\n+             */\n+            if ((replay_check_count < (VQEC_WV_MAX_REPLAY-1))\n+                || (is_transport_scrambled() == FALSE)) {\n+\n+                /* copy cache data into data */\n+                copy_len = wr_ptr - rd_ptr;\n+                if (copy_len > bytes) {\n+                    copy_len = bytes;\n+                }\n+                memcpy(data, rd_ptr, copy_len);\n+\n+                replayed = TRUE;\n+            }\n+        }\n+\n+        /* If not replayed then we are done */\n+        if (replayed == TRUE) {\n+            replay_check_count++;\n+        } else {\n+            replay_check_count = VQEC_WV_MAX_REPLAY;\n+        }\n+\n+        VQEC_WV_PRINTF("vqec_wv_replay exited: copy_len=0x%x, replayed=%d, count=%d",\n+                       copy_len, (int)replayed, replay_check_count);\n+\n+    }\n+\n+    return (copy_len);\n+}\n+\n+\n+int vqec_wv_cache_replay (uint8_t *data,\n+                    size_t bytes)\n+{\n+    int copy_len = 0;\n+    boolean replayed = FALSE;\n+\n+    if ((replay_check_count < VQEC_WV_MAX_REPLAY)\n+        && (wr_ptr >= (cache_head + VQEC_WV_MAX_CACHE_THRESHOLD))) {\n+\n+\t/*\n+\t * Only replay last attempt if stream not scrambled\n+\t */\n+\tif ((replay_check_count < (VQEC_WV_MAX_REPLAY-1))\n+\t    || (is_transport_scrambled() == FALSE)) {\n+\n+\t    /* copy cache data into data */\n+\t    copy_len = wr_ptr - rd_ptr;\n+\t    if (copy_len > bytes) {\n+\t\tcopy_len = bytes;\n+\t    }\n+\t    memcpy(data, rd_ptr, copy_len);\n+\n+\t    replayed = TRUE;\n+\t}\n+\n+        /* If not replayed then we are done */\n+        if (replayed == TRUE) {\n+            replay_check_count++;\n+        } else {\n+            replay_check_count = VQEC_WV_MAX_REPLAY;\n+        }\n+\n+        VQEC_WV_PRINTF("vqec_wv_replay exited: copy_len=0x%x, replayed=%d, count=%d",\n+                       copy_len, (int)replayed, replay_check_count);\n+\n+    }\n+\n+    return (copy_len);\n+}')]