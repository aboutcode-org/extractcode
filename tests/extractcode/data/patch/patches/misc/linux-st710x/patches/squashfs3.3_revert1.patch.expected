[('linux-2.6.23.orig/fs/Kconfig',
  'linux-2.6.23/fs/Kconfig',
  'Index: linux-2.6.23/fs/Kconfig\n===================================================================\n--- linux-2.6.23.orig/fs/Kconfig\n+++ linux-2.6.23/fs/Kconfig\n@@ -1430,56 +1430,6 @@ config CRAMFS\n\nIf unsure, say N.\n\n-config SQUASHFS\n-\ttristate "SquashFS 3.3 - Squashed file system support"\n-\tselect ZLIB_INFLATE\n-\thelp\n-\t  Saying Y here includes support for SquashFS 3.3 (a Compressed\n-\t  Read-Only File System).  Squashfs is a highly compressed read-only\n-\t  filesystem for Linux.  It uses zlib compression to compress both\n-\t  files, inodes and directories.  Inodes in the system are very small\n-\t  and all blocks are packed to minimise data overhead. Block sizes\n-\t  greater than 4K are supported up to a maximum of 1 Mbytes (default\n-\t  block size 128K).  SquashFS 3.3 supports 64 bit filesystems and files\n-\t  (larger than 4GB), full uid/gid information, hard links and timestamps.\n-\n-\t  Squashfs is intended for general read-only filesystem use, for\n-\t  archival use (i.e. in cases where a .tar.gz file may be used), and in\n-\t  embedded systems where low overhead is needed.  Further information\n-\t  and filesystem tools are available from http://squashfs.sourceforge.net.\n-\n-\t  If you want to compile this as a module ( = code which can be\n-\t  inserted in and removed from the running kernel whenever you want),\n-\t  say M here and read <file:Documentation/modules.txt>.  The module\n-\t  will be called squashfs.  Note that the root file system (the one\n-\t  containing the directory /) cannot be compiled as a module.\n-\n-\t  If unsure, say N.\n-\n-config SQUASHFS_EMBEDDED\n-\n-\tbool "Additional option for memory-constrained systems"\n-\tdepends on SQUASHFS\n-\tdefault n\n-\thelp\n-\t  Saying Y here allows you to specify cache size.\n-\n-\t  If unsure, say N.\n-\n-config SQUASHFS_FRAGMENT_CACHE_SIZE\n-\tint "Number of fragments cached" if SQUASHFS_EMBEDDED\n-\tdepends on SQUASHFS\n-\tdefault "3"\n-\thelp\n-\t  By default SquashFS caches the last 3 fragments read from\n-\t  the filesystem.  Increasing this amount may mean SquashFS\n-\t  has to re-read fragments less often from disk, at the expense\n-\t  of extra system memory.  Decreasing this amount will mean\n-\t  SquashFS uses less memory at the expense of extra reads from disk.\n-\n-\t  Note there must be at least one cached fragment.  Anything\n-\t  much more than three will probably not make much difference.\n-\nconfig VXFS_FS\ntristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"\ndepends on BLOCK'),
 ('linux-2.6.23.orig/fs/squashfs/Makefile',
  'dev/null',
  'Index: linux-2.6.23/fs/squashfs/Makefile\n===================================================================\n--- linux-2.6.23.orig/fs/squashfs/Makefile\n+++ dev/null\n@@ -1,7 +0,0 @@\n-#\n-# Makefile for the linux squashfs routines.\n-#\n-\n-obj-$(CONFIG_SQUASHFS) += squashfs.o\n-squashfs-y += inode.o\n-squashfs-y += squashfs2_0.o'),
 ('linux-2.6.23.orig/fs/squashfs/inode.c',
  'dev/null',
  'Index: linux-2.6.23/fs/squashfs/inode.c\n===================================================================\n--- linux-2.6.23.orig/fs/squashfs/inode.c\n+++ dev/null\n@@ -1,2192 +0,0 @@\n-/*\n- * Squashfs - a compressed read only filesystem for Linux\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * inode.c\n- */\n-\n-#include <linux/squashfs_fs.h>\n-#include <linux/module.h>\n-#include <linux/zlib.h>\n-#include <linux/fs.h>\n-#include <linux/squashfs_fs_sb.h>\n-#include <linux/squashfs_fs_i.h>\n-#include <linux/buffer_head.h>\n-#include <linux/vfs.h>\n-#include <linux/vmalloc.h>\n-#include <linux/smp_lock.h>\n-#include <linux/exportfs.h>\n-\n-#include "squashfs.h"\n-\n-int squashfs_cached_blks;\n-\n-static void vfs_read_inode(struct inode *i);\n-static struct dentry *squashfs_get_parent(struct dentry *child);\n-static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode);\n-static int squashfs_statfs(struct dentry *, struct kstatfs *);\n-static int squashfs_symlink_readpage(struct file *file, struct page *page);\n-static long long read_blocklist(struct inode *inode, int index,\n-\t\t\t\tint readahead_blks, char *block_list,\n-\t\t\t\tunsigned short **block_p, unsigned int *bsize);\n-static int squashfs_readpage(struct file *file, struct page *page);\n-static int squashfs_readdir(struct file *, void *, filldir_t);\n-static struct dentry *squashfs_lookup(struct inode *, struct dentry *,\n-\t\t\t\tstruct nameidata *);\n-static int squashfs_remount(struct super_block *s, int *flags, char *data);\n-static void squashfs_put_super(struct super_block *);\n-static int squashfs_get_sb(struct file_system_type *,int, const char *, void *,\n-\t\t\t\tstruct vfsmount *);\n-static struct inode *squashfs_alloc_inode(struct super_block *sb);\n-static void squashfs_destroy_inode(struct inode *inode);\n-static int init_inodecache(void);\n-static void destroy_inodecache(void);\n-\n-static struct file_system_type squashfs_fs_type = {\n-\t.owner = THIS_MODULE,\n-\t.name = "squashfs",\n-\t.get_sb = squashfs_get_sb,\n-\t.kill_sb = kill_block_super,\n-\t.fs_flags = FS_REQUIRES_DEV\n-};\n-\n-static const unsigned char squashfs_filetype_table[] = {\n-\tDT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK\n-};\n-\n-static struct super_operations squashfs_super_ops = {\n-\t.alloc_inode = squashfs_alloc_inode,\n-\t.destroy_inode = squashfs_destroy_inode,\n-\t.statfs = squashfs_statfs,\n-\t.put_super = squashfs_put_super,\n-\t.remount_fs = squashfs_remount\n-};\n-\n-static struct super_operations squashfs_export_super_ops = {\n-\t.alloc_inode = squashfs_alloc_inode,\n-\t.destroy_inode = squashfs_destroy_inode,\n-\t.statfs = squashfs_statfs,\n-\t.put_super = squashfs_put_super,\n-\t.read_inode = vfs_read_inode\n-};\n-\n-static struct export_operations squashfs_export_ops = {\n-\t.get_parent = squashfs_get_parent\n-};\n-\n-SQSH_EXTERN const struct address_space_operations squashfs_symlink_aops = {\n-\t.readpage = squashfs_symlink_readpage\n-};\n-\n-SQSH_EXTERN const struct address_space_operations squashfs_aops = {\n-\t.readpage = squashfs_readpage\n-};\n-\n-static const struct file_operations squashfs_dir_ops = {\n-\t.read = generic_read_dir,\n-\t.readdir = squashfs_readdir\n-};\n-\n-SQSH_EXTERN struct inode_operations squashfs_dir_inode_ops = {\n-\t.lookup = squashfs_lookup\n-};\n-\n-\n-static struct buffer_head *get_block_length(struct super_block *s,\n-\t\t\t\tint *cur_index, int *offset, int *c_byte)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tunsigned short temp;\n-\tstruct buffer_head *bh;\n-\n-\tif (!(bh = sb_bread(s, *cur_index)))\n-\t\tgoto out;\n-\n-\tif (msblk->devblksize - *offset == 1) {\n-\t\tif (msblk->swap)\n-\t\t\t((unsigned char *) &temp)[1] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset));\n-\t\telse\n-\t\t\t((unsigned char *) &temp)[0] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset));\n-\t\tbrelse(bh);\n-\t\tif (!(bh = sb_bread(s, ++(*cur_index))))\n-\t\t\tgoto out;\n-\t\tif (msblk->swap)\n-\t\t\t((unsigned char *) &temp)[0] = *((unsigned char *)\n-\t\t\t\tbh->b_data);\n-\t\telse\n-\t\t\t((unsigned char *) &temp)[1] = *((unsigned char *)\n-\t\t\t\tbh->b_data);\n-\t\t*c_byte = temp;\n-\t\t*offset = 1;\n-\t} else {\n-\t\tif (msblk->swap) {\n-\t\t\t((unsigned char *) &temp)[1] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset));\n-\t\t\t((unsigned char *) &temp)[0] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset + 1));\n-\t\t} else {\n-\t\t\t((unsigned char *) &temp)[0] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset));\n-\t\t\t((unsigned char *) &temp)[1] = *((unsigned char *)\n-\t\t\t\t(bh->b_data + *offset + 1));\n-\t\t}\n-\t\t*c_byte = temp;\n-\t\t*offset += 2;\n-\t}\n-\n-\tif (SQUASHFS_CHECK_DATA(msblk->sblk.flags)) {\n-\t\tif (*offset == msblk->devblksize) {\n-\t\t\tbrelse(bh);\n-\t\t\tif (!(bh = sb_bread(s, ++(*cur_index))))\n-\t\t\t\tgoto out;\n-\t\t\t*offset = 0;\n-\t\t}\n-\t\tif (*((unsigned char *) (bh->b_data + *offset)) !=\n-\t\t\t\t\t\tSQUASHFS_MARKER_BYTE) {\n-\t\t\tERROR("Metadata block marker corrupt @ %x\\n",\n-\t\t\t\t\t\t*cur_index);\n-\t\t\tbrelse(bh);\n-\t\t\tgoto out;\n-\t\t}\n-\t\t(*offset)++;\n-\t}\n-\treturn bh;\n-\n-out:\n-\treturn NULL;\n-}\n-\n-\n-SQSH_EXTERN unsigned int squashfs_read_data(struct super_block *s, char *buffer,\n-\t\t\tlong long index, unsigned int length,\n-\t\t\tlong long *next_index, int srclength)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tstruct buffer_head **bh;\n-\tunsigned int offset = index & ((1 << msblk->devblksize_log2) - 1);\n-\tunsigned int cur_index = index >> msblk->devblksize_log2;\n-\tint bytes, avail_bytes, b = 0, k = 0;\n-\tunsigned int compressed;\n-\tunsigned int c_byte = length;\n-\n-\tbh = kmalloc(((sblk->block_size >> msblk->devblksize_log2) + 1) *\n-\t\t\t\t\t\t\t\tsizeof(struct buffer_head *), GFP_KERNEL);\n-\tif (bh == NULL)\n-\t\tgoto read_failure;\n-\n-\tif (c_byte) {\n-\t\tbytes = msblk->devblksize - offset;\n-\t\tcompressed = SQUASHFS_COMPRESSED_BLOCK(c_byte);\n-\t\tc_byte = SQUASHFS_COMPRESSED_SIZE_BLOCK(c_byte);\n-\n-\t\tTRACE("Block @ 0x%llx, %scompressed size %d, src size %d\\n", index,\n-\t\t\t\t\tcompressed ? "" : "un", (unsigned int) c_byte, srclength);\n-\n-\t\tif (c_byte > srclength || index < 0 || (index + c_byte) > sblk->bytes_used)\n-\t\t\tgoto read_failure;\n-\n-\t\tbh[0] = sb_getblk(s, cur_index);\n-\t\tif (bh[0] == NULL)\n-\t\t\tgoto block_release;\n-\n-\t\tfor (b = 1; bytes < c_byte; b++) {\n-\t\t\tbh[b] = sb_getblk(s, ++cur_index);\n-\t\t\tif (bh[b] == NULL)\n-\t\t\t\tgoto block_release;\n-\t\t\tbytes += msblk->devblksize;\n-\t\t}\n-\t\tll_rw_block(READ, b, bh);\n-\t} else {\n-\t\tif (index < 0 || (index + 2) > sblk->bytes_used)\n-\t\t\tgoto read_failure;\n-\n-\t\tbh[0] = get_block_length(s, &cur_index, &offset, &c_byte);\n-\t\tif (bh[0] == NULL)\n-\t\t\tgoto read_failure;\n-\n-\t\tbytes = msblk->devblksize - offset;\n-\t\tcompressed = SQUASHFS_COMPRESSED(c_byte);\n-\t\tc_byte = SQUASHFS_COMPRESSED_SIZE(c_byte);\n-\n-\t\tTRACE("Block @ 0x%llx, %scompressed size %d\\n", index, compressed\n-\t\t\t\t\t? "" : "un", (unsigned int) c_byte);\n-\n-\t\tif (c_byte > srclength || (index + c_byte) > sblk->bytes_used)\n-\t\t\tgoto read_failure;\n-\n-\t\tfor (b = 1; bytes < c_byte; b++) {\n-\t\t\tbh[b] = sb_getblk(s, ++cur_index);\n-\t\t\tif (bh[b] == NULL)\n-\t\t\t\tgoto block_release;\n-\t\t\tbytes += msblk->devblksize;\n-\t\t}\n-\t\tll_rw_block(READ, b - 1, bh + 1);\n-\t}\n-\n-\tif (compressed) {\n-\t\tint zlib_err = 0;\n-\n-\t\t/*\n-\t \t* uncompress block\n-\t \t*/\n-\n-\t\tmutex_lock(&msblk->read_data_mutex);\n-\n-\t\tmsblk->stream.next_out = buffer;\n-\t\tmsblk->stream.avail_out = srclength;\n-\n-\t\tfor (bytes = 0; k < b; k++) {\n-\t\t\tavail_bytes = min(c_byte - bytes, msblk->devblksize - offset);\n-\n-\t\t\twait_on_buffer(bh[k]);\n-\t\t\tif (!buffer_uptodate(bh[k]))\n-\t\t\t\tgoto release_mutex;\n-\n-\t\t\tmsblk->stream.next_in = bh[k]->b_data + offset;\n-\t\t\tmsblk->stream.avail_in = avail_bytes;\n-\n-\t\t\tif (k == 0) {\n-\t\t\t\tzlib_err = zlib_inflateInit(&msblk->stream);\n-\t\t\t\tif (zlib_err != Z_OK) {\n-\t\t\t\t\tERROR("zlib_inflateInit returned unexpected result 0x%x,"\n-\t\t\t\t\t\t" srclength %d\\n", zlib_err, srclength);\n-\t\t\t\t\tgoto release_mutex;\n-\t\t\t\t}\n-\n-\t\t\t\tif (avail_bytes == 0) {\n-\t\t\t\t\toffset = 0;\n-\t\t\t\t\tbrelse(bh[k]);\n-\t\t\t\t\tcontinue;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tzlib_err = zlib_inflate(&msblk->stream, Z_NO_FLUSH);\n-\t\t\tif (zlib_err != Z_OK && zlib_err != Z_STREAM_END) {\n-\t\t\t\tERROR("zlib_inflate returned unexpected result 0x%x,"\n-\t\t\t\t\t" srclength %d, avail_in %d, avail_out %d\\n", zlib_err,\n-\t\t\t\t\tsrclength, msblk->stream.avail_in, msblk->stream.avail_out);\n-\t\t\t\tgoto release_mutex;\n-\t\t\t}\n-\n-\t\t\tbytes += avail_bytes;\n-\t\t\toffset = 0;\n-\t\t\tbrelse(bh[k]);\n-\t\t}\n-\n-\t\tif (zlib_err != Z_STREAM_END)\n-\t\t\tgoto release_mutex;\n-\n-\t\tzlib_err = zlib_inflateEnd(&msblk->stream);\n-\t\tif (zlib_err != Z_OK) {\n-\t\t\tERROR("zlib_inflateEnd returned unexpected result 0x%x,"\n-\t\t\t\t" srclength %d\\n", zlib_err, srclength);\n-\t\t\tgoto release_mutex;\n-\t\t}\n-\t\tbytes = msblk->stream.total_out;\n-\t\tmutex_unlock(&msblk->read_data_mutex);\n-\t} else {\n-\t\tint i;\n-\n-\t\tfor(i = 0; i < b; i++) {\n-\t\t\twait_on_buffer(bh[i]);\n-\t\t\tif (!buffer_uptodate(bh[i]))\n-\t\t\t\tgoto block_release;\n-\t\t}\n-\n-\t\tfor (bytes = 0; k < b; k++) {\n-\t\t\tavail_bytes = min(c_byte - bytes, msblk->devblksize - offset);\n-\n-\t\t\tmemcpy(buffer + bytes, bh[k]->b_data + offset, avail_bytes);\n-\t\t\tbytes += avail_bytes;\n-\t\t\toffset = 0;\n-\t\t\tbrelse(bh[k]);\n-\t\t}\n-\t}\n-\n-\tif (next_index)\n-\t\t*next_index = index + c_byte + (length ? 0 :\n-\t\t\t\t(SQUASHFS_CHECK_DATA(msblk->sblk.flags) ? 3 : 2));\n-\n-\tkfree(bh);\n-\treturn bytes;\n-\n-release_mutex:\n-\tmutex_unlock(&msblk->read_data_mutex);\n-\n-block_release:\n-\tfor (; k < b; k++)\n-\t\tbrelse(bh[k]);\n-\n-read_failure:\n-\tERROR("sb_bread failed reading block 0x%x\\n", cur_index);\n-\tkfree(bh);\n-\treturn 0;\n-}\n-\n-\n-SQSH_EXTERN int squashfs_get_cached_block(struct super_block *s, void *buffer,\n-\t\t\t\tlong long block, unsigned int offset,\n-\t\t\t\tint length, long long *next_block,\n-\t\t\t\tunsigned int *next_offset)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tint n, i, bytes, return_length = length;\n-\tlong long next_index;\n-\n-\tTRACE("Entered squashfs_get_cached_block [%llx:%x]\\n", block, offset);\n-\n-\twhile (1) {\n-\t\tfor (i = 0; i < squashfs_cached_blks; i++)\n-\t\t\tif (msblk->block_cache[i].block == block)\n-\t\t\t\tbreak;\n-\n-\t\tmutex_lock(&msblk->block_cache_mutex);\n-\n-\t\tif (i == squashfs_cached_blks) {\n-\t\t\t/* read inode header block */\n-\t\t\tif (msblk->unused_cache_blks == 0) {\n-\t\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\t\twait_event(msblk->waitq, msblk->unused_cache_blks);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\ti = msblk->next_cache;\n-\t\t\tfor (n = 0; n < squashfs_cached_blks; n++) {\n-\t\t\t\tif (msblk->block_cache[i].block != SQUASHFS_USED_BLK)\n-\t\t\t\t\tbreak;\n-\t\t\t\ti = (i + 1) % squashfs_cached_blks;\n-\t\t\t}\n-\n-\t\t\tmsblk->next_cache = (i + 1) % squashfs_cached_blks;\n-\n-\t\t\tif (msblk->block_cache[i].block == SQUASHFS_INVALID_BLK) {\n-\t\t\t\tmsblk->block_cache[i].data = vmalloc(SQUASHFS_METADATA_SIZE);\n-\t\t\t\tif (msblk->block_cache[i].data == NULL) {\n-\t\t\t\t\tERROR("Failed to allocate cache block\\n");\n-\t\t\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\t\t\tgoto out;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tmsblk->block_cache[i].block = SQUASHFS_USED_BLK;\n-\t\t\tmsblk->unused_cache_blks --;\n-\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\n-\t\t\tmsblk->block_cache[i].length = squashfs_read_data(s,\n-\t\t\t\tmsblk->block_cache[i].data, block, 0, &next_index,\n-\t\t\t\tSQUASHFS_METADATA_SIZE);\n-\n-\t\t\tif (msblk->block_cache[i].length == 0) {\n-\t\t\t\tERROR("Unable to read cache block [%llx:%x]\\n", block, offset);\n-\t\t\t\tmutex_lock(&msblk->block_cache_mutex);\n-\t\t\t\tmsblk->block_cache[i].block = SQUASHFS_INVALID_BLK;\n-\t\t\t\tmsblk->unused_cache_blks ++;\n-\t\t\t\tsmp_mb();\n-\t\t\t\tvfree(msblk->block_cache[i].data);\n-\t\t\t\twake_up(&msblk->waitq);\n-\t\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\t\tgoto out;\n-\t\t\t}\n-\n-\t\t\tmutex_lock(&msblk->block_cache_mutex);\n-\t\t\tmsblk->block_cache[i].block = block;\n-\t\t\tmsblk->block_cache[i].next_index = next_index;\n-\t\t\tmsblk->unused_cache_blks ++;\n-\t\t\tsmp_mb();\n-\t\t\twake_up(&msblk->waitq);\n-\t\t\tTRACE("Read cache block [%llx:%x]\\n", block, offset);\n-\t\t}\n-\n-\t\tif (msblk->block_cache[i].block != block) {\n-\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\tcontinue;\n-\t\t}\n-\n-\t\tbytes = msblk->block_cache[i].length - offset;\n-\n-\t\tif (bytes < 1) {\n-\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\tgoto out;\n-\t\t} else if (bytes >= length) {\n-\t\t\tif (buffer)\n-\t\t\t\tmemcpy(buffer, msblk->block_cache[i].data + offset, length);\n-\t\t\tif (msblk->block_cache[i].length - offset == length) {\n-\t\t\t\t*next_block = msblk->block_cache[i].next_index;\n-\t\t\t\t*next_offset = 0;\n-\t\t\t} else {\n-\t\t\t\t*next_block = block;\n-\t\t\t\t*next_offset = offset + length;\n-\t\t\t}\n-\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\tgoto finish;\n-\t\t} else {\n-\t\t\tif (buffer) {\n-\t\t\t\tmemcpy(buffer, msblk->block_cache[i].data + offset, bytes);\n-\t\t\t\tbuffer = (char *) buffer + bytes;\n-\t\t\t}\n-\t\t\tblock = msblk->block_cache[i].next_index;\n-\t\t\tmutex_unlock(&msblk->block_cache_mutex);\n-\t\t\tlength -= bytes;\n-\t\t\toffset = 0;\n-\t\t}\n-\t}\n-\n-finish:\n-\treturn return_length;\n-out:\n-\treturn 0;\n-}\n-\n-\n-static int get_fragment_location(struct super_block *s, unsigned int fragment,\n-\t\t\t\tlong long *fragment_start_block,\n-\t\t\t\tunsigned int *fragment_size)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tlong long start_block =\n-\t\tmsblk->fragment_index[SQUASHFS_FRAGMENT_INDEX(fragment)];\n-\tint offset = SQUASHFS_FRAGMENT_INDEX_OFFSET(fragment);\n-\tstruct squashfs_fragment_entry fragment_entry;\n-\n-\tif (msblk->swap) {\n-\t\tstruct squashfs_fragment_entry sfragment_entry;\n-\n-\t\tif (!squashfs_get_cached_block(s, &sfragment_entry, start_block, offset,\n-\t\t\t\t\t sizeof(sfragment_entry), &start_block, &offset))\n-\t\t\tgoto out;\n-\t\tSQUASHFS_SWAP_FRAGMENT_ENTRY(&fragment_entry, &sfragment_entry);\n-\t} else\n-\t\tif (!squashfs_get_cached_block(s, &fragment_entry, start_block, offset,\n-\t\t\t\t\t sizeof(fragment_entry), &start_block, &offset))\n-\t\t\tgoto out;\n-\n-\t*fragment_start_block = fragment_entry.start_block;\n-\t*fragment_size = fragment_entry.size;\n-\n-\treturn 1;\n-\n-out:\n-\treturn 0;\n-}\n-\n-\n-SQSH_EXTERN void release_cached_fragment(struct squashfs_sb_info *msblk,\n-\t\t\t\tstruct squashfs_fragment_cache *fragment)\n-{\n-\tmutex_lock(&msblk->fragment_mutex);\n-\tfragment->locked --;\n-\tif (fragment->locked == 0) {\n-\t\tmsblk->unused_frag_blks ++;\n-\t\tsmp_mb();\n-\t\twake_up(&msblk->fragment_wait_queue);\n-\t}\n-\tmutex_unlock(&msblk->fragment_mutex);\n-}\n-\n-\n-SQSH_EXTERN\n-struct squashfs_fragment_cache *get_cached_fragment(struct super_block *s,\n-\t\t\t\tlong long start_block, int length)\n-{\n-\tint i, n;\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\twhile (1) {\n-\t\tmutex_lock(&msblk->fragment_mutex);\n-\n-\t\tfor (i = 0; i < SQUASHFS_CACHED_FRAGMENTS &&\n-\t\t\t\tmsblk->fragment[i].block != start_block; i++);\n-\n-\t\tif (i == SQUASHFS_CACHED_FRAGMENTS) {\n-\t\t\tif (msblk->unused_frag_blks == 0) {\n-\t\t\t\tmutex_unlock(&msblk->fragment_mutex);\n-\t\t\t\twait_event(msblk->fragment_wait_queue, msblk->unused_frag_blks);\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\n-\t\t\ti = msblk->next_fragment;\n-\t\t\tfor (n = 0; n < SQUASHFS_CACHED_FRAGMENTS; n++) {\n-\t\t\t\tif (msblk->fragment[i].locked == 0)\n-\t\t\t\t\tbreak;\n-\t\t\t\ti = (i + 1) % SQUASHFS_CACHED_FRAGMENTS;\n-\t\t\t}\n-\n-\t\t\tmsblk->next_fragment = (msblk->next_fragment + 1) %\n-\t\t\t\tSQUASHFS_CACHED_FRAGMENTS;\n-\n-\t\t\tif (msblk->fragment[i].data == NULL) {\n-\t\t\t\tmsblk->fragment[i].data = vmalloc(sblk->block_size);\n-\t\t\t\tif (msblk->fragment[i].data == NULL) {\n-\t\t\t\t\tERROR("Failed to allocate fragment cache block\\n");\n-\t\t\t\t\tmutex_unlock(&msblk->fragment_mutex);\n-\t\t\t\t\tgoto out;\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tmsblk->unused_frag_blks --;\n-\t\t\tmsblk->fragment[i].block = SQUASHFS_INVALID_BLK;\n-\t\t\tmsblk->fragment[i].locked = 1;\n-\t\t\tmutex_unlock(&msblk->fragment_mutex);\n-\n-\t\t\tmsblk->fragment[i].length = squashfs_read_data(s,\n-\t\t\t\tmsblk->fragment[i].data, start_block, length, NULL,\n-\t\t\t\tsblk->block_size);\n-\n-\t\t\tif (msblk->fragment[i].length == 0) {\n-\t\t\t\tERROR("Unable to read fragment cache block [%llx]\\n", start_block);\n-\t\t\t\tmsblk->fragment[i].locked = 0;\n-\t\t\t\tmsblk->unused_frag_blks ++;\n-\t\t\t\tsmp_mb();\n-\t\t\t\twake_up(&msblk->fragment_wait_queue);\n-\t\t\t\tgoto out;\n-\t\t\t}\n-\n-\t\t\tmutex_lock(&msblk->fragment_mutex);\n-\t\t\tmsblk->fragment[i].block = start_block;\n-\t\t\tTRACE("New fragment %d, start block %lld, locked %d\\n",\n-\t\t\t\ti, msblk->fragment[i].block, msblk->fragment[i].locked);\n-\t\t\tmutex_unlock(&msblk->fragment_mutex);\n-\t\t\tbreak;\n-\t\t}\n-\n-\t\tif (msblk->fragment[i].locked == 0)\n-\t\t\tmsblk->unused_frag_blks --;\n-\t\tmsblk->fragment[i].locked++;\n-\t\tmutex_unlock(&msblk->fragment_mutex);\n-\t\tTRACE("Got fragment %d, start block %lld, locked %d\\n", i,\n-\t\t\tmsblk->fragment[i].block, msblk->fragment[i].locked);\n-\t\tbreak;\n-\t}\n-\n-\treturn &msblk->fragment[i];\n-\n-out:\n-\treturn NULL;\n-}\n-\n-\n-static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,\n-\t\t\t\tstruct squashfs_base_inode_header *inodeb)\n-{\n-\ti->i_ino = inodeb->inode_number;\n-\ti->i_mtime.tv_sec = inodeb->mtime;\n-\ti->i_atime.tv_sec = inodeb->mtime;\n-\ti->i_ctime.tv_sec = inodeb->mtime;\n-\ti->i_uid = msblk->uid[inodeb->uid];\n-\ti->i_mode = inodeb->mode;\n-\ti->i_size = 0;\n-\n-\tif (inodeb->guid == SQUASHFS_GUIDS)\n-\t\ti->i_gid = i->i_uid;\n-\telse\n-\t\ti->i_gid = msblk->guid[inodeb->guid];\n-}\n-\n-\n-static squashfs_inode_t squashfs_inode_lookup(struct super_block *s, int ino)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tlong long start = msblk->inode_lookup_table[SQUASHFS_LOOKUP_BLOCK(ino - 1)];\n-\tint offset = SQUASHFS_LOOKUP_BLOCK_OFFSET(ino - 1);\n-\tsquashfs_inode_t inode;\n-\n-\tTRACE("Entered squashfs_inode_lookup, inode_number = %d\\n", ino);\n-\n-\tif (msblk->swap) {\n-\t\tsquashfs_inode_t sinode;\n-\n-\t\tif (!squashfs_get_cached_block(s, &sinode, start, offset,\n-\t\t\t\t\tsizeof(sinode), &start, &offset))\n-\t\t\tgoto out;\n-\t\tSQUASHFS_SWAP_INODE_T((&inode), &sinode);\n-\t} else if (!squashfs_get_cached_block(s, &inode, start, offset,\n-\t\t\t\t\tsizeof(inode), &start, &offset))\n-\t\t\tgoto out;\n-\n-\tTRACE("squashfs_inode_lookup, inode = 0x%llx\\n", inode);\n-\n-\treturn inode;\n-\n-out:\n-\treturn SQUASHFS_INVALID_BLK;\n-}\n-\n-\n-static void vfs_read_inode(struct inode *i)\n-{\n-\tstruct squashfs_sb_info *msblk = i->i_sb->s_fs_info;\n-\tsquashfs_inode_t inode = squashfs_inode_lookup(i->i_sb, i->i_ino);\n-\n-\tTRACE("Entered vfs_read_inode\\n");\n-\n-\tif(inode != SQUASHFS_INVALID_BLK)\n-\t\t(msblk->read_inode)(i, inode);\n-}\n-\n-\n-static struct dentry *squashfs_get_parent(struct dentry *child)\n-{\n-\tstruct inode *i = child->d_inode;\n-\tstruct inode *parent = iget(i->i_sb, SQUASHFS_I(i)->u.s2.parent_inode);\n-\tstruct dentry *rv;\n-\n-\tTRACE("Entered squashfs_get_parent\\n");\n-\n-\tif(parent == NULL) {\n-\t\trv = ERR_PTR(-EACCES);\n-\t\tgoto out;\n-\t}\n-\n-\trv = d_alloc_anon(parent);\n-\tif(rv == NULL)\n-\t\trv = ERR_PTR(-ENOMEM);\n-\n-out:\n-\treturn rv;\n-}\n-\n-\n-SQSH_EXTERN struct inode *squashfs_iget(struct super_block *s,\n-\t\t\t\tsquashfs_inode_t inode, unsigned int inode_number)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct inode *i = iget_locked(s, inode_number);\n-\n-\tTRACE("Entered squashfs_iget\\n");\n-\n-\tif(i && (i->i_state & I_NEW)) {\n-\t\t(msblk->read_inode)(i, inode);\n-\t\tunlock_new_inode(i);\n-\t}\n-\n-\treturn i;\n-}\n-\n-\n-static int squashfs_read_inode(struct inode *i, squashfs_inode_t inode)\n-{\n-\tstruct super_block *s = i->i_sb;\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tlong long block = SQUASHFS_INODE_BLK(inode) + sblk->inode_table_start;\n-\tunsigned int offset = SQUASHFS_INODE_OFFSET(inode);\n-\tlong long next_block;\n-\tunsigned int next_offset;\n-\tunion squashfs_inode_header id, sid;\n-\tstruct squashfs_base_inode_header *inodeb = &id.base, *sinodeb = &sid.base;\n-\n-\tTRACE("Entered squashfs_read_inode\\n");\n-\n-\tif (msblk->swap) {\n-\t\tif (!squashfs_get_cached_block(s, sinodeb, block, offset,\n-\t\t\t\t\tsizeof(*sinodeb), &next_block, &next_offset))\n-\t\t\tgoto failed_read;\n-\t\tSQUASHFS_SWAP_BASE_INODE_HEADER(inodeb, sinodeb, sizeof(*sinodeb));\n-\t} else\n-\t\tif (!squashfs_get_cached_block(s, inodeb, block, offset,\n-\t\t\t\t\tsizeof(*inodeb), &next_block, &next_offset))\n-\t\t\tgoto failed_read;\n-\n-\tsquashfs_new_inode(msblk, i, inodeb);\n-\n-\tswitch(inodeb->inode_type) {\n-\t\tcase SQUASHFS_FILE_TYPE: {\n-\t\t\tunsigned int frag_size;\n-\t\t\tlong long frag_blk;\n-\t\t\tstruct squashfs_reg_inode_header *inodep = &id.reg;\n-\t\t\tstruct squashfs_reg_inode_header *sinodep = &sid.reg;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_REG_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n-\n-\t\t\tif (inodep->fragment != SQUASHFS_INVALID_FRAG)\n-\t\t\t\t\tif(!get_fragment_location(s, inodep->fragment, &frag_blk,\n-\t\t\t\t\t\t\t\t\t\t\t\t&frag_size))\n-\t\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = 1;\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_fop = &generic_ro_fops;\n-\t\t\ti->i_mode |= S_IFREG;\n-\t\t\ti->i_blocks = ((i->i_size - 1) >> 9) + 1;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_size = frag_size;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->u.s1.block_list_start = next_block;\n-\t\t\tSQUASHFS_I(i)->offset = next_offset;\n-\t\t\ti->i_data.a_ops = &squashfs_aops;\n-\n-\t\t\tTRACE("File inode %x:%x, start_block %llx, "\n-\t\t\t\t\t"block_list_start %llx, offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->start_block, next_block,\n-\t\t\t\t\tnext_offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_LREG_TYPE: {\n-\t\t\tunsigned int frag_size;\n-\t\t\tlong long frag_blk;\n-\t\t\tstruct squashfs_lreg_inode_header *inodep = &id.lreg;\n-\t\t\tstruct squashfs_lreg_inode_header *sinodep = &sid.lreg;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_LREG_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n-\n-\t\t\tif (inodep->fragment != SQUASHFS_INVALID_FRAG)\n-\t\t\t\tif (!get_fragment_location(s, inodep->fragment, &frag_blk,\n-\t\t\t\t\t\t\t\t\t\t\t\t &frag_size))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_fop = &generic_ro_fops;\n-\t\t\ti->i_mode |= S_IFREG;\n-\t\t\ti->i_blocks = ((i->i_size - 1) >> 9) + 1;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_size = frag_size;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->u.s1.block_list_start = next_block;\n-\t\t\tSQUASHFS_I(i)->offset = next_offset;\n-\t\t\ti->i_data.a_ops = &squashfs_aops;\n-\n-\t\t\tTRACE("File inode %x:%x, start_block %llx, "\n-\t\t\t\t\t"block_list_start %llx, offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->start_block, next_block,\n-\t\t\t\t\tnext_offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_DIR_TYPE: {\n-\t\t\tstruct squashfs_dir_inode_header *inodep = &id.dir;\n-\t\t\tstruct squashfs_dir_inode_header *sinodep = &sid.dir;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_DIR_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_op = &squashfs_dir_inode_ops;\n-\t\t\ti->i_fop = &squashfs_dir_ops;\n-\t\t\ti->i_mode |= S_IFDIR;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count = 0;\n-\t\t\tSQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;\n-\n-\t\t\tTRACE("Directory inode %x:%x, start_block %x, offset "\n-\t\t\t\t\t"%x\\n", SQUASHFS_INODE_BLK(inode),\n-\t\t\t\t\toffset, inodep->start_block,\n-\t\t\t\t\tinodep->offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_LDIR_TYPE: {\n-\t\t\tstruct squashfs_ldir_inode_header *inodep = &id.ldir;\n-\t\t\tstruct squashfs_ldir_inode_header *sinodep = &sid.ldir;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_LDIR_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_op = &squashfs_dir_inode_ops;\n-\t\t\ti->i_fop = &squashfs_dir_ops;\n-\t\t\ti->i_mode |= S_IFDIR;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start = next_block;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset = next_offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count = inodep->i_count;\n-\t\t\tSQUASHFS_I(i)->u.s2.parent_inode = inodep->parent_inode;\n-\n-\t\t\tTRACE("Long directory inode %x:%x, start_block %x, offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->start_block, inodep->offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_SYMLINK_TYPE: {\n-\t\t\tstruct squashfs_symlink_inode_header *inodep = &id.symlink;\n-\t\t\tstruct squashfs_symlink_inode_header *sinodep = &sid.symlink;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_SYMLINK_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_size = inodep->symlink_size;\n-\t\t\ti->i_op = &page_symlink_inode_operations;\n-\t\t\ti->i_data.a_ops = &squashfs_symlink_aops;\n-\t\t\ti->i_mode |= S_IFLNK;\n-\t\t\tSQUASHFS_I(i)->start_block = next_block;\n-\t\t\tSQUASHFS_I(i)->offset = next_offset;\n-\n-\t\t\tTRACE("Symbolic link inode %x:%x, start_block %llx, offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tnext_block, next_offset);\n-\t\t\tbreak;\n-\t\t }\n-\t\t case SQUASHFS_BLKDEV_TYPE:\n-\t\t case SQUASHFS_CHRDEV_TYPE: {\n-\t\t\tstruct squashfs_dev_inode_header *inodep = &id.dev;\n-\t\t\tstruct squashfs_dev_inode_header *sinodep = &sid.dev;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_DEV_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_mode |= (inodeb->inode_type == SQUASHFS_CHRDEV_TYPE) ?\n-\t\t\t\t\tS_IFCHR : S_IFBLK;\n-\t\t\tinit_special_inode(i, i->i_mode, old_decode_dev(inodep->rdev));\n-\n-\t\t\tTRACE("Device inode %x:%x, rdev %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset, inodep->rdev);\n-\t\t\tbreak;\n-\t\t }\n-\t\t case SQUASHFS_FIFO_TYPE:\n-\t\t case SQUASHFS_SOCKET_TYPE: {\n-\t\t\tstruct squashfs_ipc_inode_header *inodep = &id.ipc;\n-\t\t\tstruct squashfs_ipc_inode_header *sinodep = &sid.ipc;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, sinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_IPC_INODE_HEADER(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, inodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_nlink = inodep->nlink;\n-\t\t\ti->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)\n-\t\t\t\t\t\t\t? S_IFIFO : S_IFSOCK;\n-\t\t\tinit_special_inode(i, i->i_mode, 0);\n-\t\t\tbreak;\n-\t\t }\n-\t\t default:\n-\t\t\tERROR("Unknown inode type %d in squashfs_iget!\\n",\n-\t\t\t\t\tinodeb->inode_type);\n-\t\t\tgoto failed_read1;\n-\t}\n-\n-\treturn 1;\n-\n-failed_read:\n-\tERROR("Unable to read inode [%llx:%x]\\n", block, offset);\n-\n-failed_read1:\n-\tmake_bad_inode(i);\n-\treturn 0;\n-}\n-\n-\n-static int read_inode_lookup_table(struct super_block *s)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tunsigned int length = SQUASHFS_LOOKUP_BLOCK_BYTES(sblk->inodes);\n-\n-\tTRACE("In read_inode_lookup_table, length %d\\n", length);\n-\n-\t/* Allocate inode lookup table */\n-\tmsblk->inode_lookup_table = kmalloc(length, GFP_KERNEL);\n-\tif (msblk->inode_lookup_table == NULL) {\n-\t\tERROR("Failed to allocate inode lookup table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (!squashfs_read_data(s, (char *) msblk->inode_lookup_table,\n-\t\t\tsblk->lookup_table_start, length |\n-\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {\n-\t\tERROR("unable to read inode lookup table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (msblk->swap) {\n-\t\tint i;\n-\t\tlong long block;\n-\n-\t\tfor (i = 0; i < SQUASHFS_LOOKUP_BLOCKS(sblk->inodes); i++) {\n-\t\t\t/* XXX */\n-\t\t\tSQUASHFS_SWAP_LOOKUP_BLOCKS((&block),\n-\t\t\t\t\t\t&msblk->inode_lookup_table[i], 1);\n-\t\t\tmsblk->inode_lookup_table[i] = block;\n-\t\t}\n-\t}\n-\n-\treturn 1;\n-}\n-\n-\n-static int read_fragment_index_table(struct super_block *s)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tunsigned int length = SQUASHFS_FRAGMENT_INDEX_BYTES(sblk->fragments);\n-\n-\tif(length == 0)\n-\t\treturn 1;\n-\n-\t/* Allocate fragment index table */\n-\tmsblk->fragment_index = kmalloc(length, GFP_KERNEL);\n-\tif (msblk->fragment_index == NULL) {\n-\t\tERROR("Failed to allocate fragment index table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (!squashfs_read_data(s, (char *) msblk->fragment_index,\n-\t\t\tsblk->fragment_table_start, length |\n-\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, length)) {\n-\t\tERROR("unable to read fragment index table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (msblk->swap) {\n-\t\tint i;\n-\t\tlong long fragment;\n-\n-\t\tfor (i = 0; i < SQUASHFS_FRAGMENT_INDEXES(sblk->fragments); i++) {\n-\t\t\t/* XXX */\n-\t\t\tSQUASHFS_SWAP_FRAGMENT_INDEXES((&fragment),\n-\t\t\t\t\t\t&msblk->fragment_index[i], 1);\n-\t\t\tmsblk->fragment_index[i] = fragment;\n-\t\t}\n-\t}\n-\n-\treturn 1;\n-}\n-\n-\n-static int readahead_metadata(struct super_block *s)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tint i;\n-\n-\tsquashfs_cached_blks = SQUASHFS_CACHED_BLKS;\n-\n-\t/* Init inode_table block pointer array */\n-\tmsblk->block_cache = kmalloc(sizeof(struct squashfs_cache) *\n-\t\t\t\t\tsquashfs_cached_blks, GFP_KERNEL);\n-\tif (msblk->block_cache == NULL) {\n-\t\tERROR("Failed to allocate block cache\\n");\n-\t\tgoto failed;\n-\t}\n-\n-\tfor (i = 0; i < squashfs_cached_blks; i++)\n-\t\tmsblk->block_cache[i].block = SQUASHFS_INVALID_BLK;\n-\n-\tmsblk->next_cache = 0;\n-\tmsblk->unused_cache_blks = squashfs_cached_blks;\n-\n-\treturn 1;\n-\n-failed:\n-\treturn 0;\n-}\n-\n-\n-static int supported_squashfs_filesystem(struct squashfs_sb_info *msblk, int silent)\n-{\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\tmsblk->read_inode = squashfs_read_inode;\n-\tmsblk->read_blocklist = read_blocklist;\n-\tmsblk->read_fragment_index_table = read_fragment_index_table;\n-\n-\tif (sblk->s_major == 1) {\n-\t\tif (!squashfs_1_0_supported(msblk)) {\n-\t\t\tSERROR("Major/Minor mismatch, Squashfs 1.0 filesystems "\n-\t\t\t\t"are unsupported\\n");\n-\t\t\tSERROR("Please recompile with Squashfs 1.0 support enabled\\n");\n-\t\t\treturn 0;\n-\t\t}\n-\t} else if (sblk->s_major == 2) {\n-\t\tif (!squashfs_2_0_supported(msblk)) {\n-\t\t\tSERROR("Major/Minor mismatch, Squashfs 2.0 filesystems "\n-\t\t\t\t"are unsupported\\n");\n-\t\t\tSERROR("Please recompile with Squashfs 2.0 support enabled\\n");\n-\t\t\treturn 0;\n-\t\t}\n-\t} else if(sblk->s_major != SQUASHFS_MAJOR || sblk->s_minor >\n-\t\t\tSQUASHFS_MINOR) {\n-\t\tSERROR("Major/Minor mismatch, trying to mount newer %d.%d "\n-\t\t\t\t"filesystem\\n", sblk->s_major, sblk->s_minor);\n-\t\tSERROR("Please update your kernel\\n");\n-\t\treturn 0;\n-\t}\n-\n-\treturn 1;\n-}\n-\n-\n-static int squashfs_fill_super(struct super_block *s, void *data, int silent)\n-{\n-\tstruct squashfs_sb_info *msblk;\n-\tstruct squashfs_super_block *sblk;\n-\tint i;\n-\tchar b[BDEVNAME_SIZE];\n-\tstruct inode *root;\n-\n-\tTRACE("Entered squashfs_fill_superblock\\n");\n-\n-\ts->s_fs_info = kzalloc(sizeof(struct squashfs_sb_info), GFP_KERNEL);\n-\tif (s->s_fs_info == NULL) {\n-\t\tERROR("Failed to allocate superblock\\n");\n-\t\tgoto failure;\n-\t}\n-\tmsblk = s->s_fs_info;\n-\n-\tmsblk->stream.workspace = vmalloc(zlib_inflate_workspacesize());\n-\tif (msblk->stream.workspace == NULL) {\n-\t\tERROR("Failed to allocate zlib workspace\\n");\n-\t\tgoto failure;\n-\t}\n-\tsblk = &msblk->sblk;\n-\n-\tmsblk->devblksize = sb_min_blocksize(s, BLOCK_SIZE);\n-\tmsblk->devblksize_log2 = ffz(~msblk->devblksize);\n-\n-\tmutex_init(&msblk->read_data_mutex);\n-\tmutex_init(&msblk->read_page_mutex);\n-\tmutex_init(&msblk->block_cache_mutex);\n-\tmutex_init(&msblk->fragment_mutex);\n-\tmutex_init(&msblk->meta_index_mutex);\n-\n-\tinit_waitqueue_head(&msblk->waitq);\n-\tinit_waitqueue_head(&msblk->fragment_wait_queue);\n-\n-\t/* sblk->bytes_used is checked in squashfs_read_data to ensure reads are not\n- \t * beyond filesystem end.  As we\'re using squashfs_read_data to read sblk here,\n- \t * first set sblk->bytes_used to a useful value */\n-\tsblk->bytes_used = sizeof(struct squashfs_super_block);\n-\tif (!squashfs_read_data(s, (char *) sblk, SQUASHFS_START,\n-\t\t\t\t\tsizeof(struct squashfs_super_block) |\n-\t\t\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, sizeof(struct squashfs_super_block))) {\n-\t\tSERROR("unable to read superblock\\n");\n-\t\tgoto failed_mount;\n-\t}\n-\n-\t/* Check it is a SQUASHFS superblock */\n-\tif ((s->s_magic = sblk->s_magic) != SQUASHFS_MAGIC) {\n-\t\tif (sblk->s_magic == SQUASHFS_MAGIC_SWAP) {\n-\t\t\tstruct squashfs_super_block ssblk;\n-\n-\t\t\tWARNING("Mounting a different endian SQUASHFS filesystem on %s\\n",\n-\t\t\t\tbdevname(s->s_bdev, b));\n-\n-\t\t\tSQUASHFS_SWAP_SUPER_BLOCK(&ssblk, sblk);\n-\t\t\tmemcpy(sblk, &ssblk, sizeof(struct squashfs_super_block));\n-\t\t\tmsblk->swap = 1;\n-\t\t} else  {\n-\t\t\tSERROR("Can\'t find a SQUASHFS superblock on %s\\n",\n-\t\t\t\t\t\t\tbdevname(s->s_bdev, b));\n-\t\t\tgoto failed_mount;\n-\t\t}\n-\t}\n-\n-\t/* Check the MAJOR & MINOR versions */\n-\tif(!supported_squashfs_filesystem(msblk, silent))\n-\t\tgoto failed_mount;\n-\n-\t/* Check the filesystem does not extend beyond the end of the\n-\t   block device */\n-\tif(sblk->bytes_used < 0 || sblk->bytes_used > i_size_read(s->s_bdev->bd_inode))\n-\t\tgoto failed_mount;\n-\n-\t/* Check the root inode for sanity */\n-\tif (SQUASHFS_INODE_OFFSET(sblk->root_inode) > SQUASHFS_METADATA_SIZE)\n-\t\tgoto failed_mount;\n-\n-\tTRACE("Found valid superblock on %s\\n", bdevname(s->s_bdev, b));\n-\tTRACE("Inodes are %scompressed\\n", SQUASHFS_UNCOMPRESSED_INODES(sblk->flags)\n-\t\t\t\t\t? "un" : "");\n-\tTRACE("Data is %scompressed\\n", SQUASHFS_UNCOMPRESSED_DATA(sblk->flags)\n-\t\t\t\t\t? "un" : "");\n-\tTRACE("Check data is %spresent in the filesystem\\n",\n-\t\t\t\t\tSQUASHFS_CHECK_DATA(sblk->flags) ?  "" : "not ");\n-\tTRACE("Filesystem size %lld bytes\\n", sblk->bytes_used);\n-\tTRACE("Block size %d\\n", sblk->block_size);\n-\tTRACE("Number of inodes %d\\n", sblk->inodes);\n-\tif (sblk->s_major > 1)\n-\t\tTRACE("Number of fragments %d\\n", sblk->fragments);\n-\tTRACE("Number of uids %d\\n", sblk->no_uids);\n-\tTRACE("Number of gids %d\\n", sblk->no_guids);\n-\tTRACE("sblk->inode_table_start %llx\\n", sblk->inode_table_start);\n-\tTRACE("sblk->directory_table_start %llx\\n", sblk->directory_table_start);\n-\tif (sblk->s_major > 1)\n-\t\tTRACE("sblk->fragment_table_start %llx\\n", sblk->fragment_table_start);\n-\tTRACE("sblk->uid_start %llx\\n", sblk->uid_start);\n-\n-\ts->s_maxbytes = MAX_LFS_FILESIZE;\n-\ts->s_flags |= MS_RDONLY;\n-\ts->s_op = &squashfs_super_ops;\n-\n-\tif (readahead_metadata(s) == 0)\n-\t\tgoto failed_mount;\n-\n-\t/* Allocate read_page block */\n-\tmsblk->read_page = vmalloc(sblk->block_size);\n-\tif (msblk->read_page == NULL) {\n-\t\tERROR("Failed to allocate read_page block\\n");\n-\t\tgoto failed_mount;\n-\t}\n-\n-\t/* Allocate uid and gid tables */\n-\tmsblk->uid = kmalloc((sblk->no_uids + sblk->no_guids) *\n-\t\t\t\t\tsizeof(unsigned int), GFP_KERNEL);\n-\tif (msblk->uid == NULL) {\n-\t\tERROR("Failed to allocate uid/gid table\\n");\n-\t\tgoto failed_mount;\n-\t}\n-\tmsblk->guid = msblk->uid + sblk->no_uids;\n-\n-\tif (msblk->swap) {\n-\t\tunsigned int suid[sblk->no_uids + sblk->no_guids];\n-\n-\t\tif (!squashfs_read_data(s, (char *) &suid, sblk->uid_start,\n-\t\t\t\t\t((sblk->no_uids + sblk->no_guids) *\n-\t\t\t\t\t sizeof(unsigned int)) |\n-\t\t\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {\n-\t\t\tERROR("unable to read uid/gid table\\n");\n-\t\t\tgoto failed_mount;\n-\t\t}\n-\n-\t\tSQUASHFS_SWAP_DATA(msblk->uid, suid, (sblk->no_uids +\n-\t\t\tsblk->no_guids), (sizeof(unsigned int) * 8));\n-\t} else\n-\t\tif (!squashfs_read_data(s, (char *) msblk->uid, sblk->uid_start,\n-\t\t\t\t\t((sblk->no_uids + sblk->no_guids) *\n-\t\t\t\t\t sizeof(unsigned int)) |\n-\t\t\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, (sblk->no_uids + sblk->no_guids) * sizeof(unsigned int))) {\n-\t\t\tERROR("unable to read uid/gid table\\n");\n-\t\t\tgoto failed_mount;\n-\t\t}\n-\n-\n-\tif (sblk->s_major == 1 && squashfs_1_0_supported(msblk))\n-\t\tgoto allocate_root;\n-\n-\tmsblk->fragment = kzalloc(sizeof(struct squashfs_fragment_cache) *\n-\t\t\t\tSQUASHFS_CACHED_FRAGMENTS, GFP_KERNEL);\n-\tif (msblk->fragment == NULL) {\n-\t\tERROR("Failed to allocate fragment block cache\\n");\n-\t\tgoto failed_mount;\n-\t}\n-\n-\tfor (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++) {\n-\t\tmsblk->fragment[i].block = SQUASHFS_INVALID_BLK;\n-\t}\n-\n-\tmsblk->next_fragment = 0;\n-\tmsblk->unused_frag_blks = SQUASHFS_CACHED_FRAGMENTS;\n-\n-\t/* Allocate and read fragment index table */\n-\tif (msblk->read_fragment_index_table(s) == 0)\n-\t\tgoto failed_mount;\n-\n-\tif(sblk->s_major < 3 || sblk->lookup_table_start == SQUASHFS_INVALID_BLK)\n-\t\tgoto allocate_root;\n-\n-\t/* Allocate and read inode lookup table */\n-\tif (read_inode_lookup_table(s) == 0)\n-\t\tgoto failed_mount;\n-\n-\ts->s_op = &squashfs_export_super_ops;\n-\ts->s_export_op = &squashfs_export_ops;\n-\n-allocate_root:\n-\troot = new_inode(s);\n-\tif ((msblk->read_inode)(root, sblk->root_inode) == 0)\n-\t\tgoto failed_mount;\n-\tinsert_inode_hash(root);\n-\n-\ts->s_root = d_alloc_root(root);\n-\tif (s->s_root == NULL) {\n-\t\tERROR("Root inode create failed\\n");\n-\t\tiput(root);\n-\t\tgoto failed_mount;\n-\t}\n-\n-\tTRACE("Leaving squashfs_fill_super\\n");\n-\treturn 0;\n-\n-failed_mount:\n-\tkfree(msblk->inode_lookup_table);\n-\tkfree(msblk->fragment_index);\n-\tkfree(msblk->fragment);\n-\tkfree(msblk->uid);\n-\tvfree(msblk->read_page);\n-\tkfree(msblk->block_cache);\n-\tkfree(msblk->fragment_index_2);\n-\tvfree(msblk->stream.workspace);\n-\tkfree(s->s_fs_info);\n-\ts->s_fs_info = NULL;\n-\treturn -EINVAL;\n-\n-failure:\n-\treturn -ENOMEM;\n-}\n-\n-\n-static int squashfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n-{\n-\tstruct squashfs_sb_info *msblk = dentry->d_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\tTRACE("Entered squashfs_statfs\\n");\n-\n-\tbuf->f_type = SQUASHFS_MAGIC;\n-\tbuf->f_bsize = sblk->block_size;\n-\tbuf->f_blocks = ((sblk->bytes_used - 1) >> sblk->block_log) + 1;\n-\tbuf->f_bfree = buf->f_bavail = 0;\n-\tbuf->f_files = sblk->inodes;\n-\tbuf->f_ffree = 0;\n-\tbuf->f_namelen = SQUASHFS_NAME_LEN;\n-\n-\treturn 0;\n-}\n-\n-\n-static int squashfs_symlink_readpage(struct file *file, struct page *page)\n-{\n-\tstruct inode *inode = page->mapping->host;\n-\tint index = page->index << PAGE_CACHE_SHIFT, length, bytes, avail_bytes;\n-\tlong long block = SQUASHFS_I(inode)->start_block;\n-\tint offset = SQUASHFS_I(inode)->offset;\n-\tvoid *pageaddr = kmap(page);\n-\n-\tTRACE("Entered squashfs_symlink_readpage, page index %ld, start block "\n-\t\t\t\t"%llx, offset %x\\n", page->index,\n-\t\t\t\tSQUASHFS_I(inode)->start_block,\n-\t\t\t\tSQUASHFS_I(inode)->offset);\n-\n-\tfor (length = 0; length < index; length += bytes) {\n-\t\tbytes = squashfs_get_cached_block(inode->i_sb, NULL, block,\n-\t\t\t\toffset, PAGE_CACHE_SIZE, &block, &offset);\n-\t\tif (bytes == 0) {\n-\t\t\tERROR("Unable to read symbolic link [%llx:%x]\\n", block, offset);\n-\t\t\tgoto skip_read;\n-\t\t}\n-\t}\n-\n-\tif (length != index) {\n-\t\tERROR("(squashfs_symlink_readpage) length != index\\n");\n-\t\tbytes = 0;\n-\t\tgoto skip_read;\n-\t}\n-\n-\tavail_bytes = min_t(int, i_size_read(inode) - length, PAGE_CACHE_SIZE);\n-\n-\tbytes = squashfs_get_cached_block(inode->i_sb, pageaddr, block, offset,\n-\t\tavail_bytes, &block, &offset);\n-\tif (bytes == 0)\n-\t\tERROR("Unable to read symbolic link [%llx:%x]\\n", block, offset);\n-\n-skip_read:\n-\tmemset(pageaddr + bytes, 0, PAGE_CACHE_SIZE - bytes);\n-\tkunmap(page);\n-\tflush_dcache_page(page);\n-\tSetPageUptodate(page);\n-\tunlock_page(page);\n-\n-\treturn 0;\n-}\n-\n-\n-struct meta_index *locate_meta_index(struct inode *inode, int index, int offset)\n-{\n-\tstruct meta_index *meta = NULL;\n-\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n-\tint i;\n-\n-\tmutex_lock(&msblk->meta_index_mutex);\n-\n-\tTRACE("locate_meta_index: index %d, offset %d\\n", index, offset);\n-\n-\tif (msblk->meta_index == NULL)\n-\t\tgoto not_allocated;\n-\n-\tfor (i = 0; i < SQUASHFS_META_NUMBER; i ++) {\n-\t\tif (msblk->meta_index[i].inode_number == inode->i_ino &&\n-\t\t\t\tmsblk->meta_index[i].offset >= offset &&\n-\t\t\t\tmsblk->meta_index[i].offset <= index &&\n-\t\t\t\tmsblk->meta_index[i].locked == 0) {\n-\t\t\tTRACE("locate_meta_index: entry %d, offset %d\\n", i,\n-\t\t\t\t\tmsblk->meta_index[i].offset);\n-\t\t\tmeta = &msblk->meta_index[i];\n-\t\t\toffset = meta->offset;\n-\t\t}\n-\t}\n-\n-\tif (meta)\n-\t\tmeta->locked = 1;\n-\n-not_allocated:\n-\tmutex_unlock(&msblk->meta_index_mutex);\n-\n-\treturn meta;\n-}\n-\n-\n-struct meta_index *empty_meta_index(struct inode *inode, int offset, int skip)\n-{\n-\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n-\tstruct meta_index *meta = NULL;\n-\tint i;\n-\n-\tmutex_lock(&msblk->meta_index_mutex);\n-\n-\tTRACE("empty_meta_index: offset %d, skip %d\\n", offset, skip);\n-\n-\tif (msblk->meta_index == NULL) {\n-\t\tmsblk->meta_index = kmalloc(sizeof(struct meta_index) *\n-\t\t\t\t\tSQUASHFS_META_NUMBER, GFP_KERNEL);\n-\t\tif (msblk->meta_index == NULL) {\n-\t\t\tERROR("Failed to allocate meta_index\\n");\n-\t\t\tgoto failed;\n-\t\t}\n-\t\tfor (i = 0; i < SQUASHFS_META_NUMBER; i++) {\n-\t\t\tmsblk->meta_index[i].inode_number = 0;\n-\t\t\tmsblk->meta_index[i].locked = 0;\n-\t\t}\n-\t\tmsblk->next_meta_index = 0;\n-\t}\n-\n-\tfor (i = SQUASHFS_META_NUMBER; i &&\n-\t\t\tmsblk->meta_index[msblk->next_meta_index].locked; i --)\n-\t\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n-\t\t\tSQUASHFS_META_NUMBER;\n-\n-\tif (i == 0) {\n-\t\tTRACE("empty_meta_index: failed!\\n");\n-\t\tgoto failed;\n-\t}\n-\n-\tTRACE("empty_meta_index: returned meta entry %d, %p\\n",\n-\t\t\tmsblk->next_meta_index,\n-\t\t\t&msblk->meta_index[msblk->next_meta_index]);\n-\n-\tmeta = &msblk->meta_index[msblk->next_meta_index];\n-\tmsblk->next_meta_index = (msblk->next_meta_index + 1) %\n-\t\t\tSQUASHFS_META_NUMBER;\n-\n-\tmeta->inode_number = inode->i_ino;\n-\tmeta->offset = offset;\n-\tmeta->skip = skip;\n-\tmeta->entries = 0;\n-\tmeta->locked = 1;\n-\n-failed:\n-\tmutex_unlock(&msblk->meta_index_mutex);\n-\treturn meta;\n-}\n-\n-\n-void release_meta_index(struct inode *inode, struct meta_index *meta)\n-{\n-\tmeta->locked = 0;\n-\tsmp_mb();\n-}\n-\n-\n-static int read_block_index(struct super_block *s, int blocks, char *block_list,\n-\t\t\t\tlong long *start_block, int *offset)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tunsigned int *block_listp;\n-\tint block = 0;\n-\n-\tif (msblk->swap) {\n-\t\tchar sblock_list[blocks << 2];\n-\n-\t\tif (!squashfs_get_cached_block(s, sblock_list, *start_block,\n-\t\t\t\t*offset, blocks << 2, start_block, offset)) {\n-\t\t\tERROR("Fail reading block list [%llx:%x]\\n", *start_block, *offset);\n-\t\t\tgoto failure;\n-\t\t}\n-\t\tSQUASHFS_SWAP_INTS(((unsigned int *)block_list),\n-\t\t\t\t((unsigned int *)sblock_list), blocks);\n-\t} else {\n-\t\tif (!squashfs_get_cached_block(s, block_list, *start_block,\n-\t\t\t\t*offset, blocks << 2, start_block, offset)) {\n-\t\t\tERROR("Fail reading block list [%llx:%x]\\n", *start_block, *offset);\n-\t\t\tgoto failure;\n-\t\t}\n-\t}\n-\n-\tfor (block_listp = (unsigned int *) block_list; blocks;\n-\t\t\t\tblock_listp++, blocks --)\n-\t\tblock += SQUASHFS_COMPRESSED_SIZE_BLOCK(*block_listp);\n-\n-\treturn block;\n-\n-failure:\n-\treturn -1;\n-}\n-\n-\n-#define SIZE 256\n-\n-static inline int calculate_skip(int blocks) {\n-\tint skip = (blocks - 1) / ((SQUASHFS_SLOTS * SQUASHFS_META_ENTRIES + 1) * SQUASHFS_META_INDEXES);\n-\treturn skip >= 7 ? 7 : skip + 1;\n-}\n-\n-\n-static int get_meta_index(struct inode *inode, int index,\n-\t\tlong long *index_block, int *index_offset,\n-\t\tlong long *data_block, char *block_list)\n-{\n-\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tint skip = calculate_skip(i_size_read(inode) >> sblk->block_log);\n-\tint offset = 0;\n-\tstruct meta_index *meta;\n-\tstruct meta_entry *meta_entry;\n-\tlong long cur_index_block = SQUASHFS_I(inode)->u.s1.block_list_start;\n-\tint cur_offset = SQUASHFS_I(inode)->offset;\n-\tlong long cur_data_block = SQUASHFS_I(inode)->start_block;\n-\tint i;\n-\n-\tindex /= SQUASHFS_META_INDEXES * skip;\n-\n-\twhile (offset < index) {\n-\t\tmeta = locate_meta_index(inode, index, offset + 1);\n-\n-\t\tif (meta == NULL) {\n-\t\t\tmeta = empty_meta_index(inode, offset + 1, skip);\n-\t\t\tif (meta == NULL)\n-\t\t\t\tgoto all_done;\n-\t\t} else {\n-\t\t\tif(meta->entries == 0)\n-\t\t\t\tgoto failed;\n-\t\t\t/* XXX */\n-\t\t\toffset = index < meta->offset + meta->entries ? index :\n-\t\t\t\tmeta->offset + meta->entries - 1;\n-\t\t\t/* XXX */\n-\t\t\tmeta_entry = &meta->meta_entry[offset - meta->offset];\n-\t\t\tcur_index_block = meta_entry->index_block + sblk->inode_table_start;\n-\t\t\tcur_offset = meta_entry->offset;\n-\t\t\tcur_data_block = meta_entry->data_block;\n-\t\t\tTRACE("get_meta_index: offset %d, meta->offset %d, "\n-\t\t\t\t"meta->entries %d\\n", offset, meta->offset, meta->entries);\n-\t\t\tTRACE("get_meta_index: index_block 0x%llx, offset 0x%x"\n-\t\t\t\t" data_block 0x%llx\\n", cur_index_block,\n-\t\t\t\tcur_offset, cur_data_block);\n-\t\t}\n-\n-\t\tfor (i = meta->offset + meta->entries; i <= index &&\n-\t\t\t\ti < meta->offset + SQUASHFS_META_ENTRIES; i++) {\n-\t\t\tint blocks = skip * SQUASHFS_META_INDEXES;\n-\n-\t\t\twhile (blocks) {\n-\t\t\t\tint block = blocks > (SIZE >> 2) ? (SIZE >> 2) : blocks;\n-\t\t\t\tint res = read_block_index(inode->i_sb, block, block_list,\n-\t\t\t\t\t&cur_index_block, &cur_offset);\n-\n-\t\t\t\tif (res == -1)\n-\t\t\t\t\tgoto failed;\n-\n-\t\t\t\tcur_data_block += res;\n-\t\t\t\tblocks -= block;\n-\t\t\t}\n-\n-\t\t\tmeta_entry = &meta->meta_entry[i - meta->offset];\n-\t\t\tmeta_entry->index_block = cur_index_block - sblk->inode_table_start;\n-\t\t\tmeta_entry->offset = cur_offset;\n-\t\t\tmeta_entry->data_block = cur_data_block;\n-\t\t\tmeta->entries ++;\n-\t\t\toffset ++;\n-\t\t}\n-\n-\t\tTRACE("get_meta_index: meta->offset %d, meta->entries %d\\n",\n-\t\t\t\tmeta->offset, meta->entries);\n-\n-\t\trelease_meta_index(inode, meta);\n-\t}\n-\n-all_done:\n-\t*index_block = cur_index_block;\n-\t*index_offset = cur_offset;\n-\t*data_block = cur_data_block;\n-\n-\treturn offset * SQUASHFS_META_INDEXES * skip;\n-\n-failed:\n-\trelease_meta_index(inode, meta);\n-\treturn -1;\n-}\n-\n-\n-static long long read_blocklist(struct inode *inode, int index,\n-\t\t\t\tint readahead_blks, char *block_list,\n-\t\t\t\tunsigned short **block_p, unsigned int *bsize)\n-{\n-\tlong long block_ptr;\n-\tint offset;\n-\tlong long block;\n-\tint res = get_meta_index(inode, index, &block_ptr, &offset, &block,\n-\t\tblock_list);\n-\n-\tTRACE("read_blocklist: res %d, index %d, block_ptr 0x%llx, offset"\n-\t\t       " 0x%x, block 0x%llx\\n", res, index, block_ptr, offset, block);\n-\n-\tif(res == -1)\n-\t\tgoto failure;\n-\n-\tindex -= res;\n-\n-\twhile (index) {\n-\t\tint blocks = index > (SIZE >> 2) ? (SIZE >> 2) : index;\n-\t\tint res = read_block_index(inode->i_sb, blocks, block_list,\n-\t\t\t&block_ptr, &offset);\n-\t\tif (res == -1)\n-\t\t\tgoto failure;\n-\t\tblock += res;\n-\t\tindex -= blocks;\n-\t}\n-\n-\tif (read_block_index(inode->i_sb, 1, block_list, &block_ptr, &offset) == -1)\n-\t\tgoto failure;\n-\t*bsize = *((unsigned int *) block_list);\n-\n-\treturn block;\n-\n-failure:\n-\treturn 0;\n-}\n-\n-\n-static int squashfs_readpage(struct file *file, struct page *page)\n-{\n-\tstruct inode *inode = page->mapping->host;\n-\tstruct squashfs_sb_info *msblk = inode->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tunsigned char *block_list = NULL;\n-\tlong long block;\n-\tunsigned int bsize, i;\n-\tint bytes;\n-\tint index = page->index >> (sblk->block_log - PAGE_CACHE_SHIFT);\n- \tvoid *pageaddr;\n-\tstruct squashfs_fragment_cache *fragment = NULL;\n-\tchar *data_ptr = msblk->read_page;\n-\n-\tint mask = (1 << (sblk->block_log - PAGE_CACHE_SHIFT)) - 1;\n-\tint start_index = page->index & ~mask;\n-\tint end_index = start_index | mask;\n-\tint file_end = i_size_read(inode) >> sblk->block_log;\n-\tint sparse = 0;\n-\n-\tTRACE("Entered squashfs_readpage, page index %lx, start block %llx\\n",\n-\t\t\t\t\tpage->index, SQUASHFS_I(inode)->start_block);\n-\n-\tif (page->index >= ((i_size_read(inode) + PAGE_CACHE_SIZE - 1) >>\n-\t\t\t\t\tPAGE_CACHE_SHIFT))\n-\t\tgoto out;\n-\n-\tif (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK\n-\t\t\t\t\t|| index < file_end) {\n-\t\tblock_list = kmalloc(SIZE, GFP_KERNEL);\n-\t\tif (block_list == NULL) {\n-\t\t\tERROR("Failed to allocate block_list\\n");\n-\t\t\tgoto error_out;\n-\t\t}\n-\n-\t\tblock = (msblk->read_blocklist)(inode, index, 1, block_list, NULL, &bsize);\n-\t\tif (block == 0)\n-\t\t\tgoto error_out;\n-\n-\t\tif (bsize == 0) { /* hole */\n-\t\t\tbytes = index == file_end ?\n-\t\t\t\t(i_size_read(inode) & (sblk->block_size - 1)) : sblk->block_size;\n-\t\t\tsparse = 1;\n-\t\t} else {\n-\t\t\tmutex_lock(&msblk->read_page_mutex);\n-\n-\t\t\tbytes = squashfs_read_data(inode->i_sb, msblk->read_page, block,\n-\t\t\t\tbsize, NULL, sblk->block_size);\n-\n-\t\t\tif (bytes == 0) {\n-\t\t\t\tERROR("Unable to read page, block %llx, size %x\\n", block, bsize);\n-\t\t\t\tmutex_unlock(&msblk->read_page_mutex);\n-\t\t\t\tgoto error_out;\n-\t\t\t}\n-\t\t}\n-\t} else {\n-\t\tfragment = get_cached_fragment(inode->i_sb,\n-\t\t\t\t\tSQUASHFS_I(inode)-> u.s1.fragment_start_block,\n-\t\t\t\t\tSQUASHFS_I(inode)->u.s1.fragment_size);\n-\n-\t\tif (fragment == NULL) {\n-\t\t\tERROR("Unable to read page, block %llx, size %x\\n",\n-\t\t\t\t\tSQUASHFS_I(inode)->u.s1.fragment_start_block,\n-\t\t\t\t\t(int) SQUASHFS_I(inode)->u.s1.fragment_size);\n-\t\t\tgoto error_out;\n-\t\t}\n-\t\tbytes = i_size_read(inode) & (sblk->block_size - 1);\n-\t\tdata_ptr = fragment->data + SQUASHFS_I(inode)->u.s1.fragment_offset;\n-\t}\n-\n-\tfor (i = start_index; i <= end_index && bytes > 0; i++,\n-\t\t\t\t\t\tbytes -= PAGE_CACHE_SIZE, data_ptr += PAGE_CACHE_SIZE) {\n-\t\tstruct page *push_page;\n-\t\tint avail = sparse ? 0 : min_t(unsigned int, bytes, PAGE_CACHE_SIZE);\n-\n-\t\tTRACE("bytes %d, i %d, available_bytes %d\\n", bytes, i, avail);\n-\n-\t\tpush_page = (i == page->index) ? page :\n-\t\t\tgrab_cache_page_nowait(page->mapping, i);\n-\n-\t\tif (!push_page)\n-\t\t\tcontinue;\n-\n-\t\tif (PageUptodate(push_page))\n-\t\t\tgoto skip_page;\n-\n- \t\tpageaddr = kmap_atomic(push_page, KM_USER0);\n-\t\tmemcpy(pageaddr, data_ptr, avail);\n-\t\tmemset(pageaddr + avail, 0, PAGE_CACHE_SIZE - avail);\n-\t\tkunmap_atomic(pageaddr, KM_USER0);\n-\t\tflush_dcache_page(push_page);\n-\t\tSetPageUptodate(push_page);\n-skip_page:\n-\t\tunlock_page(push_page);\n-\t\tif(i != page->index)\n-\t\t\tpage_cache_release(push_page);\n-\t}\n-\n-\tif (SQUASHFS_I(inode)->u.s1.fragment_start_block == SQUASHFS_INVALID_BLK\n-\t\t\t\t\t|| index < file_end) {\n-\t\tif (!sparse)\n-\t\t\tmutex_unlock(&msblk->read_page_mutex);\n-\t\tkfree(block_list);\n-\t} else\n-\t\trelease_cached_fragment(msblk, fragment);\n-\n-\treturn 0;\n-\n-error_out:\n-\tSetPageError(page);\n-out:\n-\tpageaddr = kmap_atomic(page, KM_USER0);\n-\tmemset(pageaddr, 0, PAGE_CACHE_SIZE);\n-\tkunmap_atomic(pageaddr, KM_USER0);\n-\tflush_dcache_page(page);\n-\tif (!PageError(page))\n-\t\tSetPageUptodate(page);\n-\tunlock_page(page);\n-\n-\tkfree(block_list);\n-\treturn 0;\n-}\n-\n-\n-static int get_dir_index_using_offset(struct super_block *s,\n-\t\t\t\tlong long *next_block, unsigned int *next_offset,\n-\t\t\t\tlong long index_start, unsigned int index_offset, int i_count,\n-\t\t\t\tlong long f_pos)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tint i, length = 0;\n-\tstruct squashfs_dir_index index;\n-\n-\tTRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\\n",\n-\t\t\t\t\ti_count, (unsigned int) f_pos);\n-\n-\tf_pos =- 3;\n-\tif (f_pos == 0)\n-\t\tgoto finish;\n-\n-\tfor (i = 0; i < i_count; i++) {\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_index sindex;\n-\t\t\tsquashfs_get_cached_block(s, &sindex, index_start, index_offset,\n-\t\t\t\t\tsizeof(sindex), &index_start, &index_offset);\n-\t\t\tSQUASHFS_SWAP_DIR_INDEX(&index, &sindex);\n-\t\t} else\n-\t\t\tsquashfs_get_cached_block(s, &index, index_start, index_offset,\n-\t\t\t\t\tsizeof(index), &index_start, &index_offset);\n-\n-\t\tif (index.index > f_pos)\n-\t\t\tbreak;\n-\n-\t\tsquashfs_get_cached_block(s, NULL, index_start, index_offset,\n-\t\t\t\t\tindex.size + 1, &index_start, &index_offset);\n-\n-\t\tlength = index.index;\n-\t\t*next_block = index.start_block + sblk->directory_table_start;\n-\t}\n-\n-\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n-\n-finish:\n-\treturn length + 3;\n-}\n-\n-\n-static int get_dir_index_using_name(struct super_block *s,\n-\t\t\t\tlong long *next_block, unsigned int *next_offset,\n-\t\t\t\tlong long index_start, unsigned int index_offset, int i_count,\n-\t\t\t\tconst char *name, int size)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tint i, length = 0;\n-\tstruct squashfs_dir_index *index;\n-\tchar *str;\n-\n-\tTRACE("Entered get_dir_index_using_name, i_count %d\\n", i_count);\n-\n-\tstr = kmalloc(sizeof(struct squashfs_dir_index) +\n-\t\t(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL);\n-\tif (str == NULL) {\n-\t\tERROR("Failed to allocate squashfs_dir_index\\n");\n-\t\tgoto failure;\n-\t}\n-\n-\tindex = (struct squashfs_dir_index *) (str + SQUASHFS_NAME_LEN + 1);\n-\tstrncpy(str, name, size);\n-\tstr[size] = \'\\0\';\n-\n-\tfor (i = 0; i < i_count; i++) {\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_index sindex;\n-\t\t\tsquashfs_get_cached_block(s, &sindex, index_start, index_offset,\n-\t\t\t\tsizeof(sindex), &index_start, &index_offset);\n-\t\t\tSQUASHFS_SWAP_DIR_INDEX(index, &sindex);\n-\t\t} else\n-\t\t\tsquashfs_get_cached_block(s, index, index_start, index_offset,\n-\t\t\t\tsizeof(struct squashfs_dir_index), &index_start, &index_offset);\n-\n-\t\tsquashfs_get_cached_block(s, index->name, index_start, index_offset,\n-\t\t\t\t\tindex->size + 1, &index_start, &index_offset);\n-\n-\t\tindex->name[index->size + 1] = \'\\0\';\n-\n-\t\tif (strcmp(index->name, str) > 0)\n-\t\t\tbreak;\n-\n-\t\tlength = index->index;\n-\t\t*next_block = index->start_block + sblk->directory_table_start;\n-\t}\n-\n-\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n-\tkfree(str);\n-\n-failure:\n-\treturn length + 3;\n-}\n-\n-\n-static int squashfs_readdir(struct file *file, void *dirent, filldir_t filldir)\n-{\n-\tstruct inode *i = file->f_dentry->d_inode;\n-\tstruct squashfs_sb_info *msblk = i->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tlong long next_block = SQUASHFS_I(i)->start_block +\n-\t\tsblk->directory_table_start;\n-\tint next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;\n-\tstruct squashfs_dir_header dirh;\n-\tstruct squashfs_dir_entry *dire;\n-\n-\tTRACE("Entered squashfs_readdir [%llx:%x]\\n", next_block, next_offset);\n-\n-\tdire = kmalloc(sizeof(struct squashfs_dir_entry) +\n-\t\tSQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n-\tif (dire == NULL) {\n-\t\tERROR("Failed to allocate squashfs_dir_entry\\n");\n-\t\tgoto finish;\n-\t}\n-\n-\twhile(file->f_pos < 3) {\n-\t\tchar *name;\n-\t\tint size, i_ino;\n-\n-\t\tif(file->f_pos == 0) {\n-\t\t\tname = ".";\n-\t\t\tsize = 1;\n-\t\t\ti_ino = i->i_ino;\n-\t\t} else {\n-\t\t\tname = "..";\n-\t\t\tsize = 2;\n-\t\t\ti_ino = SQUASHFS_I(i)->u.s2.parent_inode;\n-\t\t}\n-\t\tTRACE("Calling filldir(%x, %s, %d, %d, %d, %d)\\n",\n-\t\t\t\t(unsigned int) dirent, name, size, (int)\n-\t\t\t\tfile->f_pos, i_ino, squashfs_filetype_table[1]);\n-\n-\t\tif (filldir(dirent, name, size, file->f_pos, i_ino,\n-\t\t\t\tsquashfs_filetype_table[1]) < 0) {\n-\t\t\t\tTRACE("Filldir returned less than 0\\n");\n-\t\t\tgoto finish;\n-\t\t}\n-\t\tfile->f_pos += size;\n-\t}\n-\n-\tlength = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count, file->f_pos);\n-\n-\twhile (length < i_size_read(i)) {\n-\t\t/* read directory header */\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_header sdirh;\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,\n-\t\t\t\t\t next_offset, sizeof(sdirh), &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(sdirh);\n-\t\t\tSQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);\n-\t\t} else {\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,\n-\t\t\t\t\tnext_offset, sizeof(dirh), &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(dirh);\n-\t\t}\n-\n-\t\tdir_count = dirh.count + 1;\n-\t\twhile (dir_count--) {\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tstruct squashfs_dir_entry sdire;\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,\n-\t\t\t\t\t\tnext_offset, sizeof(sdire), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(sdire);\n-\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);\n-\t\t\t} else {\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire, next_block,\n-\t\t\t\t\t\tnext_offset, sizeof(*dire), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(*dire);\n-\t\t\t}\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,\n-\t\t\t\t\t\tnext_offset, dire->size + 1, &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += dire->size + 1;\n-\n-\t\t\tif (file->f_pos >= length)\n-\t\t\t\tcontinue;\n-\n-\t\t\tdire->name[dire->size + 1] = \'\\0\';\n-\n-\t\t\tTRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d, %d)\\n",\n-\t\t\t\t\t(unsigned int) dirent, dire->name, dire->size + 1,\n-\t\t\t\t\t(int) file->f_pos, dirh.start_block, dire->offset,\n-\t\t\t\t\tdirh.inode_number + dire->inode_number,\n-\t\t\t\t\tsquashfs_filetype_table[dire->type]);\n-\n-\t\t\tif (filldir(dirent, dire->name, dire->size + 1, file->f_pos,\n-\t\t\t\t\tdirh.inode_number + dire->inode_number,\n-\t\t\t\t\tsquashfs_filetype_table[dire->type]) < 0) {\n-\t\t\t\tTRACE("Filldir returned less than 0\\n");\n-\t\t\t\tgoto finish;\n-\t\t\t}\n-\t\t\tfile->f_pos = length;\n-\t\t}\n-\t}\n-\n-finish:\n-\tkfree(dire);\n-\treturn 0;\n-\n-failed_read:\n-\tERROR("Unable to read directory block [%llx:%x]\\n", next_block,\n-\t\tnext_offset);\n-\tkfree(dire);\n-\treturn 0;\n-}\n-\n-\n-static struct dentry *squashfs_lookup(struct inode *i, struct dentry *dentry,\n-\t\t\t\tstruct nameidata *nd)\n-{\n-\tconst unsigned char *name = dentry->d_name.name;\n-\tint len = dentry->d_name.len;\n-\tstruct inode *inode = NULL;\n-\tstruct squashfs_sb_info *msblk = i->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tlong long next_block = SQUASHFS_I(i)->start_block +\n-\t\t\t\tsblk->directory_table_start;\n-\tint next_offset = SQUASHFS_I(i)->offset, length = 0, dir_count;\n-\tstruct squashfs_dir_header dirh;\n-\tstruct squashfs_dir_entry *dire;\n-\n-\tTRACE("Entered squashfs_lookup [%llx:%x]\\n", next_block, next_offset);\n-\n-\tdire = kmalloc(sizeof(struct squashfs_dir_entry) +\n-\t\tSQUASHFS_NAME_LEN + 1, GFP_KERNEL);\n-\tif (dire == NULL) {\n-\t\tERROR("Failed to allocate squashfs_dir_entry\\n");\n-\t\tgoto exit_lookup;\n-\t}\n-\n-\tif (len > SQUASHFS_NAME_LEN)\n-\t\tgoto exit_lookup;\n-\n-\tlength = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count, name, len);\n-\n-\twhile (length < i_size_read(i)) {\n-\t\t/* read directory header */\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_header sdirh;\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, &sdirh, next_block,\n-\t\t\t\t\t next_offset, sizeof(sdirh), &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(sdirh);\n-\t\t\tSQUASHFS_SWAP_DIR_HEADER(&dirh, &sdirh);\n-\t\t} else {\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, &dirh, next_block,\n-\t\t\t\t\tnext_offset, sizeof(dirh), &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(dirh);\n-\t\t}\n-\n-\t\tdir_count = dirh.count + 1;\n-\t\twhile (dir_count--) {\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tstruct squashfs_dir_entry sdire;\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, &sdire, next_block,\n-\t\t\t\t\t\tnext_offset, sizeof(sdire), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(sdire);\n-\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY(dire, &sdire);\n-\t\t\t} else {\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire, next_block,\n-\t\t\t\t\t\tnext_offset, sizeof(*dire), &next_block, &next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(*dire);\n-\t\t\t}\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire->name, next_block,\n-\t\t\t\t\tnext_offset, dire->size + 1, &next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += dire->size + 1;\n-\n-\t\t\tif (name[0] < dire->name[0])\n-\t\t\t\tgoto exit_lookup;\n-\n-\t\t\tif ((len == dire->size + 1) && !strncmp(name, dire->name, len)) {\n-\t\t\t\tsquashfs_inode_t ino = SQUASHFS_MKINODE(dirh.start_block,\n-\t\t\t\t\t\t\t\tdire->offset);\n-\n-\t\t\t\tTRACE("calling squashfs_iget for directory entry %s, inode"\n-\t\t\t\t\t"  %x:%x, %d\\n", name, dirh.start_block, dire->offset,\n-\t\t\t\t\tdirh.inode_number + dire->inode_number);\n-\n-\t\t\t\tinode = squashfs_iget(i->i_sb, ino, dirh.inode_number + dire->inode_number);\n-\n-\t\t\t\tgoto exit_lookup;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-exit_lookup:\n-\tkfree(dire);\n-\tif (inode)\n-\t\treturn d_splice_alias(inode, dentry);\n-\td_add(dentry, inode);\n-\treturn ERR_PTR(0);\n-\n-failed_read:\n-\tERROR("Unable to read directory block [%llx:%x]\\n", next_block,\n-\t\tnext_offset);\n-\tgoto exit_lookup;\n-}\n-\n-\n-static int squashfs_remount(struct super_block *s, int *flags, char *data)\n-{\n-\t*flags |= MS_RDONLY;\n-\treturn 0;\n-}\n-\n-\n-static void squashfs_put_super(struct super_block *s)\n-{\n-\tint i;\n-\n-\tif (s->s_fs_info) {\n-\t\tstruct squashfs_sb_info *sbi = s->s_fs_info;\n-\t\tif (sbi->block_cache)\n-\t\t\tfor (i = 0; i < squashfs_cached_blks; i++)\n-\t\t\t\tif (sbi->block_cache[i].block != SQUASHFS_INVALID_BLK)\n-\t\t\t\t\tvfree(sbi->block_cache[i].data);\n-\t\tif (sbi->fragment)\n-\t\t\tfor (i = 0; i < SQUASHFS_CACHED_FRAGMENTS; i++)\n-\t\t\t\tvfree(sbi->fragment[i].data);\n-\t\tkfree(sbi->fragment);\n-\t\tkfree(sbi->block_cache);\n-\t\tvfree(sbi->read_page);\n-\t\tkfree(sbi->uid);\n-\t\tkfree(sbi->fragment_index);\n-\t\tkfree(sbi->fragment_index_2);\n-\t\tkfree(sbi->meta_index);\n-\t\tvfree(sbi->stream.workspace);\n-\t\tkfree(s->s_fs_info);\n-\t\ts->s_fs_info = NULL;\n-\t}\n-}\n-\n-\n-static int squashfs_get_sb(struct file_system_type *fs_type, int flags,\n-\t\t\t\tconst char *dev_name, void *data, struct vfsmount *mnt)\n-{\n-\treturn get_sb_bdev(fs_type, flags, dev_name, data, squashfs_fill_super,\n-\t\t\t\tmnt);\n-}\n-\n-\n-static int __init init_squashfs_fs(void)\n-{\n-\tint err = init_inodecache();\n-\tif (err)\n-\t\tgoto out;\n-\n-\tprintk(KERN_INFO "squashfs: version 3.3 (2007/10/31) "\n-\t\t"Phillip Lougher\\n");\n-\n-\terr = register_filesystem(&squashfs_fs_type);\n-\tif (err)\n-\t\tdestroy_inodecache();\n-\n-out:\n-\treturn err;\n-}\n-\n-\n-static void __exit exit_squashfs_fs(void)\n-{\n-\tunregister_filesystem(&squashfs_fs_type);\n-\tdestroy_inodecache();\n-}\n-\n-\n-static struct kmem_cache * squashfs_inode_cachep;\n-\n-\n-static struct inode *squashfs_alloc_inode(struct super_block *sb)\n-{\n-\tstruct squashfs_inode_info *ei;\n-\tei = kmem_cache_alloc(squashfs_inode_cachep, GFP_KERNEL);\n-\treturn ei ? &ei->vfs_inode : NULL;\n-}\n-\n-\n-static void squashfs_destroy_inode(struct inode *inode)\n-{\n-\tkmem_cache_free(squashfs_inode_cachep, SQUASHFS_I(inode));\n-}\n-\n-\n-static void init_once(void * foo, struct kmem_cache * cachep, unsigned long flags)\n-{\n-\tstruct squashfs_inode_info *ei = foo;\n-\n-\tinode_init_once(&ei->vfs_inode);\n-}\n-\n-\n-static int __init init_inodecache(void)\n-{\n-\tsquashfs_inode_cachep = kmem_cache_create("squashfs_inode_cache",\n-\t    sizeof(struct squashfs_inode_info), 0,\n-\t\tSLAB_HWCACHE_ALIGN|SLAB_RECLAIM_ACCOUNT, init_once);\n-\tif (squashfs_inode_cachep == NULL)\n-\t\treturn -ENOMEM;\n-\treturn 0;\n-}\n-\n-\n-static void destroy_inodecache(void)\n-{\n-\tkmem_cache_destroy(squashfs_inode_cachep);\n-}\n-\n-\n-module_init(init_squashfs_fs);\n-module_exit(exit_squashfs_fs);\n-MODULE_DESCRIPTION("squashfs 3.2-r2-CVS, a compressed read-only filesystem");\n-MODULE_AUTHOR("Phillip Lougher <phillip@lougher.demon.co.uk>");\n-MODULE_LICENSE("GPL");'),
 ('linux-2.6.23.orig/fs/squashfs/squashfs.h',
  'dev/null',
  'Index: linux-2.6.23/fs/squashfs/squashfs.h\n===================================================================\n--- linux-2.6.23.orig/fs/squashfs/squashfs.h\n+++ dev/null\n@@ -1,86 +0,0 @@\n-/*\n- * Squashfs - a compressed read only filesystem for Linux\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * squashfs.h\n- */\n-\n-#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY\n-#undef CONFIG_SQUASHFS_1_0_COMPATIBILITY\n-#endif\n-\n-#ifdef SQUASHFS_TRACE\n-#define TRACE(s, args...)\tprintk(KERN_NOTICE "SQUASHFS: "s, ## args)\n-#else\n-#define TRACE(s, args...)\t{}\n-#endif\n-\n-#define ERROR(s, args...)\tprintk(KERN_ERR "SQUASHFS error: "s, ## args)\n-\n-#define SERROR(s, args...)\tdo { \\\n-\t\t\t\tif (!silent) \\\n-\t\t\t\tprintk(KERN_ERR "SQUASHFS error: "s, ## args);\\\n-\t\t\t\t} while(0)\n-\n-#define WARNING(s, args...)\tprintk(KERN_WARNING "SQUASHFS: "s, ## args)\n-\n-static inline struct squashfs_inode_info *SQUASHFS_I(struct inode *inode)\n-{\n-\treturn list_entry(inode, struct squashfs_inode_info, vfs_inode);\n-}\n-\n-#if defined(CONFIG_SQUASHFS_1_0_COMPATIBILITY ) || defined(CONFIG_SQUASHFS_2_0_COMPATIBILITY)\n-#define SQSH_EXTERN\n-extern unsigned int squashfs_read_data(struct super_block *s, char *buffer,\n-\t\t\t\tlong long index, unsigned int length,\n-\t\t\t\tlong long *next_index, int srclength);\n-extern int squashfs_get_cached_block(struct super_block *s, void *buffer,\n-\t\t\t\tlong long block, unsigned int offset,\n-\t\t\t\tint length, long long *next_block,\n-\t\t\t\tunsigned int *next_offset);\n-extern void release_cached_fragment(struct squashfs_sb_info *msblk, struct\n-\t\t\t\t\tsquashfs_fragment_cache *fragment);\n-extern struct squashfs_fragment_cache *get_cached_fragment(struct super_block\n-\t\t\t\t\t*s, long long start_block,\n-\t\t\t\t\tint length);\n-extern struct inode *squashfs_iget(struct super_block *s, squashfs_inode_t inode, unsigned int inode_number);\n-extern const struct address_space_operations squashfs_symlink_aops;\n-extern const struct address_space_operations squashfs_aops;\n-extern struct inode_operations squashfs_dir_inode_ops;\n-#else\n-#define SQSH_EXTERN static\n-#endif\n-\n-#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY\n-extern int squashfs_1_0_supported(struct squashfs_sb_info *msblk);\n-#else\n-static inline int squashfs_1_0_supported(struct squashfs_sb_info *msblk)\n-{\n-\treturn 0;\n-}\n-#endif\n-\n-#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY\n-extern int squashfs_2_0_supported(struct squashfs_sb_info *msblk);\n-#else\n-static inline int squashfs_2_0_supported(struct squashfs_sb_info *msblk)\n-{\n-\treturn 0;\n-}\n-#endif'),
 ('linux-2.6.23.orig/fs/squashfs/squashfs2_0.c',
  'dev/null',
  'Index: linux-2.6.23/fs/squashfs/squashfs2_0.c\n===================================================================\n--- linux-2.6.23.orig/fs/squashfs/squashfs2_0.c\n+++ dev/null\n@@ -1,740 +0,0 @@\n-/*\n- * Squashfs - a compressed read only filesystem for Linux\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * squashfs2_0.c\n- */\n-\n-#include <linux/squashfs_fs.h>\n-#include <linux/module.h>\n-#include <linux/zlib.h>\n-#include <linux/fs.h>\n-#include <linux/squashfs_fs_sb.h>\n-#include <linux/squashfs_fs_i.h>\n-\n-#include "squashfs.h"\n-static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir);\n-static struct dentry *squashfs_lookup_2(struct inode *, struct dentry *,\n-\t\t\t\tstruct nameidata *);\n-\n-static struct file_operations squashfs_dir_ops_2 = {\n-\t.read = generic_read_dir,\n-\t.readdir = squashfs_readdir_2\n-};\n-\n-static struct inode_operations squashfs_dir_inode_ops_2 = {\n-\t.lookup = squashfs_lookup_2\n-};\n-\n-static unsigned char squashfs_filetype_table[] = {\n-\tDT_UNKNOWN, DT_DIR, DT_REG, DT_LNK, DT_BLK, DT_CHR, DT_FIFO, DT_SOCK\n-};\n-\n-static int read_fragment_index_table_2(struct super_block *s)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\tif (!(msblk->fragment_index_2 = kmalloc(SQUASHFS_FRAGMENT_INDEX_BYTES_2\n-\t\t\t\t\t(sblk->fragments), GFP_KERNEL))) {\n-\t\tERROR("Failed to allocate uid/gid table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments) &&\n-\t\t\t\t\t!squashfs_read_data(s, (char *)\n-\t\t\t\t\tmsblk->fragment_index_2,\n-\t\t\t\t\tsblk->fragment_table_start,\n-\t\t\t\t\tSQUASHFS_FRAGMENT_INDEX_BYTES_2\n-\t\t\t\t\t(sblk->fragments) |\n-\t\t\t\t\tSQUASHFS_COMPRESSED_BIT_BLOCK, NULL, SQUASHFS_FRAGMENT_INDEX_BYTES_2(sblk->fragments))) {\n-\t\tERROR("unable to read fragment index table\\n");\n-\t\treturn 0;\n-\t}\n-\n-\tif (msblk->swap) {\n-\t\tint i;\n-\t\tunsigned int fragment;\n-\n-\t\tfor (i = 0; i < SQUASHFS_FRAGMENT_INDEXES_2(sblk->fragments);\n-\t\t\t\t\t\t\t\t\ti++) {\n-\t\t\tSQUASHFS_SWAP_FRAGMENT_INDEXES_2((&fragment),\n-\t\t\t\t\t\t&msblk->fragment_index_2[i], 1);\n-\t\t\tmsblk->fragment_index_2[i] = fragment;\n-\t\t}\n-\t}\n-\n-\treturn 1;\n-}\n-\n-\n-static int get_fragment_location_2(struct super_block *s, unsigned int fragment,\n-\t\t\t\tlong long *fragment_start_block,\n-\t\t\t\tunsigned int *fragment_size)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tlong long start_block =\n-\t\tmsblk->fragment_index_2[SQUASHFS_FRAGMENT_INDEX_2(fragment)];\n-\tint offset = SQUASHFS_FRAGMENT_INDEX_OFFSET_2(fragment);\n-\tstruct squashfs_fragment_entry_2 fragment_entry;\n-\n-\tif (msblk->swap) {\n-\t\tstruct squashfs_fragment_entry_2 sfragment_entry;\n-\n-\t\tif (!squashfs_get_cached_block(s, (char *) &sfragment_entry,\n-\t\t\t\t\tstart_block, offset,\n-\t\t\t\t\tsizeof(sfragment_entry), &start_block,\n-\t\t\t\t\t&offset))\n-\t\t\tgoto out;\n-\t\tSQUASHFS_SWAP_FRAGMENT_ENTRY_2(&fragment_entry, &sfragment_entry);\n-\t} else\n-\t\tif (!squashfs_get_cached_block(s, (char *) &fragment_entry,\n-\t\t\t\t\tstart_block, offset,\n-\t\t\t\t\tsizeof(fragment_entry), &start_block,\n-\t\t\t\t\t&offset))\n-\t\t\tgoto out;\n-\n-\t*fragment_start_block = fragment_entry.start_block;\n-\t*fragment_size = fragment_entry.size;\n-\n-\treturn 1;\n-\n-out:\n-\treturn 0;\n-}\n-\n-\n-static void squashfs_new_inode(struct squashfs_sb_info *msblk, struct inode *i,\n-\t\tstruct squashfs_base_inode_header_2 *inodeb, unsigned int ino)\n-{\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\ti->i_ino = ino;\n-\ti->i_mtime.tv_sec = sblk->mkfs_time;\n-\ti->i_atime.tv_sec = sblk->mkfs_time;\n-\ti->i_ctime.tv_sec = sblk->mkfs_time;\n-\ti->i_uid = msblk->uid[inodeb->uid];\n-\ti->i_mode = inodeb->mode;\n-\ti->i_nlink = 1;\n-\ti->i_size = 0;\n-\tif (inodeb->guid == SQUASHFS_GUIDS)\n-\t\ti->i_gid = i->i_uid;\n-\telse\n-\t\ti->i_gid = msblk->guid[inodeb->guid];\n-}\n-\n-\n-static int squashfs_read_inode_2(struct inode *i, squashfs_inode_t inode)\n-{\n-\tstruct super_block *s = i->i_sb;\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tunsigned int block = SQUASHFS_INODE_BLK(inode) +\n-\t\tsblk->inode_table_start;\n-\tunsigned int offset = SQUASHFS_INODE_OFFSET(inode);\n-\tunsigned int ino = SQUASHFS_MK_VFS_INODE(block -\n-\t\tsblk->inode_table_start, offset);\n-\tlong long next_block;\n-\tunsigned int next_offset;\n-\tunion squashfs_inode_header_2 id, sid;\n-\tstruct squashfs_base_inode_header_2 *inodeb = &id.base,\n-\t\t\t\t\t  *sinodeb = &sid.base;\n-\n-\tTRACE("Entered squashfs_read_inode_2\\n");\n-\n-\tif (msblk->swap) {\n-\t\tif (!squashfs_get_cached_block(s, (char *) sinodeb, block,\n-\t\t\t\t\toffset, sizeof(*sinodeb), &next_block,\n-\t\t\t\t\t&next_offset))\n-\t\t\tgoto failed_read;\n-\t\tSQUASHFS_SWAP_BASE_INODE_HEADER_2(inodeb, sinodeb,\n-\t\t\t\t\tsizeof(*sinodeb));\n-\t} else\n-\t\tif (!squashfs_get_cached_block(s, (char *) inodeb, block,\n-\t\t\t\t\toffset, sizeof(*inodeb), &next_block,\n-\t\t\t\t\t&next_offset))\n-\t\t\tgoto failed_read;\n-\n-\tsquashfs_new_inode(msblk, i, inodeb, ino);\n-\n-\tswitch(inodeb->inode_type) {\n-\t\tcase SQUASHFS_FILE_TYPE: {\n-\t\t\tstruct squashfs_reg_inode_header_2 *inodep = &id.reg;\n-\t\t\tstruct squashfs_reg_inode_header_2 *sinodep = &sid.reg;\n-\t\t\tlong long frag_blk;\n-\t\t\tunsigned int frag_size = 0;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tsinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_REG_INODE_HEADER_2(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\tfrag_blk = SQUASHFS_INVALID_BLK;\n-\t\t\tif (inodep->fragment != SQUASHFS_INVALID_FRAG &&\n-\t\t\t\t\t!get_fragment_location_2(s,\n-\t\t\t\t\tinodep->fragment, &frag_blk, &frag_size))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_fop = &generic_ro_fops;\n-\t\t\ti->i_mode |= S_IFREG;\n-\t\t\ti->i_mtime.tv_sec = inodep->mtime;\n-\t\t\ti->i_atime.tv_sec = inodep->mtime;\n-\t\t\ti->i_ctime.tv_sec = inodep->mtime;\n-\t\t\ti->i_blocks = ((i->i_size - 1) >> 9) + 1;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_start_block = frag_blk;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_size = frag_size;\n-\t\t\tSQUASHFS_I(i)->u.s1.fragment_offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->u.s1.block_list_start = next_block;\n-\t\t\tSQUASHFS_I(i)->offset = next_offset;\n-\t\t\ti->i_data.a_ops = &squashfs_aops;\n-\n-\t\t\tTRACE("File inode %x:%x, start_block %x, "\n-\t\t\t\t\t"block_list_start %llx, offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->start_block, next_block,\n-\t\t\t\t\tnext_offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_DIR_TYPE: {\n-\t\t\tstruct squashfs_dir_inode_header_2 *inodep = &id.dir;\n-\t\t\tstruct squashfs_dir_inode_header_2 *sinodep = &sid.dir;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tsinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_DIR_INODE_HEADER_2(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_op = &squashfs_dir_inode_ops_2;\n-\t\t\ti->i_fop = &squashfs_dir_ops_2;\n-\t\t\ti->i_mode |= S_IFDIR;\n-\t\t\ti->i_mtime.tv_sec = inodep->mtime;\n-\t\t\ti->i_atime.tv_sec = inodep->mtime;\n-\t\t\ti->i_ctime.tv_sec = inodep->mtime;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count = 0;\n-\t\t\tSQUASHFS_I(i)->u.s2.parent_inode = 0;\n-\n-\t\t\tTRACE("Directory inode %x:%x, start_block %x, offset "\n-\t\t\t\t\t"%x\\n", SQUASHFS_INODE_BLK(inode),\n-\t\t\t\t\toffset, inodep->start_block,\n-\t\t\t\t\tinodep->offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_LDIR_TYPE: {\n-\t\t\tstruct squashfs_ldir_inode_header_2 *inodep = &id.ldir;\n-\t\t\tstruct squashfs_ldir_inode_header_2 *sinodep = &sid.ldir;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tsinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_LDIR_INODE_HEADER_2(inodep,\n-\t\t\t\t\t\tsinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_size = inodep->file_size;\n-\t\t\ti->i_op = &squashfs_dir_inode_ops_2;\n-\t\t\ti->i_fop = &squashfs_dir_ops_2;\n-\t\t\ti->i_mode |= S_IFDIR;\n-\t\t\ti->i_mtime.tv_sec = inodep->mtime;\n-\t\t\ti->i_atime.tv_sec = inodep->mtime;\n-\t\t\ti->i_ctime.tv_sec = inodep->mtime;\n-\t\t\tSQUASHFS_I(i)->start_block = inodep->start_block;\n-\t\t\tSQUASHFS_I(i)->offset = inodep->offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start = next_block;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset =\n-\t\t\t\t\t\t\t\tnext_offset;\n-\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count =\n-\t\t\t\t\t\t\t\tinodep->i_count;\n-\t\t\tSQUASHFS_I(i)->u.s2.parent_inode = 0;\n-\n-\t\t\tTRACE("Long directory inode %x:%x, start_block %x, "\n-\t\t\t\t\t"offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->start_block, inodep->offset);\n-\t\t\tbreak;\n-\t\t}\n-\t\tcase SQUASHFS_SYMLINK_TYPE: {\n-\t\t\tstruct squashfs_symlink_inode_header_2 *inodep =\n-\t\t\t\t\t\t\t\t&id.symlink;\n-\t\t\tstruct squashfs_symlink_inode_header_2 *sinodep =\n-\t\t\t\t\t\t\t\t&sid.symlink;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tsinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(inodep,\n-\t\t\t\t\t\t\t\tsinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_size = inodep->symlink_size;\n-\t\t\ti->i_op = &page_symlink_inode_operations;\n-\t\t\ti->i_data.a_ops = &squashfs_symlink_aops;\n-\t\t\ti->i_mode |= S_IFLNK;\n-\t\t\tSQUASHFS_I(i)->start_block = next_block;\n-\t\t\tSQUASHFS_I(i)->offset = next_offset;\n-\n-\t\t\tTRACE("Symbolic link inode %x:%x, start_block %llx, "\n-\t\t\t\t\t"offset %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tnext_block, next_offset);\n-\t\t\tbreak;\n-\t\t }\n-\t\t case SQUASHFS_BLKDEV_TYPE:\n-\t\t case SQUASHFS_CHRDEV_TYPE: {\n-\t\t\tstruct squashfs_dev_inode_header_2 *inodep = &id.dev;\n-\t\t\tstruct squashfs_dev_inode_header_2 *sinodep = &sid.dev;\n-\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tsinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*sinodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\t\t\t\tSQUASHFS_SWAP_DEV_INODE_HEADER_2(inodep, sinodep);\n-\t\t\t} else\n-\t\t\t\tif (!squashfs_get_cached_block(s, (char *)\n-\t\t\t\t\t\tinodep, block, offset,\n-\t\t\t\t\t\tsizeof(*inodep), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\ti->i_mode |= (inodeb->inode_type ==\n-\t\t\t\t\tSQUASHFS_CHRDEV_TYPE) ?  S_IFCHR :\n-\t\t\t\t\tS_IFBLK;\n-\t\t\tinit_special_inode(i, i->i_mode,\n-\t\t\t\t\told_decode_dev(inodep->rdev));\n-\n-\t\t\tTRACE("Device inode %x:%x, rdev %x\\n",\n-\t\t\t\t\tSQUASHFS_INODE_BLK(inode), offset,\n-\t\t\t\t\tinodep->rdev);\n-\t\t\tbreak;\n-\t\t }\n-\t\t case SQUASHFS_FIFO_TYPE:\n-\t\t case SQUASHFS_SOCKET_TYPE: {\n-\n-\t\t\ti->i_mode |= (inodeb->inode_type == SQUASHFS_FIFO_TYPE)\n-\t\t\t\t\t\t\t? S_IFIFO : S_IFSOCK;\n-\t\t\tinit_special_inode(i, i->i_mode, 0);\n-\t\t\tbreak;\n-\t\t }\n-\t\t default:\n-\t\t\tERROR("Unknown inode type %d in squashfs_iget!\\n",\n-\t\t\t\t\tinodeb->inode_type);\n-\t\t\tgoto failed_read1;\n-\t}\n-\n-\treturn 1;\n-\n-failed_read:\n-\tERROR("Unable to read inode [%x:%x]\\n", block, offset);\n-\n-failed_read1:\n-\treturn 0;\n-}\n-\n-\n-static int get_dir_index_using_offset(struct super_block *s, long long\n-\t\t\t\t*next_block, unsigned int *next_offset,\n-\t\t\t\tlong long index_start,\n-\t\t\t\tunsigned int index_offset, int i_count,\n-\t\t\t\tlong long f_pos)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tint i, length = 0;\n-\tstruct squashfs_dir_index_2 index;\n-\n-\tTRACE("Entered get_dir_index_using_offset, i_count %d, f_pos %d\\n",\n-\t\t\t\t\ti_count, (unsigned int) f_pos);\n-\n-\tif (f_pos == 0)\n-\t\tgoto finish;\n-\n-\tfor (i = 0; i < i_count; i++) {\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_index_2 sindex;\n-\t\t\tsquashfs_get_cached_block(s, (char *) &sindex,\n-\t\t\t\t\tindex_start, index_offset,\n-\t\t\t\t\tsizeof(sindex), &index_start,\n-\t\t\t\t\t&index_offset);\n-\t\t\tSQUASHFS_SWAP_DIR_INDEX_2(&index, &sindex);\n-\t\t} else\n-\t\t\tsquashfs_get_cached_block(s, (char *) &index,\n-\t\t\t\t\tindex_start, index_offset,\n-\t\t\t\t\tsizeof(index), &index_start,\n-\t\t\t\t\t&index_offset);\n-\n-\t\tif (index.index > f_pos)\n-\t\t\tbreak;\n-\n-\t\tsquashfs_get_cached_block(s, NULL, index_start, index_offset,\n-\t\t\t\t\tindex.size + 1, &index_start,\n-\t\t\t\t\t&index_offset);\n-\n-\t\tlength = index.index;\n-\t\t*next_block = index.start_block + sblk->directory_table_start;\n-\t}\n-\n-\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n-\n-finish:\n-\treturn length;\n-}\n-\n-\n-static int get_dir_index_using_name(struct super_block *s, long long\n-\t\t\t\t*next_block, unsigned int *next_offset,\n-\t\t\t\tlong long index_start,\n-\t\t\t\tunsigned int index_offset, int i_count,\n-\t\t\t\tconst char *name, int size)\n-{\n-\tstruct squashfs_sb_info *msblk = s->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tint i, length = 0;\n-\tstruct squashfs_dir_index_2 *index;\n-\tchar *str;\n-\n-\tTRACE("Entered get_dir_index_using_name, i_count %d\\n", i_count);\n-\n-\tif (!(str = kmalloc(sizeof(struct squashfs_dir_index) +\n-\t\t(SQUASHFS_NAME_LEN + 1) * 2, GFP_KERNEL))) {\n-\t\tERROR("Failed to allocate squashfs_dir_index\\n");\n-\t\tgoto failure;\n-\t}\n-\n-\tindex = (struct squashfs_dir_index_2 *) (str + SQUASHFS_NAME_LEN + 1);\n-\tstrncpy(str, name, size);\n-\tstr[size] = \'\\0\';\n-\n-\tfor (i = 0; i < i_count; i++) {\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_index_2 sindex;\n-\t\t\tsquashfs_get_cached_block(s, (char *) &sindex,\n-\t\t\t\t\tindex_start, index_offset,\n-\t\t\t\t\tsizeof(sindex), &index_start,\n-\t\t\t\t\t&index_offset);\n-\t\t\tSQUASHFS_SWAP_DIR_INDEX_2(index, &sindex);\n-\t\t} else\n-\t\t\tsquashfs_get_cached_block(s, (char *) index,\n-\t\t\t\t\tindex_start, index_offset,\n-\t\t\t\t\tsizeof(struct squashfs_dir_index_2),\n-\t\t\t\t\t&index_start, &index_offset);\n-\n-\t\tsquashfs_get_cached_block(s, index->name, index_start,\n-\t\t\t\t\tindex_offset, index->size + 1,\n-\t\t\t\t\t&index_start, &index_offset);\n-\n-\t\tindex->name[index->size + 1] = \'\\0\';\n-\n-\t\tif (strcmp(index->name, str) > 0)\n-\t\t\tbreak;\n-\n-\t\tlength = index->index;\n-\t\t*next_block = index->start_block + sblk->directory_table_start;\n-\t}\n-\n-\t*next_offset = (length + *next_offset) % SQUASHFS_METADATA_SIZE;\n-\tkfree(str);\n-failure:\n-\treturn length;\n-}\n-\n-\n-static int squashfs_readdir_2(struct file *file, void *dirent, filldir_t filldir)\n-{\n-\tstruct inode *i = file->f_dentry->d_inode;\n-\tstruct squashfs_sb_info *msblk = i->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tlong long next_block = SQUASHFS_I(i)->start_block +\n-\t\tsblk->directory_table_start;\n-\tint next_offset = SQUASHFS_I(i)->offset, length = 0,\n-\t\tdir_count;\n-\tstruct squashfs_dir_header_2 dirh;\n-\tstruct squashfs_dir_entry_2 *dire;\n-\n-\tTRACE("Entered squashfs_readdir_2 [%llx:%x]\\n", next_block, next_offset);\n-\n-\tif (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +\n-\t\tSQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {\n-\t\tERROR("Failed to allocate squashfs_dir_entry\\n");\n-\t\tgoto finish;\n-\t}\n-\n-\tlength = get_dir_index_using_offset(i->i_sb, &next_block, &next_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count,\n-\t\t\t\tfile->f_pos);\n-\n-\twhile (length < i_size_read(i)) {\n-\t\t/* read directory header */\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_header_2 sdirh;\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,\n-\t\t\t\t\tnext_block, next_offset, sizeof(sdirh),\n-\t\t\t\t\t&next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(sdirh);\n-\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n-\t\t} else {\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,\n-\t\t\t\t\tnext_block, next_offset, sizeof(dirh),\n-\t\t\t\t\t&next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(dirh);\n-\t\t}\n-\n-\t\tdir_count = dirh.count + 1;\n-\t\twhile (dir_count--) {\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tstruct squashfs_dir_entry_2 sdire;\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *)\n-\t\t\t\t\t\t&sdire, next_block, next_offset,\n-\t\t\t\t\t\tsizeof(sdire), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(sdire);\n-\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n-\t\t\t} else {\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *)\n-\t\t\t\t\t\tdire, next_block, next_offset,\n-\t\t\t\t\t\tsizeof(*dire), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(*dire);\n-\t\t\t}\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire->name,\n-\t\t\t\t\t\tnext_block, next_offset,\n-\t\t\t\t\t\tdire->size + 1, &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += dire->size + 1;\n-\n-\t\t\tif (file->f_pos >= length)\n-\t\t\t\tcontinue;\n-\n-\t\t\tdire->name[dire->size + 1] = \'\\0\';\n-\n-\t\t\tTRACE("Calling filldir(%x, %s, %d, %d, %x:%x, %d)\\n",\n-\t\t\t\t\t(unsigned int) dirent, dire->name,\n-\t\t\t\t\tdire->size + 1, (int) file->f_pos,\n-\t\t\t\t\tdirh.start_block, dire->offset,\n-\t\t\t\t\tsquashfs_filetype_table[dire->type]);\n-\n-\t\t\tif (filldir(dirent, dire->name, dire->size + 1,\n-\t\t\t\t\tfile->f_pos, SQUASHFS_MK_VFS_INODE(\n-\t\t\t\t\tdirh.start_block, dire->offset),\n-\t\t\t\t\tsquashfs_filetype_table[dire->type])\n-\t\t\t\t\t< 0) {\n-\t\t\t\tTRACE("Filldir returned less than 0\\n");\n-\t\t\t\tgoto finish;\n-\t\t\t}\n-\t\t\tfile->f_pos = length;\n-\t\t}\n-\t}\n-\n-finish:\n-\tkfree(dire);\n-\treturn 0;\n-\n-failed_read:\n-\tERROR("Unable to read directory block [%llx:%x]\\n", next_block,\n-\t\tnext_offset);\n-\tkfree(dire);\n-\treturn 0;\n-}\n-\n-\n-static struct dentry *squashfs_lookup_2(struct inode *i, struct dentry *dentry,\n-\t\t\t\tstruct nameidata *nd)\n-{\n-\tconst unsigned char *name = dentry->d_name.name;\n-\tint len = dentry->d_name.len;\n-\tstruct inode *inode = NULL;\n-\tstruct squashfs_sb_info *msblk = i->i_sb->s_fs_info;\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\tlong long next_block = SQUASHFS_I(i)->start_block +\n-\t\t\t\tsblk->directory_table_start;\n-\tint next_offset = SQUASHFS_I(i)->offset, length = 0,\n-\t\t\t\tdir_count;\n-\tstruct squashfs_dir_header_2 dirh;\n-\tstruct squashfs_dir_entry_2 *dire;\n-\tint sorted = sblk->s_major == 2 && sblk->s_minor >= 1;\n-\n-\tTRACE("Entered squashfs_lookup_2 [%llx:%x]\\n", next_block, next_offset);\n-\n-\tif (!(dire = kmalloc(sizeof(struct squashfs_dir_entry) +\n-\t\tSQUASHFS_NAME_LEN + 1, GFP_KERNEL))) {\n-\t\tERROR("Failed to allocate squashfs_dir_entry\\n");\n-\t\tgoto exit_loop;\n-\t}\n-\n-\tif (len > SQUASHFS_NAME_LEN)\n-\t\tgoto exit_loop;\n-\n-\tlength = get_dir_index_using_name(i->i_sb, &next_block, &next_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_start,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_offset,\n-\t\t\t\tSQUASHFS_I(i)->u.s2.directory_index_count, name,\n-\t\t\t\tlen);\n-\n-\twhile (length < i_size_read(i)) {\n-\t\t/* read directory header */\n-\t\tif (msblk->swap) {\n-\t\t\tstruct squashfs_dir_header_2 sdirh;\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *) &sdirh,\n-\t\t\t\t\tnext_block, next_offset, sizeof(sdirh),\n-\t\t\t\t\t&next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(sdirh);\n-\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n-\t\t} else {\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *) &dirh,\n-\t\t\t\t\tnext_block, next_offset, sizeof(dirh),\n-\t\t\t\t\t&next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += sizeof(dirh);\n-\t\t}\n-\n-\t\tdir_count = dirh.count + 1;\n-\t\twhile (dir_count--) {\n-\t\t\tif (msblk->swap) {\n-\t\t\t\tstruct squashfs_dir_entry_2 sdire;\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *)\n-\t\t\t\t\t\t&sdire, next_block,next_offset,\n-\t\t\t\t\t\tsizeof(sdire), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(sdire);\n-\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n-\t\t\t} else {\n-\t\t\t\tif (!squashfs_get_cached_block(i->i_sb, (char *)\n-\t\t\t\t\t\tdire, next_block,next_offset,\n-\t\t\t\t\t\tsizeof(*dire), &next_block,\n-\t\t\t\t\t\t&next_offset))\n-\t\t\t\t\tgoto failed_read;\n-\n-\t\t\t\tlength += sizeof(*dire);\n-\t\t\t}\n-\n-\t\t\tif (!squashfs_get_cached_block(i->i_sb, dire->name,\n-\t\t\t\t\tnext_block, next_offset, dire->size + 1,\n-\t\t\t\t\t&next_block, &next_offset))\n-\t\t\t\tgoto failed_read;\n-\n-\t\t\tlength += dire->size + 1;\n-\n-\t\t\tif (sorted && name[0] < dire->name[0])\n-\t\t\t\tgoto exit_loop;\n-\n-\t\t\tif ((len == dire->size + 1) && !strncmp(name,\n-\t\t\t\t\t\tdire->name, len)) {\n-\t\t\t\tsquashfs_inode_t ino =\n-\t\t\t\t\tSQUASHFS_MKINODE(dirh.start_block,\n-\t\t\t\t\tdire->offset);\n-\t\t\t\tunsigned int inode_number = SQUASHFS_MK_VFS_INODE(dirh.start_block,\n-\t\t\t\t\tdire->offset);\n-\n-\t\t\t\tTRACE("calling squashfs_iget for directory "\n-\t\t\t\t\t"entry %s, inode %x:%x, %lld\\n", name,\n-\t\t\t\t\tdirh.start_block, dire->offset, ino);\n-\n-\t\t\t\tinode = squashfs_iget(i->i_sb, ino, inode_number);\n-\n-\t\t\t\tgoto exit_loop;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-exit_loop:\n-\tkfree(dire);\n-\td_add(dentry, inode);\n-\treturn ERR_PTR(0);\n-\n-failed_read:\n-\tERROR("Unable to read directory block [%llx:%x]\\n", next_block,\n-\t\tnext_offset);\n-\tgoto exit_loop;\n-}\n-\n-\n-int squashfs_2_0_supported(struct squashfs_sb_info *msblk)\n-{\n-\tstruct squashfs_super_block *sblk = &msblk->sblk;\n-\n-\tmsblk->read_inode = squashfs_read_inode_2;\n-\tmsblk->read_fragment_index_table = read_fragment_index_table_2;\n-\n-\tsblk->bytes_used = sblk->bytes_used_2;\n-\tsblk->uid_start = sblk->uid_start_2;\n-\tsblk->guid_start = sblk->guid_start_2;\n-\tsblk->inode_table_start = sblk->inode_table_start_2;\n-\tsblk->directory_table_start = sblk->directory_table_start_2;\n-\tsblk->fragment_table_start = sblk->fragment_table_start_2;\n-\n-\treturn 1;\n-}'),
 ('linux-2.6.23.orig/fs/Makefile',
  'linux-2.6.23/fs/Makefile',
  'Index: linux-2.6.23/fs/Makefile\n===================================================================\n--- linux-2.6.23.orig/fs/Makefile\n+++ linux-2.6.23/fs/Makefile\n@@ -72,7 +72,6 @@ obj-$(CONFIG_JBD)\t\t+= jbd/\nobj-$(CONFIG_JBD2)\t\t+= jbd2/\nobj-$(CONFIG_EXT2_FS)\t\t+= ext2/\nobj-$(CONFIG_CRAMFS)\t\t+= cramfs/\n-obj-$(CONFIG_SQUASHFS)\t\t+= squashfs/\nobj-$(CONFIG_RAMFS)\t\t+= ramfs/\nobj-$(CONFIG_HUGETLBFS)\t\t+= hugetlbfs/\nobj-$(CONFIG_CODA_FS)\t\t+= coda/'),
 ('linux-2.6.23.orig/include/linux/squashfs_fs.h',
  'dev/null',
  'Index: linux-2.6.23/include/linux/squashfs_fs.h\n===================================================================\n--- linux-2.6.23.orig/include/linux/squashfs_fs.h\n+++ dev/null\n@@ -1,935 +0,0 @@\n-#ifndef SQUASHFS_FS\n-#define SQUASHFS_FS\n-\n-/*\n- * Squashfs\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * squashfs_fs.h\n- */\n-\n-#ifndef CONFIG_SQUASHFS_2_0_COMPATIBILITY\n-#define CONFIG_SQUASHFS_2_0_COMPATIBILITY\n-#endif\n-\n-#define SQUASHFS_CACHED_FRAGMENTS\tCONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE\n-#define SQUASHFS_MAJOR\t\t\t3\n-#define SQUASHFS_MINOR\t\t\t1\n-#define SQUASHFS_MAGIC\t\t\t0x73717368\n-#define SQUASHFS_MAGIC_SWAP\t\t0x68737173\n-#define SQUASHFS_START\t\t\t0\n-\n-/* size of metadata (inode and directory) blocks */\n-#define SQUASHFS_METADATA_SIZE\t\t8192\n-#define SQUASHFS_METADATA_LOG\t\t13\n-\n-/* default size of data blocks */\n-#define SQUASHFS_FILE_SIZE\t\t131072\n-#define SQUASHFS_FILE_LOG\t\t17\n-\n-#define SQUASHFS_FILE_MAX_SIZE\t\t1048576\n-\n-/* Max number of uids and gids */\n-#define SQUASHFS_UIDS\t\t\t256\n-#define SQUASHFS_GUIDS\t\t\t255\n-\n-/* Max length of filename (not 255) */\n-#define SQUASHFS_NAME_LEN\t\t256\n-\n-#define SQUASHFS_INVALID\t\t((long long) 0xffffffffffff)\n-#define SQUASHFS_INVALID_FRAG\t\t((unsigned int) 0xffffffff)\n-#define SQUASHFS_INVALID_BLK\t\t((long long) -1)\n-#define SQUASHFS_USED_BLK\t\t((long long) -2)\n-\n-/* Filesystem flags */\n-#define SQUASHFS_NOI\t\t\t0\n-#define SQUASHFS_NOD\t\t\t1\n-#define SQUASHFS_CHECK\t\t\t2\n-#define SQUASHFS_NOF\t\t\t3\n-#define SQUASHFS_NO_FRAG\t\t4\n-#define SQUASHFS_ALWAYS_FRAG\t\t5\n-#define SQUASHFS_DUPLICATE\t\t6\n-#define SQUASHFS_EXPORT\t\t\t7\n-\n-#define SQUASHFS_BIT(flag, bit)\t\t((flag >> bit) & 1)\n-\n-#define SQUASHFS_UNCOMPRESSED_INODES(flags)\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_NOI)\n-\n-#define SQUASHFS_UNCOMPRESSED_DATA(flags)\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_NOD)\n-\n-#define SQUASHFS_UNCOMPRESSED_FRAGMENTS(flags)\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_NOF)\n-\n-#define SQUASHFS_NO_FRAGMENTS(flags)\t\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_NO_FRAG)\n-\n-#define SQUASHFS_ALWAYS_FRAGMENTS(flags)\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_ALWAYS_FRAG)\n-\n-#define SQUASHFS_DUPLICATES(flags)\t\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_DUPLICATE)\n-\n-#define SQUASHFS_EXPORTABLE(flags)\t\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_EXPORT)\n-\n-#define SQUASHFS_CHECK_DATA(flags)\t\tSQUASHFS_BIT(flags, \\\n-\t\t\t\t\t\tSQUASHFS_CHECK)\n-\n-#define SQUASHFS_MKFLAGS(noi, nod, check_data, nof, no_frag, always_frag, \\\n-\t\tduplicate_checking, exortable)\t(noi | (nod << 1) | (check_data << 2) \\\n-\t\t| (nof << 3) | (no_frag << 4) | (always_frag << 5) | \\\n-\t\t(duplicate_checking << 6) | (exportable << 7))\n-\n-/* Max number of types and file types */\n-#define SQUASHFS_DIR_TYPE\t\t1\n-#define SQUASHFS_FILE_TYPE\t\t2\n-#define SQUASHFS_SYMLINK_TYPE\t\t3\n-#define SQUASHFS_BLKDEV_TYPE\t\t4\n-#define SQUASHFS_CHRDEV_TYPE\t\t5\n-#define SQUASHFS_FIFO_TYPE\t\t6\n-#define SQUASHFS_SOCKET_TYPE\t\t7\n-#define SQUASHFS_LDIR_TYPE\t\t8\n-#define SQUASHFS_LREG_TYPE\t\t9\n-\n-/* 1.0 filesystem type definitions */\n-#define SQUASHFS_TYPES\t\t\t5\n-#define SQUASHFS_IPC_TYPE\t\t0\n-\n-/* Flag whether block is compressed or uncompressed, bit is set if block is\n- * uncompressed */\n-#define SQUASHFS_COMPRESSED_BIT\t\t(1 << 15)\n-\n-#define SQUASHFS_COMPRESSED_SIZE(B)\t(((B) & ~SQUASHFS_COMPRESSED_BIT) ? \\\n-\t\t(B) & ~SQUASHFS_COMPRESSED_BIT :  SQUASHFS_COMPRESSED_BIT)\n-\n-#define SQUASHFS_COMPRESSED(B)\t\t(!((B) & SQUASHFS_COMPRESSED_BIT))\n-\n-#define SQUASHFS_COMPRESSED_BIT_BLOCK\t\t(1 << 24)\n-\n-#define SQUASHFS_COMPRESSED_SIZE_BLOCK(B)\t((B) & \\\n-\t~SQUASHFS_COMPRESSED_BIT_BLOCK)\n-\n-#define SQUASHFS_COMPRESSED_BLOCK(B)\t(!((B) & SQUASHFS_COMPRESSED_BIT_BLOCK))\n-\n-/*\n- * Inode number ops.  Inodes consist of a compressed block number, and an\n- * uncompressed  offset within that block\n- */\n-#define SQUASHFS_INODE_BLK(a)\t\t((unsigned int) ((a) >> 16))\n-\n-#define SQUASHFS_INODE_OFFSET(a)\t((unsigned int) ((a) & 0xffff))\n-\n-#define SQUASHFS_MKINODE(A, B)\t\t((squashfs_inode_t)(((squashfs_inode_t) (A)\\\n-\t\t\t\t\t<< 16) + (B)))\n-\n-/* Compute 32 bit VFS inode number from squashfs inode number */\n-#define SQUASHFS_MK_VFS_INODE(a, b)\t((unsigned int) (((a) << 8) + \\\n-\t\t\t\t\t((b) >> 2) + 1))\n-/* XXX */\n-\n-/* Translate between VFS mode and squashfs mode */\n-#define SQUASHFS_MODE(a)\t\t((a) & 0xfff)\n-\n-/* fragment and fragment table defines */\n-#define SQUASHFS_FRAGMENT_BYTES(A)\t((A) * sizeof(struct squashfs_fragment_entry))\n-\n-#define SQUASHFS_FRAGMENT_INDEX(A)\t(SQUASHFS_FRAGMENT_BYTES(A) / \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEX_OFFSET(A)\t(SQUASHFS_FRAGMENT_BYTES(A) % \\\n-\t\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEXES(A)\t((SQUASHFS_FRAGMENT_BYTES(A) + \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE - 1) / \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEX_BYTES(A)\t(SQUASHFS_FRAGMENT_INDEXES(A) *\\\n-\t\t\t\t\t\tsizeof(long long))\n-\n-/* inode lookup table defines */\n-#define SQUASHFS_LOOKUP_BYTES(A)\t((A) * sizeof(squashfs_inode_t))\n-\n-#define SQUASHFS_LOOKUP_BLOCK(A)\t\t(SQUASHFS_LOOKUP_BYTES(A) / \\\n-\t\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_LOOKUP_BLOCK_OFFSET(A)\t\t(SQUASHFS_LOOKUP_BYTES(A) % \\\n-\t\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_LOOKUP_BLOCKS(A)\t((SQUASHFS_LOOKUP_BYTES(A) + \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE - 1) / \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_LOOKUP_BLOCK_BYTES(A)\t(SQUASHFS_LOOKUP_BLOCKS(A) *\\\n-\t\t\t\t\tsizeof(long long))\n-\n-/* cached data constants for filesystem */\n-#define SQUASHFS_CACHED_BLKS\t\t8\n-\n-#define SQUASHFS_MAX_FILE_SIZE_LOG\t64\n-\n-#define SQUASHFS_MAX_FILE_SIZE\t\t((long long) 1 << \\\n-\t\t\t\t\t(SQUASHFS_MAX_FILE_SIZE_LOG - 2))\n-\n-#define SQUASHFS_MARKER_BYTE\t\t0xff\n-\n-/* meta index cache */\n-#define SQUASHFS_META_INDEXES\t(SQUASHFS_METADATA_SIZE / sizeof(unsigned int))\n-#define SQUASHFS_META_ENTRIES\t31\n-#define SQUASHFS_META_NUMBER\t8\n-#define SQUASHFS_SLOTS\t\t4\n-\n-struct meta_entry {\n-\tlong long\t\tdata_block;\n-\tunsigned int\t\tindex_block;\n-\tunsigned short\t\toffset;\n-\tunsigned short\t\tpad;\n-};\n-\n-struct meta_index {\n-\tunsigned int\t\tinode_number;\n-\tunsigned int\t\toffset;\n-\tunsigned short\t\tentries;\n-\tunsigned short\t\tskip;\n-\tunsigned short\t\tlocked;\n-\tunsigned short\t\tpad;\n-\tstruct meta_entry\tmeta_entry[SQUASHFS_META_ENTRIES];\n-};\n-\n-\n-/*\n- * definitions for structures on disk\n- */\n-\n-typedef long long\t\tsquashfs_block_t;\n-typedef long long\t\tsquashfs_inode_t;\n-\n-struct squashfs_super_block {\n-\tunsigned int\t\ts_magic;\n-\tunsigned int\t\tinodes;\n-\tunsigned int\t\tbytes_used_2;\n-\tunsigned int\t\tuid_start_2;\n-\tunsigned int\t\tguid_start_2;\n-\tunsigned int\t\tinode_table_start_2;\n-\tunsigned int\t\tdirectory_table_start_2;\n-\tunsigned int\t\ts_major:16;\n-\tunsigned int\t\ts_minor:16;\n-\tunsigned int\t\tblock_size_1:16;\n-\tunsigned int\t\tblock_log:16;\n-\tunsigned int\t\tflags:8;\n-\tunsigned int\t\tno_uids:8;\n-\tunsigned int\t\tno_guids:8;\n-\tunsigned int\t\tmkfs_time /* time of filesystem creation */;\n-\tsquashfs_inode_t\troot_inode;\n-\tunsigned int\t\tblock_size;\n-\tunsigned int\t\tfragments;\n-\tunsigned int\t\tfragment_table_start_2;\n-\tlong long\t\tbytes_used;\n-\tlong long\t\tuid_start;\n-\tlong long\t\tguid_start;\n-\tlong long\t\tinode_table_start;\n-\tlong long\t\tdirectory_table_start;\n-\tlong long\t\tfragment_table_start;\n-\tlong long\t\tlookup_table_start;\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_index {\n-\tunsigned int\t\tindex;\n-\tunsigned int\t\tstart_block;\n-\tunsigned char\t\tsize;\n-\tunsigned char\t\tname[0];\n-} __attribute__ ((packed));\n-\n-#define SQUASHFS_BASE_INODE_HEADER\t\t\\\n-\tunsigned int\t\tinode_type:4;\t\\\n-\tunsigned int\t\tmode:12;\t\\\n-\tunsigned int\t\tuid:8;\t\t\\\n-\tunsigned int\t\tguid:8;\t\t\\\n-\tunsigned int\t\tmtime;\t\t\\\n-\tunsigned int \t\tinode_number;\n-\n-struct squashfs_base_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-} __attribute__ ((packed));\n-\n-struct squashfs_ipc_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-} __attribute__ ((packed));\n-\n-struct squashfs_dev_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-\tunsigned short\t\trdev;\n-} __attribute__ ((packed));\n-\n-struct squashfs_symlink_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-\tunsigned short\t\tsymlink_size;\n-\tchar\t\t\tsymlink[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_reg_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tsquashfs_block_t\tstart_block;\n-\tunsigned int\t\tfragment;\n-\tunsigned int\t\toffset;\n-\tunsigned int\t\tfile_size;\n-\tunsigned short\t\tblock_list[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_lreg_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-\tsquashfs_block_t\tstart_block;\n-\tunsigned int\t\tfragment;\n-\tunsigned int\t\toffset;\n-\tlong long\t\tfile_size;\n-\tunsigned short\t\tblock_list[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-\tunsigned int\t\tfile_size:19;\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\tparent_inode;\n-} __attribute__  ((packed));\n-\n-struct squashfs_ldir_inode_header {\n-\tSQUASHFS_BASE_INODE_HEADER;\n-\tunsigned int\t\tnlink;\n-\tunsigned int\t\tfile_size:27;\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\ti_count:16;\n-\tunsigned int\t\tparent_inode;\n-\tstruct squashfs_dir_index\tindex[0];\n-} __attribute__  ((packed));\n-\n-union squashfs_inode_header {\n-\tstruct squashfs_base_inode_header\tbase;\n-\tstruct squashfs_dev_inode_header\tdev;\n-\tstruct squashfs_symlink_inode_header\tsymlink;\n-\tstruct squashfs_reg_inode_header\treg;\n-\tstruct squashfs_lreg_inode_header\tlreg;\n-\tstruct squashfs_dir_inode_header\tdir;\n-\tstruct squashfs_ldir_inode_header\tldir;\n-\tstruct squashfs_ipc_inode_header\tipc;\n-};\n-\n-struct squashfs_dir_entry {\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\ttype:3;\n-\tunsigned int\t\tsize:8;\n-\tint\t\t\tinode_number:16;\n-\tchar\t\t\tname[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_header {\n-\tunsigned int\t\tcount:8;\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\tinode_number;\n-} __attribute__ ((packed));\n-\n-struct squashfs_fragment_entry {\n-\tlong long\t\tstart_block;\n-\tunsigned int\t\tsize;\n-\tunsigned int\t\tpending;\n-} __attribute__ ((packed));\n-\n-extern int squashfs_uncompress_block(void *d, int dstlen, void *s, int srclen);\n-extern int squashfs_uncompress_init(void);\n-extern int squashfs_uncompress_exit(void);\n-\n-/*\n- * macros to convert each packed bitfield structure from little endian to big\n- * endian and vice versa.  These are needed when creating or using a filesystem\n- * on a machine with different byte ordering to the target architecture.\n- *\n- */\n-\n-#define SQUASHFS_SWAP_START \\\n-\tint bits;\\\n-\tint b_pos;\\\n-\tunsigned long long val;\\\n-\tunsigned char *s;\\\n-\tunsigned char *d;\n-\n-#define SQUASHFS_SWAP_SUPER_BLOCK(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_super_block));\\\n-\tSQUASHFS_SWAP((s)->s_magic, d, 0, 32);\\\n-\tSQUASHFS_SWAP((s)->inodes, d, 32, 32);\\\n-\tSQUASHFS_SWAP((s)->bytes_used_2, d, 64, 32);\\\n-\tSQUASHFS_SWAP((s)->uid_start_2, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->guid_start_2, d, 128, 32);\\\n-\tSQUASHFS_SWAP((s)->inode_table_start_2, d, 160, 32);\\\n-\tSQUASHFS_SWAP((s)->directory_table_start_2, d, 192, 32);\\\n-\tSQUASHFS_SWAP((s)->s_major, d, 224, 16);\\\n-\tSQUASHFS_SWAP((s)->s_minor, d, 240, 16);\\\n-\tSQUASHFS_SWAP((s)->block_size_1, d, 256, 16);\\\n-\tSQUASHFS_SWAP((s)->block_log, d, 272, 16);\\\n-\tSQUASHFS_SWAP((s)->flags, d, 288, 8);\\\n-\tSQUASHFS_SWAP((s)->no_uids, d, 296, 8);\\\n-\tSQUASHFS_SWAP((s)->no_guids, d, 304, 8);\\\n-\tSQUASHFS_SWAP((s)->mkfs_time, d, 312, 32);\\\n-\tSQUASHFS_SWAP((s)->root_inode, d, 344, 64);\\\n-\tSQUASHFS_SWAP((s)->block_size, d, 408, 32);\\\n-\tSQUASHFS_SWAP((s)->fragments, d, 440, 32);\\\n-\tSQUASHFS_SWAP((s)->fragment_table_start_2, d, 472, 32);\\\n-\tSQUASHFS_SWAP((s)->bytes_used, d, 504, 64);\\\n-\tSQUASHFS_SWAP((s)->uid_start, d, 568, 64);\\\n-\tSQUASHFS_SWAP((s)->guid_start, d, 632, 64);\\\n-\tSQUASHFS_SWAP((s)->inode_table_start, d, 696, 64);\\\n-\tSQUASHFS_SWAP((s)->directory_table_start, d, 760, 64);\\\n-\tSQUASHFS_SWAP((s)->fragment_table_start, d, 824, 64);\\\n-\tSQUASHFS_SWAP((s)->lookup_table_start, d, 888, 64);\\\n-}\n-\n-#define SQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\\\n-\tSQUASHFS_MEMSET(s, d, n);\\\n-\tSQUASHFS_SWAP((s)->inode_type, d, 0, 4);\\\n-\tSQUASHFS_SWAP((s)->mode, d, 4, 12);\\\n-\tSQUASHFS_SWAP((s)->uid, d, 16, 8);\\\n-\tSQUASHFS_SWAP((s)->guid, d, 24, 8);\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 32, 32);\\\n-\tSQUASHFS_SWAP((s)->inode_number, d, 64, 32);\n-\n-#define SQUASHFS_SWAP_BASE_INODE_HEADER(s, d, n) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, n)\\\n-}\n-\n-#define SQUASHFS_SWAP_IPC_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_ipc_inode_header))\\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_DEV_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_dev_inode_header)); \\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->rdev, d, 128, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_symlink_inode_header));\\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->symlink_size, d, 128, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_REG_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_reg_inode_header));\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 96, 64);\\\n-\tSQUASHFS_SWAP((s)->fragment, d, 160, 32);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 192, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 224, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_LREG_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_lreg_inode_header));\\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 128, 64);\\\n-\tSQUASHFS_SWAP((s)->fragment, d, 192, 32);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 224, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 256, 64);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_dir_inode_header));\\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 128, 19);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 147, 13);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 160, 32);\\\n-\tSQUASHFS_SWAP((s)->parent_inode, d, 192, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_LDIR_INODE_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE(s, d, \\\n-\t\t\tsizeof(struct squashfs_ldir_inode_header));\\\n-\tSQUASHFS_SWAP((s)->nlink, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 128, 27);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 155, 13);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 168, 32);\\\n-\tSQUASHFS_SWAP((s)->i_count, d, 200, 16);\\\n-\tSQUASHFS_SWAP((s)->parent_inode, d, 216, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_INDEX(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index));\\\n-\tSQUASHFS_SWAP((s)->index, d, 0, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 32, 32);\\\n-\tSQUASHFS_SWAP((s)->size, d, 64, 8);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_HEADER(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header));\\\n-\tSQUASHFS_SWAP((s)->count, d, 0, 8);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 8, 32);\\\n-\tSQUASHFS_SWAP((s)->inode_number, d, 40, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_ENTRY(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry));\\\n-\tSQUASHFS_SWAP((s)->offset, d, 0, 13);\\\n-\tSQUASHFS_SWAP((s)->type, d, 13, 3);\\\n-\tSQUASHFS_SWAP((s)->size, d, 16, 8);\\\n-\tSQUASHFS_SWAP((s)->inode_number, d, 24, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_FRAGMENT_ENTRY(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry));\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 0, 64);\\\n-\tSQUASHFS_SWAP((s)->size, d, 64, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_INODE_T(s, d) SQUASHFS_SWAP_LONG_LONGS(s, d, 1)\n-\n-#define SQUASHFS_SWAP_SHORTS(s, d, n) {\\\n-\tint entry;\\\n-\tint bit_position;\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, n * 2);\\\n-\tfor(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \\\n-\t\t\t16)\\\n-\t\tSQUASHFS_SWAP(s[entry], d, bit_position, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_INTS(s, d, n) {\\\n-\tint entry;\\\n-\tint bit_position;\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, n * 4);\\\n-\tfor(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \\\n-\t\t\t32)\\\n-\t\tSQUASHFS_SWAP(s[entry], d, bit_position, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_LONG_LONGS(s, d, n) {\\\n-\tint entry;\\\n-\tint bit_position;\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, n * 8);\\\n-\tfor(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \\\n-\t\t\t64)\\\n-\t\tSQUASHFS_SWAP(s[entry], d, bit_position, 64);\\\n-}\n-\n-#define SQUASHFS_SWAP_DATA(s, d, n, bits) {\\\n-\tint entry;\\\n-\tint bit_position;\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, n * bits / 8);\\\n-\tfor(entry = 0, bit_position = 0; entry < n; entry++, bit_position += \\\n-\t\t\tbits)\\\n-\t\tSQUASHFS_SWAP(s[entry], d, bit_position, bits);\\\n-}\n-\n-#define SQUASHFS_SWAP_FRAGMENT_INDEXES(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)\n-#define SQUASHFS_SWAP_LOOKUP_BLOCKS(s, d, n) SQUASHFS_SWAP_LONG_LONGS(s, d, n)\n-\n-#ifdef CONFIG_SQUASHFS_1_0_COMPATIBILITY\n-\n-struct squashfs_base_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-} __attribute__ ((packed));\n-\n-struct squashfs_ipc_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-\tunsigned int\t\ttype:4;\n-\tunsigned int\t\toffset:4;\n-} __attribute__ ((packed));\n-\n-struct squashfs_dev_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-\tunsigned short\t\trdev;\n-} __attribute__ ((packed));\n-\n-struct squashfs_symlink_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-\tunsigned short\t\tsymlink_size;\n-\tchar\t\t\tsymlink[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_reg_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-\tunsigned int\t\tmtime;\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\tfile_size:32;\n-\tunsigned short\t\tblock_list[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_inode_header_1 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:4; /* index into uid table */\n-\tunsigned int\t\tguid:4; /* index into guid table */\n-\tunsigned int\t\tfile_size:19;\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\tmtime;\n-\tunsigned int\t\tstart_block:24;\n-} __attribute__  ((packed));\n-\n-union squashfs_inode_header_1 {\n-\tstruct squashfs_base_inode_header_1\tbase;\n-\tstruct squashfs_dev_inode_header_1\tdev;\n-\tstruct squashfs_symlink_inode_header_1\tsymlink;\n-\tstruct squashfs_reg_inode_header_1\treg;\n-\tstruct squashfs_dir_inode_header_1\tdir;\n-\tstruct squashfs_ipc_inode_header_1\tipc;\n-};\n-\n-#define SQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n) \\\n-\tSQUASHFS_MEMSET(s, d, n);\\\n-\tSQUASHFS_SWAP((s)->inode_type, d, 0, 4);\\\n-\tSQUASHFS_SWAP((s)->mode, d, 4, 12);\\\n-\tSQUASHFS_SWAP((s)->uid, d, 16, 4);\\\n-\tSQUASHFS_SWAP((s)->guid, d, 20, 4);\n-\n-#define SQUASHFS_SWAP_BASE_INODE_HEADER_1(s, d, n) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, n)\\\n-}\n-\n-#define SQUASHFS_SWAP_IPC_INODE_HEADER_1(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \\\n-\t\t\tsizeof(struct squashfs_ipc_inode_header_1));\\\n-\tSQUASHFS_SWAP((s)->type, d, 24, 4);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 28, 4);\\\n-}\n-\n-#define SQUASHFS_SWAP_DEV_INODE_HEADER_1(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \\\n-\t\t\tsizeof(struct squashfs_dev_inode_header_1));\\\n-\tSQUASHFS_SWAP((s)->rdev, d, 24, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_1(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \\\n-\t\t\tsizeof(struct squashfs_symlink_inode_header_1));\\\n-\tSQUASHFS_SWAP((s)->symlink_size, d, 24, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_REG_INODE_HEADER_1(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \\\n-\t\t\tsizeof(struct squashfs_reg_inode_header_1));\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 24, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 56, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 88, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_INODE_HEADER_1(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_1(s, d, \\\n-\t\t\tsizeof(struct squashfs_dir_inode_header_1));\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 24, 19);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 43, 13);\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 56, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 88, 24);\\\n-}\n-\n-#endif\n-\n-#ifdef CONFIG_SQUASHFS_2_0_COMPATIBILITY\n-\n-struct squashfs_dir_index_2 {\n-\tunsigned int\t\tindex:27;\n-\tunsigned int\t\tstart_block:29;\n-\tunsigned char\t\tsize;\n-\tunsigned char\t\tname[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_base_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-} __attribute__ ((packed));\n-\n-struct squashfs_ipc_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-} __attribute__ ((packed));\n-\n-struct squashfs_dev_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-\tunsigned short\t\trdev;\n-} __attribute__ ((packed));\n-\n-struct squashfs_symlink_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-\tunsigned short\t\tsymlink_size;\n-\tchar\t\t\tsymlink[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_reg_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-\tunsigned int\t\tmtime;\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\tfragment;\n-\tunsigned int\t\toffset;\n-\tunsigned int\t\tfile_size:32;\n-\tunsigned short\t\tblock_list[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-\tunsigned int\t\tfile_size:19;\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\tmtime;\n-\tunsigned int\t\tstart_block:24;\n-} __attribute__  ((packed));\n-\n-struct squashfs_ldir_inode_header_2 {\n-\tunsigned int\t\tinode_type:4;\n-\tunsigned int\t\tmode:12; /* protection */\n-\tunsigned int\t\tuid:8; /* index into uid table */\n-\tunsigned int\t\tguid:8; /* index into guid table */\n-\tunsigned int\t\tfile_size:27;\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\tmtime;\n-\tunsigned int\t\tstart_block:24;\n-\tunsigned int\t\ti_count:16;\n-\tstruct squashfs_dir_index_2\tindex[0];\n-} __attribute__  ((packed));\n-\n-union squashfs_inode_header_2 {\n-\tstruct squashfs_base_inode_header_2\tbase;\n-\tstruct squashfs_dev_inode_header_2\tdev;\n-\tstruct squashfs_symlink_inode_header_2\tsymlink;\n-\tstruct squashfs_reg_inode_header_2\treg;\n-\tstruct squashfs_dir_inode_header_2\tdir;\n-\tstruct squashfs_ldir_inode_header_2\tldir;\n-\tstruct squashfs_ipc_inode_header_2\tipc;\n-};\n-\n-struct squashfs_dir_header_2 {\n-\tunsigned int\t\tcount:8;\n-\tunsigned int\t\tstart_block:24;\n-} __attribute__ ((packed));\n-\n-struct squashfs_dir_entry_2 {\n-\tunsigned int\t\toffset:13;\n-\tunsigned int\t\ttype:3;\n-\tunsigned int\t\tsize:8;\n-\tchar\t\t\tname[0];\n-} __attribute__ ((packed));\n-\n-struct squashfs_fragment_entry_2 {\n-\tunsigned int\t\tstart_block;\n-\tunsigned int\t\tsize;\n-} __attribute__ ((packed));\n-\n-#define SQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\\\n-\tSQUASHFS_MEMSET(s, d, n);\\\n-\tSQUASHFS_SWAP((s)->inode_type, d, 0, 4);\\\n-\tSQUASHFS_SWAP((s)->mode, d, 4, 12);\\\n-\tSQUASHFS_SWAP((s)->uid, d, 16, 8);\\\n-\tSQUASHFS_SWAP((s)->guid, d, 24, 8);\\\n-\n-#define SQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, n) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, n)\\\n-}\n-\n-#define SQUASHFS_SWAP_IPC_INODE_HEADER_2(s, d) \\\n-\tSQUASHFS_SWAP_BASE_INODE_HEADER_2(s, d, sizeof(struct squashfs_ipc_inode_header_2))\n-\n-#define SQUASHFS_SWAP_DEV_INODE_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \\\n-\t\t\tsizeof(struct squashfs_dev_inode_header_2)); \\\n-\tSQUASHFS_SWAP((s)->rdev, d, 32, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_SYMLINK_INODE_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \\\n-\t\t\tsizeof(struct squashfs_symlink_inode_header_2));\\\n-\tSQUASHFS_SWAP((s)->symlink_size, d, 32, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_REG_INODE_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \\\n-\t\t\tsizeof(struct squashfs_reg_inode_header_2));\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 32, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 64, 32);\\\n-\tSQUASHFS_SWAP((s)->fragment, d, 96, 32);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 128, 32);\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 160, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_INODE_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \\\n-\t\t\tsizeof(struct squashfs_dir_inode_header_2));\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 32, 19);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 51, 13);\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 64, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 96, 24);\\\n-}\n-\n-#define SQUASHFS_SWAP_LDIR_INODE_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_SWAP_BASE_INODE_CORE_2(s, d, \\\n-\t\t\tsizeof(struct squashfs_ldir_inode_header_2));\\\n-\tSQUASHFS_SWAP((s)->file_size, d, 32, 27);\\\n-\tSQUASHFS_SWAP((s)->offset, d, 59, 13);\\\n-\tSQUASHFS_SWAP((s)->mtime, d, 72, 32);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 104, 24);\\\n-\tSQUASHFS_SWAP((s)->i_count, d, 128, 16);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_INDEX_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_index_2));\\\n-\tSQUASHFS_SWAP((s)->index, d, 0, 27);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 27, 29);\\\n-\tSQUASHFS_SWAP((s)->size, d, 56, 8);\\\n-}\n-#define SQUASHFS_SWAP_DIR_HEADER_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_header_2));\\\n-\tSQUASHFS_SWAP((s)->count, d, 0, 8);\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 8, 24);\\\n-}\n-\n-#define SQUASHFS_SWAP_DIR_ENTRY_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_dir_entry_2));\\\n-\tSQUASHFS_SWAP((s)->offset, d, 0, 13);\\\n-\tSQUASHFS_SWAP((s)->type, d, 13, 3);\\\n-\tSQUASHFS_SWAP((s)->size, d, 16, 8);\\\n-}\n-\n-#define SQUASHFS_SWAP_FRAGMENT_ENTRY_2(s, d) {\\\n-\tSQUASHFS_SWAP_START\\\n-\tSQUASHFS_MEMSET(s, d, sizeof(struct squashfs_fragment_entry_2));\\\n-\tSQUASHFS_SWAP((s)->start_block, d, 0, 32);\\\n-\tSQUASHFS_SWAP((s)->size, d, 32, 32);\\\n-}\n-\n-#define SQUASHFS_SWAP_FRAGMENT_INDEXES_2(s, d, n) SQUASHFS_SWAP_INTS(s, d, n)\n-\n-/* fragment and fragment table defines */\n-#define SQUASHFS_FRAGMENT_BYTES_2(A)\t(A * sizeof(struct squashfs_fragment_entry_2))\n-\n-#define SQUASHFS_FRAGMENT_INDEX_2(A)\t(SQUASHFS_FRAGMENT_BYTES_2(A) / \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEX_OFFSET_2(A)\t(SQUASHFS_FRAGMENT_BYTES_2(A) % \\\n-\t\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEXES_2(A)\t((SQUASHFS_FRAGMENT_BYTES_2(A) + \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE - 1) / \\\n-\t\t\t\t\tSQUASHFS_METADATA_SIZE)\n-\n-#define SQUASHFS_FRAGMENT_INDEX_BYTES_2(A)\t(SQUASHFS_FRAGMENT_INDEXES_2(A) *\\\n-\t\t\t\t\t\tsizeof(int))\n-\n-#endif\n-\n-#ifdef __KERNEL__\n-\n-/*\n- * macros used to swap each structure entry, taking into account\n- * bitfields and different bitfield placing conventions on differing\n- * architectures\n- */\n-\n-#include <asm/byteorder.h>\n-\n-#ifdef __BIG_ENDIAN\n-\t/* convert from little endian to big endian */\n-#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \\\n-\t\ttbits, b_pos)\n-#else\n-\t/* convert from big endian to little endian */\n-#define SQUASHFS_SWAP(value, p, pos, tbits) _SQUASHFS_SWAP(value, p, pos, \\\n-\t\ttbits, 64 - tbits - b_pos)\n-#endif\n-\n-#define _SQUASHFS_SWAP(value, p, pos, tbits, SHIFT) {\\\n-\tb_pos = pos % 8;\\\n-\tval = 0;\\\n-\ts = (unsigned char *)p + (pos / 8);\\\n-\td = ((unsigned char *) &val) + 7;\\\n-\tfor(bits = 0; bits < (tbits + b_pos); bits += 8) \\\n-\t\t*d-- = *s++;\\\n-\tvalue = (val >> (SHIFT))/* & ((1 << tbits) - 1)*/;\\\n-}\n-\n-#define SQUASHFS_MEMSET(s, d, n)\tmemset(s, 0, n);\n-\n-#endif\n-#endif'),
 ('linux-2.6.23.orig/include/linux/squashfs_fs_i.h',
  'dev/null',
  'Index: linux-2.6.23/include/linux/squashfs_fs_i.h\n===================================================================\n--- linux-2.6.23.orig/include/linux/squashfs_fs_i.h\n+++ dev/null\n@@ -1,45 +0,0 @@\n-#ifndef SQUASHFS_FS_I\n-#define SQUASHFS_FS_I\n-/*\n- * Squashfs\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * squashfs_fs_i.h\n- */\n-\n-struct squashfs_inode_info {\n-\tlong long\tstart_block;\n-\tunsigned int\toffset;\n-\tunion {\n-\t\tstruct {\n-\t\t\tlong long\tfragment_start_block;\n-\t\t\tunsigned int\tfragment_size;\n-\t\t\tunsigned int\tfragment_offset;\n-\t\t\tlong long\tblock_list_start;\n-\t\t} s1;\n-\t\tstruct {\n-\t\t\tlong long\tdirectory_index_start;\n-\t\t\tunsigned int\tdirectory_index_offset;\n-\t\t\tunsigned int\tdirectory_index_count;\n-\t\t\tunsigned int\tparent_inode;\n-\t\t} s2;\n-\t} u;\n-\tstruct inode\tvfs_inode;\n-};\n-#endif'),
 ('linux-2.6.23.orig/include/linux/squashfs_fs_sb.h',
  'dev/null',
  'Index: linux-2.6.23/include/linux/squashfs_fs_sb.h\n===================================================================\n--- linux-2.6.23.orig/include/linux/squashfs_fs_sb.h\n+++ dev/null\n@@ -1,76 +0,0 @@\n-#ifndef SQUASHFS_FS_SB\n-#define SQUASHFS_FS_SB\n-/*\n- * Squashfs\n- *\n- * Copyright (c) 2002, 2003, 2004, 2005, 2006, 2007\n- * Phillip Lougher <phillip@lougher.demon.co.uk>\n- *\n- * This program is free software; you can redistribute it and/or\n- * modify it under the terms of the GNU General Public License\n- * as published by the Free Software Foundation; either version 2,\n- * or (at your option) any later version.\n- *\n- * This program is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- * GNU General Public License for more details.\n- *\n- * You should have received a copy of the GNU General Public License\n- * along with this program; if not, write to the Free Software\n- * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n- *\n- * squashfs_fs_sb.h\n- */\n-\n-#include <linux/squashfs_fs.h>\n-\n-struct squashfs_cache {\n-\tlong long\tblock;\n-\tint\t\tlength;\n-\tlong long\tnext_index;\n-\tchar\t\t*data;\n-};\n-\n-struct squashfs_fragment_cache {\n-\tlong long\tblock;\n-\tint\t\tlength;\n-\tunsigned int\tlocked;\n-\tchar\t\t*data;\n-};\n-\n-struct squashfs_sb_info {\n-\tstruct squashfs_super_block\tsblk;\n-\tint\t\t\tdevblksize;\n-\tint\t\t\tdevblksize_log2;\n-\tint\t\t\tswap;\n-\tstruct squashfs_cache\t*block_cache;\n-\tstruct squashfs_fragment_cache\t*fragment;\n-\tint\t\t\tnext_cache;\n-\tint\t\t\tnext_fragment;\n-\tint\t\t\tnext_meta_index;\n-\tunsigned int\t\t*uid;\n-\tunsigned int\t\t*guid;\n-\tlong long\t\t*fragment_index;\n-\tunsigned int\t\t*fragment_index_2;\n-\tchar\t\t\t*read_page;\n-\tstruct mutex\t\tread_data_mutex;\n-\tstruct mutex\t\tread_page_mutex;\n-\tstruct mutex\t\tblock_cache_mutex;\n-\tstruct mutex\t\tfragment_mutex;\n-\tstruct mutex\t\tmeta_index_mutex;\n-\twait_queue_head_t\twaitq;\n-\twait_queue_head_t\tfragment_wait_queue;\n-\tstruct meta_index\t*meta_index;\n-\tz_stream\t\tstream;\n-\tlong long\t\t*inode_lookup_table;\n-\tint\t\t\tunused_cache_blks;\n-\tint\t\t\tunused_frag_blks;\n-\tint\t\t\t(*read_inode)(struct inode *i,  squashfs_inode_t \\\n-\t\t\t\tinode);\n-\tlong long\t\t(*read_blocklist)(struct inode *inode, int \\\n-\t\t\t\tindex, int readahead_blks, char *block_list, \\\n-\t\t\t\tunsigned short **block_p, unsigned int *bsize);\n-\tint\t\t\t(*read_fragment_index_table)(struct super_block *s);\n-};\n-#endif'),
 ('linux-2.6.23.orig/init/do_mounts_rd.c',
  'linux-2.6.23/init/do_mounts_rd.c',
  'Index: linux-2.6.23/init/do_mounts_rd.c\n===================================================================\n--- linux-2.6.23.orig/init/do_mounts_rd.c\n+++ linux-2.6.23/init/do_mounts_rd.c\n@@ -5,7 +5,6 @@\n#include <linux/ext2_fs.h>\n#include <linux/romfs_fs.h>\n#include <linux/cramfs_fs.h>\n-#include <linux/squashfs_fs.h>\n#include <linux/initrd.h>\n#include <linux/string.h>\n\n@@ -40,7 +39,6 @@ static int __init crd_load(int in_fd, in\n* numbers could not be found.\n*\n* We currently check for the following magic numbers:\n- *      squashfs\n* \tminix\n* \text2\n*\tromfs\n@@ -55,7 +53,6 @@ identify_ramdisk_image(int fd, int start\nstruct ext2_super_block *ext2sb;\nstruct romfs_super_block *romfsb;\nstruct cramfs_super *cramfsb;\n-\tstruct squashfs_super_block *squashfsb;\nint nblocks = -1;\nunsigned char *buf;\n\n@@ -67,7 +64,6 @@ identify_ramdisk_image(int fd, int start\next2sb = (struct ext2_super_block *) buf;\nromfsb = (struct romfs_super_block *) buf;\ncramfsb = (struct cramfs_super *) buf;\n-\tsquashfsb = (struct squashfs_super_block *) buf;\nmemset(buf, 0xe5, size);\n\n/*\n@@ -105,18 +101,6 @@ identify_ramdisk_image(int fd, int start\ngoto done;\n}\n\n-\t/* squashfs is at block zero too */\n-\tif (squashfsb->s_magic == SQUASHFS_MAGIC) {\n-\t\tprintk(KERN_NOTICE\n-\t\t       "RAMDISK: squashfs filesystem found at block %d\\n",\n-\t\t       start_block);\n-\t\tif (squashfsb->s_major < 3)\n-\t\t\tnblocks = (squashfsb->bytes_used_2+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;\n-\t\telse\n-\t\t\tnblocks = (squashfsb->bytes_used+BLOCK_SIZE-1)>>BLOCK_SIZE_BITS;\n-\t\tgoto done;\n-\t}\n-\n/*\n* Read block 1 to test for minix and ext2 superblock\n*/')]