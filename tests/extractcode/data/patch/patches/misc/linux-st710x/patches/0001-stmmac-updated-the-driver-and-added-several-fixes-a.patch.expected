[('drivers/net/stmmac/stmmac_ethtool.c',
  'drivers/net/stmmac/stmmac_ethtool.c',
  '>From df42a30a40c84d890a9372d1316cae1b63d04b3f Mon Sep 17 00:00:00 2001\nFrom: Giuseppe Cavallaro <peppe.cavallaro@st.com>\nDate: Wed, 3 Mar 2010 15:21:03 +0100\nSubject: [PATCH] stmmac: updated the driver and added several fixes and enhancements\n\nThis patch updates the driver to the latest stable version and adds the following:\n\n1) There was a problem behind the logic used for understanding if\nthere is pending work to do in case of transmission.\nWe looked at the OWN bit instead of looking at ring pointers status\n(as the clean process does).\n2) fix the PM while resuming from another device\n3) statically fix the default coalescence parameters\n4) generate a random MAC address when invalid\n5) add a parameter to make the Magic Frame the default\nIf the device can wake-up the system adding the option below the\nMagic Frame will be automatically turned-on (it is disable by\ndefault). stmmaceth=wol:1\n\nSigned-off-by: Giuseppe Cavallaro <peppe.cavallaro@st.com>\n---\ndrivers/net/stmmac/stmmac_ethtool.c |    2 +-\ndrivers/net/stmmac/stmmac_main.c    |  102 +++++++++++++++++++++++++++--------\n2 files changed, 81 insertions(+), 23 deletions(-)\n\ndiff --git a/drivers/net/stmmac/stmmac_ethtool.c b/drivers/net/stmmac/stmmac_ethtool.c\nindex 71202b8..918bca9 100644\n--- drivers/net/stmmac/stmmac_ethtool.c\n+++ drivers/net/stmmac/stmmac_ethtool.c\n@@ -64,7 +64,7 @@ int stmmac_ethtool_getsettings(struct net_device *dev, struct ethtool_cmd *cmd)\n\nint stmmac_ethtool_setsettings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n-\tstruct stmmac_priv *priv = dev->priv;\n+\tstruct stmmac_priv *priv = netdev_priv(dev);\nstruct phy_device *phy = priv->phydev;\nint rc;\n'),
 ('drivers/net/stmmac/stmmac_main.c',
  'drivers/net/stmmac/stmmac_main.c',
  'diff --git a/drivers/net/stmmac/stmmac_main.c b/drivers/net/stmmac/stmmac_main.c\nindex dae50a4..cc3f95b 100644\n--- drivers/net/stmmac/stmmac_main.c\n+++ drivers/net/stmmac/stmmac_main.c\n@@ -110,24 +110,23 @@ static int tc = TC_DEFAULT;\nmodule_param(tc, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(tc, "DMA threshold control value");\n\n-/*\n- * These values have been set based on testing data as well as attempting\n- * to minimize response time while increasing bulk throughput. */\n-#if defined(CONFIG_STMMAC_TIMER)\n-#define RX_COALESCE\t32\n-#define TX_COALESCE\t64\n-#else\n-#define RX_COALESCE\t1\t/* Always interrupt on completion */\n-#define TX_COALESCE\t-1\t/* No moderation by default */\n+#ifdef CONFIG_PM\n+/* By deafult, WoL is off and can be turned-on by ethtool */\n+static int wol;\n+module_param(wol, int, S_IRUGO | S_IWUSR);\n+MODULE_PARM_DESC(wol, "Enable WoL throgh Magic-Frame only");\n#endif\n\n+#define RX_NO_COALESCE\t1\t/* Always interrupt on completion */\n+#define TX_NO_COALESCE\t-1\t/* No moderation by default */\n+\n/* It makes sense to combine interrupt coalescence when the timer is enabled\n* to avoid adverse effects on timing and make safe the TCP traffic.*/\n-static int rx_coalesce = RX_COALESCE;\n+static int rx_coalesce = RX_NO_COALESCE;\nmodule_param(rx_coalesce, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(rx_coalesce, "Rx irq coalescence parameter");\n\n-static int tx_coalesce = TX_COALESCE;\n+static int tx_coalesce = TX_NO_COALESCE;\nmodule_param(tx_coalesce, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(tx_coalesce, "Tx irq coalescence parameter");\n\n@@ -163,10 +162,46 @@ static int stmmac_rx(struct net_device *dev, int limit);\nextern struct ethtool_ops stmmac_ethtool_ops;\n\n/**\n+ * stmmac_init_coalescence - init the coalescence parameters\n+ * Description: initialises the coalescence parameters statically when\n+ *\t\tuse Timer optimisation.\n+ * These values have been set based on testing data as well as attempting\n+ * to minimize response time while increasing bulk throughput.\n+ * These parameters can also be tuned via sys and new values can be\n+ * used after reopening the interface (via ifconfig for example).\n+ * TODO: tunes these dynamically..\n+ */\n+static void stmmac_init_coalescence(int gmac, int mtu)\n+{\n+#ifdef CONFIG_STMMAC_TIMER\n+\t/* maybe, params passed through cmdline?!? Do not use the defaults\n+\t * values. */\n+\tif ((rx_coalesce != RX_NO_COALESCE) ||\n+\t    (tx_coalesce != TX_NO_COALESCE))\n+\t\treturn;\n+\n+\tif (gmac) {\n+\t\trx_coalesce = 32;\n+\t\ttx_coalesce = 64;\n+\n+\t\tif (unlikely(mtu > ETH_DATA_LEN)) {\n+\t\t\t/* Tests on Jumbo showed that it\'s better to\n+\t\t\t * reduce the coalescence. */\n+\t\t\trx_coalesce = 4;\n+\t\t\ttx_coalesce = 4;\n+\t\t}\n+\t} else {\n+\t\trx_coalesce = 16;\n+\t\ttx_coalesce = 32;\n+\t}\n+#endif\n+}\n+\n+/**\n* stmmac_verify_args - Check work parameters passed to the driver\n* Description: wrong parameters are replaced with the default values\n*/\n-static __inline__ void stmmac_verify_args(void)\n+static void stmmac_verify_args(void)\n{\nif (watchdog < 0)\nwatchdog = TX_TIMEO;\n@@ -175,9 +210,9 @@ static __inline__ void stmmac_verify_args(void)\nif (dma_txsize < 0)\ndma_txsize = DMA_TX_SIZE;\nif (tx_coalesce >= (dma_txsize))\n-\t\ttx_coalesce = TX_COALESCE;\n+\t\ttx_coalesce = TX_NO_COALESCE;\nif (rx_coalesce > (dma_rxsize))\n-\t\trx_coalesce = RX_COALESCE;\n+\t\trx_coalesce = RX_NO_COALESCE;\nif ((buf_sz < DMA_BUFFER_SIZE) || (buf_sz > BUF_SIZE_16KiB))\nbuf_sz = DMA_BUFFER_SIZE;\nif (flow_ctrl > 1)\n@@ -901,8 +936,7 @@ void stmmac_timer_work(struct net_device *dev)\nstruct stmmac_priv *priv = netdev_priv(dev);\n\nunsigned int rxentry = priv->cur_rx % priv->dma_rx_size;\n-\tunsigned int txentry = priv->dirty_tx % priv->dma_tx_size;\n-\tint rxret, txret;\n+\tint rxret, txret = 0;\n\n/* Look at if there is pending work to do; otherwise, do not spend\nany other time here. */\n@@ -910,12 +944,13 @@ void stmmac_timer_work(struct net_device *dev)\nif (likely(rxret == 0))\nstmmac_schedule_rx(dev);\n\n-\ttxret = priv->mac_type->ops->get_tx_owner(priv->dma_rx + txentry);\n-\tif (likely(txret == 0))\n+\tif (priv->dirty_tx != priv->cur_tx) {\n+\t\ttxret = 1;\ntasklet_schedule(&priv->tx_task);\n+\t}\n\n/* Timer will be re-started later. */\n-\tif (likely(rxret == 0) || (rxret == 0))\n+\tif (likely(!rxret) || (txret))\npriv->tm->timer_stop();\n\nreturn;\n@@ -1085,8 +1120,12 @@ static int stmmac_open(struct net_device *dev)\n* address using the following linux command:\n*      ifconfig eth0 hw ether xx:xx:xx:xx:xx:xx  */\nif (!is_valid_ether_addr(dev->dev_addr)) {\n-\t\tprintk(KERN_ERR "%s: no valid eth hw addr\\n", __FUNCTION__);\n-\t\treturn -EINVAL;\n+\t\trandom_ether_addr(dev->dev_addr);\n+\t\tprintk(KERN_WARNING "%s: generated random MAC address "\n+\t\t\t"%.2x:%.2x:%.2x:%.2x:%.2x:%.2x.\\n", dev->name,\n+\t\t\tdev->dev_addr[0], dev->dev_addr[1],\n+\t\t\tdev->dev_addr[2], dev->dev_addr[3],\n+\t\t\tdev->dev_addr[4], dev->dev_addr[5]);\n}\n\nstmmac_verify_args();\n@@ -1192,6 +1231,11 @@ static int stmmac_open(struct net_device *dev)\nif (priv->phydev)\nphy_start(priv->phydev);\n\n+#ifdef CONFIG_PM\n+\t/* This could be done by using ethtool too*/\n+\tif ((priv->wolenabled == PMT_SUPPORTED) && (wol != 0))\n+\t\tpriv->wolopts = WAKE_MAGIC;\n+#endif\nnetif_start_queue(dev);\nreturn 0;\n}\n@@ -1865,6 +1909,7 @@ static int stmmac_probe(struct net_device *dev)\n\n/* Get the MAC address */\npriv->mac_type->ops->get_umac_addr(dev->base_addr, dev->dev_addr, 0);\n+\tstmmac_init_coalescence(priv->is_gmac, dev->mtu);\n\nif (!is_valid_ether_addr(dev->dev_addr)) {\nprintk(KERN_NOTICE "No valid MAC address yet; "\n@@ -2065,7 +2110,7 @@ static int stmmac_dvr_probe(struct platform_device *pdev)\n/* Set the I/O base addr */\nndev->base_addr = (unsigned long)addr;\n\n-\t/* MAC HW revice detection */\n+\t/* MAC HW device detection */\nstmmac_mac_device_setup(ndev);\n\n/* Network Device Registration */\n@@ -2228,6 +2273,15 @@ static int stmmac_resume(struct platform_device *pdev)\ngoto out_resume;\n}\n\n+\t/* Power Down bit, into the PM register, is cleared\n+\t * automatically as soon as a magic packet or a Wake-up frame\n+\t * is received. Anyway, it\'s better to manually clear\n+\t * this bit because it can generate problems while resuming\n+\t * from another devices (e.g. serial console). */\n+\tif (device_may_wakeup(&(pdev->dev)))\n+\t\tif (priv->wolenabled == PMT_SUPPORTED)\n+\t\t\tpriv->mac_type->ops->pmt(dev->base_addr, 0);\n+\nnetif_device_attach(dev);\n\n/* Enable the MAC and DMA */\n@@ -2326,6 +2380,10 @@ static int __init stmmac_cmdline_opt(char *str)\ntx_coalesce = simple_strtoul(opt + 12, NULL, 0);\n} else if (!strncmp(opt, "rx_coalesce:", 12)) {\nrx_coalesce = simple_strtoul(opt + 12, NULL, 0);\n+#ifdef CONFIG_PM\n+\t\t} else if (!strncmp(opt, "wol:", 4)) {\n+\t\t\twol = simple_strtoul(opt + 4, NULL, 0);\n+#endif\n#ifdef CONFIG_STMMAC_TIMER\n} else if (!strncmp(opt, "tmrate:", 7)) {\ntmrate = simple_strtoul(opt + 7, NULL, 0);')]