[('linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c',
  'linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c',
  'Index: linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c\n===================================================================\n--- linux-2.6.23.orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c\n+++ linux-2.6.23/arch/sh/kernel/cpu/sh4/setup-stb7100.c\n@@ -25,7 +25,7 @@\n#include <asm/sci.h>\n#include <asm/irq-ilc.h>\n\n-static unsigned long chip_revision, chip_7109;\n+static unsigned long chip_revision, chip_7109, chip_5202=0;\nstatic struct sysconf_field *sys_cfg7_0;\n\nstatic struct plat_sci_port sci_platform_data[] = {\n@@ -103,7 +103,7 @@ void __init stx7100_configure_usb(void)\npin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);\nstpio_set_pin(pin, 0);\n}\n-\n+#ifndef CONFIG_SH_MOTOROLA_VIP19XX\n/*\n* There have been two changes to the USB power enable signal:\n*\n@@ -128,7 +128,7 @@ void __init stx7100_configure_usb(void)\n*/\npin = stpio_request_pin(5,7, "USBPWR", STPIO_OUT);\nstpio_set_pin(pin, 1);\n-\n+#endif\n#ifndef CONFIG_PM\nsc = sysconf_claim(SYS_CFG, 2, 1, 1, "usb");\nreg = sysconf_read(sc);\n@@ -735,7 +735,10 @@ void __init stb7100_configure_asc(const\nstruct platform_device *pdev;\nunsigned int *fdma_requests;\n\n-\t\tport = ascs[i] & 0xff;\n+\t\tif (chip_5202 && chip_7109)\n+\t\t\tport = 2;\n+\t\telse\n+\t\t\tport = ascs[i] & 0xff;\nflags = ascs[i] >> 8;\npdev = &stm_stasc_devices[port];\n\n@@ -815,6 +818,10 @@ void __init stx7100_early_device_init(vo\n{\nstruct sysconf_field *sc;\nunsigned long devid;\n+\tunsigned char *addr=0;\n+\tunsigned int value=0;\n+\tunsigned char *lmi_sys_addr=0;\n+\tunsigned char *lmi_vid_addr=0;\n\n/* Create a PMB mapping so that the ioremap calls these drivers\n* will make can be satisfied without having to call get_vm_area\n@@ -822,6 +829,66 @@ void __init stx7100_early_device_init(vo\n* there will be lots of devices in this range.\n*/\nioremap_nocache(0x18000000, 0x04000000);\n+\n+#ifdef CONFIG_SH_MOTOROLA_VIP19XX\n+\n+\tlmi_sys_addr = ioremap_nocache(0x0f000000, 0x01000000);\n+\tlmi_vid_addr = ioremap_nocache(0x17000000, 0x01000000);\n+\n+\tif (readl(lmi_vid_addr + 0x30)==0) {\n+\t  // The 5202 has the same DEVICE_ID as the 7109 (0x02C).\n+\t  // On the 5202 (VIP800) the LMIVID_SDRA0=0 since this chip has no video memory\n+\t  chip_5202 = 1;\n+\t}\n+\n+\tprintk(KERN_NOTICE "LMI SYS setup, fixing blue dots\\n");\n+\twritel(0x00000001, lmi_sys_addr + 0x10);\n+\twritel(0x00000003, lmi_sys_addr + 0x10);\n+\twritel(0x00000001, lmi_sys_addr + 0x10);\n+\twritel(0x00000002, lmi_sys_addr + 0x10);\n+\twritel(0x00000400, lmi_sys_addr + 0x48);\n+\twritel(0x00000133, lmi_sys_addr + 0x48);\n+\twritel(0x00000002, lmi_sys_addr + 0x10);\n+\twritel(0x00000004, lmi_sys_addr + 0x10);\n+\twritel(0x00000004, lmi_sys_addr + 0x10);\n+\twritel(0x00000004, lmi_sys_addr + 0x10);\n+\twritel(0x00000033, lmi_sys_addr + 0x48);\n+\twritel(0x00000000, lmi_sys_addr + 0x10);\n+\n+    if (!chip_5202) {\n+\t\tprintk(KERN_NOTICE "LMI VID setup, fixing blue dots\\n");\n+\t\twritel(0x00000001, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000003, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000001, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000002, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000400, lmi_vid_addr + 0x48);\n+\t\twritel(0x00000133, lmi_vid_addr + 0x48);\n+\t\twritel(0x00000002, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000004, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000004, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000004, lmi_vid_addr + 0x10);\n+\t\twritel(0x00000033, lmi_vid_addr + 0x48);\n+\t\twritel(0x00000000, lmi_vid_addr + 0x10);\n+\t}\n+\n+\t// Setup memory limiters\n+\twritel(0x061a025f, lmi_sys_addr + 0x8);\n+\twritel(0x00000005, lmi_sys_addr + 0xc);\n+\twritel(0x061a025f, lmi_vid_addr + 0x8);\n+\twritel(0x00000005, lmi_vid_addr + 0xc);\n+\n+\t// Auto precharge on low prio but not on high prio\n+\taddr = ioremap_nocache(0x19000000, 0x01000000);\n+\tvalue = readl(addr + 0x112C);\n+\tvalue |= (1 << 19);\n+\tvalue |= (1 << 21);\n+\tvalue &= ~(1 << 20);\n+\tvalue &= ~(1 << 22);\n+\twritel(value, addr + 0x112C);\n+\tiounmap(lmi_sys_addr);\n+\tiounmap(lmi_vid_addr);\n+\tiounmap(addr);\n+#endif\n\n/* Initialise PIO and sysconf drivers */\n\n@@ -835,14 +902,19 @@ void __init stx7100_early_device_init(vo\nchip_revision = (devid >> 28) + 1;\nboot_cpu_data.cut_major = chip_revision;\n\n-\tprintk("%s version %ld.x\\n",\n-\t       chip_7109 ? "STx7109" : "STx7100", chip_revision);\n+    if (chip_5202) {\n+\t\tprintk("STi5202 version %ld.x\\n", chip_revision);\n+\t}\n+\telse{\n+\t\tprintk(KERN_NOTICE "%s version %ld.x\\n",\n+\t    \t   chip_7109 ? "STx7109" : "STx7100", chip_revision);\n+\t}\n\nif (chip_7109) {\nboot_cpu_data.type = CPU_STB7109;\nsc = sysconf_claim(SYS_STA, 9, 0, 7, "devid");\ndevid = sysconf_read(sc);\n-\t\tprintk("Chip version %ld.%ld\\n", (devid >> 4)+1, devid & 0xf);\n+\t\tprintk(KERN_NOTICE "Chip version %ld.%ld\\n", (devid >> 4)+1, devid & 0xf);\nboot_cpu_data.cut_minor = devid & 0xf;\n}\n\n@@ -852,6 +924,12 @@ void __init stx7100_early_device_init(vo\nsc = sysconf_claim(SYS_CFG, 8, 1, 1, "rtc");\nsysconf_write(sc, 1);\n\n+\t/* SCIF_PIO_OUT_EN = 0 */\n+\t/* Route UART2 and PWM to PIO4 instead of SCIF */\n+\tsc = sysconf_claim(SYS_CFG, 7, 0, 0, "asc");\n+\tsysconf_write(sc, 0);\n+\tsysconf_release(sc);\n+\n/* We haven\'t configured the LPC, so the sleep instruction may\n* do bad things. Thus we disable it here. */\ndisable_hlt();')]