[('linux-2.6.23.orig/drivers/block/Makefile',
  'linux-2.6.23/drivers/block/Makefile',
  'Index: linux-2.6.23/drivers/block/Makefile\n===================================================================\n--- linux-2.6.23.orig/drivers/block/Makefile\n+++ linux-2.6.23/drivers/block/Makefile\n@@ -32,3 +32,4 @@ obj-$(CONFIG_BLK_DEV_UB)\t+= ub.o\n\nobj-$(CONFIG_XEN_BLKDEV_FRONTEND)\t+= xen-blkfront.o\nobj-$(CONFIG_LGUEST_BLOCK)\t+= lguest_blk.o\n+obj-$(CONFIG_BLK_MOTOROLA_ROOTDISK)\t+= rootdisk.o'),
 ('linux-2.6.23.orig/drivers/block/Kconfig',
  'linux-2.6.23/drivers/block/Kconfig',
  'Index: linux-2.6.23/drivers/block/Kconfig\n===================================================================\n--- linux-2.6.23.orig/drivers/block/Kconfig\n+++ linux-2.6.23/drivers/block/Kconfig\n@@ -327,6 +327,12 @@ config BLK_DEV_UB\n\nIf unsure, say N.\n\n+config BLK_MOTOROLA_ROOTDISK\n+       boolean "Motorola rootdisk block device"\n+       help\n+\t  Motorola rootdisk block device is used to mount rootdisk\n+\t  in ram, specified by cmdline rootdisk=m:<size>@<offset>\n+\nconfig BLK_DEV_RAM\ntristate "RAM disk support"\n---help---'),
 ('dev/null',
  'linux-2.6.23/drivers/block/rootdisk.c',
  'Index: linux-2.6.23/drivers/block/rootdisk.c\n===================================================================\n--- dev/null\n+++ linux-2.6.23/drivers/block/rootdisk.c\n@@ -0,0 +1,175 @@\n+/*\n+ *---------------------------------------------------------------------------\n+ *\n+ * rootdisk.c\n+ *\n+ * Linux block device driver for mapping a rootdisk in memory.\n+ *\n+ * Copyright (c) 2009-2011 Motorola, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ * notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ * notice, this list of conditions and the following disclaimer in the\n+ * documentation and/or other materials provided with the distribution.\n+ * 3. The name of the author may not be used to endorse or promote products\n+ * derived from this software without specific prior written permission.\n+ *\n+ * Alternatively, this software may be distributed under the terms of the\n+ * GNU General Public License ("GPL") version 2 as published by the Free\n+ * Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ *---------------------------------------------------------------------------\n+ */\n+\n+#include <linux/bio.h>\n+#include <linux/module.h>\n+#include <linux/moduleparam.h>\n+#include <linux/init.h>\n+#include <linux/pagemap.h>\n+#include <linux/blkdev.h>\n+#include <linux/genhd.h>\n+\n+#define ROOTDISK_MAJOR 1\n+#define ROOTDISK_MEMORY \'m\'\n+#define ROOTDISK_FLASH \'f\'\n+#define ROOTDISK_BLOCK_SIZE 512\n+\n+unsigned long rootdisk_offset = 0;\n+EXPORT_SYMBOL(rootdisk_offset);\n+unsigned long rootdisk_size = 0;\n+EXPORT_SYMBOL(rootdisk_size);\n+char rootdisk_type = ROOTDISK_FLASH;\n+EXPORT_SYMBOL(rootdisk_type);\n+\n+struct rootdisk_dev {\n+        int size;\n+        u8 *data;\n+        short users;\n+        spinlock_t lock;\n+        struct request_queue *queue;\n+        struct gendisk *gd;\n+};\n+\n+struct rootdisk_dev rdev;\n+\n+static int rootdisk_ioctl (struct inode *inode, struct file *filp,\n+                    unsigned int cmd, unsigned long arg)\n+{\n+        return -ENOTTY; /* unknown command */\n+}\n+\n+static int rootdisk_open(struct inode *inode, struct file *filp)\n+{\n+\n+        filp->private_data = &rdev;\n+        spin_lock(&rdev.lock);\n+        rdev.users++;\n+        spin_unlock(&rdev.lock);\n+        return 0;\n+}\n+\n+static void rootdisk_transfer(struct rootdisk_dev *dev, unsigned long sector,\n+                              unsigned long nsect, char *buffer, int write)\n+{\n+        unsigned long offset = sector*ROOTDISK_BLOCK_SIZE;\n+        unsigned long nbytes = nsect*ROOTDISK_BLOCK_SIZE;\n+        if ((offset + nbytes) > dev->size) {\n+                printk (KERN_NOTICE "Beyond-end write (%ld %ld)\\n", offset, nbytes);\n+                return;\n+        }\n+\n+        if (write)\n+                memcpy(dev->data + offset, buffer, nbytes);\n+        else\n+                memcpy(buffer, dev->data + offset, nbytes);\n+}\n+\n+static void rootdisk_request(struct request_queue *q)\n+{\n+        struct request *req;\n+        while ((req = elv_next_request(q)) != NULL) {\n+                struct rootdisk_dev *dev = req->rq_disk->private_data;\n+                if (! blk_fs_request(req)) {\n+                        printk (KERN_NOTICE "Skip non-fs request\\n");\n+                        end_request(req, 0);\n+                        continue;\n+                }\n+                rootdisk_transfer(dev, req->sector, req->current_nr_sectors,\n+                                  req->buffer, rq_data_dir(req));\n+                end_request(req, 1);\n+        }\n+}\n+\n+static int __init early_setup_rootdisk(char *str)\n+{\n+        if (sscanf(str,"%c:0x%lx@0x%lx",\n+                   &rootdisk_type, &rootdisk_size, &rootdisk_offset) != 3) {\n+                printk(KERN_WARNING "Invalid format of rootdisk parameter, should be [mf]:<size>@<offset>\\n");\n+        }\n+\treturn 0;\n+}\n+early_param("rootdisk", early_setup_rootdisk);\n+\n+static struct block_device_operations rootdisk_bd_op = {\n+\t.owner =\tTHIS_MODULE,\n+\t.open =\t\trootdisk_open,\n+\t.ioctl =\trootdisk_ioctl,\n+};\n+\n+static int __init rootdisk_init(void)\n+{\n+        if (rootdisk_type == \'m\') {\n+                memset(&rdev, 0, sizeof(struct rootdisk_dev));\n+                spin_lock_init(&rdev.lock);\n+                rdev.queue = blk_init_queue(rootdisk_request, &rdev.lock);\n+                rdev.data = (u8*)rootdisk_offset;\n+                rdev.size = rootdisk_size;\n+\n+                rdev.gd = alloc_disk(1);\n+                rdev.gd->major = ROOTDISK_MAJOR;\n+                rdev.gd->first_minor = 0;\n+                rdev.gd->fops = &rootdisk_bd_op;\n+                rdev.gd->queue = rdev.queue;\n+                rdev.gd->private_data = &rdev;\n+                snprintf (rdev.gd->disk_name, 32, "rootdisk%d", 0);\n+                blk_queue_hardsect_size(rdev.queue, ROOTDISK_BLOCK_SIZE);\n+                set_capacity(rdev.gd, rootdisk_size / ROOTDISK_BLOCK_SIZE);\n+                add_disk(rdev.gd);\n+\n+                if (register_blkdev(ROOTDISK_MAJOR, "rootdisk")) {\n+                        return -EIO;\n+                }\n+                printk(KERN_DEBUG "Added Motorola rootdisk, %s (0x%08x@0x%p)\\n",\n+                       rdev.gd->disk_name, rdev.size, rdev.data);\n+\n+        }\n+        return 0;\n+}\n+\n+static int __exit rootdisk_cleanup(void)\n+{\n+        return 0;\n+}\n+\n+module_init(rootdisk_init);\n+module_exit(rootdisk_cleanup);\n+\n+MODULE_LICENSE("GPL");\n+MODULE_AUTHOR("Jonas Wid\xc3\xa9n <wjo022@motorola.com>");\n+MODULE_DESCRIPTION("Linux block device driver for mapping a rootdisk in memory");'),
 ('linux-2.6.23.orig/arch/sh/kernel/setup.c',
  'linux-2.6.23/arch/sh/kernel/setup.c',
  'Index: linux-2.6.23/arch/sh/kernel/setup.c\n===================================================================\n--- linux-2.6.23.orig/arch/sh/kernel/setup.c\n+++ linux-2.6.23/arch/sh/kernel/setup.c\n@@ -96,7 +96,11 @@ EXPORT_SYMBOL(memory_start);\nunsigned long memory_end;\nEXPORT_SYMBOL(memory_end);\nunsigned long ramtopaddress=0;\n-\n+#ifdef CONFIG_BLK_MOTOROLA_ROOTDISK\n+extern unsigned long rootdisk_offset;\n+extern unsigned long rootdisk_size;\n+extern char rootdisk_type;\n+#endif\nstatic int __init early_parse_mem(char *p)\n{\nunsigned long size;\n@@ -233,6 +237,15 @@ void __init setup_bootmem_allocator(unsi\n\n/* Reserve mem for the ST DSP */\nreserve_bootmem(__MEMORY_START, dsp_mem_size);\n+#ifdef CONFIG_BLK_MOTOROLA_ROOTDISK\n+\tif (rootdisk_type == \'m\' &&\n+\t    rootdisk_offset != 0 && rootdisk_size !=0) {\n+\t  printk(KERN_DEBUG "Reserve memory for Motorola rootdisk\\n");\n+\t  reserve_bootmem(__MEMORY_START +\n+\t\t\t  (rootdisk_offset & ~CONFIG_PAGE_OFFSET),\n+\t\t\t  rootdisk_size + (PAGE_SIZE - (rootdisk_size % PAGE_SIZE)));\n+\t}\n+#endif\n#ifndef CONFIG_CPU_SUBTYPE_STX7105\n/* Reserve mem for STAPI usage and for the common_data_header\n* The common data header is 4096 bytes (PAGE_SIZE)')]