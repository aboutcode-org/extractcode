[('linux-orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c',
  'linux/arch/sh/kernel/cpu/sh4/setup-stb7100.c',
  '--- linux-orig/arch/sh/kernel/cpu/sh4/setup-stb7100.c\n+++ linux/arch/sh/kernel/cpu/sh4/setup-stb7100.c\n@@ -193,7 +193,7 @@\npin = stpio_request_pin(5,6, "USBOC", STPIO_OUT);\nstpio_set_pin(pin, 0);\n}\n-\n+#ifndef CONFIG_SH_MOTOROLA_VIP19XX\n/*\n* There have been two changes to the USB power enable signal:\n*\n@@ -218,6 +218,6 @@\n*/\npin = stpio_request_pin(5,7, "USBPWR", STPIO_OUT);\nstpio_set_pin(pin, 1);\n-\n+#endif\nsc = sysconf_claim(SYS_CFG, 2, 1, 1, "usb");\nreg = sysconf_read(sc);\n@@ -1082,6 +1115,41 @@\nstruct sysconf_field *sc;\nunsigned long devid;\n\n+/*\n+        unsigned int value;\n+        // Stop TX and RX DMA since if they are up and running they\n+        // can cause memory overwrites in i.e. tmpfs.\n+        printk("stmmac: Stop RX and TX DMA\\n");\n+        value = (unsigned int)readl(0xf8111018);\n+        value &= ~0x00002000;\n+        value &= ~0x00000002;\n+        writel(value, 0xf8111018);\n+\n+        // Setup memory limiters\n+        ctrl_outl(0x061a025f, 0xef000008);\n+        ctrl_outl(0x00000005, 0xef00000c);\n+        ctrl_outl(0x061a025f, 0xf7000008);\n+        ctrl_outl(0x00000005, 0xf700000c);\n+\n+        // Auto precharge on low prio but not on high prio\n+\tsc = sysconf_claim(SYS_CFG, 11, 19, 22, "precharge");\n+\tsysconf_write(sc, 5);\n+\n+        // STBUS priorities\n+        ctrl_outl(1, 0xf9216200);\n+        ctrl_outl(5, 0xf9216204);\n+        ctrl_outl(3, 0xf9216208);\n+        ctrl_outl(2, 0xf921620c);\n+        ctrl_outl(4, 0xf9216210);\n+        ctrl_outl(4, 0xf9243000);\n+        ctrl_outl(3, 0xf9243004);\n+        ctrl_outl(2, 0xf9243008);\n+        ctrl_outl(1, 0xf924300c);\n+        ctrl_outl(5, 0xf9243010);\n+\n+*/\n+\n+\n/* Create a PMB mapping so that the ioremap calls these drivers\n* will make can be satisfied without having to call get_vm_area\n* or cause a fault. Its probably also a good for efficiency as')]