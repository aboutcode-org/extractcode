[('linux-2.6.23/arch/sh/kernel/head.S_org',
  'linux-2.6.23/arch/sh/kernel/head.S',
  '--- linux-2.6.23/arch/sh/kernel/head.S_org\n+++ linux-2.6.23/arch/sh/kernel/head.S\n@@ -14,33 +14,59 @@\n#include <asm/thread_info.h>\n\n#ifdef CONFIG_CPU_SH4A\n-#define SYNCO()\t\tsynco\n+#define SYNCO()                synco\n\n-#define PREFI(label, reg)\t\\\n-\tmov.l\tlabel, reg;\t\\\n-\tprefi\t@reg\n+#define PREFI(label, reg) \\\n+        mov.l        label, reg; \\\n+        prefi        @reg\n#else\n#define SYNCO()\n#define PREFI(label, reg)\n#endif\n\n-\t.section\t.empty_zero_page, "aw"\n+#ifdef CONFIG_32BIT\n+.macro  SEND_UART_CHAR val\n+1:      mov.w        @(0x10,r13), r0 ! Wait for UART to finish\n+        tst          #0x02,r0\n+        bt           1b\n+        mov          #(\\val &0x00FF), r0 ! Send val\n+        mov.w        r0, @(0x00,r13)\n+.endm\n+\n+.macro  SEND_UART_BUFFER addr\n+        mov.l        (\\addr), r0\n+        mov          r0,r1\n+1:      mov.w        @(0x10,r13), r0 ! Wait for UART to finish\n+        tst          #0x02,r0\n+        bt           1b\n+        mov.b        @r1,r0\n+        tst          #0xff,r0\n+        bt           2f\n+        mov.b        r0, @(0x00,r13)\n+        add          #1,r1\n+        bra 1b\n+        nop\n+2:\n+.endm\n+#endif\n+\n+        .section        .empty_zero_page, "aw"\nENTRY(empty_zero_page)\n-\t.long\t1\t\t/* MOUNT_ROOT_RDONLY */\n-\t.long\t0\t\t/* RAMDISK_FLAGS */\n-\t.long\t0x0200\t\t/* ORIG_ROOT_DEV */\n-\t.long\t1\t\t/* LOADER_TYPE */\n-\t.long\t0x00000000\t/* INITRD_START */\n-\t.long\t0x00000000\t/* INITRD_SIZE */\n+        .long        1                      /* MOUNT_ROOT_RDONLY */\n+        .long        0                      /* RAMDISK_FLAGS */\n+        .long        0x0200                 /* ORIG_ROOT_DEV */\n+        .long        1                      /* LOADER_TYPE */\n+        .long        0x00000000             /* INITRD_START */\n+        .long        0x00000000             /* INITRD_SIZE */\n#ifdef CONFIG_32BIT\n-\t.long\t0x53453f00 + 32\t/* "SE?" = 32 bit */\n+        .long        0x53453f00 + 32        /* "SE?" = 32 bit */\n#else\n-\t.long\t0x53453f00 + 29\t/* "SE?" = 29 bit */\n+        .long        0x53453f00 + 29        /* "SE?" = 29 bit */\n#endif\n1:\n-\t.skip\tPAGE_SIZE - empty_zero_page - 1b\n+        .skip        PAGE_SIZE - empty_zero_page - 1b\n\n-\t.section\t.text.head, "ax"\n+        .section     .text.head, "ax"\n\n/*\n* Condition at the entry of _stext:\n@@ -54,6 +80,853 @@\n*\n*/\nENTRY(_stext)\n+#ifndef JTAG_DEBUGGING\n+#if defined(CONFIG_32BIT) && !defined(CONFIG_CPU_SUBTYPE_STX7105)\n+\n+\n+/*\n+Normally the setup of 32 bit memory is done when executing in flash which would\n+be done at the very first steps in the RBL. But since we already manufactured\n+units which used 29 bit adressing in RBL and DBL we have to handle this swich\n+while running in RAM before we can execute the new 32 bit Linux. Note that it\n+is not possible to change the RBL on units in the field since it is sometimes\n+locked in OTP and we shouldn\'t change the RBL anyway since the units will be\n+destroyed if we get a power loss during programming.\n+\n+The code below swithes from 29 bit adressing mode to 32 bit addressing while\n+running in RAM. On a CPU with MES enabled we are facing the following problems:\n+1) The memory will be scrambled when changing the mem base addr due to the MES\n+2) The PC will not be valid after the base addr change\n+3) The Linux kernel must be moved up 64 MB to be valid after the addr change\n+\n+The solution is to use the video memory as a temporary execution point and\n+storage during the base addr change as described in step A - V below.\n+\n+A STi5202 cannot use the steps A - V below since it does not have a video mem.\n+Instead we use the execution cache as a temporary memory during the base addr\n+change. The code below uses this mode for non MES versions of the STi7109 since\n+this is much faster and the picture will only be black for 100 ms instead of 1\n+sec. For non MES STi7109 and STi5202 the steps taken are A,B,P,H,F,G,Q,R,U.\n+\n+The procedure to change to 32 bit mode while running in RAM would be:\n+A.Initialize the PMB array\n+  Before the Space Enhanced mode bit can be turned on we need to setup the PBM\n+  otherwise the CPU will reboot. The PMB (Priviliged Mapping Buffer) is the new\n+  translation table which translates the 32 bit addresses in into physical memory\n+\n+B.Stop GDP1 and GDP3\n+  The graphic engine is using the memory and will crach if it is turned on while\n+  changing the memory base address so we need to turn this off during the\n+  transition. This will make the picture black for 1 second.\n+\n+C.Setup the MES for the whole address space\n+  This is needed on system with the MES turned on, like the Conax version.\n+\n+D.Copy the code below to video memory\n+  In order to change the base address of the system memory we need to be\n+  executing in the video memory. This step copies the code to the upper part\n+  of the video memory.\n+\n+E.Jump to the code in video memory\n+  Start executing in the video memory\n+\n+F.Modify the UBA value of the system LMI register to be valid in the 32 bit\n+  memory layout.The LMI registers must be modifed to be valid in the new system\n+  memory layout\n+\n+G.Move system memory to the new memory layout\n+  Now it\'s time to change the actual base address for the system memory\n+\n+H.Enter Space Enhanced Mode\n+  Now we can finally turn on the Space Enhanced mode which is the new 32 bit\n+  mode which uses the PMB\n+\n+I.Copy video mem (32 MB) to sys mem (sys new location)\n+  Make a copy of the whole video memory into a temporary location in the system\n+  memory. This is needed on systems with the MES turned on (Like the Conax CPU)\n+  since the memory is encrypted with an address dependent XOR value the memory\n+  content will be scambled when chaning the base address. The wolution is to\n+  copy the mem content back and forth between the system mem and the video mem.\n+\n+J.Move back system memory to the old memory layout\n+  We need to temporary change back to the old base address (0x04000000) to be\n+  able to make a backup of Linux and Ramtopaddress due to the MES\n+\n+K.Backup ramtopaddress area from sys mem to video mem\n+  Make a backup of ramtopaddress due to the MES\n+\n+M.Backup the first 6 MB (Linux kernel) to video memory\n+  Make a backup of Linux due to the MES\n+\n+N.Move system memory to the new memory layout (again!)\n+  Now we can set the system memory back to its final location (0x40000000)\n+\n+O.Copy back ramtopaddress area from video mem to sys mem\n+  Copy back the ramtopaddress due to the MES\n+\n+P.Copy back the linux kernel from video mem to sys mem (new location). This is\n+  where we will execute in 32 bit mode Copy back the Linux kernel due to the\n+  MES. This is actually also needed due to the fact that Linux will move\n+  64 MB up in the memory. The old memory starts at 0x84000000 but the new\n+  memory starts at 0x80000000 and since the Linux code is linked to 0x84000000\n+  (to be compatible with 29 bit addressing too) we need to copy Linux to\n+  0x84000000 before we can start executing the code as intended by the linker.\n+\n+Q.Continue in System memory (Where the linker put it)\n+  Now the memory is back where it should be in the system memory and we can\n+  start executing from there\n+\n+R.Fixup the GAM_GDP1_NVN/GAM_GDP3_NVN for the new memory layout\n+  Since the system memory now is back in it\'s final position we can turn on\n+  the graphics again\n+\n+S.Modify the UBA value of the system LMI register to be valid in the 32 bit\n+  memory layout. We need to adjust the LMI registers for the video memory too\n+\n+T.Move video memory to the new memory layout\n+  Change the base address of the video memory\n+\n+U.Modify the PMB because video memory move\n+  We need to modify the PMB so that the code below can access it now when the\n+  video memory has changed to its new location (0x60000000)\n+\n+V.Copy back the video mem from system memory\n+\n+\n+An other feature of the code below is the automatic detection of the CPU type.\n+Since the STb7100 CPU does not support the Space Enhanced mode we just start\n+executing Linux anyway. This works since Linux is compiled for the base address\n+0x84000000 which is valid for both 29 bit and 32 bit addressing modes. All\n+differences between the 29 bit addressing and 29 bit addressing must be handled\n+in run time in the Linux kernel too to make this work. All units which are\n+alredy running 32 bit mode when entering this code will just start this code\n+and start Linux normally. This is what we should use on all new model.\n+\n+For further details on this 29 to 32 bit mode swithing code please contact:\n+Tomas Franzon, tomas.franzon@motorola.com\n+\n+*/\n+        mov.l        MMUCR, r12\n+        mov.l        @r12, r0\n+        tst          #0x10,r0\n+        bf           RUNNING_32BIT\n+        nop\n+\n+        mov.l        DEVICE_ID, r12\n+        mov.l        @r12, r0\n+        shlr2        r0\n+        shlr2        r0\n+        shlr8        r0\n+        mov.l        DEVICE_ID_MASK, r13\n+        and          r13,r0\n+        cmp/eq       #0x24,r0\n+        bt           RUNNING_29BIT_7100\n+        nop\n+\n+        bra          SE_START\n+        nop\n+\n+RUNNING_29BIT_7100:\n+! The CPU is already running 32 bit mode\n+        mov.l        UART_REG, r13\n+! Message: Running 29 bit Mode\n+        SEND_UART_BUFFER(mess_29_bit_7100)\n+\n+        bra          SE_END\n+        nop\n+\n+RUNNING_32BIT:\n+! The CPU is already running 32 bit mode\n+        mov.l        UART_REG, r13\n+! Message: Running 32 bit Mode\n+        SEND_UART_BUFFER(mess_32_bit)\n+        bra          SE_END\n+        nop\n+\n+SE_START:\n+! Setup UART\n+        mov.l        UART_REG, r13\n+\n+! Message: Entering Space Enhanced Mode (32 bit)\n+        SEND_UART_BUFFER(mess_enter_se)\n+\n+        ! Set-up cache\n+        mov.l        CCR, r1\n+        mov.l        CCR_val, r5\n+        mov.l        r5, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+\n+! Turn off the Ethernet DMA.\n+! This is a bug workaround for 7109 boards with old Firmware\n+! We need to do this as early as possible beacuse if an ethernet packet\n+! arrives we the box might crach\n+\t\tmov          #0,r0\n+        mov.l        ETH_DMA_CTRL, r1\n+        mov.l        r0,@r1\n+! Disable video mem MES\n+        mov.l        MES_ENCRYPT_ALL_VID, r1\n+        mov.l        r0, @(0x08,r1)\n+\n+! Stop GDP1 and GDP3\n+        mov.l        MIX1, r2\n+        mov.l        @r2, r1         ! r1 is assigned to gdb_original_state later\n+        ! Store original gdp (gdp1) status (the way firmware left it)\n+        mova         mix1_original_state, r0\n+        mov.l        r1, @r0\n+        mov          #0, r3\n+        mov.l        r3,@r2\n+        mov.l        MIX2, r2\n+\n+        mov.l        @r2, r1\n+        mova         mix2_original_state, r0\n+        mov.l        r1, @r0\n+\n+        mov.l        r3,@r2\n+\n+! Wait enough time for the GDPs to be stopped (~50ms)\n+        mov.l        MIX_D_LOOP, r2\n+2:      add          #-1,r2\n+        mov          #0, r3\n+        cmp/eq       r3,r2\n+        bf           2b\n+        nop\n+\n+! Initialize the PMB array\n+        mov          #0, r1\n+        mov.l        PMB_DATA_ARRAY, r7\n+        mov.l        PMB_ADDR_ARRAY, r8\n+        mova         PMB_DATA_ARRAY_val, r0\n+        mov          r0,r9\n+        mova         PMB_ADDR_ARRAY_val, r0\n+        mov          r0,r4\n+1:      mov          r1,r0\n+        shll2        r0\n+        mov.l        @(r0,r9),r5\n+        mov.l        @(r0,r4),r3\n+        mov          r1,r0\n+        shll8        r0\n+        mov.l        r3, @(r0,r8)\n+        mov.l        r5, @(r0,r7)\n+        add          #1, r1\n+        mov          #16, r0\n+        cmp/eq       r1, r0\n+        bf           1b\n+! PMB init end\n+\n+! Check if CPU is STi5202 by checking if LMIVID=0\n+        mov.l        LMIVID_SDRA, r12\n+        mov.l        @(0x00,r12), r0\n+        cmp/eq       #0, r0\n+        bt           SwitchUsingCache\n+        nop\n+\n+\n+! Check if MES exists by writing to video mem (disabled above)\n+! and reading the ENCRYPT_ALL_ERR bit\n+        mov.l        VID_ADDR_NO_CACHE, r3\n+        mov.l        @r3,r0 ! Try to read from Video mem\n+\n+        mov.l        MES_ENCRYPT_ALL_VID_STATUS, r3\n+        mov.l        @(0x00,r3),r0\n+        tst          #0x40,r0  ! Check if ENCRYPT_ALL_ERR occured\n+        bt           SwitchUsingCache\n+        nop\n+! Setup the MES for the whole address space\n+        mov          #0x00000000, r0\n+        mov          #0xFFFFFFFF, r2\n+        mov.l        MES_ENCRYPT_ALL_SYS, r1\n+        mov.l        r0, @(0x04,r1)\n+        mov.l        r2, @(0x08,r1)\n+        mov.l        MES_ENCRYPT_ALL_VID, r1\n+        mov.l        r0, @(0x04,r1)\n+        mov.l        r2, @(0x08,r1)\n+! MES updated\n+\n+        bra          SwitchUsingVideoMem\n+        nop\n+\n+SwitchUsingCache:\n+\n+! Copy the first 6 MB (Linux kernel) 64 MB up in sys memory\n+        mov.l        SYS_ADDR_OLD, r8\n+        mov.l        SYS_ADDR_NEW, r7\n+        mov.l        SYS_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 6MB copy end\n+\n+! Switch to A4xxxxxx address\n+        mova         RunInA4Addr,r0\n+        mov.l        A4_ADDR_MASK, r1\n+        or           r1,r0\n+        jmp          @r0\n+        nop\n+\n+        .balign      4\n+RunInA4Addr:\n+! Switch end\n+\n+! Setup registers to be used after MMUCR.SE\n+        mov.l        SYS_CFG36, r8\n+        mov.l        SYS_CFG36_VID, r9\n+        mov.l        LMISYS_SDRA, r10\n+        mov.l        @(0x00,r10),r12\n+        mov.l        LMI_UBA_MASK, r0\n+        and          r0,r12\n+        mov.l        LMISYS_SDRA_UBA, r0\n+        or           r0,r12\n+        mov.l        SYSTEM_MEM_CODE_label, r0\n+        mov          r0,r7\n+\n+! Enter Space Enhanced Mode\n+        mov.l        CCN_MMUCR, r1\n+        mov          #0x10, r0\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        mov.l        r0, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+\n+! Modify the UBA value of the system LMI register to be valid in the 32 bit memory layout\n+!        SEND_UART_CHAR (\'a\')\n+!        SEND_UART_CHAR (\'b\')\n+        mov.l        r12, @(0x00,r10)\n+        mov.l        r12, @(0x08,r10)\n+\n+! Move system memory to the new memory layout\n+        mov.l        r9, @r8\n+! Move end\n+        mov          #1, r12 ! 1=5202/7109 using cache\n+\n+! Continue in memory (Where the linker put it)\n+        mov          r7,r0\n+        jmp          @r0\n+        nop\n+\n+        .balign 4\n+mess_29_bit_7100:    .long      mess_29_bit_7100_val\n+mess_32_bit:         .long      mess_32_bit_val\n+mess_enter_se:       .long      mess_enter_se_val\n+\n+\n+SwitchUsingVideoMem:\n+\n+! Copy the code below to video memory\n+        mov.l        VID_ADDR, r7\n+        mova         VIDEO_MEM_CODE, r0\n+        mov          r0,r8\n+        mova         COPY_END, r0\n+        mov          r0,r9\n+        sub          r8,r9\n+\n+        shlr2        r9\n+        add          #4,r9\n+1:\n+        dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! copy end\n+\n+! Jump to the code in video memory\n+        mov.l        VID_ADDR, r0\n+        jmp          @r0\n+        nop\n+\n+        .balign 4\n+ENTRY(VIDEO_MEM_CODE)\n+\n+! Modify the UBA value of the system LMI register to be valid in the 32 bit memory layout\n+        mov.l        LMISYS_SDRA, r10\n+        mov.l        @(0x00,r10),r2\n+        mov          r2,r6\n+        mov.l        LMI_UBA_MASK, r0\n+        and          r0,r2\n+        mov.l        LMISYS_SDRA_UBA, r0\n+        or           r0,r2\n+        mov.l        r2, @(0x00,r10)\n+        mov.l        r2, @(0x08,r10)\n+        mov          r2,r12\n+\n+! Move system memory to the new memory layout\n+        mov.l        SYS_CFG36, r3\n+        mov.l        SYS_CFG36_SYS, r2\n+        mov.l        @r3, r4 ! r4 = old layout\n+        mov.l        r2, @r3\n+! Move end\n+\n+! Enter Space Enhanced Mode\n+        mov.l        CCN_MMUCR, r1\n+        mov          #0x10, r0\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        mov.l        r0, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+\n+! Copy video mem (32 MB) to sys mem (sys new location)\n+        mov.l        VID_ADDR, r8\n+        mov.l        SYS_ADDR_VIDEO_COPY_SE, r7\n+        mov.l        VID_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 16MB copy end\n+\n+! Move back system memory to the old memory layout\n+        mov.l        r4, @r3\n+        mov.l        r6, @(0x00,r10)\n+        mov.l        r6, @(0x08,r10)\n+! Move end\n+\n+! Backup ramtopaddress area from sys mem to video mem\n+        mov.l        SYS_RAMTOPADDRESS_ADDR29, r8\n+        mov.l        VID_ADDR_RAMTOPADDRESS_BACKUP, r7\n+        mov.l        RAMTOPADDRESS_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 10MB copy end\n+\n+! Backup the first 6 MB (Linux kernel) to video memory\n+        mov.l        SYS_ADDR_OLD29, r8\n+        mov.l        VID_ADDR_LINUX_BACKUP, r7\n+        mov.l        SYS_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 6MB copy end\n+\n+! Move system memory to the new memory layout (again!)\n+        mov.l        r2, @r3\n+        mov.l        r12, @(0x00,r10)\n+        mov.l        r12, @(0x08,r10)\n+! Move end\n+\n+! Copy back ramtopaddress area from video mem to sys mem\n+        mov.l        VID_ADDR_RAMTOPADDRESS_BACKUP, r8\n+        mov.l        SYS_RAMTOPADDRESS_ADDR2, r7\n+        mov.l        RAMTOPADDRESS_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 10MB copy end\n+\n+! Copy back the linux kernel from video mem to sys mem (new location). This is where we will execute in 32 bit mode\n+        mov.l        VID_ADDR_LINUX_BACKUP, r8\n+        mov.l        SYS_ADDR_OLD, r7\n+        mov.l        SYS_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 16MB copy end\n+\n+! Continue in System memory (Where the linker put it)\n+        mov          #2, r12 ! 2=7109 with MES\n+        mov.l        SYSTEM_MEM_CODE_label, r0\n+        jmp          @r0\n+        nop\n+\n+        .balign      4\n+SYSTEM_MEM_CODE:\n+\n+        ! Turn off cache\n+        mov.l        CCR, r1\n+        mov          #0, r5\n+        mov.l        r5, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+\n+! Wait before starting the GDPs (~ 1 - 2 sec)\n+        mov.l        MIX_D_LOOP2, r2\n+2:      add          #-1,r2\n+        mov          #0, r3\n+        cmp/eq       r3,r2\n+        bf           2b\n+        nop\n+\n+! Fixup the GAM_GDP1_NVN/GAM_GDP3_NVN for the new memory layout\n+\n+        mov.l        NVN_MEM_DIFF, r2\n+        mov.l        GAM_MEM_BASE,r6\n+!    Reenable GDP1 (main output)\n+        mov.l        GAM_GDP1_NVN, r4\n+        mov.l        @r4, r0\n+        cmp/eq       #0, r0\n+        bt           1f\n+        nop\n+        add          r2,r0\n+        mov.l        r0, @r4\n+        add          r6, r0\n+        mov.l        @(0x14,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x14,r0)\n+        mov.l        @(0x24,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x24,r0)\n+1:\n+!    Reenable GDP3 (aux output)\n+        mov.l        GAM_GDP3_NVN, r4\n+        mov.l        NVN_MEM_DIFF, r2\n+        mov.l        @r4, r0\n+        cmp/eq       #0, r0\n+        bt           1f\n+        nop\n+        add          r2,r0\n+        mov.l        r0, @r4\n+        add          r6, r0\n+        mov.l        @(0x14,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x14,r0)\n+        mov.l        @(0x38,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x38,r0)\n+        mov.l        @(0x24,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x24,r0)\n+        mov          r3,r0\n+        mov.l        @(0x14,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x14,r0)\n+        mov.l        @(0x38,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x38,r0)\n+        mov.l        @(0x24,r0),r3\n+        add          r2,r3\n+        mov.l        r3,@(0x24,r0)\n+\n+! Turn the GDP1 and GDP3 back on\n+        mov.l        mix1_original_state, r3\n+        mov.l        MIX1,r4\n+        mov.l        r3,@r4\n+        mov.l        mix2_original_state, r3\n+        mov.l        MIX2,r4\n+        mov.l        r3,@r4\n+1:\n+!!!\n+\n+! Check if CPU is STi5202 by checking if LMIVID=0\n+        mov.l        LMIVID_SDRA, r1\n+        mov.l        @(0x00,r1), r0\n+        cmp/eq       #0, r0\n+        bt           SE_END_PART\n+        nop\n+\n+MODIFY_VID_MEM:\n+! Modify the UBA value of the system LMI register to be valid in the 32 bit memory layout\n+        mov.l        LMIVID_SDRA, r1\n+        mov.l        @(0x00,r1),r2\n+        mov.l        LMI_UBA_MASK, r0\n+        and          r0,r2\n+        mov.l        LMIVID_SDRA_UBA, r0\n+        or           r0,r2\n+        mov.l        r2, @(0x00,r1)\n+        mov.l        r2, @(0x08,r1)\n+\n+! Check if we executed video mem\n+        mov          r12,r0\n+        cmp/eq       #0x02,r0\n+        bf           SE_END_PART\n+        nop\n+\n+! Move video memory to the new memory layout\n+        mov.l        SYS_CFG36, r1\n+        mov.l        SYS_CFG36_VID, r0\n+        mov.l        r0, @r1\n+\n+! Modify the PMB because video memory move\n+        mov.l        PMB_DATA_ARRAY2, r1\n+        mov.l        PMB_DATA_ARRAY_VID, r0\n+        mov.l        r0, @r1\n+\n+! Set-up cache (again!)\n+        mov.l        CCR, r1\n+        mov.l        CCR_val, r5\n+        mov.l        r5, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+\n+! Copy back the video mem from system memory\n+        mov.l        SYS_ADDR_VIDEO_COPY_SE, r8\n+        mov.l        VID_ADDR, r7\n+        mov.l        VID_COPY_SIZE, r9\n+1:      dt           r9\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        mov.l        @r8+,r5\n+        mov.l        r5, @r7\n+        add          #4,r7\n+        bf           1b\n+        nop\n+! 16MB copy end\n+\n+SE_END_PART:\n+        mov.l        UART_REG, r13\n+! Message: Running 32 bit Mode\n+        SEND_UART_BUFFER(mess_32_bit2)\n+\n+! Clear the PMB array. Leave only sys mem for Linux\n+        mov          #0, r1\n+        mov          #0, r5\n+        mov.l        PMB_DATA_ARRAY2, r7\n+1:      mov          r1,r0\n+        shll8        r0\n+        mov.l        r5, @(r0,r7)\n+        add          #1, r1\n+        mov          #15, r0\n+        cmp/eq       r1, r0\n+        bf           1b\n+        nop\n+! PMB init end\n+\n+!Setup cache suitable for Linux\n+        mov.l        CCR, r1\n+        mov.l        CCR_LINUX, r5\n+        mov.l        r5, @r1\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+        nop\n+!cache end\n+\n+        bra SE_END\n+        nop\n+\n+        .balign 4\n+MMUCR:               .long        0xFF000010\n+ETH_DMA_CTRL:        .long        0xB8111018\n+DEVICE_ID:           .long        0xb9001000\n+DEVICE_ID_MASK:      .long        0x000003FF\n+LMISYS_SDRA:         .long        0xAF000030\n+LMIVID_SDRA:         .long        0xB7000030\n+LMISYS_SDRA_UBA:     .long        0x50000000\n+LMIVID_SDRA_UBA:     .long        0x64000000\n+LMI_UBA_MASK:        .long        0x001FFFFF\n+UART_REG:            .long        0xB8031004\n+GAM_GDP1_NVN:        .long        0xB920A124\n+GAM_GDP3_NVN:        .long        0xB920A324\n+NVN_MEM_DIFF:        .long        0x40000000 - 0x04000000\n+GAM_MEM_BASE:        .long        0x40000000\n+MIX1:                .long        0xb920ac00\n+MIX2:                .long        0xb920ad00\n+VID_ADDR:            .long        0x90000000\n+VID_ADDR_NO_CACHE:   .long        0xB0000000\n+MIX_D_LOOP:          .long        0x00250000 ! ~50ms\n+MIX_D_LOOP2:         .long        0x00020000 ! ~100ms\n+MES_ENCRYPT_ALL_SYS: .long        0xB9500050\n+MES_ENCRYPT_ALL_VID: .long        0xB9508050\n+MES_ENCRYPT_ALL_VID_STATUS: .long 0xB9508004\n+CCR:                 .long        0xFF00001C\n+CCR_val:             .long        0x8000010B\n+CCR_LINUX:           .long        0x80000105\n+mix1_original_state: .long        0\n+mix2_original_state: .long        0\n+\n+PMB_DATA_ARRAY:      .long        0xF7100000\n+PMB_ADDR_ARRAY:      .long        0xF6100000\n+\n+PMB_ADDR_ARRAY_val:\n+                     .long        0x80000000\n+                     .long        0x90000000\n+                     .long        0xB8000000\n+                     .long        0xAF000000\n+                     .long        0xB7000000\n+                     .long        0xA4000000\n+                     .long        0xA8000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+PMB_DATA_ARRAY_val:\n+                     .long        0x40000189\n+                     .long        0x10000119\n+                     .long        0x18000110\n+                     .long        0x0F000100\n+                     .long        0x17000100\n+                     .long        0x04000119\n+                     .long        0x08000119\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+                     .long        0x00000000\n+\n+PMB_DATA_ARRAY_VID:\n+                     .long        0x60000118\n+\n+CCN_MMUCR:           .long        0xFF000010\n+SYS_ADDR_OLD:        .long        (0x80000000 + CONFIG_ZERO_PAGE_OFFSET)\n+SYS_ADDR_NEW:        .long        (0x84000000 + CONFIG_ZERO_PAGE_OFFSET)\n+SYS_COPY_SIZE:       .long        0x00060000 ! 6 MB (note: devided by 16)\n+SYS_CFG36:           .long        0xB9001190\n+SYS_CFG36_SYS:       .long        0x00100040\n+SYS_CFG36_VID:       .long        0x00600040\n+A4_ADDR_MASK:        .long        0xA0000000\n+SYS_ADDR_OLD29:      .long        (0xA0000000 + CONFIG_ZERO_PAGE_OFFSET)\n+VID_COPY_SIZE:       .long        0x00200000 ! 32 MB (note: devided by 16)\n+PMB_DATA_ARRAY2:     .long        0xF7100100\n+\n+SYS_ADDR_VIDEO_COPY_SE:        .long        0x81000000\n+\n+SYS_RAMTOPADDRESS_ADDR29:      .long        0xAB600000\n+SYS_RAMTOPADDRESS_ADDR2:       .long        0x87600000\n+VID_ADDR_RAMTOPADDRESS_BACKUP: .long        0x90600000\n+VID_ADDR_LINUX_BACKUP:         .long        0x91000000\n+RAMTOPADDRESS_COPY_SIZE:       .long        0x000A0000 ! 10 MB (note: devided by 16)\n+SYSTEM_MEM_CODE_label:         .long        SYSTEM_MEM_CODE\n+dummy:        .long        0\n+ENTRY(COPY_END)\n+mess_32_bit2:         .long       mess_32_bit_val\n+        .balign 4\n+mess_29_bit_7100_val:.string      "Running 29 bit Mode (STb7100)\\r\\n"\n+        .balign 4\n+mess_32_bit_val:     .string      "Running 32 bit Mode\\r\\n"\n+        .balign 4\n+mess_enter_se_val:   .string      "Entering Space Enhanced Mode (32 bit)\\r\\n"\n+        .balign 4\n+\n+ENTRY(SE_END)\n+#endif\n+#endif\n!\t\t\tInitialize Status Register\nmov.l\t1f, r0\t\t! MD=1, RB=0, BL=0, IMASK=0xF\nldc\tr0, sr\n@@ -91,11 +964,14 @@\nmov.l\t3f, r1\nadd\t#4, r1\nmov.l\t4f, r2\n+9:\nmov\t#0, r0\n-9:\tcmp/hs\tr2, r1\n+\tcmp/hs\tr2, r1\nbf/s\t9b\t\t! while (r1 < r2)\nmov.l\tr0,@-r2\n\n+! End of clear bss\n+\n10:\n!\t\t\tAdditional CPU initialization\nmov.l\t6f, r0\n@@ -123,3 +999,4 @@\n5:\t.long\tstart_kernel\n6:\t.long\tsh_cpu_init\n7:\t.long\tinit_thread_union\n+8:\t.long\tlinux_banner')]