[
  [
    "linux-2.6.23/drivers/i2c/busses/i2c-stm.c.118", 
    "linux-2.6.23/drivers/i2c/busses/i2c-stm.c", 
    [
      "--- linux-2.6.23/drivers/i2c/busses/i2c-stm.c.118", 
      "+++ linux-2.6.23/drivers/i2c/busses/i2c-stm.c", 
      "@@ -29,29 +29,10 @@", 
      "*   + Add delay after stop to ensure I2C tBUF satisfied", 
      "*   + Clear SSC status after reset", 
      "*   + Reorder TX & I2C config register pokes in prepare to read phase", 
      "- * Version 2.5 (24th Oct 2008)  Carl Shaw <carl.shaw@st.com>", 
      "- *   + Rewrite START state - in case of write it now preloads TX FIFO", 
      "- *                           and it is also shared for REPSTART address", 
      "- *   + Change RX prepare - checks for NACK, reads address and then falls", 
      "- *                         through to read state", 
      "- *   + Change RX state - Use TEEN interrupt to reduce unnecessary interrupt", 
      "- *                       loading.  Previously, RIR was used which generated", 
      "- *                       an interrupt per byte", 
      "- *   + Change TX state - correctly unload RX FIFO (using both FIFO status", 
      "- *                       AND RIR bit)", 
      "- *                     - use TEEN interrupt rather than TIR", 
      "- *   + Change repstart address - just call START state but suppress STARTG", 
      "- *   + Only use PIO recovery as last-ditch effort", 
      "- *   + Fix retry method", 
      "- *   + Add auto retry in case of arbitration problem", 
      "- *   + Allow a PIO mode for clock of push-pull rather than BIDIR.  This", 
      "- *     can help with spurious noise glitches on the SCK line and in the", 
      "- *     case where SCK rise times are marginal due to capacitance on the", 
      "- *     bus.", 
      "*", 
      "* --------------------------------------------------------------------", 
      "*", 
      "- *  Copyright (C) 2006 - 2008 STMicroelectronics", 
      "+ *  Copyright (C) 2006, 2007, 2008 : STMicroelectronics", 
      "*  Author: Francesco Virlinzi     <francesco.virlinzi@st.com>", 
      "*", 
      "* May be copied or modified under the terms of the GNU General Public", 
      "@@ -75,70 +56,87 @@", 
      "#include \"./i2c-stm.h\"", 
      "#include <linux/stm/stssc.h>", 
      "", 
      "-#undef dbg_print", 
      "+#undef dgb_print", 
      "", 
      "#ifdef  CONFIG_I2C_DEBUG_BUS", 
      "-#define dbg_print(fmt, args...)  printk(\"%s: \" fmt, __FUNCTION__ , ## args)", 
      "+#define dgb_print(fmt, args...)  printk(\"%s: \" fmt, __FUNCTION__ , ## args)", 
      "#else", 
      "-#define dbg_print(fmt, args...)", 
      "+#define dgb_print(fmt, args...)", 
      "#endif", 
      "", 
      "-#undef dbg_print2", 
      "+#undef dgb_print2", 
      "#ifdef  CONFIG_I2C_DEBUG_ALGO", 
      "-#define dbg_print2(fmt, args...)  printk(\"%s: \" fmt, __FUNCTION__ , ## args)", 
      "+#define dgb_print2(fmt, args...)  printk(\"%s: \" fmt, __FUNCTION__ , ## args)", 
      "#else", 
      "-#define dbg_print2(fmt, args...)", 
      "+#define dgb_print2(fmt, args...)", 
      "#endif", 
      "", 
      "/* --- Defines for I2C --- */", 
      "/* These values WILL produce physical clocks which are slower */", 
      "-/* Especially if hardware glitch suppression is enabled       */", 
      "+/* Especially if hardware glith suppression is enabled        */", 
      "/* They should probably be made board dependent?              */", 
      "-#define I2C_RATE_NORMAL\t\t\t100000", 
      "+#define I2C_RATE_NORMAL                 100000", 
      "#define I2C_RATE_FASTMODE\t\t400000", 
      "", 
      "+", 
      "#define NANOSEC_PER_SEC\t\t\t1000000000", 
      "", 
      "/* Standard I2C timings */", 
      "#define REP_START_HOLD_TIME_NORMAL\t4000", 
      "-#define START_HOLD_TIME_NORMAL\t\t4000", 
      "-#define REP_START_SETUP_TIME_NORMAL\t4700", 
      "-#define DATA_SETUP_TIME_NORMAL\t\t 250", 
      "-#define STOP_SETUP_TIME_NORMAL\t\t4000", 
      "-#define BUS_FREE_TIME_NORMAL\t\t4700", 
      "-", 
      "#define REP_START_HOLD_TIME_FAST\t 600", 
      "+#define START_HOLD_TIME_NORMAL\t\t4000", 
      "#define START_HOLD_TIME_FAST\t\t 600", 
      "+#define REP_START_SETUP_TIME_NORMAL\t4700", 
      "#define REP_START_SETUP_TIME_FAST\t 600", 
      "+#define DATA_SETUP_TIME_NORMAL\t\t 250", 
      "#define DATA_SETUP_TIME_FAST\t\t 100", 
      "+#define STOP_SETUP_TIME_NORMAL\t\t4000", 
      "#define STOP_SETUP_TIME_FAST\t\t 600", 
      "+#define BUS_FREE_TIME_NORMAL\t\t4700", 
      "#define BUS_FREE_TIME_FAST\t\t1300", 
      "", 
      "+/* These values come from hw boys... */", 
      "+/*", 
      "+#define REP_START_HOLD_TIME_NORMAL\t4000", 
      "+#define REP_START_HOLD_TIME_FAST\t6500", 
      "+#define START_HOLD_TIME_NORMAL\t\t4500", 
      "+#define START_HOLD_TIME_FAST\t\t800", 
      "+#define REP_START_SETUP_TIME_NORMAL\t4700", 
      "+#define REP_START_SETUP_TIME_FAST\t800", 
      "+#define DATA_SETUP_TIME_NORMAL\t\t300", 
      "+#define DATA_SETUP_TIME_FAST\t\t300", 
      "+#define STOP_SETUP_TIME_NORMAL\t\t4200", 
      "+#define STOP_SETUP_TIME_FAST\t\t800", 
      "+#define BUS_FREE_TIME_NORMAL\t\t5700", 
      "+#define BUS_FREE_TIME_FAST\t\t1500", 
      "+*/", 
      "+", 
      "/* Define for glitch suppression support */", 
      "#ifdef CONFIG_I2C_STM_GLITCH_SUPPORT", 
      "-#if CONFIG_GLITCH_CLK_WIDTH > 0", 
      "-#define GLITCH_WIDTH_CLOCK\t\t\tCONFIG_GLITCH_CLK_WIDTH", 
      "+  #if CONFIG_GLITCH_CLK_WIDTH > 0", 
      "+    #define GLITCH_WIDTH_CLOCK\t\t\tCONFIG_GLITCH_CLK_WIDTH", 
      "+  #else", 
      "+    #define GLITCH_WIDTH_CLOCK\t\t\t500 /* in nanosecs */", 
      "+  #endif", 
      "+  #if CONFIG_GLITCH_DATA_WIDTH > 0", 
      "+    #define GLITCH_WIDTH_DATA\t\t\tCONFIG_GLITCH_DATA_WIDTH", 
      "+  #else", 
      "+    #define GLITCH_WIDTH_DATA\t\t\t500 /* in nanosecs */", 
      "+  #endif", 
      "#else", 
      "-#define GLITCH_WIDTH_CLOCK\t\t\t500\t/* in nanosecs */", 
      "-#endif", 
      "-#if CONFIG_GLITCH_DATA_WIDTH > 0", 
      "-#define GLITCH_WIDTH_DATA\t\t\tCONFIG_GLITCH_DATA_WIDTH", 
      "-#else", 
      "-#define GLITCH_WIDTH_DATA\t\t\t500\t/* in nanosecs */", 
      "-#endif", 
      "-#else", 
      "-#define GLITCH_WIDTH_DATA\t\t\t0", 
      "-#define GLITCH_WIDTH_CLOCK\t\t\t0", 
      "+    #define GLITCH_WIDTH_DATA\t\t\t0", 
      "+    #define GLITCH_WIDTH_CLOCK\t\t\t0", 
      "#endif", 
      "", 
      "#ifdef CONFIG_I2C_STM_HW_GLITCH", 
      "-#if CONFIG_HW_GLITCH_WIDTH > 0", 
      "-#define HW_GLITCH_WIDTH\t\t\tCONFIG_HW_GLITCH_WIDTH", 
      "-#else", 
      "-#define HW_GLITCH_WIDTH\t\t\t1\t/* in microseconds */", 
      "-#endif", 
      "+  #if CONFIG_HW_GLITCH_WIDTH > 0", 
      "+    #define HW_GLITCH_WIDTH\t\t\tCONFIG_HW_GLITCH_WIDTH", 
      "+  #else", 
      "+    #define HW_GLITCH_WIDTH\t\t\t1 /* in microseconds */", 
      "+  #endif", 
      "#endif", 
      "", 
      "+", 
      "/* To manage normal vs fast mode */", 
      "#define IIC_STM_CONFIG_SPEED_MASK          0x1", 
      "#define IIC_STM_CONFIG_SPEED_FAST          0x1", 
      "@@ -148,7 +146,6 @@", 
      "typedef enum _iic_state_machine_e {", 
      "IIC_FSM_VOID = 0,", 
      "IIC_FSM_PREPARE,", 
      "-\tIIC_FSM_NOREPSTART,", 
      "IIC_FSM_START,", 
      "IIC_FSM_DATA_WRITE,", 
      "IIC_FSM_PREPARE_2_READ,", 
      "@@ -160,19 +157,11 @@", 
      "IIC_FSM_ABORT", 
      "} iic_state_machine_e;", 
      "", 
      "-#ifdef CONFIG_I2C_DEBUG_ALGO", 
      "-char *statename[] =", 
      "-    { \"VOID\", \"PREPARE\", \"START\", \"DATA_WRITE\", \"PREPARE_2_READ\",", 
      "-\t\"DATA_READ\", \"STOP\", \"COMPLETE\", \"REPSTART\", \"REPSTART_ADDR\", \"ABORT\"", 
      "-};", 
      "-#endif", 
      "-", 
      "typedef enum _iic_fsm_error_e {", 
      "IIC_E_NO_ERROR = 0x0,", 
      "IIC_E_RUNNING = 0x1,", 
      "IIC_E_NOTACK = 0x2,", 
      "-\tIIC_E_ARBL = 0x4,", 
      "-\tIIC_E_BUSY = 0x8", 
      "+\tIIC_E_ARBL = 0x4", 
      "} iic_fsm_error_e;", 
      "", 
      "/*", 
      "@@ -187,8 +176,8 @@", 
      "struct i2c_msg *msgs_queue;", 
      "int attempt;", 
      "int queue_length;", 
      "-\tint current_msg;\t/* the message on going */", 
      "-\tint idx_current_msg;\t/* the byte in the message */", 
      "+\tint current_msg;\t\t/* the message on going */", 
      "+\tint idx_current_msg;\t\t/* the byte in the message */", 
      "iic_fsm_error_e status_error;", 
      "int waitcondition;", 
      "};", 
      "@@ -205,8 +194,14 @@", 
      "#define jump_on_fsm_start(x)\t{ (x)->state = IIC_FSM_START;\t\\", 
      "goto be_fsm_start;\t}", 
      "", 
      "-#define jump_on_fsm_stop(x)\tdo { (x)->state = IIC_FSM_STOP;    \\", 
      "-\t\t\t\tgoto be_fsm_stop; } while (0)", 
      "+#define jump_on_fsm_repstart(x)\t{ (x)->state = IIC_FSM_REPSTART; \\", 
      "+                                goto be_fsm_repstart;\t}", 
      "+", 
      "+#define jump_on_fsm_complete(x)\t{ (x)->state = IIC_FSM_COMPLETE; \\", 
      "+\t\t\t\tgoto be_fsm_complete;\t}", 
      "+", 
      "+#define jump_on_fsm_stop(x)\t{ (x)->state = IIC_FSM_STOP;\t\\", 
      "+                                  goto be_fsm_stop;\t}", 
      "", 
      "#define jump_on_fsm_abort(x)\t{ (x)->state = IIC_FSM_ABORT;    \\", 
      "goto be_fsm_abort;\t}", 
      "@@ -221,26 +216,38 @@", 
      "", 
      "#define clear_ready_fastmode(adap) ((adap)->config &= ~IIC_STM_READY_SPEED_FAST)", 
      "", 
      "-static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long rate);", 
      "+#if defined(CONFIG_I2C_STM_NOSTOP_API)", 
      "+#define LAST_I2C_WAS_NO_STOP                   0x4", 
      "+#define LAST_I2C_WAS_NO_STOP_MASK              0x4", 
      "+#define check_lasti2cwas_nostop(adap)          (((adap)->config &                      \\", 
      "+                                                       LAST_I2C_WAS_NO_STOP_MASK) ? 1 : 0 )", 
      "+#define set_lasti2cwas_nostop(adap)            ((adap)->config |=  LAST_I2C_WAS_NO_STOP)", 
      "+#define clear_lasti2cwas_nostop(adap)          ((adap)->config &= ~LAST_I2C_WAS_NO_STOP_MASK)", 
      "+#else", 
      "+#define check_lasti2cwas_nostop(adap)          (1==0)", 
      "+#define set_lasti2cwas_nostop(adap)            {}", 
      "+#define clear_lasti2cwas_nostop(adap)          {}", 
      "+#endif", 
      "+", 
      "+static void iic_stm_setup_timing(struct iic_ssc *adap,unsigned long rate);", 
      "", 
      "static irqreturn_t iic_state_machine(int this_irq, void *data)", 
      "{", 
      "struct iic_ssc *adap = (struct iic_ssc *)data;", 
      "struct iic_transaction *trsc = adap->trns;", 
      "-\tunsigned int status;", 
      "-\tunsigned int idx, previntmask, lim, intflags, conflags = 0;", 
      "-#ifdef CONFIG_I2C_DEBUG_ALGO", 
      "-\tunsigned int cw;", 
      "-#endif", 
      "+\tunsigned short status;", 
      "+\tshort tx_fifo_status;", 
      "+\tunsigned int idx, previntmask;", 
      "unsigned short address;", 
      "struct i2c_msg *pmsg;", 
      "char fast_mode;", 
      "union {", 
      "char bytes[2];", 
      "-\t\tunsigned short word;", 
      "+\t\tshort word;", 
      "} tmp;", 
      "-\tunsigned short txbuff[SSC_TXFIFO_SIZE];", 
      "-\tunsigned int txbuffcount;", 
      "+\tint tmp2=0;", 
      "+", 
      "+\tdgb_print2(\"\\n\");", 
      "", 
      "fast_mode = check_fastmode(adap);", 
      "pmsg = trsc->msgs_queue + trsc->current_msg;", 
      "@@ -250,334 +257,270 @@", 
      "ssc_store32(adap, SSC_IEN, 0);", 
      "", 
      "status = ssc_load32(adap, SSC_STA);", 
      "-\tdbg_print2(\"ISR status = 0x%08x\\n\", status);", 
      "", 
      "-\t/* Slave mode detection - this should never happen as we don't support multi-master */", 
      "-\tif (trsc->state > IIC_FSM_START && ((status & SSC_STA_ARBL)", 
      "-\t\t\t\t\t    || !(ssc_load32(adap, SSC_CTL) &", 
      "-\t\t\t\t\t\t SSC_CTL_MS))) {", 
      "-\t\tdbg_print2(\"SLAVE mode (state %d, status %08x)\\n\",", 
      "-\t\t\t   trsc->state, status);", 
      "-\t\tdbg_print2(\" Message [%d of %d] is %s address 0x%02x bus %d\\n\",", 
      "-\t\t\t   trsc->current_msg + 1, trsc->queue_length,", 
      "-\t\t\t   (pmsg->flags & I2C_M_RD) ? \"READ from\" : \"WRITE to\",", 
      "-\t\t\t   pmsg->addr, adap->adapter.nr);", 
      "-\t\tdbg_print2", 
      "-\t\t    (\"   data is %d bytes, currently at %d, last 0x%02x\\n\",", 
      "-\t\t     pmsg->len, trsc->idx_current_msg,", 
      "-\t\t     (trsc->idx_current_msg >", 
      "-\t\t      0) ? pmsg->buf[trsc->idx_current_msg - 1] : 0);", 
      "-\t\tdbg_print2(\"Prev State: %s Changing to state: %s \\n\",", 
      "-\t\t\t   statename[trsc->state], statename[trsc->next_state]);", 
      "-", 
      "-\t\tdbg_print2", 
      "-\t\t    (\"Status: 0x%08x SSC_IEN 0x%08x \"", 
      "-\t\t\t\"SSC_CTL 0x%08x SSC_I2C 0x%08x\\n\",", 
      "-\t\t     status, previntmask, ssc_load32(adap, SSC_CTL),", 
      "-\t\t     ssc_load32(adap, SSC_I2C));", 
      "+\ttrsc->state = trsc->next_state;", 
      "", 
      "+\t/* Slave mode detection - this should never happen as we don't support multi-master */", 
      "+\tif ( trsc->state > IIC_FSM_START &&", 
      "+\t     ((status & SSC_STA_ARBL) || !(ssc_load32(adap, SSC_CTL) & SSC_CTL_MS)) ){", 
      "+\t\tdgb_print2(\"In SLAVE mode (state %d, status %08x)!\\n\", trsc->state, status);", 
      "trsc->status_error = IIC_E_ARBL;", 
      "-\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "-\t\ttrsc->waitcondition = 0;", 
      "-\t\twake_up(&(adap->wait_queue));", 
      "-\t\treturn IRQ_HANDLED;", 
      "+    clear_lasti2cwas_nostop(adap);", 
      "+    ssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+    ssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "+    trsc->next_state = IIC_FSM_COMPLETE;", 
      "+    ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+          SSC_I2C_TXENB | SSC_I2C_STOPG |", 
      "+          (SSC_I2C_I2CFSMODE * fast_mode));", 
      "+    ssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);", 
      "+    return IRQ_HANDLED;", 
      "}", 
      "", 
      "-\ttrsc->state = trsc->next_state;", 
      "-", 
      "switch (trsc->state) {", 
      "case IIC_FSM_PREPARE:", 
      "-\t\tdbg_print2(\"-Prepare\\n\");", 
      "+\t\tdgb_print2(\"-Prepare\\n\");", 
      "+\t\tif (check_lasti2cwas_nostop(adap)) {", 
      "+\t\t\tclear_lasti2cwas_nostop(adap);", 
      "+\t\t\tjump_on_fsm_repstart(trsc);", 
      "+\t\t}", 
      "/*", 
      "* check if the i2c timing register", 
      "* of ssc are ready to use", 
      "*/", 
      "if ((check_fastmode(adap) && !check_ready_fastmode(adap)) ||", 
      "-\t\t    (!check_fastmode(adap) && check_ready_fastmode(adap)))", 
      "+\t\t    (!check_fastmode(adap) && check_ready_fastmode(adap)) )", 
      "iic_stm_setup_timing(adap,", 
      "-\t\t\t\t\t     clk_get_rate(clk_get", 
      "-\t\t\t\t\t\t\t  (NULL, \"comms_clk\")));", 
      "-", 
      "-\t\ttrsc->start_state = IIC_FSM_START;", 
      "-", 
      "-\t\t/* Enable RX FIFO, enable clock stretch on TX empty */", 
      "-\t\tssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |", 
      "-\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |", 
      "-\t\t\t    SSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO);", 
      "-", 
      "-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);", 
      "-", 
      "-\t\t/* NO break! */", 
      "+\t\t\t\tclk_get_rate(clk_get(NULL,\"comms_clk\")));", 
      "+\t\tjump_on_fsm_start(trsc);", 
      "+\t\tbreak;", 
      "", 
      "-\tcase IIC_FSM_NOREPSTART:", 
      "+\tcase IIC_FSM_START:", 
      "+\t      be_fsm_start:", 
      "+\t\tdgb_print2(\"-Start address 0x%x\\n\", pmsg->addr);", 
      "+\t\t/* Reset SSC */", 
      "+\t\tssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |", 
      "+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);", 
      "ssc_store32(adap, SSC_CLR, 0xdc0);", 
      "-\t\ttrsc->state = IIC_FSM_START;", 
      "-\t\tconflags = SSC_I2C_STRTG;", 
      "", 
      "-\t\tif (!check_fastmode(adap))", 
      "-\t\t\tndelay(4000);", 
      "-\t\telse", 
      "-\t\t\tndelay(700);", 
      "+\t\t/* enable RX, TX FIFOs */", 
      "+\t\tssc_store32(adap, SSC_CTL,", 
      "+\t\t\t    SSC_CTL_EN | SSC_CTL_MS |", 
      "+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |", 
      "+\t\t\t    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);", 
      "", 
      "-\t\t/* NO break! */", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));", 
      "", 
      "-\tcase IIC_FSM_START:", 
      "-be_fsm_start:", 
      "-\t\tdbg_print2(\"-Start address 0x%x\\n\", pmsg->addr);", 
      "-", 
      "-\t\ttrsc->idx_current_msg = 0;", 
      "+\t\ttrsc->start_state = IIC_FSM_START;", 
      "+\t\ttrsc->next_state  = IIC_FSM_DATA_WRITE;", 
      "", 
      "address = (pmsg->addr << 2) | 0x1;", 
      "-\t\tif (pmsg->flags & I2C_M_RD) {", 
      "-\t\t\tdbg_print2(\" Reading %d bytes\\n\", pmsg->len);", 
      "-", 
      "+\t\tif (pmsg->flags & I2C_M_RD){", 
      "address |= 0x2;", 
      "trsc->next_state = IIC_FSM_PREPARE_2_READ;", 
      "-\t\t\tintflags =", 
      "-\t\t\t    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;", 
      "-", 
      "-\t\t\ttxbuff[0] = address;", 
      "-\t\t\ttxbuffcount = 1;", 
      "-\t\t} else {", 
      "-\t\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;", 
      "-\t\t\tintflags =", 
      "-\t\t\t    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;", 
      "-", 
      "-\t\t\tdbg_print2(\"-Writing %d bytes\\n\", pmsg->len);", 
      "-\t\t\ttxbuff[0] = address;", 
      "-\t\t\ttxbuffcount = 1;", 
      "-\t\t\tidx = SSC_TXFIFO_SIZE - 1;", 
      "-\t\t\tdbg_print2(\" TX FIFO %d empty slots\\n\", idx);", 
      "-", 
      "-\t\t\t/* In the write case, we also preload the TX buffer", 
      "-\t\t\t * with some data to reduce the interrupt loading", 
      "-\t\t\t */", 
      "-\t\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {", 
      "-\t\t\t\ttmp.bytes[0] =", 
      "-\t\t\t\t    pmsg->buf[trsc->idx_current_msg++];", 
      "-\t\t\t\ttxbuff[txbuffcount] = tmp.word << 1 | 0x1;", 
      "-\t\t\t\tdbg_print2(\" write 0x%02x\\n\", tmp.bytes[0]);", 
      "-\t\t\t\ttxbuffcount++;", 
      "-\t\t\t\tidx--;", 
      "-\t\t\t}", 
      "}", 
      "+\t\ttrsc->idx_current_msg = 0;", 
      "", 
      "-\t\t/* drive SDA... */", 
      "-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB);", 
      "-\t\tfor (idx = 0; idx < txbuffcount; idx++)", 
      "-\t\t\tssc_store32(adap, SSC_TBUF, txbuff[idx]);", 
      "-\t\tssc_store32(adap, SSC_IEN, intflags);", 
      "-", 
      "-\t\t/* Check for bus busy.  This shouldn't happen but if the RX", 
      "-\t\t * FIFOs are not empty in the last transaction BEFORE the SSC", 
      "-\t\t * reset occurs, then we get a BUSY error here...", 
      "-\t\t */", 
      "-\t\tif (trsc->start_state != IIC_FSM_REPSTART) {", 
      "-\t\t\tif (ssc_load32(adap, SSC_STA) & SSC_STA_BUSY) {", 
      "-\t\t\t\tdbg_print2(\" bus BUSY!\\n\");", 
      "-\t\t\t\ttrsc->waitcondition = 0;", 
      "-\t\t\t\ttrsc->status_error = IIC_E_BUSY;", 
      "-\t\t\t} else {", 
      "-\t\t\t\t/* START! */", 
      "-\t\t\t\tssc_store32(adap, SSC_I2C,", 
      "-\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |", 
      "-\t\t\t\t\t    conflags);", 
      "-\t\t\t}", 
      "+\t\tstatus = ssc_load32(adap, SSC_STA);", 
      "+\t\tif (status & SSC_STA_BUSY){", 
      "+\t\t\tdgb_print2(\"    bus BUSY!\\n\");", 
      "+\t\t\ttrsc->waitcondition = 0; /* to not sleep */", 
      "+\t\t\ttrsc->status_error = IIC_E_RUNNING;\t/* to raise the error */", 
      "+\t\t\treturn -1;", 
      "}", 
      "", 
      "+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);", 
      "+\t\tssc_store32(adap, SSC_TBUF, address);", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t    SSC_I2C_STRTG | SSC_I2C_TXENB |", 
      "+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));", 
      "break;", 
      "", 
      "-\tcase IIC_FSM_REPSTART_ADDR:", 
      "-\t\tdbg_print2(\"-Rep Start addr 0x%x\\n\", pmsg->addr);", 
      "-", 
      "-\t\t/* Clear NACK */", 
      "-\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "-", 
      "-\t\ttrsc->start_state = IIC_FSM_REPSTART;", 
      "-\t\tconflags = 0;", 
      "-", 
      "-\t\tjump_on_fsm_start(trsc);", 
      "-", 
      "-", 
      "case IIC_FSM_PREPARE_2_READ:", 
      "-\t\tdbg_print2(\"-Prepare to Read...\\n\");", 
      "-", 
      "-\t\t/* Read address */", 
      "-\t\tssc_load32(adap, SSC_RBUF);", 
      "+\t\t/* Clear the RBUF */", 
      "+\t\twhile (ssc_load32(adap, SSC_RX_FSTAT)){", 
      "+\t\t\tdgb_print2(\".\");", 
      "+\t\t\tssc_load32(adap, SSC_RBUF);", 
      "+\t\t}", 
      "", 
      "-\t\t/* Check for NACK */", 
      "-\t\tif (status & SSC_STA_NACK) {", 
      "-\t\t\tdbg_print2(\" read: NACK detected\\n\");", 
      "-\t\t\tjump_on_fsm_abort(trsc);", 
      "+\t\tif (ssc_load32(adap, SSC_TX_FSTAT)){", 
      "+\t\t\tprintk(KERN_ERR \"i2c-stm: IIC_FSM_PREPARE_2_READ:TX FIFO NOT empty!\\n\");", 
      "}", 
      "", 
      "-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG);", 
      "+\t\tstatus = ssc_load32(adap, SSC_STA);", 
      "+\t\tdgb_print2(\" Prepare to Read... Status=0x%x\\n\", status);", 
      "+", 
      "+\t\tif (status & SSC_STA_NACK)", 
      "+\t\t\tjump_on_fsm_abort(trsc);", 
      "", 
      "trsc->next_state = IIC_FSM_DATA_READ;", 
      "", 
      "-\t\t/* NO break */", 
      "+\t\tswitch (pmsg->len) {", 
      "+\t\tcase 0: dgb_print2(\"Zero Read\\n\");", 
      "+\t\t\tjump_on_fsm_stop(trsc);", 
      "+", 
      "+\t\tcase 1:", 
      "+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t\t(SSC_I2C_I2CFSMODE * fast_mode));", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);", 
      "+\t\t   break;", 
      "+\t\tdefault:", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG |", 
      "+\t\t\t\t(SSC_I2C_I2CFSMODE * fast_mode));", 
      "+\t\t\t/* P.S.: in any case the last byte has to be", 
      "+\t\t\t *       managed in a different manner", 
      "+\t\t\t */", 
      "+\t\t\tfor ( idx = 0;  idx < SSC_TXFIFO_SIZE &&", 
      "+\t\t\t\t\tidx < pmsg->len-1 ;  ++idx )", 
      "+\t\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);", 
      "+\t\t}", 
      "+\t\tbreak;", 
      "", 
      "case IIC_FSM_DATA_READ:", 
      "-\t\tdbg_print2(\"-Read\\n\");", 
      "-\t\t/* Clear the RX buffer */", 
      "-\t\tidx = (ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS);", 
      "-\t\tif (!idx && (ssc_load32(adap, SSC_STA) & SSC_STA_RIR))", 
      "-\t\t\tidx = SSC_RXFIFO_SIZE;", 
      "+\t\t/* Check for transmit problem */", 
      "+\t\tif (!(status & SSC_STA_TE)){", 
      "+\t\t\tssc_store32(adap, SSC_IEN, previntmask);", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t\t/* Check for unexpected bus STOP condition */", 
      "+\t\tif (status & SSC_STA_STOP){", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\t\tjump_on_fsm_abort(trsc);", 
      "+\t\t}", 
      "", 
      "-\t\tdbg_print2(\" Rx %d bytes in FIFO...\\n\", idx);", 
      "-\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {", 
      "+\t\tdgb_print2(\" Data Read...Status=0x%x\\n\",status);", 
      "+\t\t/* 1.0 Is it the last byte */", 
      "+\t\tif (trsc->idx_current_msg == pmsg->len-1) {", 
      "tmp.word = ssc_load32(adap, SSC_RBUF);", 
      "tmp.word = tmp.word >> 1;", 
      "pmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];", 
      "-\t\t\tdbg_print2(\" Rx Data 0x%02x\\n\", tmp.bytes[0] & 0xff);", 
      "-\t\t\tidx--;", 
      "+\t\t\tdgb_print2(\" Rx Data %d-%c\\n\",tmp.bytes[0], tmp.bytes[0]);", 
      "+\t\t} else {", 
      "+\t\t\t/* 1.1 take the bytes from Rx fifo */", 
      "+\t\t\tfor (idx = 0 ;  idx < SSC_RXFIFO_SIZE &&", 
      "+\t\t\t\ttrsc->idx_current_msg < pmsg->len-1; ++idx ) {", 
      "+\t\t\t\t\ttmp.word = ssc_load32(adap, SSC_RBUF);", 
      "+\t\t\t\t\ttmp.word = tmp.word >> 1;", 
      "+\t\t\t\t\tpmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];", 
      "+\t\t\t\t\tdgb_print2(\" Rx Data %d-%c\\n\",tmp.bytes[0], tmp.bytes[0]);", 
      "+\t\t\t}", 
      "}", 
      "", 
      "-\t\t/* If end of RX, issue STOP or REPSTART */", 
      "+\t\t/* 2. Do we finish? */", 
      "if (trsc->idx_current_msg == pmsg->len) {", 
      "+\t\t\tstatus &= ~SSC_STA_NACK;", 
      "jump_on_fsm_stop(trsc);", 
      "}", 
      "", 
      "-\t\t/*    Generate clock for another set of bytes.", 
      "-\t\t *    We have to process the last byte separately as we need to", 
      "-\t\t *    NOT generate an ACK", 
      "+\t\t/* 3. Ask other 'idx' bytes in fifo mode", 
      "+\t\t *    but we want save the latest [pmsg->len-1]", 
      "+\t\t *    in any case...", 
      "+\t\t *    This will also clear any pending clockstretch", 
      "*/", 
      "-\t\tif (trsc->idx_current_msg == (pmsg->len - 1)) {", 
      "-\t\t\t/* last byte - disable ACKG */", 
      "-\t\t\tdbg_print2(\" Rx last byte\\n\");", 
      "-\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);", 
      "-\t\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t\t    SSC_IEN_NACKEN | SSC_IEN_ARBLEN);", 
      "+\t\tfor (idx=0; idx<SSC_TXFIFO_SIZE &&", 
      "+\t\t\t   (trsc->idx_current_msg+idx)<pmsg->len-1; ++idx)", 
      "ssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "-\t\t} else {", 
      "-#ifdef CONFIG_I2C_DEBUG_ALGO", 
      "-\t\t\tcw = 0;", 
      "-#endif", 
      "-\t\t\tidx = SSC_TXFIFO_SIZE;", 
      "-\t\t\tdbg_print2(\" idx=%d status=0x%08x\\n\", idx,", 
      "-\t\t\t\t   ssc_load32(adap, SSC_STA));", 
      "-", 
      "-\t\t\twhile (idx", 
      "-\t\t\t       && (trsc->idx_current_msg +", 
      "-\t\t\t\t   (SSC_TXFIFO_SIZE - idx)) < (pmsg->len - 1)) {", 
      "-\t\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "-#ifdef CONFIG_I2C_DEBUG_ALGO", 
      "-\t\t\t\tcw++;", 
      "-#endif", 
      "-\t\t\t\tidx--;", 
      "-\t\t\t}", 
      "-\t\t\tdbg_print2(\"Clock writes: %d\\n\", cw);", 
      "", 
      "-\t\t\t/* only take one interrupt when transmit FIFO empty! */", 
      "-\t\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t\t    SSC_IEN_ARBLEN | SSC_IEN_TEEN);", 
      "-\t\t}", 
      "+\t\tdgb_print2(\" Asked %x bytes in fifo mode\\n\",idx);", 
      "+", 
      "+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);", 
      "", 
      "+\t\t/*Is the next byte the last byte? */", 
      "+\t\tif (trsc->idx_current_msg == (pmsg->len - 1)) {", 
      "+\t\t\tdgb_print2(\" Asked the last byte\\n\");", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);", 
      "+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode) );", 
      "+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);", 
      "+\t\t}", 
      "break;", 
      "", 
      "case IIC_FSM_DATA_WRITE:", 
      "-\t\tdbg_print2(\"-Write\\n\");", 
      "-\t\t/* Clear RX data from FIFO */", 
      "-", 
      "-\t\t/* It is not clear from the SSC4 datasheet, but the RX_FSTAT", 
      "-\t\t * register does not tell the whole story...  if RIR is set in", 
      "-\t\t * the STATUS reg then we need to read 8 words.  RX_FSTAT only", 
      "-\t\t * notifies us of at most 7 words - hence the extra check below", 
      "-\t\t */", 
      "-", 
      "-\t\tlim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;", 
      "-\t\tif (!lim && (status & SSC_STA_RIR))", 
      "-\t\t\tlim = 8;", 
      "+\t\t/* Check for unexpected bus STOP condition */", 
      "+\t\tif (status & SSC_STA_STOP){", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\t\tjump_on_fsm_abort(trsc);", 
      "+\t\t}", 
      "", 
      "-\t\tdbg_print2(\" clearing %d RX words\\n\", lim);", 
      "-\t\tfor (idx = 0; idx < lim; idx++)", 
      "+\t\t/* just to clear some bits in the STATUS register */", 
      "+\t\twhile (ssc_load32(adap, SSC_RX_FSTAT))", 
      "ssc_load32(adap, SSC_RBUF);", 
      "-", 
      "-\t\t/* Clear status bits EXCEPT NACK */", 
      "+/*", 
      "+ * Be careful!!!!", 
      "+ * Here I don't have to use 0xdc0 for", 
      "+ * the SSC_CLR register", 
      "+ */", 
      "ssc_store32(adap, SSC_CLR, 0x9c0);", 
      "", 
      "-\t\t/* Check for NACK */", 
      "status = ssc_load32(adap, SSC_STA);", 
      "-\t\tdbg_print2(\"write: status = 0x%08x\\n\", status);", 
      "-\t\tif (status & SSC_STA_NACK) {", 
      "-\t\t\tdbg_print2(\" NACK detected\\n\");", 
      "+\t\tif (status & SSC_STA_NACK)", 
      "jump_on_fsm_abort(trsc);", 
      "+", 
      "+\t\ttx_fifo_status = ssc_load32(adap,SSC_TX_FSTAT);", 
      "+\t\tif ( tx_fifo_status ) {", 
      "+\t\t\tdgb_print2(\" Fifo not empty\\n\");", 
      "+\t\t\tssc_store32(adap, SSC_IEN, previntmask);", 
      "+\t\t\tbreak;", 
      "}", 
      "", 
      "-\t\t/* If end of TX, issue STOP or REPSTART */", 
      "-\t\tif (trsc->idx_current_msg == pmsg->len)", 
      "+\t\tif (trsc->idx_current_msg == pmsg->len || !(pmsg->len))", 
      "jump_on_fsm_stop(trsc);", 
      "", 
      "-\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;", 
      "+\t\tdgb_print2(\" Data Write...Status=0x%x 0x%x-%c\\n\", status,", 
      "+\t\t\t  pmsg->buf[trsc->idx_current_msg],", 
      "+\t\t\t  pmsg->buf[trsc->idx_current_msg]);", 
      "", 
      "-\t\t/* Interrupt when TX buffer empty */", 
      "-\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t    SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |", 
      "+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));", 
      "", 
      "-\t\tidx = SSC_TXFIFO_SIZE;", 
      "-\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {", 
      "+\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;", 
      "+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);", 
      "+", 
      "+\t\tfor (; tx_fifo_status < SSC_TXFIFO_SIZE &&", 
      "+\t\t\ttrsc->idx_current_msg < pmsg->len ;++tx_fifo_status )", 
      "+\t\t{", 
      "tmp.bytes[0] = pmsg->buf[trsc->idx_current_msg++];", 
      "ssc_store32(adap, SSC_TBUF, tmp.word << 1 | 0x1);", 
      "-\t\t\tdbg_print2(\" Write 0x%02x\\n\", tmp.bytes[0]);", 
      "-\t\t\tidx--;", 
      "}", 
      "-", 
      "break;", 
      "", 
      "case IIC_FSM_ABORT:", 
      "be_fsm_abort:", 
      "-\t\tdbg_print2(\"Abort - issuing STOP\\n\");", 
      "+\t\tdgb_print2(\" Abort\\n\");", 
      "trsc->status_error |= IIC_E_NOTACK;", 
      "+\t\t/* Don't ADD the break */", 
      "", 
      "+\tcase IIC_FSM_STOP:", 
      "+\t      be_fsm_stop:", 
      "+\t\tif (!(status & SSC_STA_NACK) &&", 
      "+\t\t    (++trsc->current_msg < trsc->queue_length)) {", 
      "+\t\t\tjump_on_fsm_repstart(trsc);", 
      "+\t\t}", 
      "+\t\tif (pmsg->flags & I2C_M_NOSTOP && !(status & SSC_STA_NACK)){    /* NoStop message! */", 
      "+\t\t\tset_lasti2cwas_nostop(adap);", 
      "+\t\t\tdgb_print2(\" Stop not done\\n\");", 
      "+\t\t\tjump_on_fsm_complete(trsc);", 
      "+\t\t}", 
      "+\t\tclear_lasti2cwas_nostop(adap);", 
      "+\t\tdgb_print2(\" Stop\\n\");", 
      "ssc_store32(adap, SSC_CLR, 0xdc0);", 
      "trsc->next_state = IIC_FSM_COMPLETE;", 
      "-", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t    SSC_I2C_TXENB | SSC_I2C_STOPG |", 
      "+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));", 
      "ssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);", 
      "-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_STOPG);", 
      "-\t\tbreak;", 
      "-", 
      "-\tcase IIC_FSM_STOP:", 
      "-be_fsm_stop:", 
      "-\t\tdbg_print2(\"-Stop\\n\");", 
      "-", 
      "-\t\tif (++trsc->current_msg < trsc->queue_length) {", 
      "-\t\t\t/* More transactions left... */", 
      "-\t\t\tif (pmsg->flags & I2C_M_NOREPSTART) {", 
      "-\t\t\t\t/* no repstart - stop then start */", 
      "-\t\t\t\tdbg_print2(\" STOP - STOP\\n\");", 
      "-\t\t\t\ttrsc->next_state = IIC_FSM_NOREPSTART;", 
      "-\t\t\t\tssc_store32(adap, SSC_I2C,", 
      "-\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |", 
      "-\t\t\t\t\t    SSC_I2C_STOPG);", 
      "-\t\t\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t\t\t    SSC_IEN_STOPEN | SSC_IEN_ARBLEN);", 
      "-\t\t\t} else {", 
      "-\t\t\t\t/* repstart */", 
      "-\t\t\t\tdbg_print2(\" STOP - REPSTART\\n\");", 
      "-\t\t\t\ttrsc->next_state = IIC_FSM_REPSTART_ADDR;", 
      "-\t\t\t\tssc_store32(adap, SSC_I2C,", 
      "-\t\t\t\t\t    SSC_I2C_I2CM |", 
      "-\t\t\t\t\t    SSC_I2C_TXENB |", 
      "-\t\t\t\t\t    SSC_I2C_REPSTRTG);", 
      "-\t\t\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t\t\t    SSC_IEN_REPSTRTEN |", 
      "-\t\t\t\t\t    SSC_IEN_ARBLEN);", 
      "-\t\t\t}", 
      "-\t\t} else {", 
      "-\t\t\t/* stop */", 
      "-\t\t\tdbg_print2(\" STOP - STOP\\n\");", 
      "-\t\t\ttrsc->next_state = IIC_FSM_COMPLETE;", 
      "-\t\t\tssc_store32(adap, SSC_I2C,", 
      "-\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |", 
      "-\t\t\t\t    SSC_I2C_STOPG);", 
      "-\t\t\tssc_store32(adap, SSC_IEN,", 
      "-\t\t\t\t    SSC_IEN_STOPEN | SSC_IEN_ARBLEN);", 
      "-\t\t}", 
      "-", 
      "break;", 
      "", 
      "case IIC_FSM_COMPLETE:", 
      "-\t\tdbg_print2(\"-Complete\\n\");", 
      "+\t    be_fsm_complete:", 
      "+\t\tdgb_print2(\" Complete\\n\");", 
      "+\t\tudelay(5);", 
      "", 
      "if (!(trsc->status_error & IIC_E_NOTACK))", 
      "trsc->status_error = IIC_E_NO_ERROR;", 
      "@@ -586,6 +529,40 @@", 
      "wake_up(&(adap->wait_queue));", 
      "break;", 
      "", 
      "+\tcase IIC_FSM_REPSTART:", 
      "+\t      be_fsm_repstart:", 
      "+\t\tpmsg = trsc->msgs_queue + trsc->current_msg;", 
      "+\t\tdgb_print2(\"-Rep Start (0x%x)\\n\",pmsg->addr);", 
      "+\t\ttrsc->start_state = IIC_FSM_REPSTART;", 
      "+\t\ttrsc->idx_current_msg = 0;", 
      "+\t\ttrsc->next_state = IIC_FSM_REPSTART_ADDR;", 
      "+\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\tif(ssc_load32(adap,SSC_STA) & SSC_STA_REPSTRT)", 
      "+\t\t\ttmp2=1;", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB", 
      "+\t\t\t    | SSC_I2C_REPSTRTG | (SSC_I2C_I2CFSMODE *", 
      "+\t\t\t\t\t\t  fast_mode));", 
      "+\t\tif(tmp2) /* we was not able to clear the status bit */", 
      "+\t\t\tudelay(5);", 
      "+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_REPSTRTEN | SSC_IEN_ARBLEN);", 
      "+\t\tbreak;", 
      "+", 
      "+\tcase IIC_FSM_REPSTART_ADDR:", 
      "+\t\tdgb_print2(\"-Rep Start addr 0x%x\\n\", pmsg->addr);", 
      "+\t\t/* Clear repstart bit */", 
      "+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB", 
      "+\t\t\t\t  | (SSC_I2C_I2CFSMODE * fast_mode));", 
      "+", 
      "+\t\tssc_store32(adap, SSC_CLR, 0xdc0);", 
      "+\t\taddress = (pmsg->addr << 2) | 0x1;", 
      "+\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;", 
      "+\t\tif (pmsg->flags & I2C_M_RD) {", 
      "+\t\t\taddress |= 0x2;", 
      "+\t\t\ttrsc->next_state = IIC_FSM_PREPARE_2_READ;", 
      "+\t\t}", 
      "+\t\tssc_store32(adap, SSC_TBUF, address);", 
      "+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);", 
      "+\t\tbreak;", 
      "default:", 
      "printk(KERN_ERR \"i2c-stm: Error in the FSM\\n\");", 
      ";", 
      "@@ -594,6 +571,7 @@", 
      "return IRQ_HANDLED;", 
      "}", 
      "", 
      "+", 
      "/*", 
      "* Wait for stop to be detected on bus", 
      "*/", 
      "@@ -601,65 +579,36 @@", 
      "{", 
      "unsigned int idx;", 
      "", 
      "-\tdbg_print(\"\\n\");", 
      "-\tfor (idx = 0; idx < 5; ++idx) {", 
      "-\t\tif (ssc_load32(adap, SSC_STA) & SSC_STA_STOP)", 
      "+\tdgb_print(\"\\n\");", 
      "+\tfor ( idx = 0; idx < 5 ; ++idx ){", 
      "+\t\tif (ssc_load32(adap,SSC_STA) & SSC_STA_STOP)", 
      "return 1;", 
      "mdelay(2);", 
      "}", 
      "", 
      "-\tprintk(KERN_ERR \"*** iic_wait_stop_condition: TIMED OUT ***\\n\");", 
      "return 0;", 
      "}", 
      "", 
      "/*", 
      "- * Reset SSC bus", 
      "- */", 
      "-static void iic_ssc_reset(struct iic_ssc *adap)", 
      "-{", 
      "-\tunsigned int lim, status, idx;", 
      "-", 
      "-\t/* Ensure RX buffer empty */", 
      "-\tstatus = ssc_load32(adap, SSC_STA);", 
      "-\tlim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;", 
      "-\tif (!lim && (status & SSC_STA_RIR))", 
      "-\t\tlim = 8;", 
      "-", 
      "-\tfor (idx = 0; idx < lim; idx++)", 
      "-\t\tssc_load32(adap, SSC_RBUF);", 
      "-", 
      "-\t/* Reset SSC */", 
      "-\tssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |", 
      "-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);", 
      "-", 
      "-\t/* enable RX, TX FIFOs - clear SR bit */", 
      "-\tssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |", 
      "-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |", 
      "-\t\t    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);", 
      "-}", 
      "-", 
      "-/*", 
      "* Wait for bus to become free", 
      "*/", 
      "static int iic_wait_free_bus(struct iic_ssc *adap)", 
      "{", 
      "-\tunsigned int reg = 0;", 
      "unsigned int idx;", 
      "", 
      "-\tdbg_print(\"\\n\");", 
      "+\tdgb_print(\"\\n\");", 
      "", 
      "-\tiic_ssc_reset(adap);", 
      "+\tif (check_lasti2cwas_nostop(adap)){", 
      "+\t\tdgb_print(\"last transaction nostop.  Not waiting for free bus\\n\");", 
      "+\t\treturn 1;", 
      "+\t}", 
      "", 
      "-\tfor (idx = 0; idx < 10; ++idx) {", 
      "-\t\treg = ssc_load32(adap, SSC_STA);", 
      "-\t\tdbg_print(\"iic_wait_free_bus: status = 0x%08x\\n\", reg);", 
      "-\t\tif (!(reg & SSC_STA_BUSY))", 
      "+\tfor ( idx = 0; idx < 5 ; ++idx ) {", 
      "+\t\tif (!(ssc_load32(adap,SSC_STA) & SSC_STA_BUSY) )", 
      "return 1;", 
      "mdelay(2);", 
      "}", 
      "", 
      "-\tprintk(KERN_ERR \"*** iic_wait_free_bus: TIMED OUT ***\\n\");", 
      "-", 
      "return 0;", 
      "}", 
      "", 
      "@@ -670,267 +619,169 @@", 
      "{", 
      "int cnt = 0;", 
      "", 
      "-\tif (!(adap->pio_info)->clk)", 
      "-\t\treturn;\t\t/* ssc hard wired */", 
      "+\tif(!(adap->pio_info)->clk)", 
      "+\t\treturn; /* ssc hard wired */", 
      "printk(KERN_WARNING \"i2c-stm: doing PIO stop!\\n\");", 
      "", 
      "/* Send STOP */", 
      "stpio_set_pin((adap->pio_info)->clk, 0);", 
      "stpio_set_pin((adap->pio_info)->sdout, 0);", 
      "-\tstpio_configure_pin((adap->pio_info)->clk, STPIO_OUT);", 
      "+\tstpio_configure_pin((adap->pio_info)->clk, STPIO_BIDIR);", 
      "stpio_configure_pin((adap->pio_info)->sdout, STPIO_BIDIR);", 
      "udelay(20);", 
      "stpio_set_pin((adap->pio_info)->clk, 1);", 
      "udelay(20);", 
      "stpio_set_pin((adap->pio_info)->sdout, 1);", 
      "udelay(30);", 
      "-\tif ((adap->pio_info)->clk_unidir)", 
      "-\t\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_OUT);", 
      "-\telse", 
      "-\t\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);", 
      "+\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);", 
      "stpio_configure_pin((adap->pio_info)->sdout, STPIO_ALT_BIDIR);", 
      "", 
      "/* Reset SSC */", 
      "ssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |", 
      "-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);", 
      "+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);", 
      "ssc_store32(adap, SSC_CLR, 0xdc0);", 
      "", 
      "/* Make sure SSC thinks the bus is free before continuing */", 
      "-\twhile (cnt < 10", 
      "-\t       && (ssc_load32(adap, SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))) {", 
      "+\twhile (cnt < 10 && (ssc_load32(adap,SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))){", 
      "mdelay(2);", 
      "-\t\tcnt++;", 
      "+\t\tcnt ++;", 
      "}", 
      "", 
      "if (cnt == 10)", 
      "-\t\tprintk(KERN_ERR", 
      "-\t\t       \"i2c-stm:  Cannot recover bus.  Status: 0x%08x\\n\",", 
      "-\t\t       ssc_load32(adap, SSC_STA));", 
      "+\t\tprintk(KERN_ERR \"i2c-stm:  Cannot recover bus.  Status: 0x%08x\\n\", ssc_load32(adap,SSC_STA));", 
      "}", 
      "", 
      "/*", 
      "* Description: Prepares the controller for a transaction", 
      "*/", 
      "static int iic_stm_xfer(struct i2c_adapter *i2c_adap,", 
      "-\t\t\tstruct i2c_msg msgs[], int num)", 
      "+\t\t\t     struct i2c_msg msgs[], int num)", 
      "{", 
      "unsigned int flag;", 
      "int result;", 
      "int timeout;", 
      "-#ifdef CONFIG_I2C_DEBUG_BUS", 
      "-\tint i;", 
      "-#endif", 
      "struct iic_ssc *adap =", 
      "-\t    (struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);", 
      "+\t\t\t(struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);", 
      "struct iic_transaction transaction = {", 
      "-\t\t.msgs_queue = msgs,", 
      "-\t\t.queue_length = num,", 
      "-\t\t.current_msg = 0x0,", 
      "-\t\t.attempt = 0x0,", 
      "-\t\t.status_error = IIC_E_RUNNING,", 
      "-\t\t.next_state = IIC_FSM_PREPARE,", 
      "-\t\t.waitcondition = 1,", 
      "-\t};", 
      "+\t\t\t.msgs_queue   = msgs,", 
      "+\t\t\t.queue_length = num,", 
      "+\t\t\t.current_msg  = 0x0,", 
      "+\t\t\t.attempt      = 0x0,", 
      "+\t\t\t.status_error = IIC_E_RUNNING,", 
      "+\t\t\t.next_state   = IIC_FSM_PREPARE,", 
      "+\t\t\t.waitcondition = 1,", 
      "+\t\t};", 
      "", 
      "-\tdbg_print(\"\\n\");", 
      "+\tdgb_print(\"\\n\");", 
      "", 
      "adap->trns = &transaction;", 
      "", 
      "-#ifdef CONFIG_I2C_DEBUG_BUS", 
      "-\tfor (i = 0; i < num; ++i) {", 
      "-\t\tif (msgs[i].len == 0)", 
      "-\t\t\tprintk(KERN_INFO", 
      "-\t\t\t       \"[%d of %d] ZERO LENGTH TRANSACTION : \"", 
      "-\t\t\t       \"%s addr 0x%02x len %d\\n\",", 
      "-\t\t\t       i + 1, num,", 
      "-\t\t\t       (msgs[i].", 
      "-\t\t\t\tflags & I2C_M_RD) ? \"read from \" :", 
      "-\t\t\t\t\"write to \",", 
      "-\t\t\t\tmsgs[i].addr, msgs[i].len);", 
      "-\t\telse", 
      "-\t\t\tprintk(KERN_INFO", 
      "-\t\t\t       \"[%d of %d] TRANSACTION : \"", 
      "-\t\t\t       \"%s addr 0x%02x len %d\\n\",", 
      "-\t\t\t       i + 1, num,", 
      "-\t\t\t       (msgs[i].", 
      "-\t\t\t\tflags & I2C_M_RD) ? \"read from \" :", 
      "-\t\t\t\t\"write to \",", 
      "-\t\t\t       msgs[i].addr, msgs[i].len);", 
      "-\t}", 
      "-#endif /* CONFIG_I2C_DEBUG_BUS */", 
      "-", 
      "iic_xfer_retry:", 
      "", 
      "-\t/* Wait for bus to become free - do a forced PIO reset if necessary to", 
      "-\t * recover the bus", 
      "-\t */", 
      "+\t/* Wait for bus to become free - do a forced PIO reset if necessary to */", 
      "+\t/* recover the bus */", 
      "if (!iic_wait_free_bus(adap))", 
      "iic_pio_stop(adap);", 
      "", 
      "iic_state_machine(0, adap);", 
      "", 
      "timeout = wait_event_interruptible_timeout(adap->wait_queue,", 
      "-\t\t\t\t\t\t   (transaction.waitcondition ==", 
      "-\t\t\t\t\t\t    0), i2c_adap->timeout * HZ);", 
      "+\t\t\t\t\t(transaction.waitcondition==0),", 
      "+\t\t\t\t\ti2c_adap->timeout);", 
      "", 
      "local_irq_save(flag);", 
      "", 
      "result = transaction.current_msg;", 
      "", 
      "-\tif (unlikely", 
      "-\t    (transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {", 
      "-\t\tdbg_print2(KERN_ERR", 
      "-\t\t\t   \"xfer: ERROR status %d, timeout %d, attempt %d\\n\",", 
      "-\t\t\t   transaction.status_error, timeout,", 
      "-\t\t\t   transaction.attempt);", 
      "-", 
      "-\t\tdbg_print2(KERN_ERR", 
      "-\t\t\t   \"Status: 0x%08x SSC_IEN 0x%08x \"", 
      "-\t\t\t   \"SSC_CTL 0x%08x SSC_I2C 0x%08x\\n\",", 
      "-\t\t\t   ssc_load32(adap, SSC_STA), ssc_load32(adap, SSC_IEN),", 
      "-\t\t\t   ssc_load32(adap, SSC_CTL), ssc_load32(adap,", 
      "-\t\t\t\t\t\t\t\t SSC_I2C));", 
      "-", 
      "-\t\tif (((transaction.status_error & IIC_E_NOTACK)", 
      "-\t\t     && transaction.start_state == IIC_FSM_START)", 
      "-\t\t    || (transaction.status_error & IIC_E_BUSY)) {", 
      "-\t\t\tif (++transaction.attempt <= adap->adapter.retries) {", 
      "-\t\t\t\tdbg_print2(\"RETRYING operation\\n\");", 
      "+\tif (unlikely(transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {", 
      "+\t\tif ((transaction.status_error & IIC_E_NOTACK) &&", 
      "+\t\t\ttransaction.start_state == IIC_FSM_START &&", 
      "+\t\t\t++transaction.attempt <= adap->adapter.retries){", 
      "/* error on the address - automatically retry */", 
      "/* this used to be done in the FSM complete but it was not safe */", 
      "/* there as we need to wait for the bus to not be busy before */", 
      "/* doing another transaction */", 
      "+\t\t\t\tprintk(KERN_ERR \"i2c-stm: error on address.  auto retry %d\\n\", transaction.attempt);", 
      "transaction.status_error = 0;", 
      "-\t\t\t\ttransaction.next_state = IIC_FSM_START;", 
      "-\t\t\t\ttransaction.waitcondition = 1;", 
      "local_irq_restore(flag);", 
      "goto iic_xfer_retry;", 
      "-\t\t\t} else {", 
      "-\t\t\t\tlocal_irq_restore(flag);", 
      "-\t\t\t\tif (transaction.status_error & IIC_E_NOTACK) {", 
      "-\t\t\t\t\tdbg_print(\"Error: Slave NACK\\n\");", 
      "-\t\t\t\t\tresult = -EREMOTEIO;", 
      "-\t\t\t\t} else {", 
      "-\t\t\t\t\tdbg_print(\"Error: Bus BUSY\\n\");", 
      "-\t\t\t\t\tresult = -EBUSY;", 
      "-\t\t\t\t}", 
      "-\t\t\t}", 
      "-\t\t} else if (transaction.status_error == IIC_E_ARBL", 
      "-\t\t\t   || (ssc_load32(adap, SSC_CTL) & SSC_CTL_MS) == 0) {", 
      "+\t\t} else if (transaction.status_error == IIC_E_ARBL){", 
      "/* Arbitration error */", 
      "-\t\t\tprintk(KERN_ERR \"i2c-stm: arbitration error\\n\");", 
      "-", 
      "-\t\t\tssc_store32(adap, SSC_CLR, SSC_CLR_SSCARBL);", 
      "-\t\t\tssc_store32(adap, SSC_CTL,", 
      "-\t\t\t\t    ssc_load32(adap, SSC_CTL) | SSC_CTL_MS);", 
      "-\t\t\ttransaction.status_error = 0;", 
      "-\t\t\ttransaction.next_state = IIC_FSM_START;", 
      "-\t\t\ttransaction.waitcondition = 1;", 
      "+\t\t  printk(\"i2c-stm: arbitration error\\n\");", 
      "+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0); //reset status register", 
      "+\t\t\tssc_store32(adap, SSC_CTL, ssc_load32(adap, SSC_CTL) | SSC_CTL_MS); // make sure we still are master", 
      "local_irq_restore(flag);", 
      "", 
      "-\t\t\tif (!iic_wait_free_bus(adap)) {", 
      "-\t\t\t\t/* Last ditch effort */", 
      "-\t\t\t\tiic_pio_stop(adap);", 
      "-\t\t\t}", 
      "-", 
      "-\t\t\tif (++transaction.attempt <= adap->adapter.retries) {", 
      "-\t\t\t\tdbg_print2(\"RETRYING operation\\n\");", 
      "-\t\t\t\tgoto iic_xfer_retry;", 
      "-\t\t\t}", 
      "+\t\t\t/* Manually issue stop condition on the bus */", 
      "+\t\t\tiic_pio_stop(adap);", 
      "} else {", 
      "/* There was another problem */", 
      "-\t\t\tif (timeout <= 0) {", 
      "+\t\t\tif(timeout<=0){", 
      "/* There was a timeout or signal.", 
      "- disable the interrupt", 
      "- generate a stop condition on the bus", 
      "all this task are done without interrupt....", 
      "*/", 
      "-\t\t\t\tdbg_print", 
      "-\t\t\t\t    (\"xfer: Wait cnd err %d, status error %d\\n\",", 
      "-\t\t\t\t     timeout, transaction.status_error);", 
      "ssc_store32(adap, SSC_IEN, 0x0);", 
      "+\t\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |", 
      "+\t\t\t\t\t    SSC_I2C_STOPG | SSC_I2C_TXENB |", 
      "+\t\t\t\t\t    (SSC_I2C_I2CFSMODE * check_fastmode(adap)));", 
      "+\t\t\t\t/* wait until the ssc detects a Stop condition on the bus */", 
      "+\t\t\t\t/* but before we do that we enable all the interrupts     */", 
      "+\t\t\t\tlocal_irq_restore(flag);", 
      "", 
      "-\t\t\t\t/* Check if bus free */", 
      "-\t\t\t\tif (!iic_wait_free_bus(adap)) {", 
      "-\t\t\t\t\t/* No - generate stop condition */", 
      "-\t\t\t\t\tssc_store32(adap, SSC_I2C,", 
      "-\t\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_STOPG", 
      "-\t\t\t\t\t\t    | SSC_I2C_TXENB);", 
      "-", 
      "-\t\t\t\t\tlocal_irq_restore(flag);", 
      "-", 
      "-\t\t\t\t\tif (!iic_wait_stop_condition(adap)) {", 
      "-\t\t\t\t\t\t/* Reset SSC */", 
      "-\t\t\t\t\t\tssc_store32(adap, SSC_CTL,", 
      "-\t\t\t\t\t\t\t    SSC_CTL_SR |", 
      "-\t\t\t\t\t\t\t    SSC_CTL_EN |", 
      "-\t\t\t\t\t\t\t    SSC_CTL_MS |", 
      "-\t\t\t\t\t\t\t    SSC_CTL_PO |", 
      "-\t\t\t\t\t\t\t    SSC_CTL_PH |", 
      "-\t\t\t\t\t\t\t    SSC_CTL_HB | 0x8);", 
      "-\t\t\t\t\t\tssc_store32(adap, SSC_CLR,", 
      "-\t\t\t\t\t\t\t    0xdc0);", 
      "-", 
      "-\t\t\t\t\t\tif (!iic_wait_free_bus(adap)) {", 
      "-\t\t\t\t\t\t\t/* Last ditch effort */", 
      "-\t\t\t\t\t\t\tiic_pio_stop(adap);", 
      "-\t\t\t\t\t\t}", 
      "-\t\t\t\t\t}", 
      "-\t\t\t\t} else {", 
      "-\t\t\t\t\tlocal_irq_restore(flag);", 
      "+\t\t\t\tif (!iic_wait_stop_condition(adap)){", 
      "+\t\t\t\t\tprintk(KERN_ERR \"i2c-stm: Error.  Manually stopping transaction.\\n\");", 
      "+\t\t\t\t\tiic_pio_stop(adap);", 
      "}", 
      "+\t\t\t\tclear_lasti2cwas_nostop(adap);", 
      "} else", 
      "local_irq_restore(flag);", 
      "", 
      "-\t\t\tif (!timeout) {", 
      "-\t\t\t\tdbg_print", 
      "-\t\t\t\t    (\"i2c-stm: Error timeout in the FSM\\n\");", 
      "+\t\t\tif (!timeout){", 
      "+\t\t\t\tprintk(KERN_ERR", 
      "+\t\t\t\t       \"i2c-stm: Error timeout in the finite state machine\\n\");", 
      "result = -ETIMEDOUT;", 
      "} else if (timeout < 0) {", 
      "-\t\t\t\tdbg_print", 
      "-\t\t\t\t    (\"i2c-stm: wait event interrupt/error\\n\");", 
      "+\t\t\t\tdgb_print(\"i2c-stm: interrupt or error in wait event\\n\");", 
      "result = timeout;", 
      "-\t\t\t} else {", 
      "-\t\t\t\tdbg_print(\"i2c-stm: slave failed to respond\\n\");", 
      "+\t\t\t} else", 
      "result = -EREMOTEIO;", 
      "-\t\t\t}", 
      "}", 
      "} else", 
      "local_irq_restore(flag);", 
      "", 
      "-#ifdef CONFIG_I2C_DEBUG_BUS", 
      "-\tprintk(KERN_INFO \"i2c-stm: i2c_stm_xfer returned %d\\n\", result);", 
      "-#endif", 
      "return result;", 
      "}", 
      "", 
      "#ifdef  CONFIG_I2C_DEBUG_BUS", 
      "static void iic_stm_timing_trace(struct iic_ssc *adap)", 
      "{", 
      "-\tdbg_print(\"SSC_BRG  %d\\n\", ssc_load32(adap, SSC_BRG));", 
      "-\tdbg_print(\"SSC_REP_START_HOLD %d\\n\",", 
      "+\tdgb_print(\"SSC_BRG  %d\\n\",ssc_load32(adap, SSC_BRG));", 
      "+\tdgb_print(\"SSC_REP_START_HOLD %d\\n\",", 
      "ssc_load32(adap, SSC_REP_START_HOLD));", 
      "-\tdbg_print(\"SSC_REP_START_SETUP %d\\n\",", 
      "+\tdgb_print(\"SSC_REP_START_SETUP %d\\n\",", 
      "ssc_load32(adap, SSC_REP_START_SETUP));", 
      "-\tdbg_print(\"SSC_START_HOLD %d\\n\", ssc_load32(adap, SSC_START_HOLD));", 
      "-\tdbg_print(\"SSC_DATA_SETUP %d\\n\", ssc_load32(adap, SSC_DATA_SETUP));", 
      "-\tdbg_print(\"SSC_STOP_SETUP %d\\n\", ssc_load32(adap, SSC_STOP_SETUP));", 
      "-\tdbg_print(\"SSC_BUS_FREE %d\\n\", ssc_load32(adap, SSC_BUS_FREE));", 
      "-\tdbg_print(\"SSC_PRE_SCALER_BRG %d\\n\",", 
      "+\tdgb_print(\"SSC_START_HOLD %d\\n\", ssc_load32(adap, SSC_START_HOLD));", 
      "+\tdgb_print(\"SSC_DATA_SETUP %d\\n\", ssc_load32(adap, SSC_DATA_SETUP));", 
      "+\tdgb_print(\"SSC_STOP_SETUP %d\\n\", ssc_load32(adap, SSC_STOP_SETUP));", 
      "+\tdgb_print(\"SSC_BUS_FREE %d\\n\", ssc_load32(adap, SSC_BUS_FREE));", 
      "+\tdgb_print(\"SSC_PRE_SCALER_BRG %d\\n\",", 
      "ssc_load32(adap, SSC_PRE_SCALER_BRG));", 
      "-\tdbg_print(\"SSC_NOISE_SUPP_WIDTH %d\\n\",", 
      "-\t\t  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH));", 
      "-\tdbg_print(\"SSC_PRSCALER %d\\n\", ssc_load32(adap, SSC_PRSCALER));", 
      "-\tdbg_print(\"SSC_NOISE_SUPP_WIDTH_DATAOUT %d\\n\",", 
      "-\t\t  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));", 
      "-\tdbg_print(\"SSC_PRSCALER_DATAOUT %d\\n\",", 
      "-\t\t  ssc_load32(adap, SSC_PRSCALER_DATAOUT));", 
      "+\tdgb_print(\"SSC_NOISE_SUPP_WIDTH %d\\n\",", 
      "+\t\t\tssc_load32(adap, SSC_NOISE_SUPP_WIDTH));", 
      "+\tdgb_print(\"SSC_PRSCALER %d\\n\",", 
      "+\t\t\tssc_load32(adap, SSC_PRSCALER));", 
      "+\tdgb_print(\"SSC_NOISE_SUPP_WIDTH_DATAOUT %d\\n\",", 
      "+\t\t\tssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));", 
      "+\tdgb_print(\"SSC_PRSCALER_DATAOUT %d\\n\",", 
      "+\t\t\tssc_load32(adap, SSC_PRSCALER_DATAOUT));", 
      "}", 
      "#endif", 
      "", 
      "static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)", 
      "{", 
      "-\tunsigned long iic_baudrate;", 
      "+\tunsigned long  iic_baudrate;", 
      "unsigned short iic_rep_start_hold;", 
      "unsigned short iic_start_hold;", 
      "unsigned short iic_rep_start_setup;", 
      "@@ -941,99 +792,67 @@", 
      "#ifdef CONFIG_I2C_STM_HW_GLITCH", 
      "unsigned short iic_glitch_width;", 
      "unsigned short iic_glitch_width_dataout;", 
      "-\tunsigned char iic_prescaler;", 
      "+\tunsigned char  iic_prescaler;", 
      "unsigned short iic_prescaler_dataout;", 
      "#endif", 
      "-\tunsigned long ns_per_clk;", 
      "+\tunsigned long  ns_per_clk;", 
      "", 
      "-\tdbg_print(\"Assuming %lu MHz for the Timing Setup\\n\", clock / 1000000);", 
      "+\tdgb_print(\"Assuming %d MHz for the Timing Setup\\n\",", 
      "+\t\t  clock / 1000000);", 
      "", 
      "-\tclock += 500000;\t/* +0.5 Mhz for rounding */", 
      "+\tclock += 500000; /* +0.5 Mhz for rounding */", 
      "ns_per_clk = NANOSEC_PER_SEC / clock;", 
      "", 
      "if (check_fastmode(adap)) {", 
      "set_ready_fastmode(adap);", 
      "iic_baudrate = clock / (2 * I2C_RATE_FASTMODE);", 
      "-\t\tiic_rep_start_hold =", 
      "-\t\t    (REP_START_HOLD_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_rep_start_setup =", 
      "-\t\t    (REP_START_SETUP_TIME_FAST +", 
      "-\t\t     GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "-\t\tif (GLITCH_WIDTH_DATA < 200)", 
      "-\t\t\tiic_start_hold =", 
      "-\t\t\t    (START_HOLD_TIME_FAST +", 
      "-\t\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\tiic_rep_start_hold  =(REP_START_HOLD_TIME_FAST +GLITCH_WIDTH_DATA) /ns_per_clk;", 
      "+\t\tiic_rep_start_setup =(REP_START_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;", 
      "+\t\tif(GLITCH_WIDTH_DATA<200)", 
      "+\t\t\tiic_start_hold =(START_HOLD_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;", 
      "else", 
      "-\t\t\tiic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_data_setup =", 
      "-\t\t    (DATA_SETUP_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_stop_setup =", 
      "-\t\t    (STOP_SETUP_TIME_FAST + GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "-\t\tiic_bus_free =", 
      "-\t\t    (BUS_FREE_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\t\tiic_start_hold =(5*GLITCH_WIDTH_DATA) /ns_per_clk;", 
      "+\t\tiic_data_setup =(DATA_SETUP_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;", 
      "+\t\tiic_stop_setup =(STOP_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;", 
      "+\t\tiic_bus_free =(BUS_FREE_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;", 
      "} else {", 
      "clear_ready_fastmode(adap);", 
      "-\t\tiic_baudrate = clock / (2 * I2C_RATE_NORMAL);", 
      "-\t\tiic_rep_start_hold =", 
      "-\t\t    (REP_START_HOLD_TIME_NORMAL +", 
      "-\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_rep_start_setup =", 
      "-\t\t    (REP_START_SETUP_TIME_NORMAL +", 
      "-\t\t     GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "-\t\tif (GLITCH_WIDTH_DATA < 1200)", 
      "-\t\t\tiic_start_hold =", 
      "-\t\t\t    (START_HOLD_TIME_NORMAL +", 
      "-\t\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\tiic_baudrate = clock  / (2 * I2C_RATE_NORMAL);", 
      "+\t\tiic_rep_start_hold =( REP_START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\tiic_rep_start_setup =( REP_START_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "+\t\tif(GLITCH_WIDTH_DATA<1200)", 
      "+\t\t\tiic_start_hold =( START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "else", 
      "-\t\t\tiic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_data_setup =", 
      "-\t\t    (DATA_SETUP_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "-\t\tiic_stop_setup =", 
      "-\t\t    (STOP_SETUP_TIME_NORMAL + GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "-\t\tiic_bus_free =", 
      "-\t\t    (BUS_FREE_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\t\tiic_start_hold =( 5*GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\tiic_data_setup =( DATA_SETUP_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "+\t\tiic_stop_setup =( STOP_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;", 
      "+\t\tiic_bus_free =( BUS_FREE_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;", 
      "}", 
      "", 
      "-\t/* set baudrate */", 
      "-\tssc_store32(adap, SSC_BRG, iic_baudrate);", 
      "-\tssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);", 
      "-", 
      "-\t/* enable I2C mode */", 
      "-\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);", 
      "-", 
      "-\t/* set other timings */", 
      "ssc_store32(adap, SSC_REP_START_HOLD, iic_rep_start_hold);", 
      "ssc_store32(adap, SSC_START_HOLD, iic_start_hold);", 
      "ssc_store32(adap, SSC_REP_START_SETUP, iic_rep_start_setup);", 
      "ssc_store32(adap, SSC_DATA_SETUP, iic_data_setup);", 
      "ssc_store32(adap, SSC_STOP_SETUP, iic_stop_setup);", 
      "ssc_store32(adap, SSC_BUS_FREE, iic_bus_free);", 
      "+\tssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);", 
      "", 
      "#ifdef CONFIG_I2C_STM_HW_GLITCH", 
      "/* See DDTS GNBvd40668 */", 
      "iic_prescaler = 1;", 
      "-\tiic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000;\t/* in uS */", 
      "+\tiic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000; /* width in uS */", 
      "iic_glitch_width_dataout = 1;", 
      "iic_prescaler_dataout = clock / 10000000;", 
      "", 
      "-/*  This should work, but causes lock-up after repstart", 
      "-    iic_prescaler = clock / 10000000;", 
      "-    iic_glitch_width = HW_GLITCH_WIDTH;", 
      "-    iic_glitch_width_dataout = 1;", 
      "-    iic_prescaler_dataout = clock / 10000000;", 
      "-    printk(\"*** iic_prescaler = %d *** \\n\", iic_prescaler);", 
      "-*/", 
      "-", 
      "ssc_store32(adap, SSC_PRSCALER, iic_prescaler);", 
      "ssc_store32(adap, SSC_NOISE_SUPP_WIDTH, iic_glitch_width);", 
      "-\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT,", 
      "-\t\t    iic_glitch_width_dataout);", 
      "+\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT, iic_glitch_width_dataout);", 
      "ssc_store32(adap, SSC_PRSCALER_DATAOUT, iic_prescaler_dataout);", 
      "-#else", 
      "-\t/* disable SSC glitch filter */", 
      "-\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH, 0);", 
      "#endif", 
      "", 
      "+\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);", 
      "+\tssc_store32(adap, SSC_BRG, iic_baudrate);", 
      "+", 
      "#ifdef  CONFIG_I2C_DEBUG_BUS", 
      "iic_stm_timing_trace(adap);", 
      "#endif", 
      "@@ -1041,20 +860,20 @@", 
      "}", 
      "", 
      "static int iic_stm_control(struct i2c_adapter *adapter,", 
      "-\t\t\t   unsigned int cmd, unsigned long arg)", 
      "+\t\t\t\tunsigned int cmd, unsigned long arg)", 
      "{", 
      "struct iic_ssc *iic_adap =", 
      "container_of(adapter, struct iic_ssc, adapter);", 
      "switch (cmd) {", 
      "case I2C_STM_IOCTL_FAST:", 
      "-\t\tdbg_print(\"ioctl fast 0x%lx\\n\", arg);", 
      "+\t\tdgb_print(\"ioctl fast 0x%x\\n\",arg);", 
      "iic_adap->config &= ~IIC_STM_CONFIG_SPEED_MASK;", 
      "if (arg)", 
      "-\t\t\tiic_adap->config |= IIC_STM_CONFIG_SPEED_FAST;", 
      "+\t\t\tiic_adap->config |=", 
      "+\t\t\t    IIC_STM_CONFIG_SPEED_FAST;", 
      "break;", 
      "default:", 
      "-\t\tprintk(KERN_WARNING \" %s: i2c-ioctl not managed\\n\",", 
      "-\t\t       __FUNCTION__);", 
      "+\t\tprintk(KERN_WARNING\" %s: i2c-ioctl not managed\\n\",__FUNCTION__);", 
      "}", 
      "return 0;", 
      "}", 
      "@@ -1065,138 +884,105 @@", 
      "}", 
      "", 
      "static struct i2c_algorithm iic_stm_algo = {", 
      "-\t.master_xfer = iic_stm_xfer,", 
      "+\t.master_xfer   = iic_stm_xfer,", 
      ".functionality = iic_stm_func,", 
      "-\t.algo_control = iic_stm_control", 
      "+\t.algo_control  = iic_stm_control", 
      "};", 
      "", 
      "static ssize_t iic_bus_show_fastmode(struct device *dev,", 
      "-\t\t\t\t     struct device_attribute *attr, char *buf)", 
      "+\t\t\t\t      struct device_attribute *attr, char *buf)", 
      "{", 
      "-\tstruct i2c_adapter *adapter =", 
      "-\t    container_of(dev, struct i2c_adapter, dev);", 
      "-\tstruct iic_ssc *iic_stm =", 
      "-\t    container_of(adapter, struct iic_ssc, adapter);", 
      "-\treturn sprintf(buf, \"%u\\n\", check_fastmode(iic_stm));", 
      "+\tstruct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);", 
      "+\tstruct iic_ssc     *iic_stm = container_of(adapter,struct iic_ssc,adapter);", 
      "+\treturn sprintf(buf, \"%u\\n\",check_fastmode(iic_stm));", 
      "}", 
      "", 
      "-static ssize_t iic_bus_store_fastmode(struct device *dev,", 
      "-\t\t\t\t      struct device_attribute *attr,", 
      "-\t\t\t\t      const char *buf, size_t count)", 
      "+static ssize_t iic_bus_store_fastmode(struct device *dev,struct device_attribute *attr,", 
      "+\t\t\t const char *buf,size_t count)", 
      "{", 
      "-\tstruct i2c_adapter *adapter =", 
      "-\t    container_of(dev, struct i2c_adapter, dev);", 
      "+\tstruct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);", 
      "unsigned long val = simple_strtoul(buf, NULL, 10);", 
      "", 
      "-\tiic_stm_control(adapter, I2C_STM_IOCTL_FAST, val);", 
      "+\tiic_stm_control(adapter,I2C_STM_IOCTL_FAST,val);", 
      "", 
      "return count;", 
      "}", 
      "", 
      "static DEVICE_ATTR(fastmode, S_IRUGO | S_IWUSR, iic_bus_show_fastmode,", 
      "-\t\t   iic_bus_store_fastmode);", 
      "+\t\t\tiic_bus_store_fastmode);", 
      "", 
      "static int __init iic_stm_probe(struct platform_device *pdev)", 
      "{", 
      "struct ssc_pio_t *pio_info =", 
      "-\t    (struct ssc_pio_t *)pdev->dev.platform_data;", 
      "+\t\t\t(struct ssc_pio_t *)pdev->dev.platform_data;", 
      "struct iic_ssc *i2c_stm;", 
      "struct resource *res;", 
      "", 
      "-\ti2c_stm = devm_kzalloc(&pdev->dev, sizeof(struct iic_ssc), GFP_KERNEL);", 
      "+\ti2c_stm = devm_kzalloc(&pdev->dev,sizeof(struct iic_ssc), GFP_KERNEL);", 
      "", 
      "if (!i2c_stm)", 
      "return -ENOMEM;", 
      "", 
      "-\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);", 
      "-\tif (!res)", 
      "+\tif (!(res=platform_get_resource(pdev, IORESOURCE_MEM, 0)))", 
      "return -ENODEV;", 
      "-", 
      "-\tif (!devm_request_mem_region", 
      "-\t    (&pdev->dev, res->start, res->end - res->start, \"i2c\")) {", 
      "-\t\tprintk(KERN_ERR \"%s: Request mem 0x%x region not done\\n\",", 
      "-\t\t       __FUNCTION__, res->start);", 
      "+\tif (!devm_request_mem_region(&pdev->dev, res->start, res->end - res->start, \"i2c\")){", 
      "+\t\tprintk(KERN_ERR \"%s: Request mem 0x%x region not done\\n\",__FUNCTION__,res->start);", 
      "return -ENOMEM;", 
      "}", 
      "if (!(i2c_stm->base =", 
      "-\t      devm_ioremap_nocache(&pdev->dev, res->start,", 
      "-\t\t\t\t   res->end - res->start))) {", 
      "-\t\tprintk(KERN_ERR \"%s: Request iomem 0x%x region not done\\n\",", 
      "-\t\t       __FUNCTION__, (unsigned int)res->start);", 
      "+\t\tdevm_ioremap_nocache(&pdev->dev, res->start, res->end - res->start))){", 
      "+\t\tprintk(KERN_ERR \"%s: Request iomem 0x%x region not done\\n\",__FUNCTION__,", 
      "+\t\t\t(unsigned int)res->start);", 
      "return -ENOMEM;", 
      "}", 
      "-", 
      "-\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);", 
      "-\tif (!res) {", 
      "-\t\tprintk(KERN_ERR \"%s Request irq %d not done\\n\", __FUNCTION__,", 
      "-\t\t       res->start);", 
      "+\tif (!(res=platform_get_resource(pdev, IORESOURCE_IRQ, 0))){", 
      "+\t\tprintk(KERN_ERR \"%s Request irq %d not done\\n\",__FUNCTION__,res->start);", 
      "return -ENODEV;", 
      "}", 
      "-\tif (devm_request_irq(&pdev->dev, res->start, iic_state_machine,", 
      "-\t\t\t     IRQF_DISABLED, \"i2c\", i2c_stm) < 0) {", 
      "-\t\tprintk(KERN_ERR \"%s: Request irq not done\\n\", __FUNCTION__);", 
      "+\tif(devm_request_irq(&pdev->dev, res->start, iic_state_machine,", 
      "+\t\tIRQF_DISABLED, \"i2c\", i2c_stm)<0){", 
      "+\t\tprintk(KERN_ERR \"%s: Request irq not done\\n\",__FUNCTION__);", 
      "return -ENODEV;", 
      "}", 
      "", 
      "-\t/* Check if we use GPIO... */", 
      "-\tif (pio_info->pio[0].pio_port == SSC_NO_PIO)", 
      "+\tif(pio_info->pio[0].pio_port==0xff) /* this means it doesn't use GPIO */", 
      "goto i2c_hard_wired;", 
      "", 
      "-\tif (pio_info->clk_unidir) {", 
      "-\t\t/* Drive clock rather than using open collector.  Setting to", 
      "-\t\t * BIDIR can help if there are problems with SCK rise times.", 
      "-\t\t * It does mean, however, that slaves cannot clock stretch.", 
      "-\t\t */", 
      "-\t\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,", 
      "-\t\t\t\t\t\t      pio_info->pio[0].pio_pin,", 
      "-\t\t\t\t\t\t      \"I2C Clock\",", 
      "-\t\t\t\t\t\t      STPIO_ALT_OUT, 1);", 
      "-\t} else {", 
      "-\t\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,", 
      "-\t\t\t\t\t\t      pio_info->pio[0].pio_pin,", 
      "-\t\t\t\t\t\t      \"I2C Clock\",", 
      "-\t\t\t\t\t\t      STPIO_ALT_BIDIR, 1);", 
      "-\t}", 
      "-", 
      "-\tif (!pio_info->clk) {", 
      "-\t\tprintk(KERN_ERR", 
      "-\t\t       \"i2c-stm: %s: Failed to get clk pin allocation\\n\",", 
      "-\t\t       __FUNCTION__);", 
      "+\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,", 
      "+\t\t\t\t\t  pio_info->pio[0].pio_pin,", 
      "+\t\t\t\t\"I2C Clock\", STPIO_ALT_BIDIR, 1);", 
      "+\tif(!pio_info->clk){", 
      "+\t\tprintk(KERN_ERR \"i2c-stm: %s: Failed to get clk pin allocation\\n\",__FUNCTION__);", 
      "return -ENODEV;", 
      "}", 
      "", 
      "pio_info->sdout = stpio_request_set_pin(pio_info->pio[1].pio_port,", 
      "-\t\t\t\t\t\tpio_info->pio[1].pio_pin,", 
      "-\t\t\t\t\t\t\"I2C Data\", STPIO_ALT_BIDIR, 1);", 
      "-\tif (!pio_info->sdout) {", 
      "-\t\tprintk(KERN_ERR \"%s: Faild to sda pin allocation\\n\",", 
      "-\t\t       __FUNCTION__);", 
      "+\t\t\t\t\t    pio_info->pio[1].pio_pin,", 
      "+\t\t\t\t\"I2C Data\", STPIO_ALT_BIDIR, 1);", 
      "+\tif(!pio_info->sdout){", 
      "+\t\tprintk(KERN_ERR \"%s: Faild to sda pin allocation\\n\",__FUNCTION__);", 
      "return -ENODEV;", 
      "}", 
      "", 
      "i2c_hard_wired:", 
      "pdev->dev.driver_data = i2c_stm;", 
      "i2c_stm->adapter.id = I2C_HW_STM_SSC;", 
      "-\ti2c_stm->adapter.timeout = 2;", 
      "-\ti2c_stm->adapter.retries = 0;", 
      "-\ti2c_stm->adapter.class = I2C_CLASS_ALL;", 
      "-\tsprintf(i2c_stm->adapter.name, \"i2c-hw-%d\", pdev->id);", 
      "+\ti2c_stm->adapter.timeout = 1000; //1000 jiffies: on ST with HZ=1000 this is 1s.", 
      "+\ti2c_stm->adapter.class   = I2C_CLASS_ALL;", 
      "+\tsprintf(i2c_stm->adapter.name,\"i2c-hw-%d\",pdev->id);", 
      "i2c_stm->adapter.nr = pdev->id;", 
      "i2c_stm->adapter.algo = &iic_stm_algo;", 
      "i2c_stm->adapter.dev.parent = &(pdev->dev);", 
      "-\tiic_stm_setup_timing(i2c_stm, clk_get_rate(clk_get(NULL, \"comms_clk\")));", 
      "+\tiic_stm_setup_timing(i2c_stm,clk_get_rate(clk_get(NULL,\"comms_clk\")));", 
      "init_waitqueue_head(&(i2c_stm->wait_queue));", 
      "i2c_stm->pio_info = pio_info;", 
      "if (i2c_add_numbered_adapter(&(i2c_stm->adapter)) < 0) {", 
      "printk(KERN_ERR", 
      "-\t\t       \"%s: The I2C Core refuses the i2c/stm adapter\\n\",", 
      "-\t\t       __FUNCTION__);", 
      "+\t\t       \"%s: The I2C Core refuses the i2c/stm adapter\\n\",__FUNCTION__);", 
      "return -ENODEV;", 
      "} else {", 
      "-\t\tif (device_create_file", 
      "-\t\t    (&(i2c_stm->adapter.dev), &dev_attr_fastmode))", 
      "-\t\t\tprintk(KERN_ERR", 
      "-\t\t\t       \"i2c-stm: cannot create fastmode sysfs entry\\n\");", 
      "+\t\tif (device_create_file(&(i2c_stm->adapter.dev), &dev_attr_fastmode))", 
      "+\t\t\tprintk(KERN_ERR \"i2c-stm: cannot create fastmode sysfs entry\\n\");", 
      "}", 
      "return 0;", 
      "", 
      "@@ -1205,18 +991,18 @@", 
      "static int iic_stm_remove(struct platform_device *pdev)", 
      "{", 
      "struct resource *res;", 
      "-\tstruct iic_ssc *iic_stm = pdev->dev.driver_data;", 
      "+\tstruct iic_ssc *iic_stm = pdev->dev.driver_data ;", 
      "struct ssc_pio_t *pio_info =", 
      "-\t    (struct ssc_pio_t *)pdev->dev.platform_data;", 
      "+\t\t\t(struct ssc_pio_t *)pdev->dev.platform_data;", 
      "", 
      "i2c_del_adapter(&iic_stm->adapter);", 
      "/* irq */", 
      "-\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);", 
      "+\tres=platform_get_resource(pdev, IORESOURCE_IRQ, 0);", 
      "devm_free_irq(&pdev->dev, res->start, iic_stm);", 
      "/* mem */", 
      "devm_iounmap(&pdev->dev, iic_stm->base);", 
      "/* pio */", 
      "-\tif (pio_info->clk) {", 
      "+\tif(pio_info->clk){", 
      "stpio_free_pin(pio_info->clk);", 
      "stpio_free_pin(pio_info->sdout);", 
      "}", 
      "@@ -1226,17 +1012,17 @@", 
      "}", 
      "", 
      "#ifdef CONFIG_PM", 
      "-static int iic_stm_suspend(struct platform_device *pdev, pm_message_t state)", 
      "+static int iic_stm_suspend(struct platform_device *pdev,pm_message_t state)", 
      "{", 
      "struct iic_ssc *i2c_bus = pdev->dev.driver_data;", 
      "-\tssc_store32(i2c_bus, SSC_IEN, 0);", 
      "-\tssc_store32(i2c_bus, SSC_CTL, 0);", 
      "+\tssc_store32(i2c_bus, SSC_IEN,0);", 
      "+\tssc_store32(i2c_bus, SSC_CTL,0);", 
      "return 0;", 
      "}", 
      "static int iic_stm_resume(struct platform_device *pdev)", 
      "{", 
      "-\tstruct iic_ssc *i2c_bus = pdev->dev.driver_data;", 
      "-\tiic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL, \"comms_clk\")));", 
      "+\tstruct iic_ssc *i2c_bus =pdev->dev.driver_data;", 
      "+\tiic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL,\"comms_clk\")));", 
      "return 0;", 
      "}", 
      "#else", 
      "@@ -1245,14 +1031,15 @@", 
      "#endif", 
      "", 
      "static struct platform_driver i2c_stm_driver = {", 
      "-\t.driver.name = \"i2c_st\",", 
      "-\t.driver.owner = THIS_MODULE,", 
      "-\t.probe = iic_stm_probe,", 
      "+        .driver.name = \"i2c_st\",", 
      "+        .driver.owner = THIS_MODULE,", 
      "+        .probe = iic_stm_probe,", 
      ".remove = iic_stm_remove,", 
      ".suspend = iic_stm_suspend,", 
      "-\t.resume = iic_stm_resume,", 
      "+\t.resume  = iic_stm_resume,", 
      "};", 
      "", 
      "+", 
      "static int __init iic_stm_init(void)", 
      "{", 
      "platform_driver_register(&i2c_stm_driver);"
    ]
  ], 
  [
    "linux-2.6.23/drivers/i2c/busses/Kconfig.118", 
    "linux-2.6.23/drivers/i2c/busses/Kconfig", 
    [
      "--- linux-2.6.23/drivers/i2c/busses/Kconfig.118", 
      "+++ linux-2.6.23/drivers/i2c/busses/Kconfig", 
      "@@ -711,4 +711,11 @@", 
      "int \"Glitch suppression width in uS\"", 
      "default \"1\"", 
      "", 
      "+config  I2C_STM_NOSTOP_API", 
      "+\tbool \"I2C add the NoStop operation API\"", 
      "+\tdepends on I2C_ST40_PIO || I2C_STM", 
      "+\tdefault n", 
      "+\t---help---", 
      "+\t  Enable this option to use the NoStop operation API", 
      "+", 
      "endmenu"
    ]
  ], 
  [
    "linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c.118", 
    "linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c", 
    [
      "--- linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c.118", 
      "+++ linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c", 
      "@@ -45,6 +45,18 @@", 
      "do {} while (0)", 
      "#endif /* DEBUG */", 
      "", 
      "+#ifdef CONFIG_I2C_STM_NOSTOP_API", 
      "+#define LAST_I2C_WAS_NO_STOP                   0x1", 
      "+#define check_lasti2cwas_nostop(adap)          (((adap)->config & \\", 
      "+                                                       LAST_I2C_WAS_NO_STOP) ? 1 : 0)", 
      "+#define set_lasti2cwas_nostop(adap)     ((adap)->config |=  LAST_I2C_WAS_NO_STOP)", 
      "+#define clear_lasti2cwas_nostop(adap)   ((adap)->config &= ~LAST_I2C_WAS_NO_STOP)", 
      "+#else", 
      "+#define check_lasti2cwas_nostop(adap)          (1==0)", 
      "+#define set_lasti2cwas_nostop(adap)            {}", 
      "+#define clear_lasti2cwas_nostop(adap)          {}", 
      "+#endif", 
      "+", 
      "/* ----- global variables ---------------------------------------------\t*/", 
      "", 
      "static int bit_test;\t/* see if the line-setting functions work\t*/", 
      "@@ -148,6 +160,7 @@", 
      "sclhi(adap);", 
      "setsda(adap, 1);", 
      "udelay(adap->udelay);", 
      "+\tclear_lasti2cwas_nostop(adap);", 
      "}", 
      "", 
      "", 
      "@@ -498,8 +511,14 @@", 
      "int i,ret;", 
      "unsigned short nak_ok;", 
      "", 
      "+\tif(check_lasti2cwas_nostop(adap)){", 
      "+\t\tbit_dbg(3, &i2c_adap->dev, \"emitting repstart condition\\n\");", 
      "+\t\tclear_lasti2cwas_nostop(adap);", 
      "+\t\ti2c_repstart(adap);", 
      "+\t} else {", 
      "bit_dbg(3, &i2c_adap->dev, \"emitting start condition\\n\");", 
      "i2c_start(adap);", 
      "+\t}", 
      "for (i=0;i<num;i++) {", 
      "pmsg = &msgs[i];", 
      "nak_ok = pmsg->flags & I2C_M_IGNORE_NAK;", 
      "@@ -544,6 +563,8 @@", 
      "ret = i;", 
      "", 
      "bailout:", 
      "+\tif ((pmsg->flags & I2C_M_NOSTOP) && ret>=0) /* if !error and last message is NoStop */", 
      "+\t\treturn ret;", 
      "bit_dbg(3, &i2c_adap->dev, \"emitting stop condition\\n\");", 
      "i2c_stop(adap);", 
      "return ret;"
    ]
  ], 
  [
    "linux-2.6.23/include/linux/i2c-algo-bit.h.118", 
    "linux-2.6.23/include/linux/i2c-algo-bit.h", 
    [
      "--- linux-2.6.23/include/linux/i2c-algo-bit.h.118", 
      "+++ linux-2.6.23/include/linux/i2c-algo-bit.h", 
      "@@ -43,6 +43,9 @@", 
      "minimum 5 us for standard-mode I2C and SMBus,", 
      "maximum 50 us for SMBus */", 
      "int timeout;\t\t/* in jiffies */", 
      "+#if defined(CONFIG_I2C_STM_NOSTOP_API)", 
      "+\tint config;", 
      "+#endif", 
      "};", 
      "", 
      "int i2c_bit_add_bus(struct i2c_adapter *);"
    ]
  ], 
  [
    "linux-2.6.23/include/linux/i2c.h.118", 
    "linux-2.6.23/include/linux/i2c.h", 
    [
      "--- linux-2.6.23/include/linux/i2c.h.118", 
      "+++ linux-2.6.23/include/linux/i2c.h", 
      "@@ -450,14 +450,14 @@", 
      "struct i2c_msg {", 
      "__u16 addr;\t/* slave address\t\t\t*/", 
      "__u16 flags;", 
      "-#define I2C_M_RD\t\t0x0001", 
      "-#define I2C_M_TEN\t\t0x0010 /* we have a ten bit chip address */", 
      "-#define I2C_M_RECV_LEN\t\t0x0400 /* length will be first received byte */", 
      "-#define I2C_M_NO_RD_ACK\t\t0x0800", 
      "-#define I2C_M_IGNORE_NAK\t0x1000", 
      "+#define I2C_M_TEN\t0x10\t/* we have a ten bit chip address\t*/", 
      "+#define I2C_M_RD\t0x01", 
      "+#define I2C_M_NOSTART\t0x4000", 
      "+#define I2C_M_NOSTOP\t0x8000 \t/* STMicroelectronics specific to support NoStop */", 
      "#define I2C_M_REV_DIR_ADDR\t0x2000", 
      "-#define I2C_M_NOSTART\t\t0x4000", 
      "-#define I2C_M_NOREPSTART\t0x8000", 
      "+#define I2C_M_IGNORE_NAK\t0x1000", 
      "+#define I2C_M_NO_RD_ACK\t\t0x0800", 
      "+#define I2C_M_RECV_LEN\t\t0x0400 /* length will be first received byte */", 
      "__u16 len;\t\t/* msg length\t\t\t\t*/", 
      "__u8 *buf;\t\t/* pointer to msg data\t\t\t*/", 
      "};"
    ]
  ]
]