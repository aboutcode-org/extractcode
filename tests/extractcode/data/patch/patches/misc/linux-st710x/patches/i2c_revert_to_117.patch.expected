[('linux-2.6.23/drivers/i2c/busses/i2c-stm.c.118',
  'linux-2.6.23/drivers/i2c/busses/i2c-stm.c',
  '--- linux-2.6.23/drivers/i2c/busses/i2c-stm.c.118\n+++ linux-2.6.23/drivers/i2c/busses/i2c-stm.c\n@@ -29,29 +29,10 @@\n*   + Add delay after stop to ensure I2C tBUF satisfied\n*   + Clear SSC status after reset\n*   + Reorder TX & I2C config register pokes in prepare to read phase\n- * Version 2.5 (24th Oct 2008)  Carl Shaw <carl.shaw@st.com>\n- *   + Rewrite START state - in case of write it now preloads TX FIFO\n- *                           and it is also shared for REPSTART address\n- *   + Change RX prepare - checks for NACK, reads address and then falls\n- *                         through to read state\n- *   + Change RX state - Use TEEN interrupt to reduce unnecessary interrupt\n- *                       loading.  Previously, RIR was used which generated\n- *                       an interrupt per byte\n- *   + Change TX state - correctly unload RX FIFO (using both FIFO status\n- *                       AND RIR bit)\n- *                     - use TEEN interrupt rather than TIR\n- *   + Change repstart address - just call START state but suppress STARTG\n- *   + Only use PIO recovery as last-ditch effort\n- *   + Fix retry method\n- *   + Add auto retry in case of arbitration problem\n- *   + Allow a PIO mode for clock of push-pull rather than BIDIR.  This\n- *     can help with spurious noise glitches on the SCK line and in the\n- *     case where SCK rise times are marginal due to capacitance on the\n- *     bus.\n*\n* --------------------------------------------------------------------\n*\n- *  Copyright (C) 2006 - 2008 STMicroelectronics\n+ *  Copyright (C) 2006, 2007, 2008 : STMicroelectronics\n*  Author: Francesco Virlinzi     <francesco.virlinzi@st.com>\n*\n* May be copied or modified under the terms of the GNU General Public\n@@ -75,70 +56,87 @@\n#include "./i2c-stm.h"\n#include <linux/stm/stssc.h>\n\n-#undef dbg_print\n+#undef dgb_print\n\n#ifdef  CONFIG_I2C_DEBUG_BUS\n-#define dbg_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)\n+#define dgb_print(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)\n#else\n-#define dbg_print(fmt, args...)\n+#define dgb_print(fmt, args...)\n#endif\n\n-#undef dbg_print2\n+#undef dgb_print2\n#ifdef  CONFIG_I2C_DEBUG_ALGO\n-#define dbg_print2(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)\n+#define dgb_print2(fmt, args...)  printk("%s: " fmt, __FUNCTION__ , ## args)\n#else\n-#define dbg_print2(fmt, args...)\n+#define dgb_print2(fmt, args...)\n#endif\n\n/* --- Defines for I2C --- */\n/* These values WILL produce physical clocks which are slower */\n-/* Especially if hardware glitch suppression is enabled       */\n+/* Especially if hardware glith suppression is enabled        */\n/* They should probably be made board dependent?              */\n-#define I2C_RATE_NORMAL\t\t\t100000\n+#define I2C_RATE_NORMAL                 100000\n#define I2C_RATE_FASTMODE\t\t400000\n\n+\n#define NANOSEC_PER_SEC\t\t\t1000000000\n\n/* Standard I2C timings */\n#define REP_START_HOLD_TIME_NORMAL\t4000\n-#define START_HOLD_TIME_NORMAL\t\t4000\n-#define REP_START_SETUP_TIME_NORMAL\t4700\n-#define DATA_SETUP_TIME_NORMAL\t\t 250\n-#define STOP_SETUP_TIME_NORMAL\t\t4000\n-#define BUS_FREE_TIME_NORMAL\t\t4700\n-\n#define REP_START_HOLD_TIME_FAST\t 600\n+#define START_HOLD_TIME_NORMAL\t\t4000\n#define START_HOLD_TIME_FAST\t\t 600\n+#define REP_START_SETUP_TIME_NORMAL\t4700\n#define REP_START_SETUP_TIME_FAST\t 600\n+#define DATA_SETUP_TIME_NORMAL\t\t 250\n#define DATA_SETUP_TIME_FAST\t\t 100\n+#define STOP_SETUP_TIME_NORMAL\t\t4000\n#define STOP_SETUP_TIME_FAST\t\t 600\n+#define BUS_FREE_TIME_NORMAL\t\t4700\n#define BUS_FREE_TIME_FAST\t\t1300\n\n+/* These values come from hw boys... */\n+/*\n+#define REP_START_HOLD_TIME_NORMAL\t4000\n+#define REP_START_HOLD_TIME_FAST\t6500\n+#define START_HOLD_TIME_NORMAL\t\t4500\n+#define START_HOLD_TIME_FAST\t\t800\n+#define REP_START_SETUP_TIME_NORMAL\t4700\n+#define REP_START_SETUP_TIME_FAST\t800\n+#define DATA_SETUP_TIME_NORMAL\t\t300\n+#define DATA_SETUP_TIME_FAST\t\t300\n+#define STOP_SETUP_TIME_NORMAL\t\t4200\n+#define STOP_SETUP_TIME_FAST\t\t800\n+#define BUS_FREE_TIME_NORMAL\t\t5700\n+#define BUS_FREE_TIME_FAST\t\t1500\n+*/\n+\n/* Define for glitch suppression support */\n#ifdef CONFIG_I2C_STM_GLITCH_SUPPORT\n-#if CONFIG_GLITCH_CLK_WIDTH > 0\n-#define GLITCH_WIDTH_CLOCK\t\t\tCONFIG_GLITCH_CLK_WIDTH\n+  #if CONFIG_GLITCH_CLK_WIDTH > 0\n+    #define GLITCH_WIDTH_CLOCK\t\t\tCONFIG_GLITCH_CLK_WIDTH\n+  #else\n+    #define GLITCH_WIDTH_CLOCK\t\t\t500 /* in nanosecs */\n+  #endif\n+  #if CONFIG_GLITCH_DATA_WIDTH > 0\n+    #define GLITCH_WIDTH_DATA\t\t\tCONFIG_GLITCH_DATA_WIDTH\n+  #else\n+    #define GLITCH_WIDTH_DATA\t\t\t500 /* in nanosecs */\n+  #endif\n#else\n-#define GLITCH_WIDTH_CLOCK\t\t\t500\t/* in nanosecs */\n-#endif\n-#if CONFIG_GLITCH_DATA_WIDTH > 0\n-#define GLITCH_WIDTH_DATA\t\t\tCONFIG_GLITCH_DATA_WIDTH\n-#else\n-#define GLITCH_WIDTH_DATA\t\t\t500\t/* in nanosecs */\n-#endif\n-#else\n-#define GLITCH_WIDTH_DATA\t\t\t0\n-#define GLITCH_WIDTH_CLOCK\t\t\t0\n+    #define GLITCH_WIDTH_DATA\t\t\t0\n+    #define GLITCH_WIDTH_CLOCK\t\t\t0\n#endif\n\n#ifdef CONFIG_I2C_STM_HW_GLITCH\n-#if CONFIG_HW_GLITCH_WIDTH > 0\n-#define HW_GLITCH_WIDTH\t\t\tCONFIG_HW_GLITCH_WIDTH\n-#else\n-#define HW_GLITCH_WIDTH\t\t\t1\t/* in microseconds */\n-#endif\n+  #if CONFIG_HW_GLITCH_WIDTH > 0\n+    #define HW_GLITCH_WIDTH\t\t\tCONFIG_HW_GLITCH_WIDTH\n+  #else\n+    #define HW_GLITCH_WIDTH\t\t\t1 /* in microseconds */\n+  #endif\n#endif\n\n+\n/* To manage normal vs fast mode */\n#define IIC_STM_CONFIG_SPEED_MASK          0x1\n#define IIC_STM_CONFIG_SPEED_FAST          0x1\n@@ -148,7 +146,6 @@\ntypedef enum _iic_state_machine_e {\nIIC_FSM_VOID = 0,\nIIC_FSM_PREPARE,\n-\tIIC_FSM_NOREPSTART,\nIIC_FSM_START,\nIIC_FSM_DATA_WRITE,\nIIC_FSM_PREPARE_2_READ,\n@@ -160,19 +157,11 @@\nIIC_FSM_ABORT\n} iic_state_machine_e;\n\n-#ifdef CONFIG_I2C_DEBUG_ALGO\n-char *statename[] =\n-    { "VOID", "PREPARE", "START", "DATA_WRITE", "PREPARE_2_READ",\n-\t"DATA_READ", "STOP", "COMPLETE", "REPSTART", "REPSTART_ADDR", "ABORT"\n-};\n-#endif\n-\ntypedef enum _iic_fsm_error_e {\nIIC_E_NO_ERROR = 0x0,\nIIC_E_RUNNING = 0x1,\nIIC_E_NOTACK = 0x2,\n-\tIIC_E_ARBL = 0x4,\n-\tIIC_E_BUSY = 0x8\n+\tIIC_E_ARBL = 0x4\n} iic_fsm_error_e;\n\n/*\n@@ -187,8 +176,8 @@\nstruct i2c_msg *msgs_queue;\nint attempt;\nint queue_length;\n-\tint current_msg;\t/* the message on going */\n-\tint idx_current_msg;\t/* the byte in the message */\n+\tint current_msg;\t\t/* the message on going */\n+\tint idx_current_msg;\t\t/* the byte in the message */\niic_fsm_error_e status_error;\nint waitcondition;\n};\n@@ -205,8 +194,14 @@\n#define jump_on_fsm_start(x)\t{ (x)->state = IIC_FSM_START;\t\\\ngoto be_fsm_start;\t}\n\n-#define jump_on_fsm_stop(x)\tdo { (x)->state = IIC_FSM_STOP;    \\\n-\t\t\t\tgoto be_fsm_stop; } while (0)\n+#define jump_on_fsm_repstart(x)\t{ (x)->state = IIC_FSM_REPSTART; \\\n+                                goto be_fsm_repstart;\t}\n+\n+#define jump_on_fsm_complete(x)\t{ (x)->state = IIC_FSM_COMPLETE; \\\n+\t\t\t\tgoto be_fsm_complete;\t}\n+\n+#define jump_on_fsm_stop(x)\t{ (x)->state = IIC_FSM_STOP;\t\\\n+                                  goto be_fsm_stop;\t}\n\n#define jump_on_fsm_abort(x)\t{ (x)->state = IIC_FSM_ABORT;    \\\ngoto be_fsm_abort;\t}\n@@ -221,26 +216,38 @@\n\n#define clear_ready_fastmode(adap) ((adap)->config &= ~IIC_STM_READY_SPEED_FAST)\n\n-static void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long rate);\n+#if defined(CONFIG_I2C_STM_NOSTOP_API)\n+#define LAST_I2C_WAS_NO_STOP                   0x4\n+#define LAST_I2C_WAS_NO_STOP_MASK              0x4\n+#define check_lasti2cwas_nostop(adap)          (((adap)->config &                      \\\n+                                                       LAST_I2C_WAS_NO_STOP_MASK) ? 1 : 0 )\n+#define set_lasti2cwas_nostop(adap)            ((adap)->config |=  LAST_I2C_WAS_NO_STOP)\n+#define clear_lasti2cwas_nostop(adap)          ((adap)->config &= ~LAST_I2C_WAS_NO_STOP_MASK)\n+#else\n+#define check_lasti2cwas_nostop(adap)          (1==0)\n+#define set_lasti2cwas_nostop(adap)            {}\n+#define clear_lasti2cwas_nostop(adap)          {}\n+#endif\n+\n+static void iic_stm_setup_timing(struct iic_ssc *adap,unsigned long rate);\n\nstatic irqreturn_t iic_state_machine(int this_irq, void *data)\n{\nstruct iic_ssc *adap = (struct iic_ssc *)data;\nstruct iic_transaction *trsc = adap->trns;\n-\tunsigned int status;\n-\tunsigned int idx, previntmask, lim, intflags, conflags = 0;\n-#ifdef CONFIG_I2C_DEBUG_ALGO\n-\tunsigned int cw;\n-#endif\n+\tunsigned short status;\n+\tshort tx_fifo_status;\n+\tunsigned int idx, previntmask;\nunsigned short address;\nstruct i2c_msg *pmsg;\nchar fast_mode;\nunion {\nchar bytes[2];\n-\t\tunsigned short word;\n+\t\tshort word;\n} tmp;\n-\tunsigned short txbuff[SSC_TXFIFO_SIZE];\n-\tunsigned int txbuffcount;\n+\tint tmp2=0;\n+\n+\tdgb_print2("\\n");\n\nfast_mode = check_fastmode(adap);\npmsg = trsc->msgs_queue + trsc->current_msg;\n@@ -250,334 +257,270 @@\nssc_store32(adap, SSC_IEN, 0);\n\nstatus = ssc_load32(adap, SSC_STA);\n-\tdbg_print2("ISR status = 0x%08x\\n", status);\n\n-\t/* Slave mode detection - this should never happen as we don\'t support multi-master */\n-\tif (trsc->state > IIC_FSM_START && ((status & SSC_STA_ARBL)\n-\t\t\t\t\t    || !(ssc_load32(adap, SSC_CTL) &\n-\t\t\t\t\t\t SSC_CTL_MS))) {\n-\t\tdbg_print2("SLAVE mode (state %d, status %08x)\\n",\n-\t\t\t   trsc->state, status);\n-\t\tdbg_print2(" Message [%d of %d] is %s address 0x%02x bus %d\\n",\n-\t\t\t   trsc->current_msg + 1, trsc->queue_length,\n-\t\t\t   (pmsg->flags & I2C_M_RD) ? "READ from" : "WRITE to",\n-\t\t\t   pmsg->addr, adap->adapter.nr);\n-\t\tdbg_print2\n-\t\t    ("   data is %d bytes, currently at %d, last 0x%02x\\n",\n-\t\t     pmsg->len, trsc->idx_current_msg,\n-\t\t     (trsc->idx_current_msg >\n-\t\t      0) ? pmsg->buf[trsc->idx_current_msg - 1] : 0);\n-\t\tdbg_print2("Prev State: %s Changing to state: %s \\n",\n-\t\t\t   statename[trsc->state], statename[trsc->next_state]);\n-\n-\t\tdbg_print2\n-\t\t    ("Status: 0x%08x SSC_IEN 0x%08x "\n-\t\t\t"SSC_CTL 0x%08x SSC_I2C 0x%08x\\n",\n-\t\t     status, previntmask, ssc_load32(adap, SSC_CTL),\n-\t\t     ssc_load32(adap, SSC_I2C));\n+\ttrsc->state = trsc->next_state;\n\n+\t/* Slave mode detection - this should never happen as we don\'t support multi-master */\n+\tif ( trsc->state > IIC_FSM_START &&\n+\t     ((status & SSC_STA_ARBL) || !(ssc_load32(adap, SSC_CTL) & SSC_CTL_MS)) ){\n+\t\tdgb_print2("In SLAVE mode (state %d, status %08x)!\\n", trsc->state, status);\ntrsc->status_error = IIC_E_ARBL;\n-\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n-\t\ttrsc->waitcondition = 0;\n-\t\twake_up(&(adap->wait_queue));\n-\t\treturn IRQ_HANDLED;\n+    clear_lasti2cwas_nostop(adap);\n+    ssc_store32(adap, SSC_CLR, 0xdc0);\n+    ssc_store32(adap, SSC_TBUF, 0x1ff);\n+    trsc->next_state = IIC_FSM_COMPLETE;\n+    ssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+          SSC_I2C_TXENB | SSC_I2C_STOPG |\n+          (SSC_I2C_I2CFSMODE * fast_mode));\n+    ssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);\n+    return IRQ_HANDLED;\n}\n\n-\ttrsc->state = trsc->next_state;\n-\nswitch (trsc->state) {\ncase IIC_FSM_PREPARE:\n-\t\tdbg_print2("-Prepare\\n");\n+\t\tdgb_print2("-Prepare\\n");\n+\t\tif (check_lasti2cwas_nostop(adap)) {\n+\t\t\tclear_lasti2cwas_nostop(adap);\n+\t\t\tjump_on_fsm_repstart(trsc);\n+\t\t}\n/*\n* check if the i2c timing register\n* of ssc are ready to use\n*/\nif ((check_fastmode(adap) && !check_ready_fastmode(adap)) ||\n-\t\t    (!check_fastmode(adap) && check_ready_fastmode(adap)))\n+\t\t    (!check_fastmode(adap) && check_ready_fastmode(adap)) )\niic_stm_setup_timing(adap,\n-\t\t\t\t\t     clk_get_rate(clk_get\n-\t\t\t\t\t\t\t  (NULL, "comms_clk")));\n-\n-\t\ttrsc->start_state = IIC_FSM_START;\n-\n-\t\t/* Enable RX FIFO, enable clock stretch on TX empty */\n-\t\tssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |\n-\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |\n-\t\t\t    SSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO);\n-\n-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);\n-\n-\t\t/* NO break! */\n+\t\t\t\tclk_get_rate(clk_get(NULL,"comms_clk")));\n+\t\tjump_on_fsm_start(trsc);\n+\t\tbreak;\n\n-\tcase IIC_FSM_NOREPSTART:\n+\tcase IIC_FSM_START:\n+\t      be_fsm_start:\n+\t\tdgb_print2("-Start address 0x%x\\n", pmsg->addr);\n+\t\t/* Reset SSC */\n+\t\tssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |\n+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);\nssc_store32(adap, SSC_CLR, 0xdc0);\n-\t\ttrsc->state = IIC_FSM_START;\n-\t\tconflags = SSC_I2C_STRTG;\n\n-\t\tif (!check_fastmode(adap))\n-\t\t\tndelay(4000);\n-\t\telse\n-\t\t\tndelay(700);\n+\t\t/* enable RX, TX FIFOs */\n+\t\tssc_store32(adap, SSC_CTL,\n+\t\t\t    SSC_CTL_EN | SSC_CTL_MS |\n+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |\n+\t\t\t    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);\n\n-\t\t/* NO break! */\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));\n\n-\tcase IIC_FSM_START:\n-be_fsm_start:\n-\t\tdbg_print2("-Start address 0x%x\\n", pmsg->addr);\n-\n-\t\ttrsc->idx_current_msg = 0;\n+\t\ttrsc->start_state = IIC_FSM_START;\n+\t\ttrsc->next_state  = IIC_FSM_DATA_WRITE;\n\naddress = (pmsg->addr << 2) | 0x1;\n-\t\tif (pmsg->flags & I2C_M_RD) {\n-\t\t\tdbg_print2(" Reading %d bytes\\n", pmsg->len);\n-\n+\t\tif (pmsg->flags & I2C_M_RD){\naddress |= 0x2;\ntrsc->next_state = IIC_FSM_PREPARE_2_READ;\n-\t\t\tintflags =\n-\t\t\t    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;\n-\n-\t\t\ttxbuff[0] = address;\n-\t\t\ttxbuffcount = 1;\n-\t\t} else {\n-\t\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;\n-\t\t\tintflags =\n-\t\t\t    SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;\n-\n-\t\t\tdbg_print2("-Writing %d bytes\\n", pmsg->len);\n-\t\t\ttxbuff[0] = address;\n-\t\t\ttxbuffcount = 1;\n-\t\t\tidx = SSC_TXFIFO_SIZE - 1;\n-\t\t\tdbg_print2(" TX FIFO %d empty slots\\n", idx);\n-\n-\t\t\t/* In the write case, we also preload the TX buffer\n-\t\t\t * with some data to reduce the interrupt loading\n-\t\t\t */\n-\t\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {\n-\t\t\t\ttmp.bytes[0] =\n-\t\t\t\t    pmsg->buf[trsc->idx_current_msg++];\n-\t\t\t\ttxbuff[txbuffcount] = tmp.word << 1 | 0x1;\n-\t\t\t\tdbg_print2(" write 0x%02x\\n", tmp.bytes[0]);\n-\t\t\t\ttxbuffcount++;\n-\t\t\t\tidx--;\n-\t\t\t}\n}\n+\t\ttrsc->idx_current_msg = 0;\n\n-\t\t/* drive SDA... */\n-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB);\n-\t\tfor (idx = 0; idx < txbuffcount; idx++)\n-\t\t\tssc_store32(adap, SSC_TBUF, txbuff[idx]);\n-\t\tssc_store32(adap, SSC_IEN, intflags);\n-\n-\t\t/* Check for bus busy.  This shouldn\'t happen but if the RX\n-\t\t * FIFOs are not empty in the last transaction BEFORE the SSC\n-\t\t * reset occurs, then we get a BUSY error here...\n-\t\t */\n-\t\tif (trsc->start_state != IIC_FSM_REPSTART) {\n-\t\t\tif (ssc_load32(adap, SSC_STA) & SSC_STA_BUSY) {\n-\t\t\t\tdbg_print2(" bus BUSY!\\n");\n-\t\t\t\ttrsc->waitcondition = 0;\n-\t\t\t\ttrsc->status_error = IIC_E_BUSY;\n-\t\t\t} else {\n-\t\t\t\t/* START! */\n-\t\t\t\tssc_store32(adap, SSC_I2C,\n-\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |\n-\t\t\t\t\t    conflags);\n-\t\t\t}\n+\t\tstatus = ssc_load32(adap, SSC_STA);\n+\t\tif (status & SSC_STA_BUSY){\n+\t\t\tdgb_print2("    bus BUSY!\\n");\n+\t\t\ttrsc->waitcondition = 0; /* to not sleep */\n+\t\t\ttrsc->status_error = IIC_E_RUNNING;\t/* to raise the error */\n+\t\t\treturn -1;\n}\n\n+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);\n+\t\tssc_store32(adap, SSC_TBUF, address);\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t    SSC_I2C_STRTG | SSC_I2C_TXENB |\n+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));\nbreak;\n\n-\tcase IIC_FSM_REPSTART_ADDR:\n-\t\tdbg_print2("-Rep Start addr 0x%x\\n", pmsg->addr);\n-\n-\t\t/* Clear NACK */\n-\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n-\n-\t\ttrsc->start_state = IIC_FSM_REPSTART;\n-\t\tconflags = 0;\n-\n-\t\tjump_on_fsm_start(trsc);\n-\n-\ncase IIC_FSM_PREPARE_2_READ:\n-\t\tdbg_print2("-Prepare to Read...\\n");\n-\n-\t\t/* Read address */\n-\t\tssc_load32(adap, SSC_RBUF);\n+\t\t/* Clear the RBUF */\n+\t\twhile (ssc_load32(adap, SSC_RX_FSTAT)){\n+\t\t\tdgb_print2(".");\n+\t\t\tssc_load32(adap, SSC_RBUF);\n+\t\t}\n\n-\t\t/* Check for NACK */\n-\t\tif (status & SSC_STA_NACK) {\n-\t\t\tdbg_print2(" read: NACK detected\\n");\n-\t\t\tjump_on_fsm_abort(trsc);\n+\t\tif (ssc_load32(adap, SSC_TX_FSTAT)){\n+\t\t\tprintk(KERN_ERR "i2c-stm: IIC_FSM_PREPARE_2_READ:TX FIFO NOT empty!\\n");\n}\n\n-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG);\n+\t\tstatus = ssc_load32(adap, SSC_STA);\n+\t\tdgb_print2(" Prepare to Read... Status=0x%x\\n", status);\n+\n+\t\tif (status & SSC_STA_NACK)\n+\t\t\tjump_on_fsm_abort(trsc);\n\ntrsc->next_state = IIC_FSM_DATA_READ;\n\n-\t\t/* NO break */\n+\t\tswitch (pmsg->len) {\n+\t\tcase 0: dgb_print2("Zero Read\\n");\n+\t\t\tjump_on_fsm_stop(trsc);\n+\n+\t\tcase 1:\n+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t\t(SSC_I2C_I2CFSMODE * fast_mode));\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);\n+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);\n+\t\t   break;\n+\t\tdefault:\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_ACKG |\n+\t\t\t\t(SSC_I2C_I2CFSMODE * fast_mode));\n+\t\t\t/* P.S.: in any case the last byte has to be\n+\t\t\t *       managed in a different manner\n+\t\t\t */\n+\t\t\tfor ( idx = 0;  idx < SSC_TXFIFO_SIZE &&\n+\t\t\t\t\tidx < pmsg->len-1 ;  ++idx )\n+\t\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);\n+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);\n+\t\t}\n+\t\tbreak;\n\ncase IIC_FSM_DATA_READ:\n-\t\tdbg_print2("-Read\\n");\n-\t\t/* Clear the RX buffer */\n-\t\tidx = (ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS);\n-\t\tif (!idx && (ssc_load32(adap, SSC_STA) & SSC_STA_RIR))\n-\t\t\tidx = SSC_RXFIFO_SIZE;\n+\t\t/* Check for transmit problem */\n+\t\tif (!(status & SSC_STA_TE)){\n+\t\t\tssc_store32(adap, SSC_IEN, previntmask);\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/* Check for unexpected bus STOP condition */\n+\t\tif (status & SSC_STA_STOP){\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\t\tjump_on_fsm_abort(trsc);\n+\t\t}\n\n-\t\tdbg_print2(" Rx %d bytes in FIFO...\\n", idx);\n-\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {\n+\t\tdgb_print2(" Data Read...Status=0x%x\\n",status);\n+\t\t/* 1.0 Is it the last byte */\n+\t\tif (trsc->idx_current_msg == pmsg->len-1) {\ntmp.word = ssc_load32(adap, SSC_RBUF);\ntmp.word = tmp.word >> 1;\npmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];\n-\t\t\tdbg_print2(" Rx Data 0x%02x\\n", tmp.bytes[0] & 0xff);\n-\t\t\tidx--;\n+\t\t\tdgb_print2(" Rx Data %d-%c\\n",tmp.bytes[0], tmp.bytes[0]);\n+\t\t} else {\n+\t\t\t/* 1.1 take the bytes from Rx fifo */\n+\t\t\tfor (idx = 0 ;  idx < SSC_RXFIFO_SIZE &&\n+\t\t\t\ttrsc->idx_current_msg < pmsg->len-1; ++idx ) {\n+\t\t\t\t\ttmp.word = ssc_load32(adap, SSC_RBUF);\n+\t\t\t\t\ttmp.word = tmp.word >> 1;\n+\t\t\t\t\tpmsg->buf[trsc->idx_current_msg++] = tmp.bytes[0];\n+\t\t\t\t\tdgb_print2(" Rx Data %d-%c\\n",tmp.bytes[0], tmp.bytes[0]);\n+\t\t\t}\n}\n\n-\t\t/* If end of RX, issue STOP or REPSTART */\n+\t\t/* 2. Do we finish? */\nif (trsc->idx_current_msg == pmsg->len) {\n+\t\t\tstatus &= ~SSC_STA_NACK;\njump_on_fsm_stop(trsc);\n}\n\n-\t\t/*    Generate clock for another set of bytes.\n-\t\t *    We have to process the last byte separately as we need to\n-\t\t *    NOT generate an ACK\n+\t\t/* 3. Ask other \'idx\' bytes in fifo mode\n+\t\t *    but we want save the latest [pmsg->len-1]\n+\t\t *    in any case...\n+\t\t *    This will also clear any pending clockstretch\n*/\n-\t\tif (trsc->idx_current_msg == (pmsg->len - 1)) {\n-\t\t\t/* last byte - disable ACKG */\n-\t\t\tdbg_print2(" Rx last byte\\n");\n-\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);\n-\t\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t\t    SSC_IEN_NACKEN | SSC_IEN_ARBLEN);\n+\t\tfor (idx=0; idx<SSC_TXFIFO_SIZE &&\n+\t\t\t   (trsc->idx_current_msg+idx)<pmsg->len-1; ++idx)\nssc_store32(adap, SSC_TBUF, 0x1ff);\n-\t\t} else {\n-#ifdef CONFIG_I2C_DEBUG_ALGO\n-\t\t\tcw = 0;\n-#endif\n-\t\t\tidx = SSC_TXFIFO_SIZE;\n-\t\t\tdbg_print2(" idx=%d status=0x%08x\\n", idx,\n-\t\t\t\t   ssc_load32(adap, SSC_STA));\n-\n-\t\t\twhile (idx\n-\t\t\t       && (trsc->idx_current_msg +\n-\t\t\t\t   (SSC_TXFIFO_SIZE - idx)) < (pmsg->len - 1)) {\n-\t\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);\n-#ifdef CONFIG_I2C_DEBUG_ALGO\n-\t\t\t\tcw++;\n-#endif\n-\t\t\t\tidx--;\n-\t\t\t}\n-\t\t\tdbg_print2("Clock writes: %d\\n", cw);\n\n-\t\t\t/* only take one interrupt when transmit FIFO empty! */\n-\t\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t\t    SSC_IEN_ARBLEN | SSC_IEN_TEEN);\n-\t\t}\n+\t\tdgb_print2(" Asked %x bytes in fifo mode\\n",idx);\n+\n+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_RIEN | SSC_IEN_TIEN | SSC_IEN_ARBLEN);\n\n+\t\t/*Is the next byte the last byte? */\n+\t\tif (trsc->idx_current_msg == (pmsg->len - 1)) {\n+\t\t\tdgb_print2(" Asked the last byte\\n");\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\t\tssc_store32(adap, SSC_TBUF, 0x1ff);\n+\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode) );\n+\t\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_ARBLEN);\n+\t\t}\nbreak;\n\ncase IIC_FSM_DATA_WRITE:\n-\t\tdbg_print2("-Write\\n");\n-\t\t/* Clear RX data from FIFO */\n-\n-\t\t/* It is not clear from the SSC4 datasheet, but the RX_FSTAT\n-\t\t * register does not tell the whole story...  if RIR is set in\n-\t\t * the STATUS reg then we need to read 8 words.  RX_FSTAT only\n-\t\t * notifies us of at most 7 words - hence the extra check below\n-\t\t */\n-\n-\t\tlim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;\n-\t\tif (!lim && (status & SSC_STA_RIR))\n-\t\t\tlim = 8;\n+\t\t/* Check for unexpected bus STOP condition */\n+\t\tif (status & SSC_STA_STOP){\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\t\tjump_on_fsm_abort(trsc);\n+\t\t}\n\n-\t\tdbg_print2(" clearing %d RX words\\n", lim);\n-\t\tfor (idx = 0; idx < lim; idx++)\n+\t\t/* just to clear some bits in the STATUS register */\n+\t\twhile (ssc_load32(adap, SSC_RX_FSTAT))\nssc_load32(adap, SSC_RBUF);\n-\n-\t\t/* Clear status bits EXCEPT NACK */\n+/*\n+ * Be careful!!!!\n+ * Here I don\'t have to use 0xdc0 for\n+ * the SSC_CLR register\n+ */\nssc_store32(adap, SSC_CLR, 0x9c0);\n\n-\t\t/* Check for NACK */\nstatus = ssc_load32(adap, SSC_STA);\n-\t\tdbg_print2("write: status = 0x%08x\\n", status);\n-\t\tif (status & SSC_STA_NACK) {\n-\t\t\tdbg_print2(" NACK detected\\n");\n+\t\tif (status & SSC_STA_NACK)\njump_on_fsm_abort(trsc);\n+\n+\t\ttx_fifo_status = ssc_load32(adap,SSC_TX_FSTAT);\n+\t\tif ( tx_fifo_status ) {\n+\t\t\tdgb_print2(" Fifo not empty\\n");\n+\t\t\tssc_store32(adap, SSC_IEN, previntmask);\n+\t\t\tbreak;\n}\n\n-\t\t/* If end of TX, issue STOP or REPSTART */\n-\t\tif (trsc->idx_current_msg == pmsg->len)\n+\t\tif (trsc->idx_current_msg == pmsg->len || !(pmsg->len))\njump_on_fsm_stop(trsc);\n\n-\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;\n+\t\tdgb_print2(" Data Write...Status=0x%x 0x%x-%c\\n", status,\n+\t\t\t  pmsg->buf[trsc->idx_current_msg],\n+\t\t\t  pmsg->buf[trsc->idx_current_msg]);\n\n-\t\t/* Interrupt when TX buffer empty */\n-\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t    SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB |\n+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));\n\n-\t\tidx = SSC_TXFIFO_SIZE;\n-\t\twhile (idx && trsc->idx_current_msg < pmsg->len) {\n+\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;\n+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_TEEN | SSC_IEN_NACKEN | SSC_IEN_ARBLEN);\n+\n+\t\tfor (; tx_fifo_status < SSC_TXFIFO_SIZE &&\n+\t\t\ttrsc->idx_current_msg < pmsg->len ;++tx_fifo_status )\n+\t\t{\ntmp.bytes[0] = pmsg->buf[trsc->idx_current_msg++];\nssc_store32(adap, SSC_TBUF, tmp.word << 1 | 0x1);\n-\t\t\tdbg_print2(" Write 0x%02x\\n", tmp.bytes[0]);\n-\t\t\tidx--;\n}\n-\nbreak;\n\ncase IIC_FSM_ABORT:\nbe_fsm_abort:\n-\t\tdbg_print2("Abort - issuing STOP\\n");\n+\t\tdgb_print2(" Abort\\n");\ntrsc->status_error |= IIC_E_NOTACK;\n+\t\t/* Don\'t ADD the break */\n\n+\tcase IIC_FSM_STOP:\n+\t      be_fsm_stop:\n+\t\tif (!(status & SSC_STA_NACK) &&\n+\t\t    (++trsc->current_msg < trsc->queue_length)) {\n+\t\t\tjump_on_fsm_repstart(trsc);\n+\t\t}\n+\t\tif (pmsg->flags & I2C_M_NOSTOP && !(status & SSC_STA_NACK)){    /* NoStop message! */\n+\t\t\tset_lasti2cwas_nostop(adap);\n+\t\t\tdgb_print2(" Stop not done\\n");\n+\t\t\tjump_on_fsm_complete(trsc);\n+\t\t}\n+\t\tclear_lasti2cwas_nostop(adap);\n+\t\tdgb_print2(" Stop\\n");\nssc_store32(adap, SSC_CLR, 0xdc0);\ntrsc->next_state = IIC_FSM_COMPLETE;\n-\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t    SSC_I2C_TXENB | SSC_I2C_STOPG |\n+\t\t\t    (SSC_I2C_I2CFSMODE * fast_mode));\nssc_store32(adap, SSC_IEN, SSC_IEN_STOPEN | SSC_IEN_ARBLEN);\n-\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_STOPG);\n-\t\tbreak;\n-\n-\tcase IIC_FSM_STOP:\n-be_fsm_stop:\n-\t\tdbg_print2("-Stop\\n");\n-\n-\t\tif (++trsc->current_msg < trsc->queue_length) {\n-\t\t\t/* More transactions left... */\n-\t\t\tif (pmsg->flags & I2C_M_NOREPSTART) {\n-\t\t\t\t/* no repstart - stop then start */\n-\t\t\t\tdbg_print2(" STOP - STOP\\n");\n-\t\t\t\ttrsc->next_state = IIC_FSM_NOREPSTART;\n-\t\t\t\tssc_store32(adap, SSC_I2C,\n-\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |\n-\t\t\t\t\t    SSC_I2C_STOPG);\n-\t\t\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t\t\t    SSC_IEN_STOPEN | SSC_IEN_ARBLEN);\n-\t\t\t} else {\n-\t\t\t\t/* repstart */\n-\t\t\t\tdbg_print2(" STOP - REPSTART\\n");\n-\t\t\t\ttrsc->next_state = IIC_FSM_REPSTART_ADDR;\n-\t\t\t\tssc_store32(adap, SSC_I2C,\n-\t\t\t\t\t    SSC_I2C_I2CM |\n-\t\t\t\t\t    SSC_I2C_TXENB |\n-\t\t\t\t\t    SSC_I2C_REPSTRTG);\n-\t\t\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t\t\t    SSC_IEN_REPSTRTEN |\n-\t\t\t\t\t    SSC_IEN_ARBLEN);\n-\t\t\t}\n-\t\t} else {\n-\t\t\t/* stop */\n-\t\t\tdbg_print2(" STOP - STOP\\n");\n-\t\t\ttrsc->next_state = IIC_FSM_COMPLETE;\n-\t\t\tssc_store32(adap, SSC_I2C,\n-\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_TXENB |\n-\t\t\t\t    SSC_I2C_STOPG);\n-\t\t\tssc_store32(adap, SSC_IEN,\n-\t\t\t\t    SSC_IEN_STOPEN | SSC_IEN_ARBLEN);\n-\t\t}\n-\nbreak;\n\ncase IIC_FSM_COMPLETE:\n-\t\tdbg_print2("-Complete\\n");\n+\t    be_fsm_complete:\n+\t\tdgb_print2(" Complete\\n");\n+\t\tudelay(5);\n\nif (!(trsc->status_error & IIC_E_NOTACK))\ntrsc->status_error = IIC_E_NO_ERROR;\n@@ -586,6 +529,40 @@\nwake_up(&(adap->wait_queue));\nbreak;\n\n+\tcase IIC_FSM_REPSTART:\n+\t      be_fsm_repstart:\n+\t\tpmsg = trsc->msgs_queue + trsc->current_msg;\n+\t\tdgb_print2("-Rep Start (0x%x)\\n",pmsg->addr);\n+\t\ttrsc->start_state = IIC_FSM_REPSTART;\n+\t\ttrsc->idx_current_msg = 0;\n+\t\ttrsc->next_state = IIC_FSM_REPSTART_ADDR;\n+\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\tif(ssc_load32(adap,SSC_STA) & SSC_STA_REPSTRT)\n+\t\t\ttmp2=1;\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB\n+\t\t\t    | SSC_I2C_REPSTRTG | (SSC_I2C_I2CFSMODE *\n+\t\t\t\t\t\t  fast_mode));\n+\t\tif(tmp2) /* we was not able to clear the status bit */\n+\t\t\tudelay(5);\n+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_REPSTRTEN | SSC_IEN_ARBLEN);\n+\t\tbreak;\n+\n+\tcase IIC_FSM_REPSTART_ADDR:\n+\t\tdgb_print2("-Rep Start addr 0x%x\\n", pmsg->addr);\n+\t\t/* Clear repstart bit */\n+\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM | SSC_I2C_TXENB\n+\t\t\t\t  | (SSC_I2C_I2CFSMODE * fast_mode));\n+\n+\t\tssc_store32(adap, SSC_CLR, 0xdc0);\n+\t\taddress = (pmsg->addr << 2) | 0x1;\n+\t\ttrsc->next_state = IIC_FSM_DATA_WRITE;\n+\t\tif (pmsg->flags & I2C_M_RD) {\n+\t\t\taddress |= 0x2;\n+\t\t\ttrsc->next_state = IIC_FSM_PREPARE_2_READ;\n+\t\t}\n+\t\tssc_store32(adap, SSC_TBUF, address);\n+\t\tssc_store32(adap, SSC_IEN, SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN);\n+\t\tbreak;\ndefault:\nprintk(KERN_ERR "i2c-stm: Error in the FSM\\n");\n;\n@@ -594,6 +571,7 @@\nreturn IRQ_HANDLED;\n}\n\n+\n/*\n* Wait for stop to be detected on bus\n*/\n@@ -601,65 +579,36 @@\n{\nunsigned int idx;\n\n-\tdbg_print("\\n");\n-\tfor (idx = 0; idx < 5; ++idx) {\n-\t\tif (ssc_load32(adap, SSC_STA) & SSC_STA_STOP)\n+\tdgb_print("\\n");\n+\tfor ( idx = 0; idx < 5 ; ++idx ){\n+\t\tif (ssc_load32(adap,SSC_STA) & SSC_STA_STOP)\nreturn 1;\nmdelay(2);\n}\n\n-\tprintk(KERN_ERR "*** iic_wait_stop_condition: TIMED OUT ***\\n");\nreturn 0;\n}\n\n/*\n- * Reset SSC bus\n- */\n-static void iic_ssc_reset(struct iic_ssc *adap)\n-{\n-\tunsigned int lim, status, idx;\n-\n-\t/* Ensure RX buffer empty */\n-\tstatus = ssc_load32(adap, SSC_STA);\n-\tlim = ssc_load32(adap, SSC_RX_FSTAT) & SSC_RX_FSTAT_STATUS;\n-\tif (!lim && (status & SSC_STA_RIR))\n-\t\tlim = 8;\n-\n-\tfor (idx = 0; idx < lim; idx++)\n-\t\tssc_load32(adap, SSC_RBUF);\n-\n-\t/* Reset SSC */\n-\tssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |\n-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);\n-\n-\t/* enable RX, TX FIFOs - clear SR bit */\n-\tssc_store32(adap, SSC_CTL, SSC_CTL_EN | SSC_CTL_MS |\n-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8 |\n-\t\t    SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO);\n-}\n-\n-/*\n* Wait for bus to become free\n*/\nstatic int iic_wait_free_bus(struct iic_ssc *adap)\n{\n-\tunsigned int reg = 0;\nunsigned int idx;\n\n-\tdbg_print("\\n");\n+\tdgb_print("\\n");\n\n-\tiic_ssc_reset(adap);\n+\tif (check_lasti2cwas_nostop(adap)){\n+\t\tdgb_print("last transaction nostop.  Not waiting for free bus\\n");\n+\t\treturn 1;\n+\t}\n\n-\tfor (idx = 0; idx < 10; ++idx) {\n-\t\treg = ssc_load32(adap, SSC_STA);\n-\t\tdbg_print("iic_wait_free_bus: status = 0x%08x\\n", reg);\n-\t\tif (!(reg & SSC_STA_BUSY))\n+\tfor ( idx = 0; idx < 5 ; ++idx ) {\n+\t\tif (!(ssc_load32(adap,SSC_STA) & SSC_STA_BUSY) )\nreturn 1;\nmdelay(2);\n}\n\n-\tprintk(KERN_ERR "*** iic_wait_free_bus: TIMED OUT ***\\n");\n-\nreturn 0;\n}\n\n@@ -670,267 +619,169 @@\n{\nint cnt = 0;\n\n-\tif (!(adap->pio_info)->clk)\n-\t\treturn;\t\t/* ssc hard wired */\n+\tif(!(adap->pio_info)->clk)\n+\t\treturn; /* ssc hard wired */\nprintk(KERN_WARNING "i2c-stm: doing PIO stop!\\n");\n\n/* Send STOP */\nstpio_set_pin((adap->pio_info)->clk, 0);\nstpio_set_pin((adap->pio_info)->sdout, 0);\n-\tstpio_configure_pin((adap->pio_info)->clk, STPIO_OUT);\n+\tstpio_configure_pin((adap->pio_info)->clk, STPIO_BIDIR);\nstpio_configure_pin((adap->pio_info)->sdout, STPIO_BIDIR);\nudelay(20);\nstpio_set_pin((adap->pio_info)->clk, 1);\nudelay(20);\nstpio_set_pin((adap->pio_info)->sdout, 1);\nudelay(30);\n-\tif ((adap->pio_info)->clk_unidir)\n-\t\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_OUT);\n-\telse\n-\t\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);\n+\tstpio_configure_pin((adap->pio_info)->clk, STPIO_ALT_BIDIR);\nstpio_configure_pin((adap->pio_info)->sdout, STPIO_ALT_BIDIR);\n\n/* Reset SSC */\nssc_store32(adap, SSC_CTL, SSC_CTL_SR | SSC_CTL_EN | SSC_CTL_MS |\n-\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);\n+\t\t\t    SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | 0x8);\nssc_store32(adap, SSC_CLR, 0xdc0);\n\n/* Make sure SSC thinks the bus is free before continuing */\n-\twhile (cnt < 10\n-\t       && (ssc_load32(adap, SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))) {\n+\twhile (cnt < 10 && (ssc_load32(adap,SSC_STA) & (SSC_STA_BUSY | SSC_STA_NACK))){\nmdelay(2);\n-\t\tcnt++;\n+\t\tcnt ++;\n}\n\nif (cnt == 10)\n-\t\tprintk(KERN_ERR\n-\t\t       "i2c-stm:  Cannot recover bus.  Status: 0x%08x\\n",\n-\t\t       ssc_load32(adap, SSC_STA));\n+\t\tprintk(KERN_ERR "i2c-stm:  Cannot recover bus.  Status: 0x%08x\\n", ssc_load32(adap,SSC_STA));\n}\n\n/*\n* Description: Prepares the controller for a transaction\n*/\nstatic int iic_stm_xfer(struct i2c_adapter *i2c_adap,\n-\t\t\tstruct i2c_msg msgs[], int num)\n+\t\t\t     struct i2c_msg msgs[], int num)\n{\nunsigned int flag;\nint result;\nint timeout;\n-#ifdef CONFIG_I2C_DEBUG_BUS\n-\tint i;\n-#endif\nstruct iic_ssc *adap =\n-\t    (struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);\n+\t\t\t(struct iic_ssc *)container_of(i2c_adap, struct iic_ssc, adapter);\nstruct iic_transaction transaction = {\n-\t\t.msgs_queue = msgs,\n-\t\t.queue_length = num,\n-\t\t.current_msg = 0x0,\n-\t\t.attempt = 0x0,\n-\t\t.status_error = IIC_E_RUNNING,\n-\t\t.next_state = IIC_FSM_PREPARE,\n-\t\t.waitcondition = 1,\n-\t};\n+\t\t\t.msgs_queue   = msgs,\n+\t\t\t.queue_length = num,\n+\t\t\t.current_msg  = 0x0,\n+\t\t\t.attempt      = 0x0,\n+\t\t\t.status_error = IIC_E_RUNNING,\n+\t\t\t.next_state   = IIC_FSM_PREPARE,\n+\t\t\t.waitcondition = 1,\n+\t\t};\n\n-\tdbg_print("\\n");\n+\tdgb_print("\\n");\n\nadap->trns = &transaction;\n\n-#ifdef CONFIG_I2C_DEBUG_BUS\n-\tfor (i = 0; i < num; ++i) {\n-\t\tif (msgs[i].len == 0)\n-\t\t\tprintk(KERN_INFO\n-\t\t\t       "[%d of %d] ZERO LENGTH TRANSACTION : "\n-\t\t\t       "%s addr 0x%02x len %d\\n",\n-\t\t\t       i + 1, num,\n-\t\t\t       (msgs[i].\n-\t\t\t\tflags & I2C_M_RD) ? "read from " :\n-\t\t\t\t"write to ",\n-\t\t\t\tmsgs[i].addr, msgs[i].len);\n-\t\telse\n-\t\t\tprintk(KERN_INFO\n-\t\t\t       "[%d of %d] TRANSACTION : "\n-\t\t\t       "%s addr 0x%02x len %d\\n",\n-\t\t\t       i + 1, num,\n-\t\t\t       (msgs[i].\n-\t\t\t\tflags & I2C_M_RD) ? "read from " :\n-\t\t\t\t"write to ",\n-\t\t\t       msgs[i].addr, msgs[i].len);\n-\t}\n-#endif /* CONFIG_I2C_DEBUG_BUS */\n-\niic_xfer_retry:\n\n-\t/* Wait for bus to become free - do a forced PIO reset if necessary to\n-\t * recover the bus\n-\t */\n+\t/* Wait for bus to become free - do a forced PIO reset if necessary to */\n+\t/* recover the bus */\nif (!iic_wait_free_bus(adap))\niic_pio_stop(adap);\n\niic_state_machine(0, adap);\n\ntimeout = wait_event_interruptible_timeout(adap->wait_queue,\n-\t\t\t\t\t\t   (transaction.waitcondition ==\n-\t\t\t\t\t\t    0), i2c_adap->timeout * HZ);\n+\t\t\t\t\t(transaction.waitcondition==0),\n+\t\t\t\t\ti2c_adap->timeout);\n\nlocal_irq_save(flag);\n\nresult = transaction.current_msg;\n\n-\tif (unlikely\n-\t    (transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {\n-\t\tdbg_print2(KERN_ERR\n-\t\t\t   "xfer: ERROR status %d, timeout %d, attempt %d\\n",\n-\t\t\t   transaction.status_error, timeout,\n-\t\t\t   transaction.attempt);\n-\n-\t\tdbg_print2(KERN_ERR\n-\t\t\t   "Status: 0x%08x SSC_IEN 0x%08x "\n-\t\t\t   "SSC_CTL 0x%08x SSC_I2C 0x%08x\\n",\n-\t\t\t   ssc_load32(adap, SSC_STA), ssc_load32(adap, SSC_IEN),\n-\t\t\t   ssc_load32(adap, SSC_CTL), ssc_load32(adap,\n-\t\t\t\t\t\t\t\t SSC_I2C));\n-\n-\t\tif (((transaction.status_error & IIC_E_NOTACK)\n-\t\t     && transaction.start_state == IIC_FSM_START)\n-\t\t    || (transaction.status_error & IIC_E_BUSY)) {\n-\t\t\tif (++transaction.attempt <= adap->adapter.retries) {\n-\t\t\t\tdbg_print2("RETRYING operation\\n");\n+\tif (unlikely(transaction.status_error != IIC_E_NO_ERROR || timeout <= 0)) {\n+\t\tif ((transaction.status_error & IIC_E_NOTACK) &&\n+\t\t\ttransaction.start_state == IIC_FSM_START &&\n+\t\t\t++transaction.attempt <= adap->adapter.retries){\n/* error on the address - automatically retry */\n/* this used to be done in the FSM complete but it was not safe */\n/* there as we need to wait for the bus to not be busy before */\n/* doing another transaction */\n+\t\t\t\tprintk(KERN_ERR "i2c-stm: error on address.  auto retry %d\\n", transaction.attempt);\ntransaction.status_error = 0;\n-\t\t\t\ttransaction.next_state = IIC_FSM_START;\n-\t\t\t\ttransaction.waitcondition = 1;\nlocal_irq_restore(flag);\ngoto iic_xfer_retry;\n-\t\t\t} else {\n-\t\t\t\tlocal_irq_restore(flag);\n-\t\t\t\tif (transaction.status_error & IIC_E_NOTACK) {\n-\t\t\t\t\tdbg_print("Error: Slave NACK\\n");\n-\t\t\t\t\tresult = -EREMOTEIO;\n-\t\t\t\t} else {\n-\t\t\t\t\tdbg_print("Error: Bus BUSY\\n");\n-\t\t\t\t\tresult = -EBUSY;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (transaction.status_error == IIC_E_ARBL\n-\t\t\t   || (ssc_load32(adap, SSC_CTL) & SSC_CTL_MS) == 0) {\n+\t\t} else if (transaction.status_error == IIC_E_ARBL){\n/* Arbitration error */\n-\t\t\tprintk(KERN_ERR "i2c-stm: arbitration error\\n");\n-\n-\t\t\tssc_store32(adap, SSC_CLR, SSC_CLR_SSCARBL);\n-\t\t\tssc_store32(adap, SSC_CTL,\n-\t\t\t\t    ssc_load32(adap, SSC_CTL) | SSC_CTL_MS);\n-\t\t\ttransaction.status_error = 0;\n-\t\t\ttransaction.next_state = IIC_FSM_START;\n-\t\t\ttransaction.waitcondition = 1;\n+\t\t  printk("i2c-stm: arbitration error\\n");\n+\t\t\tssc_store32(adap, SSC_CLR, 0xdc0); //reset status register\n+\t\t\tssc_store32(adap, SSC_CTL, ssc_load32(adap, SSC_CTL) | SSC_CTL_MS); // make sure we still are master\nlocal_irq_restore(flag);\n\n-\t\t\tif (!iic_wait_free_bus(adap)) {\n-\t\t\t\t/* Last ditch effort */\n-\t\t\t\tiic_pio_stop(adap);\n-\t\t\t}\n-\n-\t\t\tif (++transaction.attempt <= adap->adapter.retries) {\n-\t\t\t\tdbg_print2("RETRYING operation\\n");\n-\t\t\t\tgoto iic_xfer_retry;\n-\t\t\t}\n+\t\t\t/* Manually issue stop condition on the bus */\n+\t\t\tiic_pio_stop(adap);\n} else {\n/* There was another problem */\n-\t\t\tif (timeout <= 0) {\n+\t\t\tif(timeout<=0){\n/* There was a timeout or signal.\n- disable the interrupt\n- generate a stop condition on the bus\nall this task are done without interrupt....\n*/\n-\t\t\t\tdbg_print\n-\t\t\t\t    ("xfer: Wait cnd err %d, status error %d\\n",\n-\t\t\t\t     timeout, transaction.status_error);\nssc_store32(adap, SSC_IEN, 0x0);\n+\t\t\t\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM |\n+\t\t\t\t\t    SSC_I2C_STOPG | SSC_I2C_TXENB |\n+\t\t\t\t\t    (SSC_I2C_I2CFSMODE * check_fastmode(adap)));\n+\t\t\t\t/* wait until the ssc detects a Stop condition on the bus */\n+\t\t\t\t/* but before we do that we enable all the interrupts     */\n+\t\t\t\tlocal_irq_restore(flag);\n\n-\t\t\t\t/* Check if bus free */\n-\t\t\t\tif (!iic_wait_free_bus(adap)) {\n-\t\t\t\t\t/* No - generate stop condition */\n-\t\t\t\t\tssc_store32(adap, SSC_I2C,\n-\t\t\t\t\t\t    SSC_I2C_I2CM | SSC_I2C_STOPG\n-\t\t\t\t\t\t    | SSC_I2C_TXENB);\n-\n-\t\t\t\t\tlocal_irq_restore(flag);\n-\n-\t\t\t\t\tif (!iic_wait_stop_condition(adap)) {\n-\t\t\t\t\t\t/* Reset SSC */\n-\t\t\t\t\t\tssc_store32(adap, SSC_CTL,\n-\t\t\t\t\t\t\t    SSC_CTL_SR |\n-\t\t\t\t\t\t\t    SSC_CTL_EN |\n-\t\t\t\t\t\t\t    SSC_CTL_MS |\n-\t\t\t\t\t\t\t    SSC_CTL_PO |\n-\t\t\t\t\t\t\t    SSC_CTL_PH |\n-\t\t\t\t\t\t\t    SSC_CTL_HB | 0x8);\n-\t\t\t\t\t\tssc_store32(adap, SSC_CLR,\n-\t\t\t\t\t\t\t    0xdc0);\n-\n-\t\t\t\t\t\tif (!iic_wait_free_bus(adap)) {\n-\t\t\t\t\t\t\t/* Last ditch effort */\n-\t\t\t\t\t\t\tiic_pio_stop(adap);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t} else {\n-\t\t\t\t\tlocal_irq_restore(flag);\n+\t\t\t\tif (!iic_wait_stop_condition(adap)){\n+\t\t\t\t\tprintk(KERN_ERR "i2c-stm: Error.  Manually stopping transaction.\\n");\n+\t\t\t\t\tiic_pio_stop(adap);\n}\n+\t\t\t\tclear_lasti2cwas_nostop(adap);\n} else\nlocal_irq_restore(flag);\n\n-\t\t\tif (!timeout) {\n-\t\t\t\tdbg_print\n-\t\t\t\t    ("i2c-stm: Error timeout in the FSM\\n");\n+\t\t\tif (!timeout){\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       "i2c-stm: Error timeout in the finite state machine\\n");\nresult = -ETIMEDOUT;\n} else if (timeout < 0) {\n-\t\t\t\tdbg_print\n-\t\t\t\t    ("i2c-stm: wait event interrupt/error\\n");\n+\t\t\t\tdgb_print("i2c-stm: interrupt or error in wait event\\n");\nresult = timeout;\n-\t\t\t} else {\n-\t\t\t\tdbg_print("i2c-stm: slave failed to respond\\n");\n+\t\t\t} else\nresult = -EREMOTEIO;\n-\t\t\t}\n}\n} else\nlocal_irq_restore(flag);\n\n-#ifdef CONFIG_I2C_DEBUG_BUS\n-\tprintk(KERN_INFO "i2c-stm: i2c_stm_xfer returned %d\\n", result);\n-#endif\nreturn result;\n}\n\n#ifdef  CONFIG_I2C_DEBUG_BUS\nstatic void iic_stm_timing_trace(struct iic_ssc *adap)\n{\n-\tdbg_print("SSC_BRG  %d\\n", ssc_load32(adap, SSC_BRG));\n-\tdbg_print("SSC_REP_START_HOLD %d\\n",\n+\tdgb_print("SSC_BRG  %d\\n",ssc_load32(adap, SSC_BRG));\n+\tdgb_print("SSC_REP_START_HOLD %d\\n",\nssc_load32(adap, SSC_REP_START_HOLD));\n-\tdbg_print("SSC_REP_START_SETUP %d\\n",\n+\tdgb_print("SSC_REP_START_SETUP %d\\n",\nssc_load32(adap, SSC_REP_START_SETUP));\n-\tdbg_print("SSC_START_HOLD %d\\n", ssc_load32(adap, SSC_START_HOLD));\n-\tdbg_print("SSC_DATA_SETUP %d\\n", ssc_load32(adap, SSC_DATA_SETUP));\n-\tdbg_print("SSC_STOP_SETUP %d\\n", ssc_load32(adap, SSC_STOP_SETUP));\n-\tdbg_print("SSC_BUS_FREE %d\\n", ssc_load32(adap, SSC_BUS_FREE));\n-\tdbg_print("SSC_PRE_SCALER_BRG %d\\n",\n+\tdgb_print("SSC_START_HOLD %d\\n", ssc_load32(adap, SSC_START_HOLD));\n+\tdgb_print("SSC_DATA_SETUP %d\\n", ssc_load32(adap, SSC_DATA_SETUP));\n+\tdgb_print("SSC_STOP_SETUP %d\\n", ssc_load32(adap, SSC_STOP_SETUP));\n+\tdgb_print("SSC_BUS_FREE %d\\n", ssc_load32(adap, SSC_BUS_FREE));\n+\tdgb_print("SSC_PRE_SCALER_BRG %d\\n",\nssc_load32(adap, SSC_PRE_SCALER_BRG));\n-\tdbg_print("SSC_NOISE_SUPP_WIDTH %d\\n",\n-\t\t  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH));\n-\tdbg_print("SSC_PRSCALER %d\\n", ssc_load32(adap, SSC_PRSCALER));\n-\tdbg_print("SSC_NOISE_SUPP_WIDTH_DATAOUT %d\\n",\n-\t\t  ssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));\n-\tdbg_print("SSC_PRSCALER_DATAOUT %d\\n",\n-\t\t  ssc_load32(adap, SSC_PRSCALER_DATAOUT));\n+\tdgb_print("SSC_NOISE_SUPP_WIDTH %d\\n",\n+\t\t\tssc_load32(adap, SSC_NOISE_SUPP_WIDTH));\n+\tdgb_print("SSC_PRSCALER %d\\n",\n+\t\t\tssc_load32(adap, SSC_PRSCALER));\n+\tdgb_print("SSC_NOISE_SUPP_WIDTH_DATAOUT %d\\n",\n+\t\t\tssc_load32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT));\n+\tdgb_print("SSC_PRSCALER_DATAOUT %d\\n",\n+\t\t\tssc_load32(adap, SSC_PRSCALER_DATAOUT));\n}\n#endif\n\nstatic void iic_stm_setup_timing(struct iic_ssc *adap, unsigned long clock)\n{\n-\tunsigned long iic_baudrate;\n+\tunsigned long  iic_baudrate;\nunsigned short iic_rep_start_hold;\nunsigned short iic_start_hold;\nunsigned short iic_rep_start_setup;\n@@ -941,99 +792,67 @@\n#ifdef CONFIG_I2C_STM_HW_GLITCH\nunsigned short iic_glitch_width;\nunsigned short iic_glitch_width_dataout;\n-\tunsigned char iic_prescaler;\n+\tunsigned char  iic_prescaler;\nunsigned short iic_prescaler_dataout;\n#endif\n-\tunsigned long ns_per_clk;\n+\tunsigned long  ns_per_clk;\n\n-\tdbg_print("Assuming %lu MHz for the Timing Setup\\n", clock / 1000000);\n+\tdgb_print("Assuming %d MHz for the Timing Setup\\n",\n+\t\t  clock / 1000000);\n\n-\tclock += 500000;\t/* +0.5 Mhz for rounding */\n+\tclock += 500000; /* +0.5 Mhz for rounding */\nns_per_clk = NANOSEC_PER_SEC / clock;\n\nif (check_fastmode(adap)) {\nset_ready_fastmode(adap);\niic_baudrate = clock / (2 * I2C_RATE_FASTMODE);\n-\t\tiic_rep_start_hold =\n-\t\t    (REP_START_HOLD_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_rep_start_setup =\n-\t\t    (REP_START_SETUP_TIME_FAST +\n-\t\t     GLITCH_WIDTH_CLOCK) / ns_per_clk;\n-\t\tif (GLITCH_WIDTH_DATA < 200)\n-\t\t\tiic_start_hold =\n-\t\t\t    (START_HOLD_TIME_FAST +\n-\t\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\tiic_rep_start_hold  =(REP_START_HOLD_TIME_FAST +GLITCH_WIDTH_DATA) /ns_per_clk;\n+\t\tiic_rep_start_setup =(REP_START_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;\n+\t\tif(GLITCH_WIDTH_DATA<200)\n+\t\t\tiic_start_hold =(START_HOLD_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;\nelse\n-\t\t\tiic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_data_setup =\n-\t\t    (DATA_SETUP_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_stop_setup =\n-\t\t    (STOP_SETUP_TIME_FAST + GLITCH_WIDTH_CLOCK) / ns_per_clk;\n-\t\tiic_bus_free =\n-\t\t    (BUS_FREE_TIME_FAST + GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\t\tiic_start_hold =(5*GLITCH_WIDTH_DATA) /ns_per_clk;\n+\t\tiic_data_setup =(DATA_SETUP_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;\n+\t\tiic_stop_setup =(STOP_SETUP_TIME_FAST+GLITCH_WIDTH_CLOCK) /ns_per_clk;\n+\t\tiic_bus_free =(BUS_FREE_TIME_FAST+GLITCH_WIDTH_DATA) /ns_per_clk;\n} else {\nclear_ready_fastmode(adap);\n-\t\tiic_baudrate = clock / (2 * I2C_RATE_NORMAL);\n-\t\tiic_rep_start_hold =\n-\t\t    (REP_START_HOLD_TIME_NORMAL +\n-\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_rep_start_setup =\n-\t\t    (REP_START_SETUP_TIME_NORMAL +\n-\t\t     GLITCH_WIDTH_CLOCK) / ns_per_clk;\n-\t\tif (GLITCH_WIDTH_DATA < 1200)\n-\t\t\tiic_start_hold =\n-\t\t\t    (START_HOLD_TIME_NORMAL +\n-\t\t\t     GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\tiic_baudrate = clock  / (2 * I2C_RATE_NORMAL);\n+\t\tiic_rep_start_hold =( REP_START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\tiic_rep_start_setup =( REP_START_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;\n+\t\tif(GLITCH_WIDTH_DATA<1200)\n+\t\t\tiic_start_hold =( START_HOLD_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;\nelse\n-\t\t\tiic_start_hold = (5 * GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_data_setup =\n-\t\t    (DATA_SETUP_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;\n-\t\tiic_stop_setup =\n-\t\t    (STOP_SETUP_TIME_NORMAL + GLITCH_WIDTH_CLOCK) / ns_per_clk;\n-\t\tiic_bus_free =\n-\t\t    (BUS_FREE_TIME_NORMAL + GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\t\tiic_start_hold =( 5*GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\tiic_data_setup =( DATA_SETUP_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;\n+\t\tiic_stop_setup =( STOP_SETUP_TIME_NORMAL+GLITCH_WIDTH_CLOCK) / ns_per_clk;\n+\t\tiic_bus_free =( BUS_FREE_TIME_NORMAL+GLITCH_WIDTH_DATA) / ns_per_clk;\n}\n\n-\t/* set baudrate */\n-\tssc_store32(adap, SSC_BRG, iic_baudrate);\n-\tssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);\n-\n-\t/* enable I2C mode */\n-\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);\n-\n-\t/* set other timings */\nssc_store32(adap, SSC_REP_START_HOLD, iic_rep_start_hold);\nssc_store32(adap, SSC_START_HOLD, iic_start_hold);\nssc_store32(adap, SSC_REP_START_SETUP, iic_rep_start_setup);\nssc_store32(adap, SSC_DATA_SETUP, iic_data_setup);\nssc_store32(adap, SSC_STOP_SETUP, iic_stop_setup);\nssc_store32(adap, SSC_BUS_FREE, iic_bus_free);\n+\tssc_store32(adap, SSC_PRE_SCALER_BRG, iic_pre_scale_baudrate);\n\n#ifdef CONFIG_I2C_STM_HW_GLITCH\n/* See DDTS GNBvd40668 */\niic_prescaler = 1;\n-\tiic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000;\t/* in uS */\n+\tiic_glitch_width = HW_GLITCH_WIDTH * clock / 100000000; /* width in uS */\niic_glitch_width_dataout = 1;\niic_prescaler_dataout = clock / 10000000;\n\n-/*  This should work, but causes lock-up after repstart\n-    iic_prescaler = clock / 10000000;\n-    iic_glitch_width = HW_GLITCH_WIDTH;\n-    iic_glitch_width_dataout = 1;\n-    iic_prescaler_dataout = clock / 10000000;\n-    printk("*** iic_prescaler = %d *** \\n", iic_prescaler);\n-*/\n-\nssc_store32(adap, SSC_PRSCALER, iic_prescaler);\nssc_store32(adap, SSC_NOISE_SUPP_WIDTH, iic_glitch_width);\n-\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT,\n-\t\t    iic_glitch_width_dataout);\n+\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH_DATAOUT, iic_glitch_width_dataout);\nssc_store32(adap, SSC_PRSCALER_DATAOUT, iic_prescaler_dataout);\n-#else\n-\t/* disable SSC glitch filter */\n-\tssc_store32(adap, SSC_NOISE_SUPP_WIDTH, 0);\n#endif\n\n+\tssc_store32(adap, SSC_I2C, SSC_I2C_I2CM);\n+\tssc_store32(adap, SSC_BRG, iic_baudrate);\n+\n#ifdef  CONFIG_I2C_DEBUG_BUS\niic_stm_timing_trace(adap);\n#endif\n@@ -1041,20 +860,20 @@\n}\n\nstatic int iic_stm_control(struct i2c_adapter *adapter,\n-\t\t\t   unsigned int cmd, unsigned long arg)\n+\t\t\t\tunsigned int cmd, unsigned long arg)\n{\nstruct iic_ssc *iic_adap =\ncontainer_of(adapter, struct iic_ssc, adapter);\nswitch (cmd) {\ncase I2C_STM_IOCTL_FAST:\n-\t\tdbg_print("ioctl fast 0x%lx\\n", arg);\n+\t\tdgb_print("ioctl fast 0x%x\\n",arg);\niic_adap->config &= ~IIC_STM_CONFIG_SPEED_MASK;\nif (arg)\n-\t\t\tiic_adap->config |= IIC_STM_CONFIG_SPEED_FAST;\n+\t\t\tiic_adap->config |=\n+\t\t\t    IIC_STM_CONFIG_SPEED_FAST;\nbreak;\ndefault:\n-\t\tprintk(KERN_WARNING " %s: i2c-ioctl not managed\\n",\n-\t\t       __FUNCTION__);\n+\t\tprintk(KERN_WARNING" %s: i2c-ioctl not managed\\n",__FUNCTION__);\n}\nreturn 0;\n}\n@@ -1065,138 +884,105 @@\n}\n\nstatic struct i2c_algorithm iic_stm_algo = {\n-\t.master_xfer = iic_stm_xfer,\n+\t.master_xfer   = iic_stm_xfer,\n.functionality = iic_stm_func,\n-\t.algo_control = iic_stm_control\n+\t.algo_control  = iic_stm_control\n};\n\nstatic ssize_t iic_bus_show_fastmode(struct device *dev,\n-\t\t\t\t     struct device_attribute *attr, char *buf)\n+\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n-\tstruct i2c_adapter *adapter =\n-\t    container_of(dev, struct i2c_adapter, dev);\n-\tstruct iic_ssc *iic_stm =\n-\t    container_of(adapter, struct iic_ssc, adapter);\n-\treturn sprintf(buf, "%u\\n", check_fastmode(iic_stm));\n+\tstruct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);\n+\tstruct iic_ssc     *iic_stm = container_of(adapter,struct iic_ssc,adapter);\n+\treturn sprintf(buf, "%u\\n",check_fastmode(iic_stm));\n}\n\n-static ssize_t iic_bus_store_fastmode(struct device *dev,\n-\t\t\t\t      struct device_attribute *attr,\n-\t\t\t\t      const char *buf, size_t count)\n+static ssize_t iic_bus_store_fastmode(struct device *dev,struct device_attribute *attr,\n+\t\t\t const char *buf,size_t count)\n{\n-\tstruct i2c_adapter *adapter =\n-\t    container_of(dev, struct i2c_adapter, dev);\n+\tstruct i2c_adapter *adapter = container_of(dev, struct i2c_adapter, dev);\nunsigned long val = simple_strtoul(buf, NULL, 10);\n\n-\tiic_stm_control(adapter, I2C_STM_IOCTL_FAST, val);\n+\tiic_stm_control(adapter,I2C_STM_IOCTL_FAST,val);\n\nreturn count;\n}\n\nstatic DEVICE_ATTR(fastmode, S_IRUGO | S_IWUSR, iic_bus_show_fastmode,\n-\t\t   iic_bus_store_fastmode);\n+\t\t\tiic_bus_store_fastmode);\n\nstatic int __init iic_stm_probe(struct platform_device *pdev)\n{\nstruct ssc_pio_t *pio_info =\n-\t    (struct ssc_pio_t *)pdev->dev.platform_data;\n+\t\t\t(struct ssc_pio_t *)pdev->dev.platform_data;\nstruct iic_ssc *i2c_stm;\nstruct resource *res;\n\n-\ti2c_stm = devm_kzalloc(&pdev->dev, sizeof(struct iic_ssc), GFP_KERNEL);\n+\ti2c_stm = devm_kzalloc(&pdev->dev,sizeof(struct iic_ssc), GFP_KERNEL);\n\nif (!i2c_stm)\nreturn -ENOMEM;\n\n-\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n-\tif (!res)\n+\tif (!(res=platform_get_resource(pdev, IORESOURCE_MEM, 0)))\nreturn -ENODEV;\n-\n-\tif (!devm_request_mem_region\n-\t    (&pdev->dev, res->start, res->end - res->start, "i2c")) {\n-\t\tprintk(KERN_ERR "%s: Request mem 0x%x region not done\\n",\n-\t\t       __FUNCTION__, res->start);\n+\tif (!devm_request_mem_region(&pdev->dev, res->start, res->end - res->start, "i2c")){\n+\t\tprintk(KERN_ERR "%s: Request mem 0x%x region not done\\n",__FUNCTION__,res->start);\nreturn -ENOMEM;\n}\nif (!(i2c_stm->base =\n-\t      devm_ioremap_nocache(&pdev->dev, res->start,\n-\t\t\t\t   res->end - res->start))) {\n-\t\tprintk(KERN_ERR "%s: Request iomem 0x%x region not done\\n",\n-\t\t       __FUNCTION__, (unsigned int)res->start);\n+\t\tdevm_ioremap_nocache(&pdev->dev, res->start, res->end - res->start))){\n+\t\tprintk(KERN_ERR "%s: Request iomem 0x%x region not done\\n",__FUNCTION__,\n+\t\t\t(unsigned int)res->start);\nreturn -ENOMEM;\n}\n-\n-\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n-\tif (!res) {\n-\t\tprintk(KERN_ERR "%s Request irq %d not done\\n", __FUNCTION__,\n-\t\t       res->start);\n+\tif (!(res=platform_get_resource(pdev, IORESOURCE_IRQ, 0))){\n+\t\tprintk(KERN_ERR "%s Request irq %d not done\\n",__FUNCTION__,res->start);\nreturn -ENODEV;\n}\n-\tif (devm_request_irq(&pdev->dev, res->start, iic_state_machine,\n-\t\t\t     IRQF_DISABLED, "i2c", i2c_stm) < 0) {\n-\t\tprintk(KERN_ERR "%s: Request irq not done\\n", __FUNCTION__);\n+\tif(devm_request_irq(&pdev->dev, res->start, iic_state_machine,\n+\t\tIRQF_DISABLED, "i2c", i2c_stm)<0){\n+\t\tprintk(KERN_ERR "%s: Request irq not done\\n",__FUNCTION__);\nreturn -ENODEV;\n}\n\n-\t/* Check if we use GPIO... */\n-\tif (pio_info->pio[0].pio_port == SSC_NO_PIO)\n+\tif(pio_info->pio[0].pio_port==0xff) /* this means it doesn\'t use GPIO */\ngoto i2c_hard_wired;\n\n-\tif (pio_info->clk_unidir) {\n-\t\t/* Drive clock rather than using open collector.  Setting to\n-\t\t * BIDIR can help if there are problems with SCK rise times.\n-\t\t * It does mean, however, that slaves cannot clock stretch.\n-\t\t */\n-\t\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,\n-\t\t\t\t\t\t      pio_info->pio[0].pio_pin,\n-\t\t\t\t\t\t      "I2C Clock",\n-\t\t\t\t\t\t      STPIO_ALT_OUT, 1);\n-\t} else {\n-\t\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,\n-\t\t\t\t\t\t      pio_info->pio[0].pio_pin,\n-\t\t\t\t\t\t      "I2C Clock",\n-\t\t\t\t\t\t      STPIO_ALT_BIDIR, 1);\n-\t}\n-\n-\tif (!pio_info->clk) {\n-\t\tprintk(KERN_ERR\n-\t\t       "i2c-stm: %s: Failed to get clk pin allocation\\n",\n-\t\t       __FUNCTION__);\n+\tpio_info->clk = stpio_request_set_pin(pio_info->pio[0].pio_port,\n+\t\t\t\t\t  pio_info->pio[0].pio_pin,\n+\t\t\t\t"I2C Clock", STPIO_ALT_BIDIR, 1);\n+\tif(!pio_info->clk){\n+\t\tprintk(KERN_ERR "i2c-stm: %s: Failed to get clk pin allocation\\n",__FUNCTION__);\nreturn -ENODEV;\n}\n\npio_info->sdout = stpio_request_set_pin(pio_info->pio[1].pio_port,\n-\t\t\t\t\t\tpio_info->pio[1].pio_pin,\n-\t\t\t\t\t\t"I2C Data", STPIO_ALT_BIDIR, 1);\n-\tif (!pio_info->sdout) {\n-\t\tprintk(KERN_ERR "%s: Faild to sda pin allocation\\n",\n-\t\t       __FUNCTION__);\n+\t\t\t\t\t    pio_info->pio[1].pio_pin,\n+\t\t\t\t"I2C Data", STPIO_ALT_BIDIR, 1);\n+\tif(!pio_info->sdout){\n+\t\tprintk(KERN_ERR "%s: Faild to sda pin allocation\\n",__FUNCTION__);\nreturn -ENODEV;\n}\n\ni2c_hard_wired:\npdev->dev.driver_data = i2c_stm;\ni2c_stm->adapter.id = I2C_HW_STM_SSC;\n-\ti2c_stm->adapter.timeout = 2;\n-\ti2c_stm->adapter.retries = 0;\n-\ti2c_stm->adapter.class = I2C_CLASS_ALL;\n-\tsprintf(i2c_stm->adapter.name, "i2c-hw-%d", pdev->id);\n+\ti2c_stm->adapter.timeout = 1000; //1000 jiffies: on ST with HZ=1000 this is 1s.\n+\ti2c_stm->adapter.class   = I2C_CLASS_ALL;\n+\tsprintf(i2c_stm->adapter.name,"i2c-hw-%d",pdev->id);\ni2c_stm->adapter.nr = pdev->id;\ni2c_stm->adapter.algo = &iic_stm_algo;\ni2c_stm->adapter.dev.parent = &(pdev->dev);\n-\tiic_stm_setup_timing(i2c_stm, clk_get_rate(clk_get(NULL, "comms_clk")));\n+\tiic_stm_setup_timing(i2c_stm,clk_get_rate(clk_get(NULL,"comms_clk")));\ninit_waitqueue_head(&(i2c_stm->wait_queue));\ni2c_stm->pio_info = pio_info;\nif (i2c_add_numbered_adapter(&(i2c_stm->adapter)) < 0) {\nprintk(KERN_ERR\n-\t\t       "%s: The I2C Core refuses the i2c/stm adapter\\n",\n-\t\t       __FUNCTION__);\n+\t\t       "%s: The I2C Core refuses the i2c/stm adapter\\n",__FUNCTION__);\nreturn -ENODEV;\n} else {\n-\t\tif (device_create_file\n-\t\t    (&(i2c_stm->adapter.dev), &dev_attr_fastmode))\n-\t\t\tprintk(KERN_ERR\n-\t\t\t       "i2c-stm: cannot create fastmode sysfs entry\\n");\n+\t\tif (device_create_file(&(i2c_stm->adapter.dev), &dev_attr_fastmode))\n+\t\t\tprintk(KERN_ERR "i2c-stm: cannot create fastmode sysfs entry\\n");\n}\nreturn 0;\n\n@@ -1205,18 +991,18 @@\nstatic int iic_stm_remove(struct platform_device *pdev)\n{\nstruct resource *res;\n-\tstruct iic_ssc *iic_stm = pdev->dev.driver_data;\n+\tstruct iic_ssc *iic_stm = pdev->dev.driver_data ;\nstruct ssc_pio_t *pio_info =\n-\t    (struct ssc_pio_t *)pdev->dev.platform_data;\n+\t\t\t(struct ssc_pio_t *)pdev->dev.platform_data;\n\ni2c_del_adapter(&iic_stm->adapter);\n/* irq */\n-\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n+\tres=platform_get_resource(pdev, IORESOURCE_IRQ, 0);\ndevm_free_irq(&pdev->dev, res->start, iic_stm);\n/* mem */\ndevm_iounmap(&pdev->dev, iic_stm->base);\n/* pio */\n-\tif (pio_info->clk) {\n+\tif(pio_info->clk){\nstpio_free_pin(pio_info->clk);\nstpio_free_pin(pio_info->sdout);\n}\n@@ -1226,17 +1012,17 @@\n}\n\n#ifdef CONFIG_PM\n-static int iic_stm_suspend(struct platform_device *pdev, pm_message_t state)\n+static int iic_stm_suspend(struct platform_device *pdev,pm_message_t state)\n{\nstruct iic_ssc *i2c_bus = pdev->dev.driver_data;\n-\tssc_store32(i2c_bus, SSC_IEN, 0);\n-\tssc_store32(i2c_bus, SSC_CTL, 0);\n+\tssc_store32(i2c_bus, SSC_IEN,0);\n+\tssc_store32(i2c_bus, SSC_CTL,0);\nreturn 0;\n}\nstatic int iic_stm_resume(struct platform_device *pdev)\n{\n-\tstruct iic_ssc *i2c_bus = pdev->dev.driver_data;\n-\tiic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL, "comms_clk")));\n+\tstruct iic_ssc *i2c_bus =pdev->dev.driver_data;\n+\tiic_stm_setup_timing(i2c_bus, clk_get_rate(clk_get(NULL,"comms_clk")));\nreturn 0;\n}\n#else\n@@ -1245,14 +1031,15 @@\n#endif\n\nstatic struct platform_driver i2c_stm_driver = {\n-\t.driver.name = "i2c_st",\n-\t.driver.owner = THIS_MODULE,\n-\t.probe = iic_stm_probe,\n+        .driver.name = "i2c_st",\n+        .driver.owner = THIS_MODULE,\n+        .probe = iic_stm_probe,\n.remove = iic_stm_remove,\n.suspend = iic_stm_suspend,\n-\t.resume = iic_stm_resume,\n+\t.resume  = iic_stm_resume,\n};\n\n+\nstatic int __init iic_stm_init(void)\n{\nplatform_driver_register(&i2c_stm_driver);'),
 ('linux-2.6.23/drivers/i2c/busses/Kconfig.118',
  'linux-2.6.23/drivers/i2c/busses/Kconfig',
  '--- linux-2.6.23/drivers/i2c/busses/Kconfig.118\n+++ linux-2.6.23/drivers/i2c/busses/Kconfig\n@@ -711,4 +711,11 @@\nint "Glitch suppression width in uS"\ndefault "1"\n\n+config  I2C_STM_NOSTOP_API\n+\tbool "I2C add the NoStop operation API"\n+\tdepends on I2C_ST40_PIO || I2C_STM\n+\tdefault n\n+\t---help---\n+\t  Enable this option to use the NoStop operation API\n+\nendmenu'),
 ('linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c.118',
  'linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c',
  '--- linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c.118\n+++ linux-2.6.23/drivers/i2c/algos/i2c-algo-bit.c\n@@ -45,6 +45,18 @@\ndo {} while (0)\n#endif /* DEBUG */\n\n+#ifdef CONFIG_I2C_STM_NOSTOP_API\n+#define LAST_I2C_WAS_NO_STOP                   0x1\n+#define check_lasti2cwas_nostop(adap)          (((adap)->config & \\\n+                                                       LAST_I2C_WAS_NO_STOP) ? 1 : 0)\n+#define set_lasti2cwas_nostop(adap)     ((adap)->config |=  LAST_I2C_WAS_NO_STOP)\n+#define clear_lasti2cwas_nostop(adap)   ((adap)->config &= ~LAST_I2C_WAS_NO_STOP)\n+#else\n+#define check_lasti2cwas_nostop(adap)          (1==0)\n+#define set_lasti2cwas_nostop(adap)            {}\n+#define clear_lasti2cwas_nostop(adap)          {}\n+#endif\n+\n/* ----- global variables ---------------------------------------------\t*/\n\nstatic int bit_test;\t/* see if the line-setting functions work\t*/\n@@ -148,6 +160,7 @@\nsclhi(adap);\nsetsda(adap, 1);\nudelay(adap->udelay);\n+\tclear_lasti2cwas_nostop(adap);\n}\n\n\n@@ -498,8 +511,14 @@\nint i,ret;\nunsigned short nak_ok;\n\n+\tif(check_lasti2cwas_nostop(adap)){\n+\t\tbit_dbg(3, &i2c_adap->dev, "emitting repstart condition\\n");\n+\t\tclear_lasti2cwas_nostop(adap);\n+\t\ti2c_repstart(adap);\n+\t} else {\nbit_dbg(3, &i2c_adap->dev, "emitting start condition\\n");\ni2c_start(adap);\n+\t}\nfor (i=0;i<num;i++) {\npmsg = &msgs[i];\nnak_ok = pmsg->flags & I2C_M_IGNORE_NAK;\n@@ -544,6 +563,8 @@\nret = i;\n\nbailout:\n+\tif ((pmsg->flags & I2C_M_NOSTOP) && ret>=0) /* if !error and last message is NoStop */\n+\t\treturn ret;\nbit_dbg(3, &i2c_adap->dev, "emitting stop condition\\n");\ni2c_stop(adap);\nreturn ret;'),
 ('linux-2.6.23/include/linux/i2c-algo-bit.h.118',
  'linux-2.6.23/include/linux/i2c-algo-bit.h',
  '--- linux-2.6.23/include/linux/i2c-algo-bit.h.118\n+++ linux-2.6.23/include/linux/i2c-algo-bit.h\n@@ -43,6 +43,9 @@\nminimum 5 us for standard-mode I2C and SMBus,\nmaximum 50 us for SMBus */\nint timeout;\t\t/* in jiffies */\n+#if defined(CONFIG_I2C_STM_NOSTOP_API)\n+\tint config;\n+#endif\n};\n\nint i2c_bit_add_bus(struct i2c_adapter *);'),
 ('linux-2.6.23/include/linux/i2c.h.118',
  'linux-2.6.23/include/linux/i2c.h',
  '--- linux-2.6.23/include/linux/i2c.h.118\n+++ linux-2.6.23/include/linux/i2c.h\n@@ -450,14 +450,14 @@\nstruct i2c_msg {\n__u16 addr;\t/* slave address\t\t\t*/\n__u16 flags;\n-#define I2C_M_RD\t\t0x0001\n-#define I2C_M_TEN\t\t0x0010 /* we have a ten bit chip address */\n-#define I2C_M_RECV_LEN\t\t0x0400 /* length will be first received byte */\n-#define I2C_M_NO_RD_ACK\t\t0x0800\n-#define I2C_M_IGNORE_NAK\t0x1000\n+#define I2C_M_TEN\t0x10\t/* we have a ten bit chip address\t*/\n+#define I2C_M_RD\t0x01\n+#define I2C_M_NOSTART\t0x4000\n+#define I2C_M_NOSTOP\t0x8000 \t/* STMicroelectronics specific to support NoStop */\n#define I2C_M_REV_DIR_ADDR\t0x2000\n-#define I2C_M_NOSTART\t\t0x4000\n-#define I2C_M_NOREPSTART\t0x8000\n+#define I2C_M_IGNORE_NAK\t0x1000\n+#define I2C_M_NO_RD_ACK\t\t0x0800\n+#define I2C_M_RECV_LEN\t\t0x0400 /* length will be first received byte */\n__u16 len;\t\t/* msg length\t\t\t\t*/\n__u8 *buf;\t\t/* pointer to msg data\t\t\t*/\n};')]