[('linux-2.6.23.orig/arch/sh/Makefile',
  'linux-2.6.23/arch/sh/Makefile',
  'Index: linux-2.6.23/arch/sh/Makefile\n===================================================================\n--- linux-2.6.23.orig/arch/sh/Makefile\n+++ linux-2.6.23/arch/sh/Makefile\n@@ -154,6 +154,7 @@ machdir-$(CONFIG_SH_ST_MB628)\t\t\t+= st/mb\nmachdir-$(CONFIG_SH_ST_MB671)\t\t\t+= st/mb671 st/common\nmachdir-$(CONFIG_SH_ST_MB680)\t\t\t+= st/mb680 st/common\nmachdir-$(CONFIG_SH_ST_MB704)\t\t\t+= st/mb704\n+machdir-$(CONFIG_SH_ST_VIP19X3)                        += st/vip19x3 st/common\nmachdir-$(CONFIG_SH_ST_PDK7105)\t\t\t+= st/pdk7105\nmachdir-$(CONFIG_SH_ST_MB839)\t\t\t+= st/mb839\n'),
 ('dev/null',
  'linux-2.6.23/arch/sh/boards/st/vip19x3/Makefile',
  'Index: linux-2.6.23/arch/sh/boards/st/vip19x3/Makefile\n===================================================================\n--- dev/null\n+++ linux-2.6.23/arch/sh/boards/st/vip19x3/Makefile\n@@ -0,0 +1,5 @@\n+#\n+# Makefile for Motorola VIP19x3 board\n+#\n+\n+obj-y := setup.o'),
 ('dev/null',
  'linux-2.6.23/arch/sh/boards/st/vip19x3/setup.c',
  'Index: linux-2.6.23/arch/sh/boards/st/vip19x3/setup.c\n===================================================================\n--- dev/null\n+++ linux-2.6.23/arch/sh/boards/st/vip19x3/setup.c\n@@ -0,0 +1,202 @@\n+/*\n+ * arch/sh/boards/st/vip19x3/setup.c\n+ *\n+ * Copyright (C) 2008 STMicroelectronics Limited\n+ * Author: Stuart Menefy (stuart.menefy@st.com)\n+ *\n+ * May be copied or modified under the terms of the GNU General Public\n+ * License.  See linux/COPYING for more information.\n+ *\n+ * Copyright (C) 2008 Motorola, Inc.\n+ * Motorola VIP19x3 board support.\n+ */\n+\n+#include <linux/init.h>\n+#include <linux/platform_device.h>\n+#include <linux/leds.h>\n+#include <linux/stm/pio.h>\n+#include <linux/stm/soc.h>\n+#include <linux/stm/emi.h>\n+#include <linux/stm/pio.h>\n+#include <linux/mtd/mtd.h>\n+#include <linux/mtd/nand.h>\n+#include <linux/stm/nand.h>\n+#include <linux/stm/soc_init.h>\n+#include <linux/mtd/physmap.h>\n+#include <linux/mtd/partitions.h>\n+#include <linux/phy.h>\n+#include <linux/gpio_keys.h>\n+#include <linux/input.h>\n+#include <asm/irq-ilc.h>\n+#include <asm/irl.h>\n+#include <asm/io.h>\n+#include <asm/setup.h>\n+#include "../common/common.h"\n+\n+static int ascs[2] __initdata = { 1 | (STASC_FLAG_NORTSCTS << 8),\n+\t\t\t\t  2 | (STASC_FLAG_NORTSCTS << 8) };\n+\n+static void __init vip19x3_setup(char** cmdline_p)\n+{\n+\tchar command_line[COMMAND_LINE_SIZE+1];\n+\n+\tprintk("Motorola VIP19x3 board initialisation\\n");\n+\n+\tmemcpy(command_line, *cmdline_p, COMMAND_LINE_SIZE);\n+\tcommand_line[COMMAND_LINE_SIZE] = \'\\0\';\n+\tif (NULL != strstr(command_line, "rbl_mode=2")) {\n+\t\tascs[0] |= (STASC_FLAG_NORXTX << 8);\n+\t}\n+\n+\tstx7105_early_device_init();\n+\tstx7105_configure_asc(ascs, 2, 0);\n+}\n+\n+static struct plat_stm_pwm_data pwm_private_info = {\n+\t.flags\t\t= PLAT_STM_PWM_OUT0,\n+\t.routing\t= PWM_OUT0_PIO4_4,\n+};\n+\n+static struct plat_ssc_data ssc_private_info = {\n+\t.capability  =\n+\t\tssc0_has(SSC_I2C_CAPABILITY) |\n+\t\tssc1_has(SSC_UNCONFIGURED) |\n+\t\tssc2_has(SSC_UNCONFIGURED) |\n+\t\tssc3_has(SSC_I2C_CAPABILITY),\n+\t.routing =\n+\t\tSSC3_SCLK_PIO3_6 | SSC3_MTSR_PIO3_7 | SSC3_MRST_PIO3_7,\n+};\n+\n+static struct usb_init_data usb_init[2] __initdata = {\n+\t{\n+\t\t.oc_en = 1,\n+\t\t.oc_actlow = 0,\n+\t\t.oc_pinsel = USB0_OC_PIO12_5,\n+\t\t.pwr_en = 0,\n+\t\t.pwr_pinsel = USB0_PWR_PIO12_6,\n+\t}, {\n+\t\t.oc_en = 1,\n+\t\t.oc_actlow = 0,\n+\t\t.oc_pinsel = USB1_OC_PIO14_6,\n+\t\t.pwr_en = 0,\n+\t\t.pwr_pinsel = USB1_PWR_PIO14_7,\n+\t}\n+};\n+\n+static struct mtd_partition nand_partitions[] = {\n+\t{\n+\t\t.name\t= "NAND home",\n+\t\t.offset\t= 0,\n+\t\t.size\t= MTDPART_SIZ_FULL\n+\t},\n+};\n+\n+static struct plat_stmnand_data nand_config = {\n+\t/* STM_NAND_EMI data */\n+\t.emi_withinbankoffset\t= 0,\n+\t.rbn_port\t\t= -1,\n+\t.rbn_pin\t\t= -1,\n+\n+\t.timing_data = &(struct nand_timing_data) {\n+\t\t.sig_setup\t= 50,\t\t/* times in ns */\n+\t\t.sig_hold\t= 50,\n+\t\t.CE_deassert\t= 0,\n+\t\t.WE_to_RBn\t= 100,\n+\t\t.wr_on\t\t= 10,\n+\t\t.wr_off\t\t= 40,\n+\t\t.rd_on\t\t= 10,\n+\t\t.rd_off\t\t= 40,\n+\t\t.chip_delay\t= 30,\t\t/* in us */\n+\t},\n+\t.flex_rbn_connected\t= 1,\n+};\n+\n+/* Platform data for STM_NAND_EMI/FLEX/AFM. (bank# may be updated later) */\n+static struct platform_device nand_device =\n+\tSTM_NAND_DEVICE("stm-nand-flex", 1, &nand_config,\n+\t\t\tnand_partitions, ARRAY_SIZE(nand_partitions), NAND_USE_FLASH_BBT);\n+\n+static struct plat_stmmacphy_data phy_private_data = {\n+\t/* Marvell 88E3015 on Motorola VIP1903 */\n+\t.bus_id = 0,\n+\t.phy_addr = 0,\n+\t.phy_mask = 0,\n+\t.interface = PHY_INTERFACE_MODE_MII,\n+};\n+\n+static struct platform_device vip19x3_phy_device = {\n+\t.name\t\t= "stmmacphy",\n+\t.id\t\t= 0,\n+\t.num_resources\t= 1,\n+\t.resource\t= (struct resource[]) {\n+\t\t{\n+\t\t\t.name\t= "phyirq",\n+\t\t\t.start\t= ILC_EXT_IRQ(6),\n+\t\t\t.end\t= ILC_EXT_IRQ(6),\n+\t\t\t.flags\t= IORESOURCE_IRQ,\n+\t\t},\n+\t},\n+\t.dev = {\n+\t\t.platform_data = &phy_private_data,\n+\t}\n+};\n+\n+static struct platform_device *vip19x3_devices[] __initdata = {\n+\t&vip19x3_phy_device,\n+};\n+\n+/* Configuration based on Futarque-RC signals train. */\n+lirc_scd_t lirc_scd = {\n+\t.code = 0x3FFFC028,\n+\t.codelen = 0x1e,\n+\t.alt_codelen = 0,\n+\t.nomtime = 0x1f4,\n+\t.noiserecov = 0,\n+};\n+\n+static int __init device_init(void)\n+{\n+       struct stpio_pin *pin;\n+\n+\tstx7105_configure_sata();\n+\tstx7105_configure_pwm(&pwm_private_info);\n+\tstx7105_configure_ssc(&ssc_private_info);\n+\n+\tstx7105_configure_usb(0, &usb_init[0]);\n+\tstx7105_configure_usb(1, &usb_init[1]);\n+\tstx7105_configure_ethernet(0, 0, 0, 0, 1, 0);\n+\tstx7105_configure_lirc(&lirc_scd);\n+\tstx7105_configure_audio_pins(0,1,0);\n+\tstx7105_configure_nand(&nand_device);\n+\n+\t/* Enable the PHY */\n+\tpin = stpio_request_pin(14, 4, "phyreset", STPIO_OUT);\n+\tstpio_set_pin(pin, 0);\n+\n+\treturn platform_add_devices(vip19x3_devices, ARRAY_SIZE(vip19x3_devices));\n+}\n+arch_initcall(device_init);\n+\n+static void __iomem *vip19x3_ioport_map(unsigned long port, unsigned int size)\n+{\n+\t/* However picking somewhere safe isn\'t as easy as you might think.\n+\t * I used to use external ROM, but that can cause problems if you are\n+\t * in the middle of updating Flash. So I\'m now using the processor core\n+\t * version register, which is guaranted to be available, and non-writable.\n+\t */\n+\treturn (void __iomem *)CCN_PVR;\n+}\n+\n+static void __init vip19x3_init_irq(void)\n+{\n+\t/* Configure PHY interrupt as active low. */\n+\tset_irq_type(ILC_EXT_IRQ(6), IRQ_TYPE_LEVEL_LOW);\n+}\n+\n+struct sh_machine_vector mv_vip19x3 __initmv = {\n+\t.mv_name\t\t= "vip19x3",\n+\t.mv_setup\t\t= vip19x3_setup,\n+\t.mv_nr_irqs\t\t= NR_IRQS,\n+\t.mv_init_irq\t\t= vip19x3_init_irq,\n+\t.mv_ioport_map\t\t= vip19x3_ioport_map,\n+};')]