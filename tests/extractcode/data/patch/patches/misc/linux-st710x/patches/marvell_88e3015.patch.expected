[('linux-2.6.23/drivers/net/phy/marvell.c.orig',
  'linux-2.6.23/drivers/net/phy/marvell.c',
  '--- linux-2.6.23/drivers/net/phy/marvell.c.orig\n+++ linux-2.6.23/drivers/net/phy/marvell.c\n@@ -35,275 +35,240 @@\n#include <asm/irq.h>\n#include <asm/uaccess.h>\n\n-#define MII_M1011_IEVENT\t\t0x13\n-#define MII_M1011_IEVENT_CLEAR\t\t0x0000\n-\n-#define MII_M1011_IMASK\t\t\t0x12\n-#define MII_M1011_IMASK_INIT\t\t0x6400\n-#define MII_M1011_IMASK_CLEAR\t\t0x0000\n-\n-#define MII_M1011_PHY_SCR\t\t0x10\n-#define MII_M1011_PHY_SCR_AUTO_CROSS\t0x0060\n-\n-#define MII_M1145_PHY_EXT_CR\t\t0x14\n-#define MII_M1145_RGMII_RX_DELAY\t0x0080\n-#define MII_M1145_RGMII_TX_DELAY\t0x0002\n-\n-#define M1145_DEV_FLAGS_RESISTANCE\t0x00000001\n-\n-#define MII_M1111_PHY_LED_CONTROL\t0x18\n-#define MII_M1111_PHY_LED_DIRECT\t0x4100\n-#define MII_M1111_PHY_LED_COMBINE\t0x411c\n-#define MII_M1111_PHY_EXT_CR\t\t0x14\n-#define MII_M1111_RX_DELAY\t\t0x80\n-#define MII_M1111_TX_DELAY\t\t0x2\n-#define MII_M1111_PHY_EXT_SR\t\t0x1b\n-#define MII_M1111_HWCFG_MODE_MASK\t0xf\n-#define MII_M1111_HWCFG_MODE_RGMII\t0xb\n-#define MII_M1111_HWCFG_MODE_SGMII_NO_CLK\t0x4\n+#define M3015_INTERRUPT_ENABLE     (18)\n+#define M3015_INTERRUPT_STATUS     (19)\n+#define M3015_LED_PARALLEL_SELECT  (22)\n+#define M3015_MANUAL_LED_OVERRIDE  (25)\n+#define M3015_TEST_MODE_SELECT     (29)\n+#define M3015_CALIBRATION_OVERRIDE (30)  /* At page 10 */\n+#define M3015_REGISTERS            (33)\n+\n+/* Bits and modes in M3015_TEST_MODE_SELECT */\n+#define M3015_TMS_PAGE_MASK (0xffe0)\n+#define M3015_TMS_PAGE_10   (0xa)\n+#define M3015_TMS_PAGE_11   (0xb)\n+\n+/* Bits and modes in M3015_INTERRUPT_ENABLE */\n+#define M3015_INTEN_NOINTERRUPTS    (0)\n+#define M3015_INTEN_SPEEDCHANGE     (1 << 14)\n+#define M3015_INTEN_DUPLEXCHANGE    (1 << 13)\n+#define M3015_INTEN_LINKCHANGE      (1 << 10)\n+#define M3015_INTEN_CROSSOVERCHANGE (1 << 6)\n+#define M3015_INTEN_POLARITYCHANGE  (1 << 1)\n+\n+/* Bits and modes in M3015_LED_PARALLEL_SELECT */\n+#define M3015_LPS_LED2_SHIFT     (8)\n+#define M3015_LPS_LED2_MASK      (0xf0ff)\n+#define M3015_LPS_LED2_INTERRUPT (0xe)\n+#define M3015_LPS_LED1_SHIFT     (4)\n+#define M3015_LPS_LED1_MASK      (0xff0f)\n+#define M3015_LPS_LED1_ACTIVITY  (0xb)\n+#define M3015_LPS_LED0_SHIFT     (0)\n+#define M3015_LPS_LED0_MASK      (0xfff0)\n+#define M3015_LPS_LED0_LINK      (0x5)\n+\n+/* Bits and modes in M3015_CALIBRATION_OVERRIDE */\n+#define M3015_CO_PMOS_SHIFT  (8)\n+#define M3015_CO_NMOS_SHIFT  (0)\n+#define M3015_CO_LATCH       (1 << 6)\n+#define M3015_CO_PMOS_SELECT (1 << 5)\n+\n+/* Calibration impedances for I/O lines */\n+#define M3015_WEAK_PMOS_IMPEDANCE (0x00)\n+#define M3015_WEAK_NMOS_IMPEDANCE (0x00)\n\nMODULE_DESCRIPTION("Marvell PHY driver");\nMODULE_AUTHOR("Andy Fleming");\nMODULE_LICENSE("GPL");\n\n-static int marvell_ack_interrupt(struct phy_device *phydev)\n-{\n-\tint err;\n-\n-\t/* Clear the interrupts by reading the reg */\n-\terr = phy_read(phydev, MII_M1011_IEVENT);\n-\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\treturn 0;\n-}\n+/* #define MARVELL_DEBUG */\n+/* #define CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES */\n\n-static int marvell_config_intr(struct phy_device *phydev)\n+#ifdef MARVELL_DEBUG\n+static void m3015_register_dump(struct phy_device *phydev)\n{\n-\tint err;\n-\n-\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)\n-\t\terr = phy_write(phydev, MII_M1011_IMASK, MII_M1011_IMASK_INIT);\n-\telse\n-\t\terr = phy_write(phydev, MII_M1011_IMASK, MII_M1011_IMASK_CLEAR);\n+\tint result;\n+\tint i;\n\n-\treturn err;\n+\tprintk("\\nDumping Marvell 88E3015 registers\\n");\n+\tfor (i = 0; i < M3015_REGISTERS; ++i) {\n+\t\tint reg = i;\n+\t\tif (((reg > 8) && (reg < 16))\n+\t\t    || (reg == 23)) {\n+\t\t\t/* Register not used */\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (reg > M3015_TEST_MODE_SELECT) {\n+\t\t\t/* Paging mechanism for registers above */\n+\t\t\treg = M3015_TEST_MODE_SELECT;\n+\t\t\tresult = phy_read(phydev, reg);\n+\t\t\tif (result < 0) {\n+\t\t\t\tprintk("Unable to read register %d!\\n", reg);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\t/* Set page 9, 10 or 11 of the next register */\n+\t\t\tresult &= M3015_TMS_PAGE_MASK;\n+\t\t\tresult |= (9 + i - (reg + 1));\n+\t\t\tresult = phy_write(phydev, reg, result);\n+\t\t\treg = M3015_TEST_MODE_SELECT + 1;\n+\t\t}\n+\t\tresult = phy_read(phydev, reg);\n+\t\tif (result < 0) {\n+\t\t\tprintk("Unable to dump register %d!\\n", reg);\n+\t\t}\n+\t\telse {\n+\t\t\tif (i > M3015_TEST_MODE_SELECT) {\n+\t\t\t\tprintk("  Register %d_%d: 0x%04x\\n",\n+\t\t\t\t       reg, 9 + i - reg, result);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tprintk("  Register %d: 0x%04x\\n", reg, result);\n+\t\t\t}\n+\t\t}\n+\t}\n+\tprintk("Done.\\n\\n");\n}\n+#endif\n\n-static int marvell_config_aneg(struct phy_device *phydev)\n+static int m3015_ack_interrupt(struct phy_device *phydev)\n{\nint err;\n\n-\t/* The Marvell PHY has an errata which requires\n-\t * that certain registers get written in order\n-\t * to restart autonegotiation */\n-\terr = phy_write(phydev, MII_BMCR, BMCR_RESET);\n-\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, 0x1d, 0x1f);\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, 0x1e, 0x200c);\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, 0x1d, 0x5);\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, 0x1e, 0);\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, 0x1e, 0x100);\n-\tif (err < 0)\n-\t\treturn err;\n-\n-\terr = phy_write(phydev, MII_M1011_PHY_SCR,\n-\t\t\tMII_M1011_PHY_SCR_AUTO_CROSS);\n-\tif (err < 0)\n-\t\treturn err;\n+\t/* Clear the interrupts by reading the interrupt status register */\n+\terr = phy_read(phydev, M3015_INTERRUPT_STATUS);\n\n-\terr = phy_write(phydev, MII_M1111_PHY_LED_CONTROL,\n-\t\t\tMII_M1111_PHY_LED_DIRECT);\nif (err < 0)\nreturn err;\n\n-\terr = genphy_config_aneg(phydev);\n-\n-\treturn err;\n+\treturn 0;\n}\n\n-static int m88e1111_config_init(struct phy_device *phydev)\n+static int m3015_config_intr(struct phy_device *phydev)\n{\nint err;\n\n-\tif ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||\n-\t    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)) {\n-\t\tint temp;\n-\n-\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {\n-\t\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_CR);\n-\t\t\tif (temp < 0)\n-\t\t\t\treturn temp;\n-\n-\t\t\ttemp |= (MII_M1111_RX_DELAY | MII_M1111_TX_DELAY);\n-\n-\t\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_CR, temp);\n-\t\t\tif (err < 0)\n-\t\t\t\treturn err;\n-\t\t}\n-\n-\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_SR);\n-\t\tif (temp < 0)\n-\t\t\treturn temp;\n-\n-\t\ttemp &= ~(MII_M1111_HWCFG_MODE_MASK);\n-\t\ttemp |= MII_M1111_HWCFG_MODE_RGMII;\n-\n-\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);\n-\t\tif (err < 0)\n-\t\t\treturn err;\n+\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {\n+\t\t/* Configure interrupts to be generated on speed\n+\t\t   changes, duplex changes and link changes. */\n+\t\terr = phy_write(phydev, M3015_INTERRUPT_ENABLE,\n+\t\t\t\tM3015_INTEN_SPEEDCHANGE\n+\t\t\t\t| M3015_INTEN_DUPLEXCHANGE\n+\t\t\t\t| M3015_INTEN_LINKCHANGE);\n}\n-\n-\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\n-\t\tint temp;\n-\n-\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_SR);\n-\t\tif (temp < 0)\n-\t\t\treturn temp;\n-\n-\t\ttemp &= ~(MII_M1111_HWCFG_MODE_MASK);\n-\t\ttemp |= MII_M1111_HWCFG_MODE_SGMII_NO_CLK;\n-\n-\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);\n-\t\tif (err < 0)\n-\t\t\treturn err;\n+\telse {\n+\t\terr = phy_write(phydev, M3015_INTERRUPT_ENABLE,\n+\t\t\t\tM3015_INTEN_NOINTERRUPTS);\n}\n\n-\terr = phy_write(phydev, MII_BMCR, BMCR_RESET);\nif (err < 0)\nreturn err;\n\nreturn 0;\n}\n\n-static int m88e1145_config_init(struct phy_device *phydev)\n+#ifdef CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES\n+static int m3015_set_impedance_target(struct phy_device *phydev,\n+\t\t\t\t      int pmos_target_impedance,\n+\t\t\t\t      int nmos_target_impedance)\n{\n-\tint err;\n+\tint value;\n+\tint result;\n\n-\t/* Take care of errata E0 & E1 */\n-\terr = phy_write(phydev, 0x1d, 0x001b);\n-\tif (err < 0)\n-\t\treturn err;\n+\tdo {\n+\t\t/* Switch to page 10 */\n+\t\tresult = phy_read(phydev, M3015_TEST_MODE_SELECT);\n+\t\tif (result < 0) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tresult &= M3015_TMS_PAGE_MASK;\n+\t\tresult |= M3015_TMS_PAGE_10;\n+\t\tresult = phy_write(phydev, M3015_TEST_MODE_SELECT, result);\n+\t\tif (result < 0) {\n+\t\t\tbreak;\n+\t\t}\n\n-\terr = phy_write(phydev, 0x1e, 0x418f);\n-\tif (err < 0)\n-\t\treturn err;\n+\t\t/* Set new calibration target impedance value */\n+\t\tvalue = (pmos_target_impedance << M3015_CO_PMOS_SHIFT);\n+\t\tvalue |= (nmos_target_impedance << M3015_CO_NMOS_SHIFT);\n+\t\tvalue |= M3015_CO_LATCH;\n+\t\tvalue |= M3015_CO_PMOS_SELECT;  /* Latch PMOS value */\n+\t\tresult = phy_write(phydev, M3015_CALIBRATION_OVERRIDE, value);\n+\t\tif (result < 0) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tvalue &= ~M3015_CO_PMOS_SELECT;  /* Latch NMOS value */\n+\t\tresult = phy_write(phydev, M3015_CALIBRATION_OVERRIDE, value);\n\n-\terr = phy_write(phydev, 0x1d, 0x0016);\n-\tif (err < 0)\n-\t\treturn err;\n+\t} while (0);\n\n-\terr = phy_write(phydev, 0x1e, 0xa2da);\n-\tif (err < 0)\n-\t\treturn err;\n+\treturn result;\n+}\n+#endif\n\n-\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {\n-\t\tint temp = phy_read(phydev, MII_M1145_PHY_EXT_CR);\n-\t\tif (temp < 0)\n-\t\t\treturn temp;\n-\n-\t\ttemp |= (MII_M1145_RGMII_RX_DELAY | MII_M1145_RGMII_TX_DELAY);\n-\n-\t\terr = phy_write(phydev, MII_M1145_PHY_EXT_CR, temp);\n-\t\tif (err < 0)\n-\t\t\treturn err;\n-\n-\t\tif (phydev->dev_flags & M1145_DEV_FLAGS_RESISTANCE) {\n-\t\t\terr = phy_write(phydev, 0x1d, 0x0012);\n-\t\t\tif (err < 0)\n-\t\t\t\treturn err;\n-\n-\t\t\ttemp = phy_read(phydev, 0x1e);\n-\t\t\tif (temp < 0)\n-\t\t\t\treturn temp;\n-\n-\t\t\ttemp &= 0xf03f;\n-\t\t\ttemp |= 2 << 9;\t/* 36 ohm */\n-\t\t\ttemp |= 2 << 6;\t/* 39 ohm */\n-\n-\t\t\terr = phy_write(phydev, 0x1e, temp);\n-\t\t\tif (err < 0)\n-\t\t\t\treturn err;\n-\n-\t\t\terr = phy_write(phydev, 0x1d, 0x3);\n-\t\t\tif (err < 0)\n-\t\t\t\treturn err;\n-\n-\t\t\terr = phy_write(phydev, 0x1e, 0x8000);\n-\t\t\tif (err < 0)\n-\t\t\t\treturn err;\n-\t\t}\n+static int m3015_config_init(struct phy_device *phydev)\n+{\n+\tint result;\n+\n+\tdo {\n+\t  /* reset phy */\n+\t  phy_write(phydev, MII_BMCR, BMCR_RESET);\n+\n+\t  /* restart autonegotation */\n+\t  phy_write(phydev, MII_BMCR,\n+\t\t    BMCR_ANRESTART | BMCR_ANENABLE);\n+\n+#ifdef CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES\n+\t\t/* Set manual impedance values for the I/0 lines */\n+\t\tresult = m3015_set_impedance_target(\n+\t\t\tphydev,\n+\t\t\tM3015_WEAK_PMOS_IMPEDANCE,\n+\t\t\tM3015_WEAK_NMOS_IMPEDANCE);\n+\t\tif (result < 0)\n+\t\t\tbreak;\n+#endif\n+\n+\t\t/* Configure the LED2 pin as an interrupt pin */\n+\t\tresult = phy_read(phydev, M3015_LED_PARALLEL_SELECT);\n+\t\tif (result < 0)\n+\t\t\tbreak;\n+\t\tresult &= M3015_LPS_LED2_MASK;\n+\t\tresult |= (M3015_LPS_LED2_INTERRUPT << M3015_LPS_LED2_SHIFT);\n+\n+\t\t/* Configure the yellow LED on the LED1 pin to show activity */\n+\t\tresult &= M3015_LPS_LED1_MASK;\n+\t\tresult |= (M3015_LPS_LED1_ACTIVITY << M3015_LPS_LED1_SHIFT);\n+\n+\t\t/* Configure the green LED on the LED0 pin for link status */\n+\t\tresult &= M3015_LPS_LED0_MASK;\n+\t\tresult |= (M3015_LPS_LED0_LINK << M3015_LPS_LED0_SHIFT);\n+\t\tresult = phy_write(phydev, M3015_LED_PARALLEL_SELECT, result);\n+\t} while (0);\n+\n+\tif (result < 0) {\n+\t\tprintk("Marvell 88E3015: Unable to communicate with the "\n+\t\t       "device!\\n");\n+\t\treturn result;\n}\n\n+#ifdef MARVELL_DEBUG\n+\tm3015_register_dump(phydev);\n+#endif\n+\nreturn 0;\n}\n\nstatic struct phy_driver marvell_drivers[] = {\n{\n-\t\t.phy_id = 0x01410c60,\n-\t\t.phy_id_mask = 0xfffffff0,\n-\t\t.name = "Marvell 88E1101",\n-\t\t.features = PHY_GBIT_FEATURES,\n-\t\t.flags = PHY_HAS_INTERRUPT,\n-\t\t.config_aneg = &marvell_config_aneg,\n-\t\t.read_status = &genphy_read_status,\n-\t\t.ack_interrupt = &marvell_ack_interrupt,\n-\t\t.config_intr = &marvell_config_intr,\n-\t\t.driver = {.owner = THIS_MODULE,},\n-\t},\n-\t{\n-\t\t.phy_id = 0x01410c90,\n-\t\t.phy_id_mask = 0xfffffff0,\n-\t\t.name = "Marvell 88E1112",\n-\t\t.features = PHY_GBIT_FEATURES,\n-\t\t.flags = PHY_HAS_INTERRUPT,\n-\t\t.config_init = &m88e1111_config_init,\n-\t\t.config_aneg = &marvell_config_aneg,\n-\t\t.read_status = &genphy_read_status,\n-\t\t.ack_interrupt = &marvell_ack_interrupt,\n-\t\t.config_intr = &marvell_config_intr,\n-\t\t.driver = {.owner = THIS_MODULE,},\n-\t},\n-\t{\n-\t\t.phy_id = 0x01410cc0,\n-\t\t.phy_id_mask = 0xfffffff0,\n-\t\t.name = "Marvell 88E1111",\n-\t\t.features = PHY_GBIT_FEATURES,\n-\t\t.flags = PHY_HAS_INTERRUPT,\n-\t\t.config_init = &m88e1111_config_init,\n-\t\t.config_aneg = &marvell_config_aneg,\n-\t\t.read_status = &genphy_read_status,\n-\t\t.ack_interrupt = &marvell_ack_interrupt,\n-\t\t.config_intr = &marvell_config_intr,\n-\t\t.driver = {.owner = THIS_MODULE,},\n-\t},\n-\t{\n-\t\t.phy_id = 0x01410cd0,\n+\t\t.phy_id = 0x01410e20,\n.phy_id_mask = 0xfffffff0,\n-\t\t.name = "Marvell 88E1145",\n-\t\t.features = PHY_GBIT_FEATURES,\n+\t\t.name = "Marvell 88E3015",\n+\t\t.features = PHY_BASIC_FEATURES | SUPPORTED_Pause,\n.flags = PHY_HAS_INTERRUPT,\n-\t\t.config_init = &m88e1145_config_init,\n-\t\t.config_aneg = &marvell_config_aneg,\n+\t\t.config_init = &m3015_config_init,\n+\t\t.config_aneg = &genphy_config_aneg,\n.read_status = &genphy_read_status,\n-\t\t.ack_interrupt = &marvell_ack_interrupt,\n-\t\t.config_intr = &marvell_config_intr,\n+\t\t.ack_interrupt = &m3015_ack_interrupt,\n+\t\t.config_intr = &m3015_config_intr,\n.driver = {.owner = THIS_MODULE,},\n}\n};')]