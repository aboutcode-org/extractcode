[
  [
    "linux-2.6.23/drivers/net/phy/marvell.c.orig", 
    "linux-2.6.23/drivers/net/phy/marvell.c", 
    [
      "--- linux-2.6.23/drivers/net/phy/marvell.c.orig", 
      "+++ linux-2.6.23/drivers/net/phy/marvell.c", 
      "@@ -35,275 +35,240 @@", 
      "#include <asm/irq.h>", 
      "#include <asm/uaccess.h>", 
      "", 
      "-#define MII_M1011_IEVENT\t\t0x13", 
      "-#define MII_M1011_IEVENT_CLEAR\t\t0x0000", 
      "-", 
      "-#define MII_M1011_IMASK\t\t\t0x12", 
      "-#define MII_M1011_IMASK_INIT\t\t0x6400", 
      "-#define MII_M1011_IMASK_CLEAR\t\t0x0000", 
      "-", 
      "-#define MII_M1011_PHY_SCR\t\t0x10", 
      "-#define MII_M1011_PHY_SCR_AUTO_CROSS\t0x0060", 
      "-", 
      "-#define MII_M1145_PHY_EXT_CR\t\t0x14", 
      "-#define MII_M1145_RGMII_RX_DELAY\t0x0080", 
      "-#define MII_M1145_RGMII_TX_DELAY\t0x0002", 
      "-", 
      "-#define M1145_DEV_FLAGS_RESISTANCE\t0x00000001", 
      "-", 
      "-#define MII_M1111_PHY_LED_CONTROL\t0x18", 
      "-#define MII_M1111_PHY_LED_DIRECT\t0x4100", 
      "-#define MII_M1111_PHY_LED_COMBINE\t0x411c", 
      "-#define MII_M1111_PHY_EXT_CR\t\t0x14", 
      "-#define MII_M1111_RX_DELAY\t\t0x80", 
      "-#define MII_M1111_TX_DELAY\t\t0x2", 
      "-#define MII_M1111_PHY_EXT_SR\t\t0x1b", 
      "-#define MII_M1111_HWCFG_MODE_MASK\t0xf", 
      "-#define MII_M1111_HWCFG_MODE_RGMII\t0xb", 
      "-#define MII_M1111_HWCFG_MODE_SGMII_NO_CLK\t0x4", 
      "+#define M3015_INTERRUPT_ENABLE     (18)", 
      "+#define M3015_INTERRUPT_STATUS     (19)", 
      "+#define M3015_LED_PARALLEL_SELECT  (22)", 
      "+#define M3015_MANUAL_LED_OVERRIDE  (25)", 
      "+#define M3015_TEST_MODE_SELECT     (29)", 
      "+#define M3015_CALIBRATION_OVERRIDE (30)  /* At page 10 */", 
      "+#define M3015_REGISTERS            (33)", 
      "+", 
      "+/* Bits and modes in M3015_TEST_MODE_SELECT */", 
      "+#define M3015_TMS_PAGE_MASK (0xffe0)", 
      "+#define M3015_TMS_PAGE_10   (0xa)", 
      "+#define M3015_TMS_PAGE_11   (0xb)", 
      "+", 
      "+/* Bits and modes in M3015_INTERRUPT_ENABLE */", 
      "+#define M3015_INTEN_NOINTERRUPTS    (0)", 
      "+#define M3015_INTEN_SPEEDCHANGE     (1 << 14)", 
      "+#define M3015_INTEN_DUPLEXCHANGE    (1 << 13)", 
      "+#define M3015_INTEN_LINKCHANGE      (1 << 10)", 
      "+#define M3015_INTEN_CROSSOVERCHANGE (1 << 6)", 
      "+#define M3015_INTEN_POLARITYCHANGE  (1 << 1)", 
      "+", 
      "+/* Bits and modes in M3015_LED_PARALLEL_SELECT */", 
      "+#define M3015_LPS_LED2_SHIFT     (8)", 
      "+#define M3015_LPS_LED2_MASK      (0xf0ff)", 
      "+#define M3015_LPS_LED2_INTERRUPT (0xe)", 
      "+#define M3015_LPS_LED1_SHIFT     (4)", 
      "+#define M3015_LPS_LED1_MASK      (0xff0f)", 
      "+#define M3015_LPS_LED1_ACTIVITY  (0xb)", 
      "+#define M3015_LPS_LED0_SHIFT     (0)", 
      "+#define M3015_LPS_LED0_MASK      (0xfff0)", 
      "+#define M3015_LPS_LED0_LINK      (0x5)", 
      "+", 
      "+/* Bits and modes in M3015_CALIBRATION_OVERRIDE */", 
      "+#define M3015_CO_PMOS_SHIFT  (8)", 
      "+#define M3015_CO_NMOS_SHIFT  (0)", 
      "+#define M3015_CO_LATCH       (1 << 6)", 
      "+#define M3015_CO_PMOS_SELECT (1 << 5)", 
      "+", 
      "+/* Calibration impedances for I/O lines */", 
      "+#define M3015_WEAK_PMOS_IMPEDANCE (0x00)", 
      "+#define M3015_WEAK_NMOS_IMPEDANCE (0x00)", 
      "", 
      "MODULE_DESCRIPTION(\"Marvell PHY driver\");", 
      "MODULE_AUTHOR(\"Andy Fleming\");", 
      "MODULE_LICENSE(\"GPL\");", 
      "", 
      "-static int marvell_ack_interrupt(struct phy_device *phydev)", 
      "-{", 
      "-\tint err;", 
      "-", 
      "-\t/* Clear the interrupts by reading the reg */", 
      "-\terr = phy_read(phydev, MII_M1011_IEVENT);", 
      "-", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\treturn 0;", 
      "-}", 
      "+/* #define MARVELL_DEBUG */", 
      "+/* #define CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES */", 
      "", 
      "-static int marvell_config_intr(struct phy_device *phydev)", 
      "+#ifdef MARVELL_DEBUG", 
      "+static void m3015_register_dump(struct phy_device *phydev)", 
      "{", 
      "-\tint err;", 
      "-", 
      "-\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED)", 
      "-\t\terr = phy_write(phydev, MII_M1011_IMASK, MII_M1011_IMASK_INIT);", 
      "-\telse", 
      "-\t\terr = phy_write(phydev, MII_M1011_IMASK, MII_M1011_IMASK_CLEAR);", 
      "+\tint result;", 
      "+\tint i;", 
      "", 
      "-\treturn err;", 
      "+\tprintk(\"\\nDumping Marvell 88E3015 registers\\n\");", 
      "+\tfor (i = 0; i < M3015_REGISTERS; ++i) {", 
      "+\t\tint reg = i;", 
      "+\t\tif (((reg > 8) && (reg < 16))", 
      "+\t\t    || (reg == 23)) {", 
      "+\t\t\t/* Register not used */", 
      "+\t\t\tcontinue;", 
      "+\t\t}", 
      "+\t\tif (reg > M3015_TEST_MODE_SELECT) {", 
      "+\t\t\t/* Paging mechanism for registers above */", 
      "+\t\t\treg = M3015_TEST_MODE_SELECT;", 
      "+\t\t\tresult = phy_read(phydev, reg);", 
      "+\t\t\tif (result < 0) {", 
      "+\t\t\t\tprintk(\"Unable to read register %d!\\n\", reg);", 
      "+\t\t\t\tcontinue;", 
      "+\t\t\t}", 
      "+\t\t\t/* Set page 9, 10 or 11 of the next register */", 
      "+\t\t\tresult &= M3015_TMS_PAGE_MASK;", 
      "+\t\t\tresult |= (9 + i - (reg + 1));", 
      "+\t\t\tresult = phy_write(phydev, reg, result);", 
      "+\t\t\treg = M3015_TEST_MODE_SELECT + 1;", 
      "+\t\t}", 
      "+\t\tresult = phy_read(phydev, reg);", 
      "+\t\tif (result < 0) {", 
      "+\t\t\tprintk(\"Unable to dump register %d!\\n\", reg);", 
      "+\t\t}", 
      "+\t\telse {", 
      "+\t\t\tif (i > M3015_TEST_MODE_SELECT) {", 
      "+\t\t\t\tprintk(\"  Register %d_%d: 0x%04x\\n\",", 
      "+\t\t\t\t       reg, 9 + i - reg, result);", 
      "+\t\t\t}", 
      "+\t\t\telse {", 
      "+\t\t\t\tprintk(\"  Register %d: 0x%04x\\n\", reg, result);", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+\tprintk(\"Done.\\n\\n\");", 
      "}", 
      "+#endif", 
      "", 
      "-static int marvell_config_aneg(struct phy_device *phydev)", 
      "+static int m3015_ack_interrupt(struct phy_device *phydev)", 
      "{", 
      "int err;", 
      "", 
      "-\t/* The Marvell PHY has an errata which requires", 
      "-\t * that certain registers get written in order", 
      "-\t * to restart autonegotiation */", 
      "-\terr = phy_write(phydev, MII_BMCR, BMCR_RESET);", 
      "-", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, 0x1d, 0x1f);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, 0x1e, 0x200c);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, 0x1d, 0x5);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, 0x1e, 0);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, 0x1e, 0x100);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "-", 
      "-\terr = phy_write(phydev, MII_M1011_PHY_SCR,", 
      "-\t\t\tMII_M1011_PHY_SCR_AUTO_CROSS);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "+\t/* Clear the interrupts by reading the interrupt status register */", 
      "+\terr = phy_read(phydev, M3015_INTERRUPT_STATUS);", 
      "", 
      "-\terr = phy_write(phydev, MII_M1111_PHY_LED_CONTROL,", 
      "-\t\t\tMII_M1111_PHY_LED_DIRECT);", 
      "if (err < 0)", 
      "return err;", 
      "", 
      "-\terr = genphy_config_aneg(phydev);", 
      "-", 
      "-\treturn err;", 
      "+\treturn 0;", 
      "}", 
      "", 
      "-static int m88e1111_config_init(struct phy_device *phydev)", 
      "+static int m3015_config_intr(struct phy_device *phydev)", 
      "{", 
      "int err;", 
      "", 
      "-\tif ((phydev->interface == PHY_INTERFACE_MODE_RGMII) ||", 
      "-\t    (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)) {", 
      "-\t\tint temp;", 
      "-", 
      "-\t\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {", 
      "-\t\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_CR);", 
      "-\t\t\tif (temp < 0)", 
      "-\t\t\t\treturn temp;", 
      "-", 
      "-\t\t\ttemp |= (MII_M1111_RX_DELAY | MII_M1111_TX_DELAY);", 
      "-", 
      "-\t\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_CR, temp);", 
      "-\t\t\tif (err < 0)", 
      "-\t\t\t\treturn err;", 
      "-\t\t}", 
      "-", 
      "-\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_SR);", 
      "-\t\tif (temp < 0)", 
      "-\t\t\treturn temp;", 
      "-", 
      "-\t\ttemp &= ~(MII_M1111_HWCFG_MODE_MASK);", 
      "-\t\ttemp |= MII_M1111_HWCFG_MODE_RGMII;", 
      "-", 
      "-\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);", 
      "-\t\tif (err < 0)", 
      "-\t\t\treturn err;", 
      "+\tif (phydev->interrupts == PHY_INTERRUPT_ENABLED) {", 
      "+\t\t/* Configure interrupts to be generated on speed", 
      "+\t\t   changes, duplex changes and link changes. */", 
      "+\t\terr = phy_write(phydev, M3015_INTERRUPT_ENABLE,", 
      "+\t\t\t\tM3015_INTEN_SPEEDCHANGE", 
      "+\t\t\t\t| M3015_INTEN_DUPLEXCHANGE", 
      "+\t\t\t\t| M3015_INTEN_LINKCHANGE);", 
      "}", 
      "-", 
      "-\tif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {", 
      "-\t\tint temp;", 
      "-", 
      "-\t\ttemp = phy_read(phydev, MII_M1111_PHY_EXT_SR);", 
      "-\t\tif (temp < 0)", 
      "-\t\t\treturn temp;", 
      "-", 
      "-\t\ttemp &= ~(MII_M1111_HWCFG_MODE_MASK);", 
      "-\t\ttemp |= MII_M1111_HWCFG_MODE_SGMII_NO_CLK;", 
      "-", 
      "-\t\terr = phy_write(phydev, MII_M1111_PHY_EXT_SR, temp);", 
      "-\t\tif (err < 0)", 
      "-\t\t\treturn err;", 
      "+\telse {", 
      "+\t\terr = phy_write(phydev, M3015_INTERRUPT_ENABLE,", 
      "+\t\t\t\tM3015_INTEN_NOINTERRUPTS);", 
      "}", 
      "", 
      "-\terr = phy_write(phydev, MII_BMCR, BMCR_RESET);", 
      "if (err < 0)", 
      "return err;", 
      "", 
      "return 0;", 
      "}", 
      "", 
      "-static int m88e1145_config_init(struct phy_device *phydev)", 
      "+#ifdef CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES", 
      "+static int m3015_set_impedance_target(struct phy_device *phydev,", 
      "+\t\t\t\t      int pmos_target_impedance,", 
      "+\t\t\t\t      int nmos_target_impedance)", 
      "{", 
      "-\tint err;", 
      "+\tint value;", 
      "+\tint result;", 
      "", 
      "-\t/* Take care of errata E0 & E1 */", 
      "-\terr = phy_write(phydev, 0x1d, 0x001b);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "+\tdo {", 
      "+\t\t/* Switch to page 10 */", 
      "+\t\tresult = phy_read(phydev, M3015_TEST_MODE_SELECT);", 
      "+\t\tif (result < 0) {", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+\t\tresult &= M3015_TMS_PAGE_MASK;", 
      "+\t\tresult |= M3015_TMS_PAGE_10;", 
      "+\t\tresult = phy_write(phydev, M3015_TEST_MODE_SELECT, result);", 
      "+\t\tif (result < 0) {", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "", 
      "-\terr = phy_write(phydev, 0x1e, 0x418f);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "+\t\t/* Set new calibration target impedance value */", 
      "+\t\tvalue = (pmos_target_impedance << M3015_CO_PMOS_SHIFT);", 
      "+\t\tvalue |= (nmos_target_impedance << M3015_CO_NMOS_SHIFT);", 
      "+\t\tvalue |= M3015_CO_LATCH;", 
      "+\t\tvalue |= M3015_CO_PMOS_SELECT;  /* Latch PMOS value */", 
      "+\t\tresult = phy_write(phydev, M3015_CALIBRATION_OVERRIDE, value);", 
      "+\t\tif (result < 0) {", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+\t\tvalue &= ~M3015_CO_PMOS_SELECT;  /* Latch NMOS value */", 
      "+\t\tresult = phy_write(phydev, M3015_CALIBRATION_OVERRIDE, value);", 
      "", 
      "-\terr = phy_write(phydev, 0x1d, 0x0016);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "+\t} while (0);", 
      "", 
      "-\terr = phy_write(phydev, 0x1e, 0xa2da);", 
      "-\tif (err < 0)", 
      "-\t\treturn err;", 
      "+\treturn result;", 
      "+}", 
      "+#endif", 
      "", 
      "-\tif (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID) {", 
      "-\t\tint temp = phy_read(phydev, MII_M1145_PHY_EXT_CR);", 
      "-\t\tif (temp < 0)", 
      "-\t\t\treturn temp;", 
      "-", 
      "-\t\ttemp |= (MII_M1145_RGMII_RX_DELAY | MII_M1145_RGMII_TX_DELAY);", 
      "-", 
      "-\t\terr = phy_write(phydev, MII_M1145_PHY_EXT_CR, temp);", 
      "-\t\tif (err < 0)", 
      "-\t\t\treturn err;", 
      "-", 
      "-\t\tif (phydev->dev_flags & M1145_DEV_FLAGS_RESISTANCE) {", 
      "-\t\t\terr = phy_write(phydev, 0x1d, 0x0012);", 
      "-\t\t\tif (err < 0)", 
      "-\t\t\t\treturn err;", 
      "-", 
      "-\t\t\ttemp = phy_read(phydev, 0x1e);", 
      "-\t\t\tif (temp < 0)", 
      "-\t\t\t\treturn temp;", 
      "-", 
      "-\t\t\ttemp &= 0xf03f;", 
      "-\t\t\ttemp |= 2 << 9;\t/* 36 ohm */", 
      "-\t\t\ttemp |= 2 << 6;\t/* 39 ohm */", 
      "-", 
      "-\t\t\terr = phy_write(phydev, 0x1e, temp);", 
      "-\t\t\tif (err < 0)", 
      "-\t\t\t\treturn err;", 
      "-", 
      "-\t\t\terr = phy_write(phydev, 0x1d, 0x3);", 
      "-\t\t\tif (err < 0)", 
      "-\t\t\t\treturn err;", 
      "-", 
      "-\t\t\terr = phy_write(phydev, 0x1e, 0x8000);", 
      "-\t\t\tif (err < 0)", 
      "-\t\t\t\treturn err;", 
      "-\t\t}", 
      "+static int m3015_config_init(struct phy_device *phydev)", 
      "+{", 
      "+\tint result;", 
      "+", 
      "+\tdo {", 
      "+\t  /* reset phy */", 
      "+\t  phy_write(phydev, MII_BMCR, BMCR_RESET);", 
      "+", 
      "+\t  /* restart autonegotation */", 
      "+\t  phy_write(phydev, MII_BMCR,", 
      "+\t\t    BMCR_ANRESTART | BMCR_ANENABLE);", 
      "+", 
      "+#ifdef CONFIGURE_IMPEDANCE_TARGET_ON_IO_LINES", 
      "+\t\t/* Set manual impedance values for the I/0 lines */", 
      "+\t\tresult = m3015_set_impedance_target(", 
      "+\t\t\tphydev,", 
      "+\t\t\tM3015_WEAK_PMOS_IMPEDANCE,", 
      "+\t\t\tM3015_WEAK_NMOS_IMPEDANCE);", 
      "+\t\tif (result < 0)", 
      "+\t\t\tbreak;", 
      "+#endif", 
      "+", 
      "+\t\t/* Configure the LED2 pin as an interrupt pin */", 
      "+\t\tresult = phy_read(phydev, M3015_LED_PARALLEL_SELECT);", 
      "+\t\tif (result < 0)", 
      "+\t\t\tbreak;", 
      "+\t\tresult &= M3015_LPS_LED2_MASK;", 
      "+\t\tresult |= (M3015_LPS_LED2_INTERRUPT << M3015_LPS_LED2_SHIFT);", 
      "+", 
      "+\t\t/* Configure the yellow LED on the LED1 pin to show activity */", 
      "+\t\tresult &= M3015_LPS_LED1_MASK;", 
      "+\t\tresult |= (M3015_LPS_LED1_ACTIVITY << M3015_LPS_LED1_SHIFT);", 
      "+", 
      "+\t\t/* Configure the green LED on the LED0 pin for link status */", 
      "+\t\tresult &= M3015_LPS_LED0_MASK;", 
      "+\t\tresult |= (M3015_LPS_LED0_LINK << M3015_LPS_LED0_SHIFT);", 
      "+\t\tresult = phy_write(phydev, M3015_LED_PARALLEL_SELECT, result);", 
      "+\t} while (0);", 
      "+", 
      "+\tif (result < 0) {", 
      "+\t\tprintk(\"Marvell 88E3015: Unable to communicate with the \"", 
      "+\t\t       \"device!\\n\");", 
      "+\t\treturn result;", 
      "}", 
      "", 
      "+#ifdef MARVELL_DEBUG", 
      "+\tm3015_register_dump(phydev);", 
      "+#endif", 
      "+", 
      "return 0;", 
      "}", 
      "", 
      "static struct phy_driver marvell_drivers[] = {", 
      "{", 
      "-\t\t.phy_id = 0x01410c60,", 
      "-\t\t.phy_id_mask = 0xfffffff0,", 
      "-\t\t.name = \"Marvell 88E1101\",", 
      "-\t\t.features = PHY_GBIT_FEATURES,", 
      "-\t\t.flags = PHY_HAS_INTERRUPT,", 
      "-\t\t.config_aneg = &marvell_config_aneg,", 
      "-\t\t.read_status = &genphy_read_status,", 
      "-\t\t.ack_interrupt = &marvell_ack_interrupt,", 
      "-\t\t.config_intr = &marvell_config_intr,", 
      "-\t\t.driver = {.owner = THIS_MODULE,},", 
      "-\t},", 
      "-\t{", 
      "-\t\t.phy_id = 0x01410c90,", 
      "-\t\t.phy_id_mask = 0xfffffff0,", 
      "-\t\t.name = \"Marvell 88E1112\",", 
      "-\t\t.features = PHY_GBIT_FEATURES,", 
      "-\t\t.flags = PHY_HAS_INTERRUPT,", 
      "-\t\t.config_init = &m88e1111_config_init,", 
      "-\t\t.config_aneg = &marvell_config_aneg,", 
      "-\t\t.read_status = &genphy_read_status,", 
      "-\t\t.ack_interrupt = &marvell_ack_interrupt,", 
      "-\t\t.config_intr = &marvell_config_intr,", 
      "-\t\t.driver = {.owner = THIS_MODULE,},", 
      "-\t},", 
      "-\t{", 
      "-\t\t.phy_id = 0x01410cc0,", 
      "-\t\t.phy_id_mask = 0xfffffff0,", 
      "-\t\t.name = \"Marvell 88E1111\",", 
      "-\t\t.features = PHY_GBIT_FEATURES,", 
      "-\t\t.flags = PHY_HAS_INTERRUPT,", 
      "-\t\t.config_init = &m88e1111_config_init,", 
      "-\t\t.config_aneg = &marvell_config_aneg,", 
      "-\t\t.read_status = &genphy_read_status,", 
      "-\t\t.ack_interrupt = &marvell_ack_interrupt,", 
      "-\t\t.config_intr = &marvell_config_intr,", 
      "-\t\t.driver = {.owner = THIS_MODULE,},", 
      "-\t},", 
      "-\t{", 
      "-\t\t.phy_id = 0x01410cd0,", 
      "+\t\t.phy_id = 0x01410e20,", 
      ".phy_id_mask = 0xfffffff0,", 
      "-\t\t.name = \"Marvell 88E1145\",", 
      "-\t\t.features = PHY_GBIT_FEATURES,", 
      "+\t\t.name = \"Marvell 88E3015\",", 
      "+\t\t.features = PHY_BASIC_FEATURES | SUPPORTED_Pause,", 
      ".flags = PHY_HAS_INTERRUPT,", 
      "-\t\t.config_init = &m88e1145_config_init,", 
      "-\t\t.config_aneg = &marvell_config_aneg,", 
      "+\t\t.config_init = &m3015_config_init,", 
      "+\t\t.config_aneg = &genphy_config_aneg,", 
      ".read_status = &genphy_read_status,", 
      "-\t\t.ack_interrupt = &marvell_ack_interrupt,", 
      "-\t\t.config_intr = &marvell_config_intr,", 
      "+\t\t.ack_interrupt = &m3015_ack_interrupt,", 
      "+\t\t.config_intr = &m3015_config_intr,", 
      ".driver = {.owner = THIS_MODULE,},", 
      "}", 
      "};"
    ]
  ]
]