[('linux-2.6.23.orig/drivers/mtd/nand/Kconfig',
  'linux-2.6.23/drivers/mtd/nand/Kconfig',
  'Index: linux-2.6.23/drivers/mtd/nand/Kconfig\n===================================================================\n--- linux-2.6.23.orig/drivers/mtd/nand/Kconfig\n+++ linux-2.6.23/drivers/mtd/nand/Kconfig\n@@ -264,6 +264,11 @@ config MTD_NAND_CM_X270\ntristate "Support for NAND Flash on CM-X270 modules"\ndepends on MTD_NAND && MACH_ARMCORE\n\n+config MTD_NAND_VIP19XX\n+       tristate "Support for NAND flash device on Motorola VIP19xx boards"\n+       depends on SH_MOTOROLA_VIP19XX && MTD_NAND\n+       help\n+         Driver for the NAND flash on Motorola VIP19xx boards.\n\nconfig MTD_NAND_NANDSIM\ntristate "Support for NAND Flash Simulator"'),
 ('linux-2.6.23.orig/drivers/mtd/nand/Makefile',
  'linux-2.6.23/drivers/mtd/nand/Makefile',
  'Index: linux-2.6.23/drivers/mtd/nand/Makefile\n===================================================================\n--- linux-2.6.23.orig/drivers/mtd/nand/Makefile\n+++ linux-2.6.23/drivers/mtd/nand/Makefile\n@@ -27,6 +27,7 @@ obj-$(CONFIG_MTD_NAND_AT91)\t\t+= at91_nan\nobj-$(CONFIG_MTD_NAND_CM_X270)\t\t+= cmx270_nand.o\nobj-$(CONFIG_MTD_NAND_BASLER_EXCITE)\t+= excite_nandflash.o\nobj-$(CONFIG_MTD_NAND_PLATFORM)\t\t+= plat_nand.o\n+obj-$(CONFIG_MTD_NAND_VIP19XX)\t\t+= vip19xx_nand.o\nobj-$(CONFIG_MTD_NAND_STM_EMI)\t\t+= stm_nand_emi.o\nobj-$(CONFIG_MTD_NAND_STM_FLEX)\t\t+= stm_nand_flex.o stm_nand_ecc.o\n'),
 ('dev/null',
  'linux-2.6.23/drivers/mtd/nand/vip19xx_nand.c',
  'Index: linux-2.6.23/drivers/mtd/nand/vip19xx_nand.c\n===================================================================\n--- dev/null\n+++ linux-2.6.23/drivers/mtd/nand/vip19xx_nand.c\n@@ -0,0 +1,333 @@\n+/*\n+ *---------------------------------------------------------------------------\n+ *\n+ * vip19xx_nand.c\n+ *\n+ * Copyright (c) 2008-2011 Motorola, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ * notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ * notice, this list of conditions and the following disclaimer in the\n+ * documentation and/or other materials provided with the distribution.\n+ * 3. The name of the author may not be used to endorse or promote products\n+ * derived from this software without specific prior written permission.\n+ *\n+ * Alternatively, this software may be distributed under the terms of the\n+ * GNU General Public License ("GPL") version 2 as published by the Free\n+ * Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ *---------------------------------------------------------------------------\n+ */\n+\n+#include <linux/kernel.h>\n+#include <linux/init.h>\n+#include <linux/slab.h>\n+#include <linux/module.h>\n+#include <linux/mtd/mtd.h>\n+#include <linux/mtd/nand.h>\n+#include <linux/mtd/partitions.h>\n+#include <asm/io.h>\n+#include <asm/vip19xx.h>\n+\n+#include <linux/stm/pio.h>\n+\n+#define NAME "vip19xx_nand"\n+\n+static struct mtd_info *nand_mtd = NULL;\n+static int nand_cs = 0;\n+\n+/* PIO structs */\n+static struct stpio_pin *nand_cle = NULL;\n+static struct stpio_pin *nand_ale = NULL;\n+static struct stpio_pin *nand_rbusy = NULL;\n+\n+static int nand_port = 2;\n+static int cle_pin = 2;\n+static int ale_pin = 3;\n+static int rbusy_pin = 5;\n+\n+DECLARE_WAIT_QUEUE_HEAD(rbusy_wait);\n+\n+/*\n+ * Define partitions for flash device\n+ */\n+static struct mtd_partition partition_info[] = {\n+\t{\n+\t\t.name\t= "VIP19xx NANDflash partition",\n+\t\t.offset\t= 0,\n+\t\t.size\t= 32 * 1024 * 1024\n+\t}\n+};\n+\n+static inline u16 WriteConversion(uint8_t data)\n+{\n+\treturn\n+\t\t((data & 0x01)<<9) | // bit 0\n+\t\t((data & 0x02)<<1) | // bit 1\n+\t\t((data & 0x14)<<8) | // bit 2, 4\n+\t\t (data & 0x28)     | // bit 3, 5\n+\t\t((data & 0x40)<<7) | // bit 6\n+\t\t((data & 0x80)>>1);\n+}\n+\n+static inline uint8_t ReadConversion(u16 data)\n+{\n+\treturn\n+\t\t((data & 0x0200)>>9) | // bit 0\n+\t\t((data & 0x0004)>>1) | // bit 1\n+\t\t((data & 0x1400)>>8) | // bit 2, 4\n+\t\t (data & 0x0028)     | // bit 3, 5\n+\t\t((data & 0x2000)>>7) | // bit 6\n+\t\t((data & 0x0040)<<1);\n+}\n+\n+static uint8_t read_byte(struct mtd_info *mtd)\n+{\n+\tstruct nand_chip *this = mtd->priv;\n+\treturn ReadConversion(cpu_to_le16(readw(this->IO_ADDR_R)));\n+}\n+\n+/**\n+ * Write data from the buffer to the chip\n+ */\n+static void write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\n+{\n+\tint i;\n+\tstruct nand_chip *this = mtd->priv;\n+\n+\tfor (i = 0; i < len; i++) {\n+\t\twritew(WriteConversion(buf[i]), this->IO_ADDR_W);\n+\t}\n+}\n+\n+/**\n+ * Read data from the chip into the buffer\n+ */\n+static void read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\n+{\n+\tint i;\n+\tstruct nand_chip *this = mtd->priv;\n+\n+\tfor (i = 0; i < len; i++) {\n+\t\tbuf[i] = ReadConversion(readw(this->IO_ADDR_R));\n+\t}\n+}\n+\n+/**\n+ * Verify buffer contents against the chip data\n+ */\n+static int verify_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\n+{\n+\tint i;\n+\tstruct nand_chip *this = mtd->priv;\n+\n+\tfor (i = 0; i < len; i++) {\n+\t\tif (buf[i] != ReadConversion(readw(this->IO_ADDR_R))) {\n+\t\t\treturn -EFAULT;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/*\n+ * Hardwarespecific funtion for controlling ALE/CLE/nCE. Also used to write\n+ * command and address.\n+ */\n+static void cmd_ctrl(struct mtd_info *mtd, int dat, unsigned int ctrl)\n+{\n+\tstruct nand_chip *this = mtd->priv;\n+\n+\tif (ctrl & NAND_CTRL_CHANGE) {\n+\t\tint value;\n+\n+\t\tvalue = (ctrl & NAND_NCE) ? 1 : 0;\n+\t\tif (value != nand_cs) {\n+\t\t\tif (value) {\n+\t\t\t\tVIP19XX_EMI_ENABLE_CS(this->priv,\n+\t\t\t\t\t\t      VIP19XX_NAND_FLASH_EMI_BANK);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tVIP19XX_EMI_DISABLE_CS(this->priv,\n+\t\t\t\t\t\t       VIP19XX_NAND_FLASH_EMI_BANK);\n+\t\t\t}\n+\t\t\tnand_cs = value;\n+\t\t}\n+\n+\t\tvalue = (ctrl & NAND_CLE) ? 1 : 0;\n+\t\tstpio_set_pin(nand_cle, value);\n+\n+\t\tvalue = (ctrl & NAND_ALE) ? 1 : 0;\n+\t\tstpio_set_pin(nand_ale, value);\n+\t}\n+\n+\tif (dat != NAND_CMD_NONE) {\n+\t\tuint8_t tmp = dat;\n+\t\tthis->write_buf(mtd, &tmp, 1);\n+\t}\n+}\n+\n+/*\n+ * Hardware specific wait function for wait on ready.\n+ */\n+static int waitfunc(struct mtd_info *mtd, struct nand_chip *this)\n+{\n+\tthis->cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);\n+\n+\t/*\n+\t * Chip busy, wait for ready\n+\t * Using stpio with IRQ doesn\'t seem to work correctly. We get stuck\n+\t * after Schedule() is called (see wait_event_interrupible in\n+\t * linux/wait.h). Using busy-wait for now.\n+\t */\n+\twhile (stpio_get_pin(nand_rbusy) != 1);\n+\n+\treturn (int)this->read_byte(mtd);\n+}\n+\n+/* Returns 0 if the nand is busy, 1 if it is ready */\n+static int dev_ready(struct mtd_info *mtd)\n+{\n+        return stpio_get_pin(nand_rbusy);\n+}\n+\n+static int __init init(void)\n+{\n+\tstruct nand_chip *this;\n+\tint err = 0;\n+\n+\t/* Request PIO pins */\n+\tnand_cle = stpio_request_pin(nand_port,\n+\t\t\t\t     cle_pin, "NAND IO", STPIO_OUT);\n+\tnand_ale = stpio_request_pin(nand_port,\n+\t\t\t\t     ale_pin, "NAND IO", STPIO_OUT);\n+\tnand_rbusy = stpio_request_pin(nand_port,\n+\t\t\t\t       rbusy_pin, "NAND IO", STPIO_IN);\n+\n+\tif (nand_cle == NULL || nand_ale == NULL || nand_rbusy == NULL) {\n+\t\tprintk(KERN_ERR NAME ": failed to allocate PIO pins\\n");\n+\t\terr = -EIO;\n+\t\tgoto out;\n+\t}\n+\n+\t/* Allocate memory for MTD device structure and private data */\n+\tnand_mtd = kmalloc(sizeof(struct mtd_info) + sizeof (struct nand_chip),\n+\t\t\t   GFP_KERNEL);\n+\tif (!nand_mtd) {\n+\t\tprintk(KERN_ERR NAME ": unable to allocate VIP19xx NAND MTD "\n+\t\t       "device structure\\n");\n+\t\terr = -ENOMEM;\n+\t\tgoto out_pio;\n+\t}\n+\n+\t/* Get pointer to private data */\n+\tthis = (struct nand_chip *)(&nand_mtd[1]);\n+\n+\t/* Initialize structures */\n+\tmemset(nand_mtd, 0, sizeof(struct mtd_info));\n+\tmemset(this, 0, sizeof(struct nand_chip));\n+\n+\tnand_mtd->owner = THIS_MODULE;\n+\n+\t/* Link the private data with the MTD structure */\n+\tnand_mtd->priv = this;\n+\n+\t/* Set address of NAND IO lines */\n+\tthis->IO_ADDR_R = ioremap_nocache(VIP19XX_NAND_FLASH_BASE,\n+\t\t\t\t\t  VIP19XX_NAND_FLASH_SIZE);\n+\tthis->IO_ADDR_W = this->IO_ADDR_R;\n+\n+\t/* Set address of hardware control function */\n+\tthis->cmd_ctrl = cmd_ctrl;\n+\t/* 15 us command delay time */\n+\tthis->chip_delay = 15;\n+\t/* Software ECC */\n+\tthis->ecc.mode = NAND_ECC_SOFT;\n+\n+\tthis->waitfunc = waitfunc;\n+\tthis->dev_ready = dev_ready;\n+\n+\t// Map the EMI config memory\n+\tthis->priv = ioremap_nocache(VIP19XX_EMI_CONFIG_BASE, VIP19XX_EMI_CONFIG_SIZE);\n+\n+\t/* Scan to find existence of the device */\n+\tif (nand_scan(nand_mtd, 1)) {\n+\t\t/* Early 19xx boards had another NAND flash with different pin\n+\t\t * layout. The code below is only used for that old flash. */\n+\n+\t\t/* Setup the EMIbus in 16 bit mode */\n+\t\tunsigned long size;\n+\t\tsize = readl(VIP19XX_EMI_CFG_DATA0(this->priv, VIP19XX_NAND_FLASH_EMI_BANK));\n+\t\tsize &= ~VIP19XX_EMI_CFG_PORTSIZE_MASK;\n+\t\tsize |= VIP19XX_EMI_CFG_PORTSIZE_16;\n+\t\twritel(size, VIP19XX_EMI_CFG_DATA0(this->priv, VIP19XX_NAND_FLASH_EMI_BANK));\n+\n+\t\tthis->read_byte = read_byte;\n+\t\tthis->write_buf = write_buf;\n+\t\tthis->read_buf = read_buf;\n+\t\tthis->verify_buf = verify_buf;\n+\n+\t\tif (nand_scan(nand_mtd, 1)) {\n+\t\t\terr = -ENXIO;\n+\t\t\tgoto out_mtd;\n+\t\t}\n+\t}\n+\n+\t/* Register the partitions */\n+\tpartition_info[0].size = nand_mtd->size;\n+\tadd_mtd_partitions(nand_mtd, partition_info,\n+\t\t\t   ARRAY_SIZE(partition_info));\n+\n+\tgoto out;\n+\n+out_mtd:\n+\tiounmap(this->priv);\n+\tkfree(nand_mtd);\n+out_pio:\n+\tstpio_free_pin(nand_cle);\n+\tstpio_free_pin(nand_ale);\n+\tstpio_free_pin(nand_rbusy);\n+out:\n+\treturn err;\n+}\n+module_init(init);\n+\n+/* Clean up routine */\n+static void __exit cleanup(void)\n+{\n+\tstruct nand_chip *this = nand_mtd->priv;\n+\n+\tstpio_free_pin(nand_cle);\n+\tstpio_free_pin(nand_ale);\n+\tstpio_free_pin(nand_rbusy);\n+\n+\tiounmap(this->IO_ADDR_R);\n+\tiounmap(this->priv);\n+\n+\t/* Release resources, unregister device */\n+\tnand_release(nand_mtd);\n+\n+\t/* Free the MTD device structure */\n+\tkfree(nand_mtd);\n+}\n+module_exit(cleanup);\n+\n+MODULE_LICENSE("GPL");\n+MODULE_AUTHOR("Erik Johansson <erik.johansson@motorola.com>");\n+MODULE_DESCRIPTION("Motorola VIP19xx STB NAND flash driver");')]