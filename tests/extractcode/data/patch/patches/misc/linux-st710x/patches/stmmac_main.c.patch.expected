[('linux-2.6.23/drivers/net/stmmac/stmmac_main.c.orig',
  'linux-2.6.23/drivers/net/stmmac/stmmac_main.c',
  '--- linux-2.6.23/drivers/net/stmmac/stmmac_main.c.orig\n+++ linux-2.6.23/drivers/net/stmmac/stmmac_main.c\n@@ -34,11 +34,20 @@\n#include <linux/phy.h>\n#include <linux/stm/soc.h>\n#include <linux/dma-mapping.h>\n+#include <linux/reboot.h>\n+#include <linux/notifier.h>\n#include "stmmac.h"\n\n#define STMMAC_RESOURCE_NAME\t"stmmaceth"\n#define PHY_RESOURCE_NAME\t"stmmacphy"\n\n+/*\n+   Define a callback for enabling network packet handling outside of the IP-stack.\n+*/\n+typedef int (K_FILTER)(struct sk_buff*);\n+K_FILTER *kfilter_7109;\n+EXPORT_SYMBOL(kfilter_7109);\n+\n#undef STMMAC_DEBUG\n/*#define STMMAC_DEBUG*/\n#ifdef STMMAC_DEBUG\n@@ -1069,6 +1078,7 @@\nstruct stmmac_priv *priv = netdev_priv(dev);\nunsigned long ioaddr = dev->base_addr;\nint ret;\n+\tunsigned int value;\n\n/* Check that the MAC address is valid.  If its not, refuse\n* to bring the device up. The user must specify an\n@@ -1089,6 +1099,12 @@\nreturn -ENODEV;\n}\n\n+\t/* Disable tx and rx and clear any pending interrupts */\n+\tstmmac_mac_disable_tx(dev);\n+\tstmmac_mac_disable_rx(dev);\n+\tvalue = (unsigned int)readl(ioaddr + DMA_STATUS);\n+\twritel((value & 0x1ffff), ioaddr + DMA_STATUS);\n+\n/* Request the IRQ lines */\nret = request_irq(dev->irq, &stmmac_interrupt,\nIRQF_SHARED, dev->name, dev);\n@@ -1188,41 +1204,7 @@\n*/\nstatic int stmmac_release(struct net_device *dev)\n{\n-\tstruct stmmac_priv *priv = netdev_priv(dev);\n-\n-\t/* Stop and disconnect the PHY */\n-\tif (priv->phydev) {\n-\t\tphy_stop(priv->phydev);\n-\t\tphy_disconnect(priv->phydev);\n-\t\tpriv->phydev = NULL;\n-\t}\n-\n-\tnetif_stop_queue(dev);\n-\ttasklet_kill(&priv->tx_task);\n-\n-#ifdef CONFIG_STMMAC_TIMER\n-\t/* Stop and release the timer */\n-\tstmmac_close_hw_timer();\n-\tif (priv->tm != NULL)\n-\t\tkfree(priv->tm);\n-#endif\n-\n-\t/* Free the IRQ lines */\n-\tfree_irq(dev->irq, dev);\n-\n-\t/* Stop TX/RX DMA and clear the descriptors */\n-\tstmmac_dma_stop_tx(dev->base_addr);\n-\tstmmac_dma_stop_rx(dev->base_addr);\n-\n-\t/* Release and free the Rx/Tx resources */\n-\tfree_dma_desc_resources(dev);\n-\n-\t/* Disable the MAC core */\n-\tstmmac_mac_disable_tx(dev);\n-\tstmmac_mac_disable_rx(dev);\n-\n-\tnetif_carrier_off(dev);\n-\n+\tif (dev) {};\nreturn 0;\n}\n\n@@ -1512,7 +1494,15 @@\npriv->xstats.rx_vlan++;\n} /*FIXME*/\n#endif\n-\t\t\tnetif_receive_skb(skb);\n+ \t\t\t// Support for the kreatel UDP filter module\n+                        if (kfilter_7109) {\n+\t\t\t\tif (kfilter_7109(skb)) {\n+\t\t\t\t\tnetif_receive_skb(skb);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tnetif_receive_skb(skb);\n+\t\t\t}\n\ndev->stats.rx_packets++;\ndev->stats.rx_bytes += frame_len;\n@@ -1843,8 +1833,8 @@\npriv->mac_type->ops->get_umac_addr(dev->base_addr, dev->dev_addr, 0);\n\nif (!is_valid_ether_addr(dev->dev_addr)) {\n-\t\tprintk(KERN_WARNING "\\tno valid MAC address; "\n-\t\t       "please, set using ifconfig or nwhwconfig!\\n");\n+\t\tprintk(KERN_NOTICE "No valid MAC address yet; "\n+\t\t       "it will be set from the console later.\\n");\n}\n\nret = register_netdev(dev);\n@@ -1962,6 +1952,13 @@\nreturn 1;\t\t/* forces exit of driver_for_each_device() */\n}\n\n+static int stmmac_notify_sys(struct notifier_block *this,\n+\t\t\t     unsigned long code, void *unused);\n+\n+static struct notifier_block stmmac_notifier = {\n+\t.notifier_call = stmmac_notify_sys\n+};\n+\n/**\n* stmmac_dvr_probe\n* @pdev: platform device pointer\n@@ -1978,13 +1975,14 @@\nstruct stmmac_priv *priv;\nstruct plat_stmmacenet_data *plat_dat;\n\n-\tprintk(KERN_DEBUG "STMMAC driver:\\n\\tplatform registration... ");\n+\tprintk(KERN_DEBUG "STMMAC driver:\\n");\n+\tprintk(KERN_DEBUG "\\tplatform registration... ");\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\nif (!res) {\nret = -ENODEV;\ngoto out;\n}\n-\tprintk(KERN_DEBUG "done!\\n");\n+\tprintk("done!\\n");\n\nif (!request_mem_region(res->start, (res->end - res->start),\npdev->name)) {\n@@ -2064,6 +2062,9 @@\ngoto out;\nprintk(KERN_DEBUG "\\tMDIO bus registered!\\n");\n\n+\t/* Register a reboot notifier that will cleanup the driver */\n+\tregister_reboot_notifier(&stmmac_notifier);\n+\nout:\nif (ret < 0) {\nplatform_set_drvdata(pdev, NULL);\n@@ -2085,16 +2086,34 @@\nstatic int stmmac_dvr_remove(struct platform_device *pdev)\n{\nstruct net_device *ndev = platform_get_drvdata(pdev);\n+\tstruct stmmac_priv *priv = netdev_priv(ndev);\nstruct resource *res;\n\n-\tprintk(KERN_INFO "%s:\\n\\tremoving driver", __FUNCTION__);\n+\t/* Free the IRQ lines */\n+\tfree_irq(ndev->irq, ndev);\n\nstmmac_dma_stop_rx(ndev->base_addr);\nstmmac_dma_stop_tx(ndev->base_addr);\n\n+\tif (priv->phydev) {\n+\t\t/* Stop and disconnect the PHY */\n+\t\tphy_stop(priv->phydev);\n+\t\tphy_disconnect(priv->phydev);\n+\t\tpriv->phydev = NULL;\n+\t}\n+\tnetif_stop_queue(ndev);\n+\ttasklet_kill(&priv->tx_task);\n+\nstmmac_mac_disable_rx(ndev);\nstmmac_mac_disable_tx(ndev);\n\n+#ifdef CONFIG_STMMAC_TIMER\n+\t/* Stop and release the timer */\n+\tstmmac_close_hw_timer();\n+\tif (priv->tm != NULL)\n+\t\tkfree(priv->tm);\n+#endif\n+\nnetif_carrier_off(ndev);\n\nstmmac_mdio_unregister(ndev);\n@@ -2102,6 +2121,9 @@\nplatform_set_drvdata(pdev, NULL);\nunregister_netdev(ndev);\n\n+\t/* Release and free the Rx/Tx resources */\n+\tfree_dma_desc_resources(ndev);\n+\niounmap((void *)ndev->base_addr);\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\nrelease_mem_region(res->start, (res->end - res->start));\n@@ -2292,6 +2314,16 @@\nreturn 0;\n}\n\n+static int stmmac_notify_sys(struct notifier_block *this,\n+\t\t\t     unsigned long code, void *unused)\n+{\n+\tif (code == SYS_DOWN || code == SYS_HALT) {\n+\t\tplatform_driver_unregister(&stmmac_driver);\n+\t}\n+\n+\treturn NOTIFY_DONE;\n+}\n+\n__setup("stmmaceth=", stmmac_cmdline_opt);\n#endif\n')]