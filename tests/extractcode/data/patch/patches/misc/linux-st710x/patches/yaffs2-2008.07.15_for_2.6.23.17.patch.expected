[('linux-2.6.23/fs/Kconfig',
  'linux-2.6.23-yaffs2/fs/Kconfig',
  'diff -Naur linux-2.6.23/fs/Kconfig linux-2.6.23-yaffs2/fs/Kconfig\n--- linux-2.6.23/fs/Kconfig\n+++ linux-2.6.23-yaffs2/fs/Kconfig\n@@ -1182,6 +1182,10 @@\nTo compile the EFS file system support as a module, choose M here: the\nmodule will be called efs.\n\n+\n+# Patched by YAFFS\n+source "fs/yaffs2/Kconfig"\n+\nconfig JFFS2_FS\ntristate "Journalling Flash File System v2 (JFFS2) support"\nselect CRC32'),
 ('linux-2.6.23/fs/Kconfig.pre.yaffs',
  'linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs',
  'diff -Naur linux-2.6.23/fs/Kconfig.pre.yaffs linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs\n--- linux-2.6.23/fs/Kconfig.pre.yaffs\n+++ linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs\n@@ -0,0 +1,2122 @@\n+#\n+# File system configuration\n+#\n+\n+menu "File systems"\n+\n+if BLOCK\n+\n+config EXT2_FS\n+\ttristate "Second extended fs support"\n+\thelp\n+\t  Ext2 is a standard Linux file system for hard disks.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called ext2.\n+\n+\t  If unsure, say Y.\n+\n+config EXT2_FS_XATTR\n+\tbool "Ext2 extended attributes"\n+\tdepends on EXT2_FS\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page, or visit\n+\t  <http://acl.bestbits.at/> for details).\n+\n+\t  If unsure, say N.\n+\n+config EXT2_FS_POSIX_ACL\n+\tbool "Ext2 POSIX Access Control Lists"\n+\tdepends on EXT2_FS_XATTR\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  Posix Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the Posix ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config EXT2_FS_SECURITY\n+\tbool "Ext2 Security Labels"\n+\tdepends on EXT2_FS_XATTR\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the ext2 filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config EXT2_FS_XIP\n+\tbool "Ext2 execute in place support"\n+\tdepends on EXT2_FS && MMU\n+\thelp\n+\t  Execute in place can be used on memory-backed block devices. If you\n+\t  enable this option, you can select to mount block devices which are\n+\t  capable of this feature without using the page cache.\n+\n+\t  If you do not use a block device that is capable of using this,\n+\t  or if unsure, say N.\n+\n+config FS_XIP\n+# execute in place\n+\tbool\n+\tdepends on EXT2_FS_XIP\n+\tdefault y\n+\n+config EXT3_FS\n+\ttristate "Ext3 journalling file system support"\n+\tselect JBD\n+\thelp\n+\t  This is the journalling version of the Second extended file system\n+\t  (often called ext3), the de facto standard Linux file system\n+\t  (method to organize files on a storage device) for hard disks.\n+\n+\t  The journalling code included in this driver means you do not have\n+\t  to run e2fsck (file system checker) on your file systems after a\n+\t  crash.  The journal keeps track of any changes that were being made\n+\t  at the time the system crashed, and can ensure that your file system\n+\t  is consistent without the need for a lengthy check.\n+\n+\t  Other than adding the journal to the file system, the on-disk format\n+\t  of ext3 is identical to ext2.  It is possible to freely switch\n+\t  between using the ext3 driver and the ext2 driver, as long as the\n+\t  file system has been cleanly unmounted, or e2fsck is run on the file\n+\t  system.\n+\n+\t  To add a journal on an existing ext2 file system or change the\n+\t  behavior of ext3 file systems, you can use the tune2fs utility ("man\n+\t  tune2fs").  To modify attributes of files and directories on ext3\n+\t  file systems, use chattr ("man chattr").  You need to be using\n+\t  e2fsprogs version 1.20 or later in order to create ext3 journals\n+\t  (available at <http://sourceforge.net/projects/e2fsprogs/>).\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called ext3.\n+\n+config EXT3_FS_XATTR\n+\tbool "Ext3 extended attributes"\n+\tdepends on EXT3_FS\n+\tdefault y\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page, or visit\n+\t  <http://acl.bestbits.at/> for details).\n+\n+\t  If unsure, say N.\n+\n+\t  You need this for POSIX ACL support on ext3.\n+\n+config EXT3_FS_POSIX_ACL\n+\tbool "Ext3 POSIX Access Control Lists"\n+\tdepends on EXT3_FS_XATTR\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  Posix Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the Posix ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config EXT3_FS_SECURITY\n+\tbool "Ext3 Security Labels"\n+\tdepends on EXT3_FS_XATTR\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the ext3 filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config EXT4DEV_FS\n+\ttristate "Ext4dev/ext4 extended fs support development (EXPERIMENTAL)"\n+\tdepends on EXPERIMENTAL\n+\tselect JBD2\n+\thelp\n+\t  Ext4dev is a predecessor filesystem of the next generation\n+\t  extended fs ext4, based on ext3 filesystem code. It will be\n+\t  renamed ext4 fs later, once ext4dev is mature and stabilized.\n+\n+\t  Unlike the change from ext2 filesystem to ext3 filesystem,\n+\t  the on-disk format of ext4dev is not the same as ext3 any more:\n+\t  it is based on extent maps and it supports 48-bit physical block\n+\t  numbers. These combined on-disk format changes will allow\n+\t  ext4dev/ext4 to handle more than 16 TB filesystem volumes --\n+\t  a hard limit that ext3 cannot overcome without changing the\n+\t  on-disk format.\n+\n+\t  Other than extent maps and 48-bit block numbers, ext4dev also is\n+\t  likely to have other new features such as persistent preallocation,\n+\t  high resolution time stamps, and larger file support etc.  These\n+\t  features will be added to ext4dev gradually.\n+\n+\t  To compile this file system support as a module, choose M here. The\n+\t  module will be called ext4dev.\n+\n+\t  If unsure, say N.\n+\n+config EXT4DEV_FS_XATTR\n+\tbool "Ext4dev extended attributes"\n+\tdepends on EXT4DEV_FS\n+\tdefault y\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page, or visit\n+\t  <http://acl.bestbits.at/> for details).\n+\n+\t  If unsure, say N.\n+\n+\t  You need this for POSIX ACL support on ext4dev/ext4.\n+\n+config EXT4DEV_FS_POSIX_ACL\n+\tbool "Ext4dev POSIX Access Control Lists"\n+\tdepends on EXT4DEV_FS_XATTR\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  POSIX Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the POSIX ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config EXT4DEV_FS_SECURITY\n+\tbool "Ext4dev Security Labels"\n+\tdepends on EXT4DEV_FS_XATTR\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the ext4dev/ext4 filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config JBD\n+\ttristate\n+\thelp\n+\t  This is a generic journalling layer for block devices.  It is\n+\t  currently used by the ext3 and OCFS2 file systems, but it could\n+\t  also be used to add journal support to other file systems or block\n+\t  devices such as RAID or LVM.\n+\n+\t  If you are using the ext3 or OCFS2 file systems, you need to\n+\t  say Y here. If you are not using ext3 OCFS2 then you will probably\n+\t  want to say N.\n+\n+\t  To compile this device as a module, choose M here: the module will be\n+\t  called jbd.  If you are compiling ext3 or OCFS2 into the kernel,\n+\t  you cannot compile this code as a module.\n+\n+config JBD_DEBUG\n+\tbool "JBD (ext3) debugging support"\n+\tdepends on JBD\n+\thelp\n+\t  If you are using the ext3 journaled file system (or potentially any\n+\t  other file system/device using JBD), this option allows you to\n+\t  enable debugging output while the system is running, in order to\n+\t  help track down any problems you are having.  By default the\n+\t  debugging output will be turned off.\n+\n+\t  If you select Y here, then you will be able to turn on debugging\n+\t  with "echo N > /proc/sys/fs/jbd-debug", where N is a number between\n+\t  1 and 5, the higher the number, the more debugging output is\n+\t  generated.  To turn debugging off again, do\n+\t  "echo 0 > /proc/sys/fs/jbd-debug".\n+\n+config JBD2\n+\ttristate\n+\thelp\n+\t  This is a generic journaling layer for block devices that support\n+\t  both 32-bit and 64-bit block numbers.  It is currently used by\n+\t  the ext4dev/ext4 filesystem, but it could also be used to add\n+\t  journal support to other file systems or block devices such\n+\t  as RAID or LVM.\n+\n+\t  If you are using ext4dev/ext4, you need to say Y here. If you are not\n+\t  using ext4dev/ext4 then you will probably want to say N.\n+\n+\t  To compile this device as a module, choose M here. The module will be\n+\t  called jbd2.  If you are compiling ext4dev/ext4 into the kernel,\n+\t  you cannot compile this code as a module.\n+\n+config JBD2_DEBUG\n+\tbool "JBD2 (ext4dev/ext4) debugging support"\n+\tdepends on JBD2 && DEBUG_FS\n+\thelp\n+\t  If you are using the ext4dev/ext4 journaled file system (or\n+\t  potentially any other filesystem/device using JBD2), this option\n+\t  allows you to enable debugging output while the system is running,\n+\t  in order to help track down any problems you are having.\n+\t  By default, the debugging output will be turned off.\n+\n+\t  If you select Y here, then you will be able to turn on debugging\n+\t  with "echo N > /sys/kernel/debug/jbd2/jbd2-debug", where N is a\n+\t  number between 1 and 5. The higher the number, the more debugging\n+\t  output is generated.  To turn debugging off again, do\n+\t  "echo 0 > /sys/kernel/debug/jbd2/jbd2-debug".\n+\n+config FS_MBCACHE\n+# Meta block cache for Extended Attributes (ext2/ext3/ext4)\n+\ttristate\n+\tdepends on EXT2_FS_XATTR || EXT3_FS_XATTR || EXT4DEV_FS_XATTR\n+\tdefault y if EXT2_FS=y || EXT3_FS=y || EXT4DEV_FS=y\n+\tdefault m if EXT2_FS=m || EXT3_FS=m || EXT4DEV_FS=m\n+\n+config REISERFS_FS\n+\ttristate "Reiserfs support"\n+\thelp\n+\t  Stores not just filenames but the files themselves in a balanced\n+\t  tree.  Uses journalling.\n+\n+\t  Balanced trees are more efficient than traditional file system\n+\t  architectural foundations.\n+\n+\t  In general, ReiserFS is as fast as ext2, but is very efficient with\n+\t  large directories and small files.  Additional patches are needed\n+\t  for NFS and quotas, please see <http://www.namesys.com/> for links.\n+\n+\t  It is more easily extended to have features currently found in\n+\t  database and keyword search systems than block allocation based file\n+\t  systems are.  The next version will be so extended, and will support\n+\t  plugins consistent with our motto ``It takes more than a license to\n+\t  make source code open.\'\'\n+\n+\t  Read <http://www.namesys.com/> to learn more about reiserfs.\n+\n+\t  Sponsored by Threshold Networks, Emusic.com, and Bigstorage.com.\n+\n+\t  If you like it, you can pay us to add new features to it that you\n+\t  need, buy a support contract, or pay us to port it to another OS.\n+\n+config REISERFS_CHECK\n+\tbool "Enable reiserfs debug mode"\n+\tdepends on REISERFS_FS\n+\thelp\n+\t  If you set this to Y, then ReiserFS will perform every check it can\n+\t  possibly imagine of its internal consistency throughout its\n+\t  operation.  It will also go substantially slower.  More than once we\n+\t  have forgotten that this was on, and then gone despondent over the\n+\t  latest benchmarks.:-) Use of this option allows our team to go all\n+\t  out in checking for consistency when debugging without fear of its\n+\t  effect on end users.  If you are on the verge of sending in a bug\n+\t  report, say Y and you might get a useful error message.  Almost\n+\t  everyone should say N.\n+\n+config REISERFS_PROC_INFO\n+\tbool "Stats in /proc/fs/reiserfs"\n+\tdepends on REISERFS_FS && PROC_FS\n+\thelp\n+\t  Create under /proc/fs/reiserfs a hierarchy of files, displaying\n+\t  various ReiserFS statistics and internal data at the expense of\n+\t  making your kernel or module slightly larger (+8 KB). This also\n+\t  increases the amount of kernel memory required for each mount.\n+\t  Almost everyone but ReiserFS developers and people fine-tuning\n+\t  reiserfs or tracing problems should say N.\n+\n+config REISERFS_FS_XATTR\n+\tbool "ReiserFS extended attributes"\n+\tdepends on REISERFS_FS\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page, or visit\n+\t  <http://acl.bestbits.at/> for details).\n+\n+\t  If unsure, say N.\n+\n+config REISERFS_FS_POSIX_ACL\n+\tbool "ReiserFS POSIX Access Control Lists"\n+\tdepends on REISERFS_FS_XATTR\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  Posix Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the Posix ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config REISERFS_FS_SECURITY\n+\tbool "ReiserFS Security Labels"\n+\tdepends on REISERFS_FS_XATTR\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the ReiserFS filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config JFS_FS\n+\ttristate "JFS filesystem support"\n+\tselect NLS\n+\thelp\n+\t  This is a port of IBM\'s Journaled Filesystem .  More information is\n+\t  available in the file <file:Documentation/filesystems/jfs.txt>.\n+\n+\t  If you do not intend to use the JFS filesystem, say N.\n+\n+config JFS_POSIX_ACL\n+\tbool "JFS POSIX Access Control Lists"\n+\tdepends on JFS_FS\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  Posix Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the Posix ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config JFS_SECURITY\n+\tbool "JFS Security Labels"\n+\tdepends on JFS_FS\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the jfs filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config JFS_DEBUG\n+\tbool "JFS debugging"\n+\tdepends on JFS_FS\n+\thelp\n+\t  If you are experiencing any problems with the JFS filesystem, say\n+\t  Y here.  This will result in additional debugging messages to be\n+\t  written to the system log.  Under normal circumstances, this\n+\t  results in very little overhead.\n+\n+config JFS_STATISTICS\n+\tbool "JFS statistics"\n+\tdepends on JFS_FS\n+\thelp\n+\t  Enabling this option will cause statistics from the JFS file system\n+\t  to be made available to the user in the /proc/fs/jfs/ directory.\n+\n+config FS_POSIX_ACL\n+# Posix ACL utility routines (for now, only ext2/ext3/jfs/reiserfs)\n+#\n+# NOTE: you can implement Posix ACLs without these helpers (XFS does).\n+# \tNever use this symbol for ifdefs.\n+#\n+\tbool\n+\tdefault n\n+\n+source "fs/xfs/Kconfig"\n+source "fs/gfs2/Kconfig"\n+\n+config OCFS2_FS\n+\ttristate "OCFS2 file system support"\n+\tdepends on NET && SYSFS\n+\tselect CONFIGFS_FS\n+\tselect JBD\n+\tselect CRC32\n+\thelp\n+\t  OCFS2 is a general purpose extent based shared disk cluster file\n+\t  system with many similarities to ext3. It supports 64 bit inode\n+\t  numbers, and has automatically extending metadata groups which may\n+\t  also make it attractive for non-clustered use.\n+\n+\t  You\'ll want to install the ocfs2-tools package in order to at least\n+\t  get "mount.ocfs2".\n+\n+\t  Project web page:    http://oss.oracle.com/projects/ocfs2\n+\t  Tools web page:      http://oss.oracle.com/projects/ocfs2-tools\n+\t  OCFS2 mailing lists: http://oss.oracle.com/projects/ocfs2/mailman/\n+\n+\t  Note: Features which OCFS2 does not support yet:\n+\t          - extended attributes\n+\t          - quotas\n+\t          - cluster aware flock\n+\t          - Directory change notification (F_NOTIFY)\n+\t          - Distributed Caching (F_SETLEASE/F_GETLEASE/break_lease)\n+\t          - POSIX ACLs\n+\t          - readpages / writepages (not user visible)\n+\n+config OCFS2_DEBUG_MASKLOG\n+\tbool "OCFS2 logging support"\n+\tdepends on OCFS2_FS\n+\tdefault y\n+\thelp\n+\t  The ocfs2 filesystem has an extensive logging system.  The system\n+\t  allows selection of events to log via files in /sys/o2cb/logmask/.\n+\t  This option will enlarge your kernel, but it allows debugging of\n+\t  ocfs2 filesystem issues.\n+\n+config MINIX_FS\n+\ttristate "Minix fs support"\n+\thelp\n+\t  Minix is a simple operating system used in many classes about OS\'s.\n+\t  The minix file system (method to organize files on a hard disk\n+\t  partition or a floppy disk) was the original file system for Linux,\n+\t  but has been superseded by the second extended file system ext2fs.\n+\t  You don\'t want to use the minix file system on your hard disk\n+\t  because of certain built-in restrictions, but it is sometimes found\n+\t  on older Linux floppy disks.  This option will enlarge your kernel\n+\t  by about 28 KB. If unsure, say N.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called minix.  Note that the file system of your root\n+\t  partition (the one containing the directory /) cannot be compiled as\n+\t  a module.\n+\n+config ROMFS_FS\n+\ttristate "ROM file system support"\n+\t---help---\n+\t  This is a very small read-only file system mainly intended for\n+\t  initial ram disks of installation disks, but it could be used for\n+\t  other read-only media as well.  Read\n+\t  <file:Documentation/filesystems/romfs.txt> for details.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called romfs.  Note that the file system of your\n+\t  root partition (the one containing the directory /) cannot be a\n+\t  module.\n+\n+\t  If you don\'t know whether you need it, then you don\'t need it:\n+\t  answer N.\n+\n+endif\n+\n+config INOTIFY\n+\tbool "Inotify file change notification support"\n+\tdefault y\n+\t---help---\n+\t  Say Y here to enable inotify support.  Inotify is a file change\n+\t  notification system and a replacement for dnotify.  Inotify fixes\n+\t  numerous shortcomings in dnotify and introduces several new features\n+\t  including multiple file events, one-shot support, and unmount\n+\t  notification.\n+\n+\t  For more information, see Documentation/filesystems/inotify.txt\n+\n+\t  If unsure, say Y.\n+\n+config INOTIFY_USER\n+\tbool "Inotify support for userspace"\n+\tdepends on INOTIFY\n+\tdefault y\n+\t---help---\n+\t  Say Y here to enable inotify support for userspace, including the\n+\t  associated system calls.  Inotify allows monitoring of both files and\n+\t  directories via a single open fd.  Events are read from the file\n+\t  descriptor, which is also select()- and poll()-able.\n+\n+\t  For more information, see Documentation/filesystems/inotify.txt\n+\n+\t  If unsure, say Y.\n+\n+config QUOTA\n+\tbool "Quota support"\n+\thelp\n+\t  If you say Y here, you will be able to set per user limits for disk\n+\t  usage (also called disk quotas). Currently, it works for the\n+\t  ext2, ext3, and reiserfs file system. ext3 also supports journalled\n+\t  quotas for which you don\'t need to run quotacheck(8) after an unclean\n+\t  shutdown.\n+\t  For further details, read the Quota mini-HOWTO, available from\n+\t  <http://www.tldp.org/docs.html#howto>, or the documentation provided\n+\t  with the quota tools. Probably the quota support is only useful for\n+\t  multi user systems. If unsure, say N.\n+\n+config QFMT_V1\n+\ttristate "Old quota format support"\n+\tdepends on QUOTA\n+\thelp\n+\t  This quota format was (is) used by kernels earlier than 2.4.22. If\n+\t  you have quota working and you don\'t want to convert to new quota\n+\t  format say Y here.\n+\n+config QFMT_V2\n+\ttristate "Quota format v2 support"\n+\tdepends on QUOTA\n+\thelp\n+\t  This quota format allows using quotas with 32-bit UIDs/GIDs. If you\n+\t  need this functionality say Y here.\n+\n+config QUOTACTL\n+\tbool\n+\tdepends on XFS_QUOTA || QUOTA\n+\tdefault y\n+\n+config DNOTIFY\n+\tbool "Dnotify support" if EMBEDDED\n+\tdefault y\n+\thelp\n+\t  Dnotify is a directory-based per-fd file change notification system\n+\t  that uses signals to communicate events to user-space.  There exist\n+\t  superior alternatives, but some applications may still rely on\n+\t  dnotify.\n+\n+\t  Because of this, if unsure, say Y.\n+\n+config AUTOFS_FS\n+\ttristate "Kernel automounter support"\n+\thelp\n+\t  The automounter is a tool to automatically mount remote file systems\n+\t  on demand. This implementation is partially kernel-based to reduce\n+\t  overhead in the already-mounted case; this is unlike the BSD\n+\t  automounter (amd), which is a pure user space daemon.\n+\n+\t  To use the automounter you need the user-space tools from the autofs\n+\t  package; you can find the location in <file:Documentation/Changes>.\n+\t  You also want to answer Y to "NFS file system support", below.\n+\n+\t  If you want to use the newer version of the automounter with more\n+\t  features, say N here and say Y to "Kernel automounter v4 support",\n+\t  below.\n+\n+\t  To compile this support as a module, choose M here: the module will be\n+\t  called autofs.\n+\n+\t  If you are not a part of a fairly large, distributed network, you\n+\t  probably do not need an automounter, and can say N here.\n+\n+config AUTOFS4_FS\n+\ttristate "Kernel automounter version 4 support (also supports v3)"\n+\thelp\n+\t  The automounter is a tool to automatically mount remote file systems\n+\t  on demand. This implementation is partially kernel-based to reduce\n+\t  overhead in the already-mounted case; this is unlike the BSD\n+\t  automounter (amd), which is a pure user space daemon.\n+\n+\t  To use the automounter you need the user-space tools from\n+\t  <ftp://ftp.kernel.org/pub/linux/daemons/autofs/v4/>; you also\n+\t  want to answer Y to "NFS file system support", below.\n+\n+\t  To compile this support as a module, choose M here: the module will be\n+\t  called autofs4.  You will need to add "alias autofs autofs4" to your\n+\t  modules configuration file.\n+\n+\t  If you are not a part of a fairly large, distributed network or\n+\t  don\'t have a laptop which needs to dynamically reconfigure to the\n+\t  local network, you probably do not need an automounter, and can say\n+\t  N here.\n+\n+config FUSE_FS\n+\ttristate "Filesystem in Userspace support"\n+\thelp\n+\t  With FUSE it is possible to implement a fully functional filesystem\n+\t  in a userspace program.\n+\n+\t  There\'s also companion library: libfuse.  This library along with\n+\t  utilities is available from the FUSE homepage:\n+\t  <http://fuse.sourceforge.net/>\n+\n+\t  See <file:Documentation/filesystems/fuse.txt> for more information.\n+\t  See <file:Documentation/Changes> for needed library/utility version.\n+\n+\t  If you want to develop a userspace FS, or if you want to use\n+\t  a filesystem based on FUSE, answer Y or M.\n+\n+config GENERIC_ACL\n+\tbool\n+\tselect FS_POSIX_ACL\n+\n+if BLOCK\n+menu "CD-ROM/DVD Filesystems"\n+\n+config ISO9660_FS\n+\ttristate "ISO 9660 CDROM file system support"\n+\thelp\n+\t  This is the standard file system used on CD-ROMs.  It was previously\n+\t  known as "High Sierra File System" and is called "hsfs" on other\n+\t  Unix systems.  The so-called Rock-Ridge extensions which allow for\n+\t  long Unix filenames and symbolic links are also supported by this\n+\t  driver.  If you have a CD-ROM drive and want to do more with it than\n+\t  just listen to audio CDs and watch its LEDs, say Y (and read\n+\t  <file:Documentation/filesystems/isofs.txt> and the CD-ROM-HOWTO,\n+\t  available from <http://www.tldp.org/docs.html#howto>), thereby\n+\t  enlarging your kernel by about 27 KB; otherwise say N.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called isofs.\n+\n+config JOLIET\n+\tbool "Microsoft Joliet CDROM extensions"\n+\tdepends on ISO9660_FS\n+\tselect NLS\n+\thelp\n+\t  Joliet is a Microsoft extension for the ISO 9660 CD-ROM file system\n+\t  which allows for long filenames in unicode format (unicode is the\n+\t  new 16 bit character code, successor to ASCII, which encodes the\n+\t  characters of almost all languages of the world; see\n+\t  <http://www.unicode.org/> for more information).  Say Y here if you\n+\t  want to be able to read Joliet CD-ROMs under Linux.\n+\n+config ZISOFS\n+\tbool "Transparent decompression extension"\n+\tdepends on ISO9660_FS\n+\tselect ZLIB_INFLATE\n+\thelp\n+\t  This is a Linux-specific extension to RockRidge which lets you store\n+\t  data in compressed form on a CD-ROM and have it transparently\n+\t  decompressed when the CD-ROM is accessed.  See\n+\t  <http://www.kernel.org/pub/linux/utils/fs/zisofs/> for the tools\n+\t  necessary to create such a filesystem.  Say Y here if you want to be\n+\t  able to read such compressed CD-ROMs.\n+\n+config UDF_FS\n+\ttristate "UDF file system support"\n+\thelp\n+\t  This is the new file system used on some CD-ROMs and DVDs. Say Y if\n+\t  you intend to mount DVD discs or CDRW\'s written in packet mode, or\n+\t  if written to by other UDF utilities, such as DirectCD.\n+\t  Please read <file:Documentation/filesystems/udf.txt>.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called udf.\n+\n+\t  If unsure, say N.\n+\n+config UDF_NLS\n+\tbool\n+\tdefault y\n+\tdepends on (UDF_FS=m && NLS) || (UDF_FS=y && NLS=y)\n+\n+endmenu\n+endif\n+\n+if BLOCK\n+menu "DOS/FAT/NT Filesystems"\n+\n+config FAT_FS\n+\ttristate\n+\tselect NLS\n+\thelp\n+\t  If you want to use one of the FAT-based file systems (the MS-DOS and\n+\t  VFAT (Windows 95) file systems), then you must say Y or M here\n+\t  to include FAT support. You will then be able to mount partitions or\n+\t  diskettes with FAT-based file systems and transparently access the\n+\t  files on them, i.e. MSDOS files will look and behave just like all\n+\t  other Unix files.\n+\n+\t  This FAT support is not a file system in itself, it only provides\n+\t  the foundation for the other file systems. You will have to say Y or\n+\t  M to at least one of "MSDOS fs support" or "VFAT fs support" in\n+\t  order to make use of it.\n+\n+\t  Another way to read and write MSDOS floppies and hard drive\n+\t  partitions from within Linux (but not transparently) is with the\n+\t  mtools ("man mtools") program suite. You don\'t need to say Y here in\n+\t  order to do that.\n+\n+\t  If you need to move large files on floppies between a DOS and a\n+\t  Linux box, say Y here, mount the floppy under Linux with an MSDOS\n+\t  file system and use GNU tar\'s M option. GNU tar is a program\n+\t  available for Unix and DOS ("man tar" or "info tar").\n+\n+\t  The FAT support will enlarge your kernel by about 37 KB. If unsure,\n+\t  say Y.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  fat.  Note that if you compile the FAT support as a module, you\n+\t  cannot compile any of the FAT-based file systems into the kernel\n+\t  -- they will have to be modules as well.\n+\n+config MSDOS_FS\n+\ttristate "MSDOS fs support"\n+\tselect FAT_FS\n+\thelp\n+\t  This allows you to mount MSDOS partitions of your hard drive (unless\n+\t  they are compressed; to access compressed MSDOS partitions under\n+\t  Linux, you can either use the DOS emulator DOSEMU, described in the\n+\t  DOSEMU-HOWTO, available from\n+\t  <http://www.tldp.org/docs.html#howto>, or try dmsdosfs in\n+\t  <ftp://ibiblio.org/pub/Linux/system/filesystems/dosfs/>. If you\n+\t  intend to use dosemu with a non-compressed MSDOS partition, say Y\n+\t  here) and MSDOS floppies. This means that file access becomes\n+\t  transparent, i.e. the MSDOS files look and behave just like all\n+\t  other Unix files.\n+\n+\t  If you have Windows 95 or Windows NT installed on your MSDOS\n+\t  partitions, you should use the VFAT file system (say Y to "VFAT fs\n+\t  support" below), or you will not be able to see the long filenames\n+\t  generated by Windows 95 / Windows NT.\n+\n+\t  This option will enlarge your kernel by about 7 KB. If unsure,\n+\t  answer Y. This will only work if you said Y to "DOS FAT fs support"\n+\t  as well. To compile this as a module, choose M here: the module will\n+\t  be called msdos.\n+\n+config VFAT_FS\n+\ttristate "VFAT (Windows-95) fs support"\n+\tselect FAT_FS\n+\thelp\n+\t  This option provides support for normal Windows file systems with\n+\t  long filenames.  That includes non-compressed FAT-based file systems\n+\t  used by Windows 95, Windows 98, Windows NT 4.0, and the Unix\n+\t  programs from the mtools package.\n+\n+\t  The VFAT support enlarges your kernel by about 10 KB and it only\n+\t  works if you said Y to the "DOS FAT fs support" above.  Please read\n+\t  the file <file:Documentation/filesystems/vfat.txt> for details.  If\n+\t  unsure, say Y.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  vfat.\n+\n+config FAT_DEFAULT_CODEPAGE\n+\tint "Default codepage for FAT"\n+\tdepends on MSDOS_FS || VFAT_FS\n+\tdefault 437\n+\thelp\n+\t  This option should be set to the codepage of your FAT filesystems.\n+\t  It can be overridden with the "codepage" mount option.\n+\t  See <file:Documentation/filesystems/vfat.txt> for more information.\n+\n+config FAT_DEFAULT_IOCHARSET\n+\tstring "Default iocharset for FAT"\n+\tdepends on VFAT_FS\n+\tdefault "iso8859-1"\n+\thelp\n+\t  Set this to the default input/output character set you\'d\n+\t  like FAT to use. It should probably match the character set\n+\t  that most of your FAT filesystems use, and can be overridden\n+\t  with the "iocharset" mount option for FAT filesystems.\n+\t  Note that "utf8" is not recommended for FAT filesystems.\n+\t  If unsure, you shouldn\'t set "utf8" here.\n+\t  See <file:Documentation/filesystems/vfat.txt> for more information.\n+\n+config NTFS_FS\n+\ttristate "NTFS file system support"\n+\tselect NLS\n+\thelp\n+\t  NTFS is the file system of Microsoft Windows NT, 2000, XP and 2003.\n+\n+\t  Saying Y or M here enables read support.  There is partial, but\n+\t  safe, write support available.  For write support you must also\n+\t  say Y to "NTFS write support" below.\n+\n+\t  There are also a number of user-space tools available, called\n+\t  ntfsprogs.  These include ntfsundelete and ntfsresize, that work\n+\t  without NTFS support enabled in the kernel.\n+\n+\t  This is a rewrite from scratch of Linux NTFS support and replaced\n+\t  the old NTFS code starting with Linux 2.5.11.  A backport to\n+\t  the Linux 2.4 kernel series is separately available as a patch\n+\t  from the project web site.\n+\n+\t  For more information see <file:Documentation/filesystems/ntfs.txt>\n+\t  and <http://linux-ntfs.sourceforge.net/>.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called ntfs.\n+\n+\t  If you are not using Windows NT, 2000, XP or 2003 in addition to\n+\t  Linux on your computer it is safe to say N.\n+\n+config NTFS_DEBUG\n+\tbool "NTFS debugging support"\n+\tdepends on NTFS_FS\n+\thelp\n+\t  If you are experiencing any problems with the NTFS file system, say\n+\t  Y here.  This will result in additional consistency checks to be\n+\t  performed by the driver as well as additional debugging messages to\n+\t  be written to the system log.  Note that debugging messages are\n+\t  disabled by default.  To enable them, supply the option debug_msgs=1\n+\t  at the kernel command line when booting the kernel or as an option\n+\t  to insmod when loading the ntfs module.  Once the driver is active,\n+\t  you can enable debugging messages by doing (as root):\n+\t  echo 1 > /proc/sys/fs/ntfs-debug\n+\t  Replacing the "1" with "0" would disable debug messages.\n+\n+\t  If you leave debugging messages disabled, this results in little\n+\t  overhead, but enabling debug messages results in very significant\n+\t  slowdown of the system.\n+\n+\t  When reporting bugs, please try to have available a full dump of\n+\t  debugging messages while the misbehaviour was occurring.\n+\n+config NTFS_RW\n+\tbool "NTFS write support"\n+\tdepends on NTFS_FS\n+\thelp\n+\t  This enables the partial, but safe, write support in the NTFS driver.\n+\n+\t  The only supported operation is overwriting existing files, without\n+\t  changing the file length.  No file or directory creation, deletion or\n+\t  renaming is possible.  Note only non-resident files can be written to\n+\t  so you may find that some very small files (<500 bytes or so) cannot\n+\t  be written to.\n+\n+\t  While we cannot guarantee that it will not damage any data, we have\n+\t  so far not received a single report where the driver would have\n+\t  damaged someones data so we assume it is perfectly safe to use.\n+\n+\t  Note:  While write support is safe in this version (a rewrite from\n+\t  scratch of the NTFS support), it should be noted that the old NTFS\n+\t  write support, included in Linux 2.5.10 and before (since 1997),\n+\t  is not safe.\n+\n+\t  This is currently useful with TopologiLinux.  TopologiLinux is run\n+\t  on top of any DOS/Microsoft Windows system without partitioning your\n+\t  hard disk.  Unlike other Linux distributions TopologiLinux does not\n+\t  need its own partition.  For more information see\n+\t  <http://topologi-linux.sourceforge.net/>\n+\n+\t  It is perfectly safe to say N here.\n+\n+endmenu\n+endif\n+\n+menu "Pseudo filesystems"\n+\n+config PROC_FS\n+\tbool "/proc file system support" if EMBEDDED\n+\tdefault y\n+\thelp\n+\t  This is a virtual file system providing information about the status\n+\t  of the system. "Virtual" means that it doesn\'t take up any space on\n+\t  your hard disk: the files are created on the fly by the kernel when\n+\t  you try to access them. Also, you cannot read the files with older\n+\t  version of the program less: you need to use more or cat.\n+\n+\t  It\'s totally cool; for example, "cat /proc/interrupts" gives\n+\t  information about what the different IRQs are used for at the moment\n+\t  (there is a small number of Interrupt ReQuest lines in your computer\n+\t  that are used by the attached devices to gain the CPU\'s attention --\n+\t  often a source of trouble if two devices are mistakenly configured\n+\t  to use the same IRQ). The program procinfo to display some\n+\t  information about your system gathered from the /proc file system.\n+\n+\t  Before you can use the /proc file system, it has to be mounted,\n+\t  meaning it has to be given a location in the directory hierarchy.\n+\t  That location should be /proc. A command such as "mount -t proc proc\n+\t  /proc" or the equivalent line in /etc/fstab does the job.\n+\n+\t  The /proc file system is explained in the file\n+\t  <file:Documentation/filesystems/proc.txt> and on the proc(5) manpage\n+\t  ("man 5 proc").\n+\n+\t  This option will enlarge your kernel by about 67 KB. Several\n+\t  programs depend on this, so everyone should say Y here.\n+\n+config PROC_KCORE\n+\tbool "/proc/kcore support" if !ARM\n+\tdepends on PROC_FS && MMU\n+\n+config PROC_VMCORE\n+        bool "/proc/vmcore support (EXPERIMENTAL)"\n+        depends on PROC_FS && EXPERIMENTAL && CRASH_DUMP\n+\tdefault y\n+        help\n+        Exports the dump image of crashed kernel in ELF format.\n+\n+config PROC_SYSCTL\n+\tbool "Sysctl support (/proc/sys)" if EMBEDDED\n+\tdepends on PROC_FS\n+\tselect SYSCTL\n+\tdefault y\n+\t---help---\n+\t  The sysctl interface provides a means of dynamically changing\n+\t  certain kernel parameters and variables on the fly without requiring\n+\t  a recompile of the kernel or reboot of the system.  The primary\n+\t  interface is through /proc/sys.  If you say Y here a tree of\n+\t  modifiable sysctl entries will be generated beneath the\n+          /proc/sys directory. They are explained in the files\n+\t  in <file:Documentation/sysctl/>.  Note that enabling this\n+\t  option will enlarge the kernel by at least 8 KB.\n+\n+\t  As it is generally a good thing, you should say Y here unless\n+\t  building a kernel for install/rescue disks or your system is very\n+\t  limited in memory.\n+\n+config SYSFS\n+\tbool "sysfs file system support" if EMBEDDED\n+\tdefault y\n+\thelp\n+\tThe sysfs filesystem is a virtual filesystem that the kernel uses to\n+\texport internal kernel objects, their attributes, and their\n+\trelationships to one another.\n+\n+\tUsers can use sysfs to ascertain useful information about the running\n+\tkernel, such as the devices the kernel has discovered on each bus and\n+\twhich driver each is bound to. sysfs can also be used to tune devices\n+\tand other kernel subsystems.\n+\n+\tSome system agents rely on the information in sysfs to operate.\n+\t/sbin/hotplug uses device and object attributes in sysfs to assist in\n+\tdelegating policy decisions, like persistently naming devices.\n+\n+\tsysfs is currently used by the block subsystem to mount the root\n+\tpartition.  If sysfs is disabled you must specify the boot device on\n+\tthe kernel boot command line via its major and minor numbers.  For\n+\texample, "root=03:01" for /dev/hda1.\n+\n+\tDesigners of embedded systems may wish to say N here to conserve space.\n+\n+config TMPFS\n+\tbool "Virtual memory file system support (former shm fs)"\n+\thelp\n+\t  Tmpfs is a file system which keeps all files in virtual memory.\n+\n+\t  Everything in tmpfs is temporary in the sense that no files will be\n+\t  created on your hard drive. The files live in memory and swap\n+\t  space. If you unmount a tmpfs instance, everything stored therein is\n+\t  lost.\n+\n+\t  See <file:Documentation/filesystems/tmpfs.txt> for details.\n+\n+config TMPFS_POSIX_ACL\n+\tbool "Tmpfs POSIX Access Control Lists"\n+\tdepends on TMPFS\n+\tselect GENERIC_ACL\n+\thelp\n+\t  POSIX Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the POSIX ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N.\n+\n+config HUGETLBFS\n+\tbool "HugeTLB file system support"\n+\tdepends on X86 || IA64 || PPC64 || SPARC64 || (SUPERH && MMU) || BROKEN\n+\thelp\n+\t  hugetlbfs is a filesystem backing for HugeTLB pages, based on\n+\t  ramfs. For architectures that support it, say Y here and read\n+\t  <file:Documentation/vm/hugetlbpage.txt> for details.\n+\n+\t  If unsure, say N.\n+\n+config HUGETLB_PAGE\n+\tdef_bool HUGETLBFS\n+\n+config RAMFS\n+\tbool\n+\tdefault y\n+\t---help---\n+\t  Ramfs is a file system which keeps all files in RAM. It allows\n+\t  read and write access.\n+\n+\t  It is more of an programming example than a useable file system.  If\n+\t  you need a file system which lives in RAM with limit checking use\n+\t  tmpfs.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  ramfs.\n+\n+config CONFIGFS_FS\n+\ttristate "Userspace-driven configuration filesystem (EXPERIMENTAL)"\n+\tdepends on SYSFS && EXPERIMENTAL\n+\thelp\n+\t  configfs is a ram-based filesystem that provides the converse\n+\t  of sysfs\'s functionality. Where sysfs is a filesystem-based\n+\t  view of kernel objects, configfs is a filesystem-based manager\n+\t  of kernel objects, or config_items.\n+\n+\t  Both sysfs and configfs can and should exist together on the\n+\t  same system. One is not a replacement for the other.\n+\n+endmenu\n+\n+menu "Miscellaneous filesystems"\n+\n+config ADFS_FS\n+\ttristate "ADFS file system support (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\thelp\n+\t  The Acorn Disc Filing System is the standard file system of the\n+\t  RiscOS operating system which runs on Acorn\'s ARM-based Risc PC\n+\t  systems and the Acorn Archimedes range of machines. If you say Y\n+\t  here, Linux will be able to read from ADFS partitions on hard drives\n+\t  and from ADFS-formatted floppy discs. If you also want to be able to\n+\t  write to those devices, say Y to "ADFS write support" below.\n+\n+\t  The ADFS partition should be the first partition (i.e.,\n+\t  /dev/[hs]d?1) on each of your drives. Please read the file\n+\t  <file:Documentation/filesystems/adfs.txt> for further details.\n+\n+\t  To compile this code as a module, choose M here: the module will be\n+\t  called adfs.\n+\n+\t  If unsure, say N.\n+\n+config ADFS_FS_RW\n+\tbool "ADFS write support (DANGEROUS)"\n+\tdepends on ADFS_FS\n+\thelp\n+\t  If you say Y here, you will be able to write to ADFS partitions on\n+\t  hard drives and ADFS-formatted floppy disks. This is experimental\n+\t  codes, so if you\'re unsure, say N.\n+\n+config AFFS_FS\n+\ttristate "Amiga FFS file system support (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\thelp\n+\t  The Fast File System (FFS) is the common file system used on hard\n+\t  disks by Amiga(tm) systems since AmigaOS Version 1.3 (34.20).  Say Y\n+\t  if you want to be able to read and write files from and to an Amiga\n+\t  FFS partition on your hard drive.  Amiga floppies however cannot be\n+\t  read with this driver due to an incompatibility of the floppy\n+\t  controller used in an Amiga and the standard floppy controller in\n+\t  PCs and workstations. Read <file:Documentation/filesystems/affs.txt>\n+\t  and <file:fs/affs/Changes>.\n+\n+\t  With this driver you can also mount disk files used by Bernd\n+\t  Schmidt\'s Un*X Amiga Emulator\n+\t  (<http://www.freiburg.linux.de/~uae/>).\n+\t  If you want to do this, you will also need to say Y or M to "Loop\n+\t  device support", above.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called affs.  If unsure, say N.\n+\n+config ECRYPT_FS\n+\ttristate "eCrypt filesystem layer support (EXPERIMENTAL)"\n+\tdepends on EXPERIMENTAL && KEYS && CRYPTO && NET\n+\thelp\n+\t  Encrypted filesystem that operates on the VFS layer.  See\n+\t  <file:Documentation/ecryptfs.txt> to learn more about\n+\t  eCryptfs.  Userspace components are required and can be\n+\t  obtained from <http://ecryptfs.sf.net>.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called ecryptfs.\n+\n+config HFS_FS\n+\ttristate "Apple Macintosh file system support (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\tselect NLS\n+\thelp\n+\t  If you say Y here, you will be able to mount Macintosh-formatted\n+\t  floppy disks and hard drive partitions with full read-write access.\n+\t  Please read <file:fs/hfs/HFS.txt> to learn about the available mount\n+\t  options.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called hfs.\n+\n+config HFSPLUS_FS\n+\ttristate "Apple Extended HFS file system support"\n+\tdepends on BLOCK\n+\tselect NLS\n+\tselect NLS_UTF8\n+\thelp\n+\t  If you say Y here, you will be able to mount extended format\n+\t  Macintosh-formatted hard drive partitions with full read-write access.\n+\n+\t  This file system is often called HFS+ and was introduced with\n+\t  MacOS 8. It includes all Mac specific filesystem data such as\n+\t  data forks and creator codes, but it also has several UNIX\n+\t  style features such as file ownership and permissions.\n+\n+config BEFS_FS\n+\ttristate "BeOS file system (BeFS) support (read only) (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\tselect NLS\n+\thelp\n+\t  The BeOS File System (BeFS) is the native file system of Be, Inc\'s\n+\t  BeOS. Notable features include support for arbitrary attributes\n+\t  on files and directories, and database-like indices on selected\n+\t  attributes. (Also note that this driver doesn\'t make those features\n+\t  available at this time). It is a 64 bit filesystem, so it supports\n+\t  extremely large volumes and files.\n+\n+\t  If you use this filesystem, you should also say Y to at least one\n+\t  of the NLS (native language support) options below.\n+\n+\t  If you don\'t know what this is about, say N.\n+\n+\t  To compile this as a module, choose M here: the module will be\n+\t  called befs.\n+\n+config BEFS_DEBUG\n+\tbool "Debug BeFS"\n+\tdepends on BEFS_FS\n+\thelp\n+\t  If you say Y here, you can use the \'debug\' mount option to enable\n+\t  debugging output from the driver.\n+\n+config BFS_FS\n+\ttristate "BFS file system support (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\thelp\n+\t  Boot File System (BFS) is a file system used under SCO UnixWare to\n+\t  allow the bootloader access to the kernel image and other important\n+\t  files during the boot process.  It is usually mounted under /stand\n+\t  and corresponds to the slice marked as "STAND" in the UnixWare\n+\t  partition.  You should say Y if you want to read or write the files\n+\t  on your /stand slice from within Linux.  You then also need to say Y\n+\t  to "UnixWare slices support", below.  More information about the BFS\n+\t  file system is contained in the file\n+\t  <file:Documentation/filesystems/bfs.txt>.\n+\n+\t  If you don\'t know what this is about, say N.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  bfs.  Note that the file system of your root partition (the one\n+\t  containing the directory /) cannot be compiled as a module.\n+\n+\n+\n+config EFS_FS\n+\ttristate "EFS file system support (read only) (EXPERIMENTAL)"\n+\tdepends on BLOCK && EXPERIMENTAL\n+\thelp\n+\t  EFS is an older file system used for non-ISO9660 CD-ROMs and hard\n+\t  disk partitions by SGI\'s IRIX operating system (IRIX 6.0 and newer\n+\t  uses the XFS file system for hard disk partitions however).\n+\n+\t  This implementation only offers read-only access. If you don\'t know\n+\t  what all this is about, it\'s safe to say N. For more information\n+\t  about EFS see its home page at <http://aeschi.ch.eu.org/efs/>.\n+\n+\t  To compile the EFS file system support as a module, choose M here: the\n+\t  module will be called efs.\n+\n+config JFFS2_FS\n+\ttristate "Journalling Flash File System v2 (JFFS2) support"\n+\tselect CRC32\n+\tdepends on MTD\n+\thelp\n+\t  JFFS2 is the second generation of the Journalling Flash File System\n+\t  for use on diskless embedded devices. It provides improved wear\n+\t  levelling, compression and support for hard links. You cannot use\n+\t  this on normal block devices, only on \'MTD\' devices.\n+\n+\t  Further information on the design and implementation of JFFS2 is\n+\t  available at <http://sources.redhat.com/jffs2/>.\n+\n+config JFFS2_FS_DEBUG\n+\tint "JFFS2 debugging verbosity (0 = quiet, 2 = noisy)"\n+\tdepends on JFFS2_FS\n+\tdefault "0"\n+\thelp\n+\t  This controls the amount of debugging messages produced by the JFFS2\n+\t  code. Set it to zero for use in production systems. For evaluation,\n+\t  testing and debugging, it\'s advisable to set it to one. This will\n+\t  enable a few assertions and will print debugging messages at the\n+\t  KERN_DEBUG loglevel, where they won\'t normally be visible. Level 2\n+\t  is unlikely to be useful - it enables extra debugging in certain\n+\t  areas which at one point needed debugging, but when the bugs were\n+\t  located and fixed, the detailed messages were relegated to level 2.\n+\n+\t  If reporting bugs, please try to have available a full dump of the\n+\t  messages at debug level 1 while the misbehaviour was occurring.\n+\n+config JFFS2_FS_WRITEBUFFER\n+\tbool "JFFS2 write-buffering support"\n+\tdepends on JFFS2_FS\n+\tdefault y\n+\thelp\n+\t  This enables the write-buffering support in JFFS2.\n+\n+\t  This functionality is required to support JFFS2 on the following\n+\t  types of flash devices:\n+\t    - NAND flash\n+\t    - NOR flash with transparent ECC\n+\t    - DataFlash\n+\n+config JFFS2_SUMMARY\n+\tbool "JFFS2 summary support (EXPERIMENTAL)"\n+\tdepends on JFFS2_FS && EXPERIMENTAL\n+\tdefault n\n+\thelp\n+\t  This feature makes it possible to use summary information\n+\t  for faster filesystem mount.\n+\n+\t  The summary information can be inserted into a filesystem image\n+\t  by the utility \'sumtool\'.\n+\n+\t  If unsure, say \'N\'.\n+\n+config JFFS2_FS_XATTR\n+\tbool "JFFS2 XATTR support (EXPERIMENTAL)"\n+\tdepends on JFFS2_FS && EXPERIMENTAL\n+\tdefault n\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page, or visit\n+\t  <http://acl.bestbits.at/> for details).\n+\n+\t  If unsure, say N.\n+\n+config JFFS2_FS_POSIX_ACL\n+\tbool "JFFS2 POSIX Access Control Lists"\n+\tdepends on JFFS2_FS_XATTR\n+\tdefault y\n+\tselect FS_POSIX_ACL\n+\thelp\n+\t  Posix Access Control Lists (ACLs) support permissions for users and\n+\t  groups beyond the owner/group/world scheme.\n+\n+\t  To learn more about Access Control Lists, visit the Posix ACLs for\n+\t  Linux website <http://acl.bestbits.at/>.\n+\n+\t  If you don\'t know what Access Control Lists are, say N\n+\n+config JFFS2_FS_SECURITY\n+\tbool "JFFS2 Security Labels"\n+\tdepends on JFFS2_FS_XATTR\n+\tdefault y\n+\thelp\n+\t  Security labels support alternative access control models\n+\t  implemented by security modules like SELinux.  This option\n+\t  enables an extended attribute handler for file security\n+\t  labels in the jffs2 filesystem.\n+\n+\t  If you are not using a security module that requires using\n+\t  extended attributes for file security labels, say N.\n+\n+config JFFS2_COMPRESSION_OPTIONS\n+\tbool "Advanced compression options for JFFS2"\n+\tdepends on JFFS2_FS\n+\tdefault n\n+\thelp\n+\t  Enabling this option allows you to explicitly choose which\n+\t  compression modules, if any, are enabled in JFFS2. Removing\n+\t  compressors and mean you cannot read existing file systems,\n+\t  and enabling experimental compressors can mean that you\n+\t  write a file system which cannot be read by a standard kernel.\n+\n+\t  If unsure, you should _definitely_ say \'N\'.\n+\n+config JFFS2_ZLIB\n+\tbool "JFFS2 ZLIB compression support" if JFFS2_COMPRESSION_OPTIONS\n+\tselect ZLIB_INFLATE\n+\tselect ZLIB_DEFLATE\n+\tdepends on JFFS2_FS\n+\tdefault y\n+        help\n+          Zlib is designed to be a free, general-purpose, legally unencumbered,\n+          lossless data-compression library for use on virtually any computer\n+          hardware and operating system. See <http://www.gzip.org/zlib/> for\n+          further information.\n+\n+          Say \'Y\' if unsure.\n+\n+config JFFS2_RTIME\n+\tbool "JFFS2 RTIME compression support" if JFFS2_COMPRESSION_OPTIONS\n+\tdepends on JFFS2_FS\n+\tdefault y\n+        help\n+          Rtime does manage to recompress already-compressed data. Say \'Y\' if unsure.\n+\n+config JFFS2_RUBIN\n+\tbool "JFFS2 RUBIN compression support" if JFFS2_COMPRESSION_OPTIONS\n+\tdepends on JFFS2_FS\n+\tdefault n\n+        help\n+          RUBINMIPS and DYNRUBIN compressors. Say \'N\' if unsure.\n+\n+choice\n+        prompt "JFFS2 default compression mode" if JFFS2_COMPRESSION_OPTIONS\n+        default JFFS2_CMODE_PRIORITY\n+        depends on JFFS2_FS\n+        help\n+          You can set here the default compression mode of JFFS2 from\n+          the available compression modes. Don\'t touch if unsure.\n+\n+config JFFS2_CMODE_NONE\n+        bool "no compression"\n+        help\n+          Uses no compression.\n+\n+config JFFS2_CMODE_PRIORITY\n+        bool "priority"\n+        help\n+          Tries the compressors in a predefined order and chooses the first\n+          successful one.\n+\n+config JFFS2_CMODE_SIZE\n+        bool "size (EXPERIMENTAL)"\n+        help\n+          Tries all compressors and chooses the one which has the smallest\n+          result.\n+\n+endchoice\n+\n+config CRAMFS\n+\ttristate "Compressed ROM file system support (cramfs)"\n+\tdepends on BLOCK\n+\tselect ZLIB_INFLATE\n+\thelp\n+\t  Saying Y here includes support for CramFs (Compressed ROM File\n+\t  System).  CramFs is designed to be a simple, small, and compressed\n+\t  file system for ROM based embedded systems.  CramFs is read-only,\n+\t  limited to 256MB file systems (with 16MB files), and doesn\'t support\n+\t  16/32 bits uid/gid, hard links and timestamps.\n+\n+\t  See <file:Documentation/filesystems/cramfs.txt> and\n+\t  <file:fs/cramfs/README> for further information.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  cramfs.  Note that the root file system (the one containing the\n+\t  directory /) cannot be compiled as a module.\n+\n+\t  If unsure, say N.\n+\n+config SQUASHFS\n+\ttristate "SquashFS 3.3 - Squashed file system support"\n+\tselect ZLIB_INFLATE\n+\thelp\n+\t  Saying Y here includes support for SquashFS 3.3 (a Compressed\n+\t  Read-Only File System).  Squashfs is a highly compressed read-only\n+\t  filesystem for Linux.  It uses zlib compression to compress both\n+\t  files, inodes and directories.  Inodes in the system are very small\n+\t  and all blocks are packed to minimise data overhead. Block sizes\n+\t  greater than 4K are supported up to a maximum of 1 Mbytes (default\n+\t  block size 128K).  SquashFS 3.3 supports 64 bit filesystems and files\n+\t  (larger than 4GB), full uid/gid information, hard links and timestamps.\n+\n+\t  Squashfs is intended for general read-only filesystem use, for\n+\t  archival use (i.e. in cases where a .tar.gz file may be used), and in\n+\t  embedded systems where low overhead is needed.  Further information\n+\t  and filesystem tools are available from http://squashfs.sourceforge.net.\n+\n+\t  If you want to compile this as a module ( = code which can be\n+\t  inserted in and removed from the running kernel whenever you want),\n+\t  say M here and read <file:Documentation/modules.txt>.  The module\n+\t  will be called squashfs.  Note that the root file system (the one\n+\t  containing the directory /) cannot be compiled as a module.\n+\n+\t  If unsure, say N.\n+\n+config SQUASHFS_EMBEDDED\n+\n+\tbool "Additional option for memory-constrained systems"\n+\tdepends on SQUASHFS\n+\tdefault n\n+\thelp\n+\t  Saying Y here allows you to specify cache size.\n+\n+\t  If unsure, say N.\n+\n+config SQUASHFS_FRAGMENT_CACHE_SIZE\n+\tint "Number of fragments cached" if SQUASHFS_EMBEDDED\n+\tdepends on SQUASHFS\n+\tdefault "3"\n+\thelp\n+\t  By default SquashFS caches the last 3 fragments read from\n+\t  the filesystem.  Increasing this amount may mean SquashFS\n+\t  has to re-read fragments less often from disk, at the expense\n+\t  of extra system memory.  Decreasing this amount will mean\n+\t  SquashFS uses less memory at the expense of extra reads from disk.\n+\n+\t  Note there must be at least one cached fragment.  Anything\n+\t  much more than three will probably not make much difference.\n+\n+config VXFS_FS\n+\ttristate "FreeVxFS file system support (VERITAS VxFS(TM) compatible)"\n+\tdepends on BLOCK\n+\thelp\n+\t  FreeVxFS is a file system driver that support the VERITAS VxFS(TM)\n+\t  file system format.  VERITAS VxFS(TM) is the standard file system\n+\t  of SCO UnixWare (and possibly others) and optionally available\n+\t  for Sunsoft Solaris, HP-UX and many other operating systems.\n+\t  Currently only readonly access is supported.\n+\n+\t  NOTE: the file system type as used by mount(1), mount(2) and\n+\t  fstab(5) is \'vxfs\' as it describes the file system format, not\n+\t  the actual driver.\n+\n+\t  To compile this as a module, choose M here: the module will be\n+\t  called freevxfs.  If unsure, say N.\n+\n+\n+config HPFS_FS\n+\ttristate "OS/2 HPFS file system support"\n+\tdepends on BLOCK\n+\thelp\n+\t  OS/2 is IBM\'s operating system for PC\'s, the same as Warp, and HPFS\n+\t  is the file system used for organizing files on OS/2 hard disk\n+\t  partitions. Say Y if you want to be able to read files from and\n+\t  write files to an OS/2 HPFS partition on your hard drive. OS/2\n+\t  floppies however are in regular MSDOS format, so you don\'t need this\n+\t  option in order to be able to read them. Read\n+\t  <file:Documentation/filesystems/hpfs.txt>.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called hpfs.  If unsure, say N.\n+\n+\n+\n+config QNX4FS_FS\n+\ttristate "QNX4 file system support (read only)"\n+\tdepends on BLOCK\n+\thelp\n+\t  This is the file system used by the real-time operating systems\n+\t  QNX 4 and QNX 6 (the latter is also called QNX RTP).\n+\t  Further information is available at <http://www.qnx.com/>.\n+\t  Say Y if you intend to mount QNX hard disks or floppies.\n+\t  Unless you say Y to "QNX4FS read-write support" below, you will\n+\t  only be able to read these file systems.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called qnx4.\n+\n+\t  If you don\'t know whether you need it, then you don\'t need it:\n+\t  answer N.\n+\n+config QNX4FS_RW\n+\tbool "QNX4FS write support (DANGEROUS)"\n+\tdepends on QNX4FS_FS && EXPERIMENTAL && BROKEN\n+\thelp\n+\t  Say Y if you want to test write support for QNX4 file systems.\n+\n+\t  It\'s currently broken, so for now:\n+\t  answer N.\n+\n+\n+\n+config SYSV_FS\n+\ttristate "System V/Xenix/V7/Coherent file system support"\n+\tdepends on BLOCK\n+\thelp\n+\t  SCO, Xenix and Coherent are commercial Unix systems for Intel\n+\t  machines, and Version 7 was used on the DEC PDP-11. Saying Y\n+\t  here would allow you to read from their floppies and hard disk\n+\t  partitions.\n+\n+\t  If you have floppies or hard disk partitions like that, it is likely\n+\t  that they contain binaries from those other Unix systems; in order\n+\t  to run these binaries, you will want to install linux-abi which is\n+\t  a set of kernel modules that lets you run SCO, Xenix, Wyse,\n+\t  UnixWare, Dell Unix and System V programs under Linux.  It is\n+\t  available via FTP (user: ftp) from\n+\t  <ftp://ftp.openlinux.org/pub/people/hch/linux-abi/>).\n+\t  NOTE: that will work only for binaries from Intel-based systems;\n+\t  PDP ones will have to wait until somebody ports Linux to -11 ;-)\n+\n+\t  If you only intend to mount files from some other Unix over the\n+\t  network using NFS, you don\'t need the System V file system support\n+\t  (but you need NFS file system support obviously).\n+\n+\t  Note that this option is generally not needed for floppies, since a\n+\t  good portable way to transport files and directories between unixes\n+\t  (and even other operating systems) is given by the tar program ("man\n+\t  tar" or preferably "info tar").  Note also that this option has\n+\t  nothing whatsoever to do with the option "System V IPC". Read about\n+\t  the System V file system in\n+\t  <file:Documentation/filesystems/sysv-fs.txt>.\n+\t  Saying Y here will enlarge your kernel by about 27 KB.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  sysv.\n+\n+\t  If you haven\'t heard about all of this before, it\'s safe to say N.\n+\n+\n+\n+config UFS_FS\n+\ttristate "UFS file system support (read only)"\n+\tdepends on BLOCK\n+\thelp\n+\t  BSD and derivate versions of Unix (such as SunOS, FreeBSD, NetBSD,\n+\t  OpenBSD and NeXTstep) use a file system called UFS. Some System V\n+\t  Unixes can create and mount hard disk partitions and diskettes using\n+\t  this file system as well. Saying Y here will allow you to read from\n+\t  these partitions; if you also want to write to them, say Y to the\n+\t  experimental "UFS file system write support", below. Please read the\n+\t  file <file:Documentation/filesystems/ufs.txt> for more information.\n+\n+          The recently released UFS2 variant (used in FreeBSD 5.x) is\n+          READ-ONLY supported.\n+\n+\t  If you only intend to mount files from some other Unix over the\n+\t  network using NFS, you don\'t need the UFS file system support (but\n+\t  you need NFS file system support obviously).\n+\n+\t  Note that this option is generally not needed for floppies, since a\n+\t  good portable way to transport files and directories between unixes\n+\t  (and even other operating systems) is given by the tar program ("man\n+\t  tar" or preferably "info tar").\n+\n+\t  When accessing NeXTstep files, you may need to convert them from the\n+\t  NeXT character set to the Latin1 character set; use the program\n+\t  recode ("info recode") for this purpose.\n+\n+\t  To compile the UFS file system support as a module, choose M here: the\n+\t  module will be called ufs.\n+\n+\t  If you haven\'t heard about all of this before, it\'s safe to say N.\n+\n+config UFS_FS_WRITE\n+\tbool "UFS file system write support (DANGEROUS)"\n+\tdepends on UFS_FS && EXPERIMENTAL\n+\thelp\n+\t  Say Y here if you want to try writing to UFS partitions. This is\n+\t  experimental, so you should back up your UFS partitions beforehand.\n+\n+config UFS_DEBUG\n+\tbool "UFS debugging"\n+\tdepends on UFS_FS\n+\thelp\n+\t  If you are experiencing any problems with the UFS filesystem, say\n+\t  Y here.  This will result in _many_ additional debugging messages to be\n+\t  written to the system log.\n+\n+endmenu\n+\n+menu "Network File Systems"\n+\tdepends on NET\n+\n+config NFS_FS\n+\ttristate "NFS file system support"\n+\tdepends on INET\n+\tselect LOCKD\n+\tselect SUNRPC\n+\tselect NFS_ACL_SUPPORT if NFS_V3_ACL\n+\thelp\n+\t  If you are connected to some other (usually local) Unix computer\n+\t  (using SLIP, PLIP, PPP or Ethernet) and want to mount files residing\n+\t  on that computer (the NFS server) using the Network File Sharing\n+\t  protocol, say Y. "Mounting files" means that the client can access\n+\t  the files with usual UNIX commands as if they were sitting on the\n+\t  client\'s hard disk. For this to work, the server must run the\n+\t  programs nfsd and mountd (but does not need to have NFS file system\n+\t  support enabled in its kernel). NFS is explained in the Network\n+\t  Administrator\'s Guide, available from\n+\t  <http://www.tldp.org/docs.html#guide>, on its man page: "man\n+\t  nfs", and in the NFS-HOWTO.\n+\n+\t  A superior but less widely used alternative to NFS is provided by\n+\t  the Coda file system; see "Coda file system support" below.\n+\n+\t  If you say Y here, you should have said Y to TCP/IP networking also.\n+\t  This option would enlarge your kernel by about 27 KB.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called nfs.\n+\n+\t  If you are configuring a diskless machine which will mount its root\n+\t  file system over NFS at boot time, say Y here and to "Kernel\n+\t  level IP autoconfiguration" above and to "Root file system on NFS"\n+\t  below. You cannot compile this driver as a module in this case.\n+\t  There are two packages designed for booting diskless machines over\n+\t  the net: netboot, available from\n+\t  <http://ftp1.sourceforge.net/netboot/>, and Etherboot,\n+\t  available from <http://ftp1.sourceforge.net/etherboot/>.\n+\n+\t  If you don\'t know what all this is about, say N.\n+\n+config NFS_V3\n+\tbool "Provide NFSv3 client support"\n+\tdepends on NFS_FS\n+\thelp\n+\t  Say Y here if you want your NFS client to be able to speak version\n+\t  3 of the NFS protocol.\n+\n+\t  If unsure, say Y.\n+\n+config NFS_V3_ACL\n+\tbool "Provide client support for the NFSv3 ACL protocol extension"\n+\tdepends on NFS_V3\n+\thelp\n+\t  Implement the NFSv3 ACL protocol extension for manipulating POSIX\n+\t  Access Control Lists.  The server should also be compiled with\n+\t  the NFSv3 ACL protocol extension; see the CONFIG_NFSD_V3_ACL option.\n+\n+\t  If unsure, say N.\n+\n+config NFS_V4\n+\tbool "Provide NFSv4 client support (EXPERIMENTAL)"\n+\tdepends on NFS_FS && EXPERIMENTAL\n+\tselect RPCSEC_GSS_KRB5\n+\thelp\n+\t  Say Y here if you want your NFS client to be able to speak the newer\n+\t  version 4 of the NFS protocol.\n+\n+\t  Note: Requires auxiliary userspace daemons which may be found on\n+\t\thttp://www.citi.umich.edu/projects/nfsv4/\n+\n+\t  If unsure, say N.\n+\n+config NFS_DIRECTIO\n+\tbool "Allow direct I/O on NFS files"\n+\tdepends on NFS_FS\n+\thelp\n+\t  This option enables applications to perform uncached I/O on files\n+\t  in NFS file systems using the O_DIRECT open() flag.  When O_DIRECT\n+\t  is set for a file, its data is not cached in the system\'s page\n+\t  cache.  Data is moved to and from user-level application buffers\n+\t  directly.  Unlike local disk-based file systems, NFS O_DIRECT has\n+\t  no alignment restrictions.\n+\n+\t  Unless your program is designed to use O_DIRECT properly, you are\n+\t  much better off allowing the NFS client to manage data caching for\n+\t  you.  Misusing O_DIRECT can cause poor server performance or network\n+\t  storms.  This kernel build option defaults OFF to avoid exposing\n+\t  system administrators unwittingly to a potentially hazardous\n+\t  feature.\n+\n+\t  For more details on NFS O_DIRECT, see fs/nfs/direct.c.\n+\n+\t  If unsure, say N.  This reduces the size of the NFS client, and\n+\t  causes open() to return EINVAL if a file residing in NFS is\n+\t  opened with the O_DIRECT flag.\n+\n+config NFSD\n+\ttristate "NFS server support"\n+\tdepends on INET\n+\tselect LOCKD\n+\tselect SUNRPC\n+\tselect EXPORTFS\n+\tselect NFSD_V2_ACL if NFSD_V3_ACL\n+\tselect NFS_ACL_SUPPORT if NFSD_V2_ACL\n+\tselect NFSD_TCP if NFSD_V4\n+\tselect CRYPTO_MD5 if NFSD_V4\n+\tselect CRYPTO if NFSD_V4\n+\tselect FS_POSIX_ACL if NFSD_V4\n+\thelp\n+\t  If you want your Linux box to act as an NFS *server*, so that other\n+\t  computers on your local network which support NFS can access certain\n+\t  directories on your box transparently, you have two options: you can\n+\t  use the self-contained user space program nfsd, in which case you\n+\t  should say N here, or you can say Y and use the kernel based NFS\n+\t  server. The advantage of the kernel based solution is that it is\n+\t  faster.\n+\n+\t  In either case, you will need support software; the respective\n+\t  locations are given in the file <file:Documentation/Changes> in the\n+\t  NFS section.\n+\n+\t  If you say Y here, you will get support for version 2 of the NFS\n+\t  protocol (NFSv2). If you also want NFSv3, say Y to the next question\n+\t  as well.\n+\n+\t  Please read the NFS-HOWTO, available from\n+\t  <http://www.tldp.org/docs.html#howto>.\n+\n+\t  To compile the NFS server support as a module, choose M here: the\n+\t  module will be called nfsd.  If unsure, say N.\n+\n+config NFSD_V2_ACL\n+\tbool\n+\tdepends on NFSD\n+\n+config NFSD_V3\n+\tbool "Provide NFSv3 server support"\n+\tdepends on NFSD\n+\thelp\n+\t  If you would like to include the NFSv3 server as well as the NFSv2\n+\t  server, say Y here.  If unsure, say Y.\n+\n+config NFSD_V3_ACL\n+\tbool "Provide server support for the NFSv3 ACL protocol extension"\n+\tdepends on NFSD_V3\n+\thelp\n+\t  Implement the NFSv3 ACL protocol extension for manipulating POSIX\n+\t  Access Control Lists on exported file systems. NFS clients should\n+\t  be compiled with the NFSv3 ACL protocol extension; see the\n+\t  CONFIG_NFS_V3_ACL option.  If unsure, say N.\n+\n+config NFSD_V4\n+\tbool "Provide NFSv4 server support (EXPERIMENTAL)"\n+\tdepends on NFSD && NFSD_V3 && EXPERIMENTAL\n+\tselect RPCSEC_GSS_KRB5\n+\thelp\n+\t  If you would like to include the NFSv4 server as well as the NFSv2\n+\t  and NFSv3 servers, say Y here.  This feature is experimental, and\n+\t  should only be used if you are interested in helping to test NFSv4.\n+\t  If unsure, say N.\n+\n+config NFSD_TCP\n+\tbool "Provide NFS server over TCP support"\n+\tdepends on NFSD\n+\tdefault y\n+\thelp\n+\t  If you want your NFS server to support TCP connections, say Y here.\n+\t  TCP connections usually perform better than the default UDP when\n+\t  the network is lossy or congested.  If unsure, say Y.\n+\n+config ROOT_NFS\n+\tbool "Root file system on NFS"\n+\tdepends on NFS_FS=y && IP_PNP\n+\thelp\n+\t  If you want your Linux box to mount its whole root file system (the\n+\t  one containing the directory /) from some other computer over the\n+\t  net via NFS (presumably because your box doesn\'t have a hard disk),\n+\t  say Y. Read <file:Documentation/nfsroot.txt> for details. It is\n+\t  likely that in this case, you also want to say Y to "Kernel level IP\n+\t  autoconfiguration" so that your box can discover its network address\n+\t  at boot time.\n+\n+\t  Most people say N here.\n+\n+config LOCKD\n+\ttristate\n+\n+config LOCKD_V4\n+\tbool\n+\tdepends on NFSD_V3 || NFS_V3\n+\tdefault y\n+\n+config EXPORTFS\n+\ttristate\n+\n+config NFS_ACL_SUPPORT\n+\ttristate\n+\tselect FS_POSIX_ACL\n+\n+config NFS_COMMON\n+\tbool\n+\tdepends on NFSD || NFS_FS\n+\tdefault y\n+\n+config SUNRPC\n+\ttristate\n+\n+config SUNRPC_GSS\n+\ttristate\n+\n+config SUNRPC_BIND34\n+\tbool "Support for rpcbind versions 3 & 4 (EXPERIMENTAL)"\n+\tdepends on SUNRPC && EXPERIMENTAL\n+\thelp\n+\t  Provides kernel support for querying rpcbind servers via versions 3\n+\t  and 4 of the rpcbind protocol.  The kernel automatically falls back\n+\t  to version 2 if a remote rpcbind service does not support versions\n+\t  3 or 4.\n+\n+\t  If unsure, say N to get traditional behavior (version 2 rpcbind\n+\t  requests only).\n+\n+config RPCSEC_GSS_KRB5\n+\ttristate "Secure RPC: Kerberos V mechanism (EXPERIMENTAL)"\n+\tdepends on SUNRPC && EXPERIMENTAL\n+\tselect SUNRPC_GSS\n+\tselect CRYPTO\n+\tselect CRYPTO_MD5\n+\tselect CRYPTO_DES\n+\tselect CRYPTO_CBC\n+\thelp\n+\t  Provides for secure RPC calls by means of a gss-api\n+\t  mechanism based on Kerberos V5. This is required for\n+\t  NFSv4.\n+\n+\t  Note: Requires an auxiliary userspace daemon which may be found on\n+\t\thttp://www.citi.umich.edu/projects/nfsv4/\n+\n+\t  If unsure, say N.\n+\n+config RPCSEC_GSS_SPKM3\n+\ttristate "Secure RPC: SPKM3 mechanism (EXPERIMENTAL)"\n+\tdepends on SUNRPC && EXPERIMENTAL\n+\tselect SUNRPC_GSS\n+\tselect CRYPTO\n+\tselect CRYPTO_MD5\n+\tselect CRYPTO_DES\n+\tselect CRYPTO_CAST5\n+\tselect CRYPTO_CBC\n+\thelp\n+\t  Provides for secure RPC calls by means of a gss-api\n+\t  mechanism based on the SPKM3 public-key mechanism.\n+\n+\t  Note: Requires an auxiliary userspace daemon which may be found on\n+\t  \thttp://www.citi.umich.edu/projects/nfsv4/\n+\n+\t  If unsure, say N.\n+\n+config SMB_FS\n+\ttristate "SMB file system support (to mount Windows shares etc.)"\n+\tdepends on INET\n+\tselect NLS\n+\thelp\n+\t  SMB (Server Message Block) is the protocol Windows for Workgroups\n+\t  (WfW), Windows 95/98, Windows NT and OS/2 Lan Manager use to share\n+\t  files and printers over local networks.  Saying Y here allows you to\n+\t  mount their file systems (often called "shares" in this context) and\n+\t  access them just like any other Unix directory.  Currently, this\n+\t  works only if the Windows machines use TCP/IP as the underlying\n+\t  transport protocol, and not NetBEUI.  For details, read\n+\t  <file:Documentation/filesystems/smbfs.txt> and the SMB-HOWTO,\n+\t  available from <http://www.tldp.org/docs.html#howto>.\n+\n+\t  Note: if you just want your box to act as an SMB *server* and make\n+\t  files and printing services available to Windows clients (which need\n+\t  to have a TCP/IP stack), you don\'t need to say Y here; you can use\n+\t  the program SAMBA (available from <ftp://ftp.samba.org/pub/samba/>)\n+\t  for that.\n+\n+\t  General information about how to connect Linux, Windows machines and\n+\t  Macs is on the WWW at <http://www.eats.com/linux_mac_win.html>.\n+\n+\t  To compile the SMB support as a module, choose M here: the module will\n+\t  be called smbfs.  Most people say N, however.\n+\n+config SMB_NLS_DEFAULT\n+\tbool "Use a default NLS"\n+\tdepends on SMB_FS\n+\thelp\n+\t  Enabling this will make smbfs use nls translations by default. You\n+\t  need to specify the local charset (CONFIG_NLS_DEFAULT) in the nls\n+\t  settings and you need to give the default nls for the SMB server as\n+\t  CONFIG_SMB_NLS_REMOTE.\n+\n+\t  The nls settings can be changed at mount time, if your smbmount\n+\t  supports that, using the codepage and iocharset parameters.\n+\n+\t  smbmount from samba 2.2.0 or later supports this.\n+\n+config SMB_NLS_REMOTE\n+\tstring "Default Remote NLS Option"\n+\tdepends on SMB_NLS_DEFAULT\n+\tdefault "cp437"\n+\thelp\n+\t  This setting allows you to specify a default value for which\n+\t  codepage the server uses. If this field is left blank no\n+\t  translations will be done by default. The local codepage/charset\n+\t  default to CONFIG_NLS_DEFAULT.\n+\n+\t  The nls settings can be changed at mount time, if your smbmount\n+\t  supports that, using the codepage and iocharset parameters.\n+\n+\t  smbmount from samba 2.2.0 or later supports this.\n+\n+config CIFS\n+\ttristate "CIFS support (advanced network filesystem for Samba, Window and other CIFS compliant servers)"\n+\tdepends on INET\n+\tselect NLS\n+\thelp\n+\t  This is the client VFS module for the Common Internet File System\n+\t  (CIFS) protocol which is the successor to the Server Message Block\n+\t  (SMB) protocol, the native file sharing mechanism for most early\n+\t  PC operating systems.  The CIFS protocol is fully supported by\n+\t  file servers such as Windows 2000 (including Windows 2003, NT 4\n+\t  and Windows XP) as well by Samba (which provides excellent CIFS\n+\t  server support for Linux and many other operating systems). Limited\n+\t  support for OS/2 and Windows ME and similar servers is provided as well.\n+\n+\t  The intent of the cifs module is to provide an advanced\n+\t  network file system client for mounting to CIFS compliant servers,\n+\t  including support for dfs (hierarchical name space), secure per-user\n+\t  session establishment, safe distributed caching (oplock), optional\n+\t  packet signing, Unicode and other internationalization improvements.\n+\t  If you need to mount to Samba or Windows from this machine, say Y.\n+\n+config CIFS_STATS\n+        bool "CIFS statistics"\n+        depends on CIFS\n+        help\n+          Enabling this option will cause statistics for each server share\n+\t  mounted by the cifs client to be displayed in /proc/fs/cifs/Stats\n+\n+config CIFS_STATS2\n+\tbool "Extended statistics"\n+\tdepends on CIFS_STATS\n+\thelp\n+\t  Enabling this option will allow more detailed statistics on SMB\n+\t  request timing to be displayed in /proc/fs/cifs/DebugData and also\n+\t  allow optional logging of slow responses to dmesg (depending on the\n+\t  value of /proc/fs/cifs/cifsFYI, see fs/cifs/README for more details).\n+\t  These additional statistics may have a minor effect on performance\n+\t  and memory utilization.\n+\n+\t  Unless you are a developer or are doing network performance analysis\n+\t  or tuning, say N.\n+\n+config CIFS_WEAK_PW_HASH\n+\tbool "Support legacy servers which use weaker LANMAN security"\n+\tdepends on CIFS\n+\thelp\n+\t  Modern CIFS servers including Samba and most Windows versions\n+\t  (since 1997) support stronger NTLM (and even NTLMv2 and Kerberos)\n+\t  security mechanisms. These hash the password more securely\n+\t  than the mechanisms used in the older LANMAN version of the\n+          SMB protocol needed to establish sessions with old SMB servers.\n+\n+\t  Enabling this option allows the cifs module to mount to older\n+\t  LANMAN based servers such as OS/2 and Windows 95, but such\n+\t  mounts may be less secure than mounts using NTLM or more recent\n+\t  security mechanisms if you are on a public network.  Unless you\n+\t  have a need to access old SMB servers (and are on a private\n+\t  network) you probably want to say N.  Even if this support\n+\t  is enabled in the kernel build, they will not be used\n+\t  automatically. At runtime LANMAN mounts are disabled but\n+\t  can be set to required (or optional) either in\n+\t  /proc/fs/cifs (see fs/cifs/README for more detail) or via an\n+\t  option on the mount command. This support is disabled by\n+\t  default in order to reduce the possibility of a downgrade\n+\t  attack.\n+\n+\t  If unsure, say N.\n+\n+config CIFS_XATTR\n+        bool "CIFS extended attributes"\n+        depends on CIFS\n+        help\n+          Extended attributes are name:value pairs associated with inodes by\n+          the kernel or by users (see the attr(5) manual page, or visit\n+          <http://acl.bestbits.at/> for details).  CIFS maps the name of\n+          extended attributes beginning with the user namespace prefix\n+          to SMB/CIFS EAs. EAs are stored on Windows servers without the\n+          user namespace prefix, but their names are seen by Linux cifs clients\n+          prefaced by the user namespace prefix. The system namespace\n+          (used by some filesystems to store ACLs) is not supported at\n+          this time.\n+\n+          If unsure, say N.\n+\n+config CIFS_POSIX\n+        bool "CIFS POSIX Extensions"\n+        depends on CIFS_XATTR\n+        help\n+          Enabling this option will cause the cifs client to attempt to\n+\t  negotiate a newer dialect with servers, such as Samba 3.0.5\n+\t  or later, that optionally can handle more POSIX like (rather\n+\t  than Windows like) file behavior.  It also enables\n+\t  support for POSIX ACLs (getfacl and setfacl) to servers\n+\t  (such as Samba 3.10 and later) which can negotiate\n+\t  CIFS POSIX ACL support.  If unsure, say N.\n+\n+config CIFS_DEBUG2\n+\tbool "Enable additional CIFS debugging routines"\n+\tdepends on CIFS\n+\thelp\n+\t   Enabling this option adds a few more debugging routines\n+\t   to the cifs code which slightly increases the size of\n+\t   the cifs module and can cause additional logging of debug\n+\t   messages in some error paths, slowing performance. This\n+\t   option can be turned off unless you are debugging\n+\t   cifs problems.  If unsure, say N.\n+\n+config CIFS_EXPERIMENTAL\n+\t  bool "CIFS Experimental Features (EXPERIMENTAL)"\n+\t  depends on CIFS && EXPERIMENTAL\n+\t  help\n+\t    Enables cifs features under testing. These features are\n+\t    experimental and currently include DFS support and directory\n+\t    change notification ie fcntl(F_DNOTIFY), as well as the upcall\n+\t    mechanism which will be used for Kerberos session negotiation\n+\t    and uid remapping.  Some of these features also may depend on\n+\t    setting a value of 1 to the pseudo-file /proc/fs/cifs/Experimental\n+\t    (which is disabled by default). See the file fs/cifs/README\n+\t    for more details.  If unsure, say N.\n+\n+config CIFS_UPCALL\n+\t  bool "Kerberos/SPNEGO advanced session setup (EXPERIMENTAL)"\n+\t  depends on CIFS_EXPERIMENTAL\n+\t  depends on CONNECTOR\n+\t  help\n+\t    Enables an upcall mechanism for CIFS which will be used to contact\n+\t    userspace helper utilities to provide SPNEGO packaged Kerberos\n+\t    tickets which are needed to mount to certain secure servers\n+\t    (for which more secure Kerberos authentication is required). If\n+\t    unsure, say N.\n+\n+config NCP_FS\n+\ttristate "NCP file system support (to mount NetWare volumes)"\n+\tdepends on IPX!=n || INET\n+\thelp\n+\t  NCP (NetWare Core Protocol) is a protocol that runs over IPX and is\n+\t  used by Novell NetWare clients to talk to file servers.  It is to\n+\t  IPX what NFS is to TCP/IP, if that helps.  Saying Y here allows you\n+\t  to mount NetWare file server volumes and to access them just like\n+\t  any other Unix directory.  For details, please read the file\n+\t  <file:Documentation/filesystems/ncpfs.txt> in the kernel source and\n+\t  the IPX-HOWTO from <http://www.tldp.org/docs.html#howto>.\n+\n+\t  You do not have to say Y here if you want your Linux box to act as a\n+\t  file *server* for Novell NetWare clients.\n+\n+\t  General information about how to connect Linux, Windows machines and\n+\t  Macs is on the WWW at <http://www.eats.com/linux_mac_win.html>.\n+\n+\t  To compile this as a module, choose M here: the module will be called\n+\t  ncpfs.  Say N unless you are connected to a Novell network.\n+\n+source "fs/ncpfs/Kconfig"\n+\n+config CODA_FS\n+\ttristate "Coda file system support (advanced network fs)"\n+\tdepends on INET\n+\thelp\n+\t  Coda is an advanced network file system, similar to NFS in that it\n+\t  enables you to mount file systems of a remote server and access them\n+\t  with regular Unix commands as if they were sitting on your hard\n+\t  disk.  Coda has several advantages over NFS: support for\n+\t  disconnected operation (e.g. for laptops), read/write server\n+\t  replication, security model for authentication and encryption,\n+\t  persistent client caches and write back caching.\n+\n+\t  If you say Y here, your Linux box will be able to act as a Coda\n+\t  *client*.  You will need user level code as well, both for the\n+\t  client and server.  Servers are currently user level, i.e. they need\n+\t  no kernel support.  Please read\n+\t  <file:Documentation/filesystems/coda.txt> and check out the Coda\n+\t  home page <http://www.coda.cs.cmu.edu/>.\n+\n+\t  To compile the coda client support as a module, choose M here: the\n+\t  module will be called coda.\n+\n+config CODA_FS_OLD_API\n+\tbool "Use 96-bit Coda file identifiers"\n+\tdepends on CODA_FS\n+\thelp\n+\t  A new kernel-userspace API had to be introduced for Coda v6.0\n+\t  to support larger 128-bit file identifiers as needed by the\n+\t  new realms implementation.\n+\n+\t  However this new API is not backward compatible with older\n+\t  clients. If you really need to run the old Coda userspace\n+\t  cache manager then say Y.\n+\n+\t  For most cases you probably want to say N.\n+\n+config AFS_FS\n+\ttristate "Andrew File System support (AFS) (EXPERIMENTAL)"\n+\tdepends on INET && EXPERIMENTAL\n+\tselect AF_RXRPC\n+\thelp\n+\t  If you say Y here, you will get an experimental Andrew File System\n+\t  driver. It currently only supports unsecured read-only AFS access.\n+\n+\t  See <file:Documentation/filesystems/afs.txt> for more information.\n+\n+\t  If unsure, say N.\n+\n+config AFS_DEBUG\n+\tbool "AFS dynamic debugging"\n+\tdepends on AFS_FS\n+\thelp\n+\t  Say Y here to make runtime controllable debugging messages appear.\n+\n+\t  See <file:Documentation/filesystems/afs.txt> for more information.\n+\n+\t  If unsure, say N.\n+\n+config 9P_FS\n+\ttristate "Plan 9 Resource Sharing Support (9P2000) (Experimental)"\n+\tdepends on INET && NET_9P && EXPERIMENTAL\n+\thelp\n+\t  If you say Y here, you will get experimental support for\n+\t  Plan 9 resource sharing via the 9P2000 protocol.\n+\n+\t  See <http://v9fs.sf.net> for more information.\n+\n+\t  If unsure, say N.\n+\n+endmenu\n+\n+if BLOCK\n+menu "Partition Types"\n+\n+source "fs/partitions/Kconfig"\n+\n+endmenu\n+endif\n+\n+source "fs/nls/Kconfig"\n+source "fs/dlm/Kconfig"\n+\n+endmenu\n+'),
 ('linux-2.6.23/fs/Makefile',
  'linux-2.6.23-yaffs2/fs/Makefile',
  'diff -Naur linux-2.6.23/fs/Makefile linux-2.6.23-yaffs2/fs/Makefile\n--- linux-2.6.23/fs/Makefile\n+++ linux-2.6.23-yaffs2/fs/Makefile\n@@ -119,3 +119,6 @@\nobj-$(CONFIG_DEBUG_FS)\t\t+= debugfs/\nobj-$(CONFIG_OCFS2_FS)\t\t+= ocfs2/\nobj-$(CONFIG_GFS2_FS)           += gfs2/\n+\n+# Patched by YAFFS\n+obj-$(CONFIG_YAFFS_FS)\t\t+= yaffs2/'),
 ('linux-2.6.23/fs/Makefile.pre.yaffs',
  'linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs',
  'diff -Naur linux-2.6.23/fs/Makefile.pre.yaffs linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs\n--- linux-2.6.23/fs/Makefile.pre.yaffs\n+++ linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs\n@@ -0,0 +1,121 @@\n+#\n+# Makefile for the Linux filesystems.\n+#\n+# 14 Sep 2000, Christoph Hellwig <hch@infradead.org>\n+# Rewritten to use lists instead of if-statements.\n+#\n+\n+obj-y :=\topen.o read_write.o file_table.o super.o \\\n+\t\tchar_dev.o stat.o exec.o pipe.o namei.o fcntl.o \\\n+\t\tioctl.o readdir.o select.o fifo.o locks.o dcache.o inode.o \\\n+\t\tattr.o bad_inode.o file.o filesystems.o namespace.o aio.o \\\n+\t\tseq_file.o xattr.o libfs.o fs-writeback.o \\\n+\t\tpnode.o drop_caches.o splice.o sync.o utimes.o \\\n+\t\tstack.o\n+\n+ifeq ($(CONFIG_BLOCK),y)\n+obj-y +=\tbuffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o\n+else\n+obj-y +=\tno-block.o\n+endif\n+\n+obj-$(CONFIG_INOTIFY)\t\t+= inotify.o\n+obj-$(CONFIG_INOTIFY_USER)\t+= inotify_user.o\n+obj-$(CONFIG_EPOLL)\t\t+= eventpoll.o\n+obj-$(CONFIG_ANON_INODES)\t+= anon_inodes.o\n+obj-$(CONFIG_SIGNALFD)\t\t+= signalfd.o\n+obj-$(CONFIG_TIMERFD)\t\t+= timerfd.o\n+obj-$(CONFIG_EVENTFD)\t\t+= eventfd.o\n+obj-$(CONFIG_COMPAT)\t\t+= compat.o compat_ioctl.o\n+\n+nfsd-$(CONFIG_NFSD)\t\t:= nfsctl.o\n+obj-y\t\t\t\t+= $(nfsd-y) $(nfsd-m)\n+\n+obj-$(CONFIG_BINFMT_AOUT)\t+= binfmt_aout.o\n+obj-$(CONFIG_BINFMT_EM86)\t+= binfmt_em86.o\n+obj-$(CONFIG_BINFMT_MISC)\t+= binfmt_misc.o\n+\n+# binfmt_script is always there\n+obj-y\t\t\t\t+= binfmt_script.o\n+\n+obj-$(CONFIG_BINFMT_ELF)\t+= binfmt_elf.o\n+obj-$(CONFIG_BINFMT_ELF_FDPIC)\t+= binfmt_elf_fdpic.o\n+obj-$(CONFIG_BINFMT_SOM)\t+= binfmt_som.o\n+obj-$(CONFIG_BINFMT_FLAT)\t+= binfmt_flat.o\n+\n+obj-$(CONFIG_FS_MBCACHE)\t+= mbcache.o\n+obj-$(CONFIG_FS_POSIX_ACL)\t+= posix_acl.o xattr_acl.o\n+obj-$(CONFIG_NFS_COMMON)\t+= nfs_common/\n+obj-$(CONFIG_GENERIC_ACL)\t+= generic_acl.o\n+\n+obj-$(CONFIG_QUOTA)\t\t+= dquot.o\n+obj-$(CONFIG_QFMT_V1)\t\t+= quota_v1.o\n+obj-$(CONFIG_QFMT_V2)\t\t+= quota_v2.o\n+obj-$(CONFIG_QUOTACTL)\t\t+= quota.o\n+\n+obj-$(CONFIG_DNOTIFY)\t\t+= dnotify.o\n+\n+obj-$(CONFIG_PROC_FS)\t\t+= proc/\n+obj-y\t\t\t\t+= partitions/\n+obj-$(CONFIG_SYSFS)\t\t+= sysfs/\n+obj-$(CONFIG_CONFIGFS_FS)\t+= configfs/\n+obj-y\t\t\t\t+= devpts/\n+\n+obj-$(CONFIG_PROFILING)\t\t+= dcookies.o\n+obj-$(CONFIG_DLM)\t\t+= dlm/\n+\n+# Do not add any filesystems before this line\n+obj-$(CONFIG_REISERFS_FS)\t+= reiserfs/\n+obj-$(CONFIG_EXT3_FS)\t\t+= ext3/ # Before ext2 so root fs can be ext3\n+obj-$(CONFIG_EXT4DEV_FS)\t+= ext4/ # Before ext2 so root fs can be ext4dev\n+obj-$(CONFIG_JBD)\t\t+= jbd/\n+obj-$(CONFIG_JBD2)\t\t+= jbd2/\n+obj-$(CONFIG_EXT2_FS)\t\t+= ext2/\n+obj-$(CONFIG_CRAMFS)\t\t+= cramfs/\n+obj-$(CONFIG_SQUASHFS)\t\t+= squashfs/\n+obj-$(CONFIG_RAMFS)\t\t+= ramfs/\n+obj-$(CONFIG_HUGETLBFS)\t\t+= hugetlbfs/\n+obj-$(CONFIG_CODA_FS)\t\t+= coda/\n+obj-$(CONFIG_MINIX_FS)\t\t+= minix/\n+obj-$(CONFIG_FAT_FS)\t\t+= fat/\n+obj-$(CONFIG_MSDOS_FS)\t\t+= msdos/\n+obj-$(CONFIG_VFAT_FS)\t\t+= vfat/\n+obj-$(CONFIG_BFS_FS)\t\t+= bfs/\n+obj-$(CONFIG_ISO9660_FS)\t+= isofs/\n+obj-$(CONFIG_HFSPLUS_FS)\t+= hfsplus/ # Before hfs to find wrapped HFS+\n+obj-$(CONFIG_HFS_FS)\t\t+= hfs/\n+obj-$(CONFIG_ECRYPT_FS)\t\t+= ecryptfs/\n+obj-$(CONFIG_VXFS_FS)\t\t+= freevxfs/\n+obj-$(CONFIG_NFS_FS)\t\t+= nfs/\n+obj-$(CONFIG_EXPORTFS)\t\t+= exportfs/\n+obj-$(CONFIG_NFSD)\t\t+= nfsd/\n+obj-$(CONFIG_LOCKD)\t\t+= lockd/\n+obj-$(CONFIG_NLS)\t\t+= nls/\n+obj-$(CONFIG_SYSV_FS)\t\t+= sysv/\n+obj-$(CONFIG_SMB_FS)\t\t+= smbfs/\n+obj-$(CONFIG_CIFS)\t\t+= cifs/\n+obj-$(CONFIG_NCP_FS)\t\t+= ncpfs/\n+obj-$(CONFIG_HPFS_FS)\t\t+= hpfs/\n+obj-$(CONFIG_NTFS_FS)\t\t+= ntfs/\n+obj-$(CONFIG_UFS_FS)\t\t+= ufs/\n+obj-$(CONFIG_EFS_FS)\t\t+= efs/\n+obj-$(CONFIG_JFFS2_FS)\t\t+= jffs2/\n+obj-$(CONFIG_AFFS_FS)\t\t+= affs/\n+obj-$(CONFIG_ROMFS_FS)\t\t+= romfs/\n+obj-$(CONFIG_QNX4FS_FS)\t\t+= qnx4/\n+obj-$(CONFIG_AUTOFS_FS)\t\t+= autofs/\n+obj-$(CONFIG_AUTOFS4_FS)\t+= autofs4/\n+obj-$(CONFIG_ADFS_FS)\t\t+= adfs/\n+obj-$(CONFIG_FUSE_FS)\t\t+= fuse/\n+obj-$(CONFIG_UDF_FS)\t\t+= udf/\n+obj-$(CONFIG_SUN_OPENPROMFS)\t+= openpromfs/\n+obj-$(CONFIG_JFS_FS)\t\t+= jfs/\n+obj-$(CONFIG_XFS_FS)\t\t+= xfs/\n+obj-$(CONFIG_9P_FS)\t\t+= 9p/\n+obj-$(CONFIG_AFS_FS)\t\t+= afs/\n+obj-$(CONFIG_BEFS_FS)\t\t+= befs/\n+obj-$(CONFIG_HOSTFS)\t\t+= hostfs/\n+obj-$(CONFIG_HPPFS)\t\t+= hppfs/\n+obj-$(CONFIG_DEBUG_FS)\t\t+= debugfs/\n+obj-$(CONFIG_OCFS2_FS)\t\t+= ocfs2/\n+obj-$(CONFIG_GFS2_FS)           += gfs2/'),
 ('linux-2.6.23/fs/yaffs2/devextras.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/devextras.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/devextras.h linux-2.6.23-yaffs2/fs/yaffs2/devextras.h\n--- linux-2.6.23/fs/yaffs2/devextras.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/devextras.h\n@@ -0,0 +1,199 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+/*\n+ * This file is just holds extra declarations of macros that would normally\n+ * be providesd in the Linux kernel. These macros have been written from\n+ * scratch but are functionally equivalent to the Linux ones.\n+ *\n+ */\n+\n+#ifndef __EXTRAS_H__\n+#define __EXTRAS_H__\n+\n+\n+#if !(defined __KERNEL__)\n+\n+/* Definition of types */\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+typedef unsigned __u32;\n+\n+#endif\n+\n+/*\n+ * This is a simple doubly linked list implementation that matches the\n+ * way the Linux kernel doubly linked list implementation works.\n+ */\n+\n+struct ylist_head {\n+\tstruct ylist_head *next; /* next in chain */\n+\tstruct ylist_head *prev; /* previous in chain */\n+};\n+\n+\n+/* Initialise a static list */\n+#define YLIST_HEAD(name) \\\n+struct ylist_head name = { &(name),&(name)}\n+\n+\n+\n+/* Initialise a list head to an empty list */\n+#define YINIT_LIST_HEAD(p) \\\n+do { \\\n+ (p)->next = (p);\\\n+ (p)->prev = (p); \\\n+} while(0)\n+\n+\n+/* Add an element to a list */\n+static __inline__ void ylist_add(struct ylist_head *newEntry,\n+                                 struct ylist_head *list)\n+{\n+        struct ylist_head *listNext = list->next;\n+\n+        list->next = newEntry;\n+        newEntry->prev = list;\n+\tnewEntry->next = listNext;\n+\tlistNext->prev = newEntry;\n+\n+}\n+\n+static __inline__ void ylist_add_tail(struct ylist_head *newEntry,\n+\t\t\t\t struct ylist_head *list)\n+{\n+\tstruct ylist_head *listPrev = list->prev;\n+\n+\tlist->prev = newEntry;\n+\tnewEntry->next = list;\n+\tnewEntry->prev = listPrev;\n+\tlistPrev->next = newEntry;\n+\n+}\n+\n+\n+/* Take an element out of its current list, with or without\n+ * reinitialising the links.of the entry*/\n+static __inline__ void ylist_del(struct ylist_head *entry)\n+{\n+        struct ylist_head *listNext = entry->next;\n+        struct ylist_head *listPrev = entry->prev;\n+\n+        listNext->prev = listPrev;\n+        listPrev->next = listNext;\n+\n+}\n+\n+static __inline__ void ylist_del_init(struct ylist_head *entry)\n+{\n+        ylist_del(entry);\n+        entry->next = entry->prev = entry;\n+}\n+\n+\n+/* Test if the list is empty */\n+static __inline__ int ylist_empty(struct ylist_head *entry)\n+{\n+        return (entry->next == entry);\n+}\n+\n+\n+/* ylist_entry takes a pointer to a list entry and offsets it to that\n+ * we can find a pointer to the object it is embedded in.\n+ */\n+\n+\n+#define ylist_entry(entry, type, member) \\\n+        ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))\n+\n+\n+/* ylist_for_each and list_for_each_safe  iterate over lists.\n+ * ylist_for_each_safe uses temporary storage to make the list delete safe\n+ */\n+\n+#define ylist_for_each(itervar, list) \\\n+        for (itervar = (list)->next; itervar != (list); itervar = itervar->next )\n+\n+#define ylist_for_each_safe(itervar,saveVar, list) \\\n+        for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list); \\\n+         itervar = saveVar, saveVar = saveVar->next)\n+\n+\n+#if !(defined __KERNEL__)\n+\n+\n+#ifndef WIN32\n+#include <sys/stat.h>\n+#endif\n+\n+\n+#ifdef CONFIG_YAFFS_PROVIDE_DEFS\n+/* File types */\n+\n+\n+#define DT_UNKNOWN      0\n+#define DT_FIFO         1\n+#define DT_CHR          2\n+#define DT_DIR\t\t4\n+#define DT_BLK\t\t6\n+#define DT_REG          8\n+#define DT_LNK          10\n+#define DT_SOCK         12\n+#define DT_WHT          14\n+\n+\n+#ifndef WIN32\n+#include <sys/stat.h>\n+#endif\n+\n+/*\n+ * Attribute flags.  These should be or-ed together to figure out what\n+ * has been changed!\n+ */\n+#define ATTR_MODE       1\n+#define ATTR_UID        2\n+#define ATTR_GID\t4\n+#define ATTR_SIZE\t8\n+#define ATTR_ATIME\t16\n+#define ATTR_MTIME\t32\n+#define ATTR_CTIME\t64\n+\n+struct iattr {\n+\tunsigned int ia_valid;\n+\tunsigned ia_mode;\n+\tunsigned ia_uid;\n+\tunsigned ia_gid;\n+\tunsigned ia_size;\n+\tunsigned ia_atime;\n+\tunsigned ia_mtime;\n+\tunsigned ia_ctime;\n+        unsigned int ia_attr_flags;\n+};\n+\n+#endif\n+\n+\n+#define KERN_DEBUG\n+\n+#else\n+\n+#include <linux/types.h>\n+#include <linux/fs.h>\n+#include <linux/stat.h>\n+\n+#endif\n+\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/Kconfig',
  'linux-2.6.23-yaffs2/fs/yaffs2/Kconfig',
  'diff -Naur linux-2.6.23/fs/yaffs2/Kconfig linux-2.6.23-yaffs2/fs/yaffs2/Kconfig\n--- linux-2.6.23/fs/yaffs2/Kconfig\n+++ linux-2.6.23-yaffs2/fs/yaffs2/Kconfig\n@@ -0,0 +1,156 @@\n+#\n+# YAFFS file system configurations\n+#\n+\n+config YAFFS_FS\n+\ttristate "YAFFS2 file system support"\n+\tdefault n\n+\tdepends on MTD\n+\tselect YAFFS_YAFFS1\n+\tselect YAFFS_YAFFS2\n+\thelp\n+\t  YAFFS2, or Yet Another Flash Filing System, is a filing system\n+\t  optimised for NAND Flash chips.\n+\n+\t  To compile the YAFFS2 file system support as a module, choose M\n+\t  here: the module will be called yaffs2.\n+\n+\t  If unsure, say N.\n+\n+\t  Further information on YAFFS2 is available at\n+\t  <http://www.aleph1.co.uk/yaffs/>.\n+\n+config YAFFS_YAFFS1\n+\tbool "512 byte / page devices"\n+\tdepends on YAFFS_FS\n+\tdefault y\n+\thelp\n+\t  Enable YAFFS1 support -- yaffs for 512 byte / page devices\n+\n+\t  Not needed for 2K-page devices.\n+\n+\t  If unsure, say Y.\n+\n+config YAFFS_9BYTE_TAGS\n+\tbool "Use older-style on-NAND data format with pageStatus byte"\n+\tdepends on YAFFS_YAFFS1\n+\tdefault n\n+\thelp\n+\n+\t  Older-style on-NAND data format has a "pageStatus" byte to record\n+\t  chunk/page state.  This byte is zero when the page is discarded.\n+\t  Choose this option if you have existing on-NAND data using this\n+\t  format that you need to continue to support.  New data written\n+\t  also uses the older-style format.  Note: Use of this option\n+\t  generally requires that MTD\'s oob layout be adjusted to use the\n+\t  older-style format.  See notes on tags formats and MTD versions\n+\t  in yaffs_mtdif1.c.\n+\n+\t  If unsure, say N.\n+\n+config YAFFS_DOES_ECC\n+\tbool "Lets Yaffs do its own ECC"\n+\tdepends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS\n+\tdefault n\n+\thelp\n+\t  This enables Yaffs to use its own ECC functions instead of using\n+\t  the ones from the generic MTD-NAND driver.\n+\n+\t  If unsure, say N.\n+\n+config YAFFS_ECC_WRONG_ORDER\n+\tbool "Use the same ecc byte order as Steven Hill\'s nand_ecc.c"\n+\tdepends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS\n+\tdefault n\n+\thelp\n+\t  This makes yaffs_ecc.c use the same ecc byte order as Steven\n+\t  Hill\'s nand_ecc.c. If not set, then you get the same ecc byte\n+\t  order as SmartMedia.\n+\n+\t  If unsure, say N.\n+\n+config YAFFS_YAFFS2\n+\tbool "2048 byte (or larger) / page devices"\n+\tdepends on YAFFS_FS\n+\tdefault y\n+\thelp\n+\t  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices\n+\n+\t  If unsure, say Y.\n+\n+config YAFFS_AUTO_YAFFS2\n+\tbool "Autoselect yaffs2 format"\n+\tdepends on YAFFS_YAFFS2\n+\tdefault y\n+\thelp\n+\t  Without this, you need to explicitely use yaffs2 as the file\n+\t  system type. With this, you can say "yaffs" and yaffs or yaffs2\n+\t  will be used depending on the device page size (yaffs on\n+\t  512-byte page devices, yaffs2 on 2K page devices).\n+\n+\t  If unsure, say Y.\n+\n+config YAFFS_DISABLE_LAZY_LOAD\n+\tbool "Disable lazy loading"\n+\tdepends on YAFFS_YAFFS2\n+\tdefault n\n+\thelp\n+\t  "Lazy loading" defers loading file details until they are\n+\t  required. This saves mount time, but makes the first look-up\n+\t  a bit longer.\n+\n+\t  Lazy loading will only happen if enabled by this option being \'n\'\n+\t  and if the appropriate tags are available, else yaffs2 will\n+\t  automatically fall back to immediate loading and do the right\n+\t  thing.\n+\n+\t  Lazy laoding will be required by checkpointing.\n+\n+\t  Setting this to \'y\' will disable lazy loading.\n+\n+\t  If unsure, say N.\n+\n+\n+config YAFFS_DISABLE_WIDE_TNODES\n+\tbool "Turn off wide tnodes"\n+\tdepends on YAFFS_FS\n+\tdefault n\n+\thelp\n+\t  Wide tnodes are only used for NAND arrays >=32MB for 512-byte\n+\t  page devices and >=128MB for 2k page devices. They use slightly\n+\t  more RAM but are faster since they eliminate chunk group\n+\t  searching.\n+\n+\t  Setting this to \'y\' will force tnode width to 16 bits and save\n+\t  memory but make large arrays slower.\n+\n+\t  If unsure, say N.\n+\n+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED\n+\tbool "Force chunk erase check"\n+\tdepends on YAFFS_FS\n+\tdefault n\n+\thelp\n+          Normally YAFFS only checks chunks before writing until an erased\n+\t  chunk is found. This helps to detect any partially written\n+\t  chunks that might have happened due to power loss.\n+\n+\t  Enabling this forces on the test that chunks are erased in flash\n+\t  before writing to them. This takes more time but is potentially\n+\t  a bit more secure.\n+\n+\t  Suggest setting Y during development and ironing out driver\n+\t  issues etc. Suggest setting to N if you want faster writing.\n+\n+\t  If unsure, say Y.\n+\n+config YAFFS_SHORT_NAMES_IN_RAM\n+\tbool "Cache short names in RAM"\n+\tdepends on YAFFS_FS\n+\tdefault y\n+\thelp\n+\t  If this config is set, then short names are stored with the\n+\t  yaffs_Object.  This costs an extra 16 bytes of RAM per object,\n+\t  but makes look-ups faster.\n+\n+\t  If unsure, say Y.'),
 ('linux-2.6.23/fs/yaffs2/Makefile',
  'linux-2.6.23-yaffs2/fs/yaffs2/Makefile',
  'diff -Naur linux-2.6.23/fs/yaffs2/Makefile linux-2.6.23-yaffs2/fs/yaffs2/Makefile\n--- linux-2.6.23/fs/yaffs2/Makefile\n+++ linux-2.6.23-yaffs2/fs/yaffs2/Makefile\n@@ -0,0 +1,10 @@\n+#\n+# Makefile for the linux YAFFS filesystem routines.\n+#\n+\n+obj-$(CONFIG_YAFFS_FS) += yaffs.o\n+\n+yaffs-y := yaffs_ecc.o yaffs_fs.o yaffs_guts.o yaffs_checkptrw.o\n+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o yaffs_qsort.o\n+yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o\n+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o'),
 ('linux-2.6.23/fs/yaffs2/moduleconfig.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/moduleconfig.h linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h\n--- linux-2.6.23/fs/yaffs2/moduleconfig.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h\n@@ -0,0 +1,65 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_CONFIG_H__\n+#define __YAFFS_CONFIG_H__\n+\n+#ifdef YAFFS_OUT_OF_TREE\n+\n+/* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */\n+#define CONFIG_YAFFS_FS\n+#define CONFIG_YAFFS_YAFFS1\n+#define CONFIG_YAFFS_YAFFS2\n+\n+/* These options are independent of each other.  Select those that matter. */\n+\n+/* Default: Not selected */\n+/* Meaning: Yaffs does its own ECC, rather than using MTD ECC */\n+//#define CONFIG_YAFFS_DOES_ECC\n+\n+/* Default: Not selected */\n+/* Meaning: ECC byte order is \'wrong\'.  Only meaningful if */\n+/*          CONFIG_YAFFS_DOES_ECC is set */\n+//#define CONFIG_YAFFS_ECC_WRONG_ORDER\n+\n+/* Default: Selected */\n+/* Meaning: Disables testing whether chunks are erased before writing to them*/\n+#define CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK\n+\n+/* Default: Selected */\n+/* Meaning: Cache short names, taking more RAM, but faster look-ups */\n+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM\n+\n+/* Default: 10 */\n+/* Meaning: set the count of blocks to reserve for checkpointing */\n+#define CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS 10\n+\n+/*\n+Older-style on-NAND data format has a "pageStatus" byte to record\n+chunk/page state.  This byte is zeroed when the page is discarded.\n+Choose this option if you have existing on-NAND data in this format\n+that you need to continue to support.  New data written also uses the\n+older-style format.\n+Note: Use of this option generally requires that MTD\'s oob layout be\n+adjusted to use the older-style format.  See notes on tags formats and\n+MTD versions in yaffs_mtdif1.c.\n+*/\n+/* Default: Not selected */\n+/* Meaning: Use older-style on-NAND data format with pageStatus byte */\n+//#define CONFIG_YAFFS_9BYTE_TAGS\n+\n+#endif /* YAFFS_OUT_OF_TREE */\n+\n+#endif /* __YAFFS_CONFIG_H__ */'),
 ('linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c\n--- linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c\n@@ -0,0 +1,404 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+const char *yaffs_checkptrw_c_version =\n+    "$Id: yaffs_checkptrw.c,v 1.16 2008/05/05 07:58:58 charles Exp $";\n+\n+\n+#include "yaffs_checkptrw.h"\n+#include "yaffs_getblockinfo.h"\n+\n+static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)\n+{\n+\n+\tint blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,\n+\t\t(TSTR("checkpt blocks available = %d" TENDSTR),\n+\t\tblocksAvailable));\n+\n+\n+\treturn (blocksAvailable <= 0) ? 0 : 1;\n+}\n+\n+\n+static int yaffs_CheckpointErase(yaffs_Device *dev)\n+{\n+\n+\tint i;\n+\n+\n+\tif(!dev->eraseBlockInNAND)\n+\t\treturn 0;\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("checking blocks %d to %d"TENDSTR),\n+\t\tdev->internalStartBlock,dev->internalEndBlock));\n+\n+\tfor(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {\n+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);\n+\t\tif(bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT){\n+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("erasing checkpt block %d"TENDSTR),i));\n+\t\t\tif(dev->eraseBlockInNAND(dev,i- dev->blockOffset /* realign */)){\n+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_EMPTY;\n+\t\t\t\tdev->nErasedBlocks++;\n+\t\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tdev->markNANDBlockBad(dev,i);\n+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_DEAD;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tdev->blocksInCheckpoint = 0;\n+\n+\treturn 1;\n+}\n+\n+\n+static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)\n+{\n+\tint  i;\n+\tint blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;\n+\tT(YAFFS_TRACE_CHECKPOINT,\n+\t\t(TSTR("allocating checkpt block: erased %d reserved %d avail %d next %d "TENDSTR),\n+\t\tdev->nErasedBlocks,dev->nReservedBlocks,blocksAvailable,dev->checkpointNextBlock));\n+\n+\tif(dev->checkpointNextBlock >= 0 &&\n+\t   dev->checkpointNextBlock <= dev->internalEndBlock &&\n+\t   blocksAvailable > 0){\n+\n+\t\tfor(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++){\n+\t\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);\n+\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_EMPTY){\n+\t\t\t\tdev->checkpointNextBlock = i + 1;\n+\t\t\t\tdev->checkpointCurrentBlock = i;\n+\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("allocating checkpt block %d"TENDSTR),i));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t}\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("out of checkpt blocks"TENDSTR)));\n+\n+\tdev->checkpointNextBlock = -1;\n+\tdev->checkpointCurrentBlock = -1;\n+}\n+\n+static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)\n+{\n+\tint  i;\n+\tyaffs_ExtendedTags tags;\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("find next checkpt block: start:  blocks %d next %d" TENDSTR),\n+\t\tdev->blocksInCheckpoint, dev->checkpointNextBlock));\n+\n+\tif(dev->blocksInCheckpoint < dev->checkpointMaxBlocks)\n+\t\tfor(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++){\n+\t\t\tint chunk = i * dev->nChunksPerBlock;\n+\t\t\tint realignedChunk = chunk - dev->chunkOffset;\n+\n+\t\t\tdev->readChunkWithTagsFromNAND(dev,realignedChunk,NULL,&tags);\n+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("find next checkpt block: search: block %d oid %d seq %d eccr %d" TENDSTR),\n+\t\t\t\ti, tags.objectId,tags.sequenceNumber,tags.eccResult));\n+\n+\t\t\tif(tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA){\n+\t\t\t\t/* Right kind of block */\n+\t\t\t\tdev->checkpointNextBlock = tags.objectId;\n+\t\t\t\tdev->checkpointCurrentBlock = i;\n+\t\t\t\tdev->checkpointBlockList[dev->blocksInCheckpoint] = i;\n+\t\t\t\tdev->blocksInCheckpoint++;\n+\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("found checkpt block %d"TENDSTR),i));\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("found no more checkpt blocks"TENDSTR)));\n+\n+\tdev->checkpointNextBlock = -1;\n+\tdev->checkpointCurrentBlock = -1;\n+}\n+\n+\n+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)\n+{\n+\n+\t/* Got the functions we need? */\n+\tif (!dev->writeChunkWithTagsToNAND ||\n+\t    !dev->readChunkWithTagsFromNAND ||\n+\t    !dev->eraseBlockInNAND ||\n+\t    !dev->markNANDBlockBad)\n+\t\treturn 0;\n+\n+\tif(forWriting && !yaffs_CheckpointSpaceOk(dev))\n+\t\treturn 0;\n+\n+\tif(!dev->checkpointBuffer)\n+\t\tdev->checkpointBuffer = YMALLOC_DMA(dev->totalBytesPerChunk);\n+\tif(!dev->checkpointBuffer)\n+\t\treturn 0;\n+\n+\n+\tdev->checkpointPageSequence = 0;\n+\n+\tdev->checkpointOpenForWrite = forWriting;\n+\n+\tdev->checkpointByteCount = 0;\n+\tdev->checkpointSum = 0;\n+\tdev->checkpointXor = 0;\n+\tdev->checkpointCurrentBlock = -1;\n+\tdev->checkpointCurrentChunk = -1;\n+\tdev->checkpointNextBlock = dev->internalStartBlock;\n+\n+\t/* Erase all the blocks in the checkpoint area */\n+\tif(forWriting){\n+\t\tmemset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);\n+\t\tdev->checkpointByteOffset = 0;\n+\t\treturn yaffs_CheckpointErase(dev);\n+\n+\n+\t} else {\n+\t\tint i;\n+\t\t/* Set to a value that will kick off a read */\n+\t\tdev->checkpointByteOffset = dev->nDataBytesPerChunk;\n+\t\t/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)\n+\t\t * going to be way more than we need */\n+\t\tdev->blocksInCheckpoint = 0;\n+\t\tdev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;\n+\t\tdev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);\n+\t\tfor(i = 0; i < dev->checkpointMaxBlocks; i++)\n+\t\t\tdev->checkpointBlockList[i] = -1;\n+\t}\n+\n+\treturn 1;\n+}\n+\n+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)\n+{\n+\t__u32 compositeSum;\n+\tcompositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);\n+\t*sum = compositeSum;\n+\treturn 1;\n+}\n+\n+static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)\n+{\n+\n+\tint chunk;\n+\tint realignedChunk;\n+\n+\tyaffs_ExtendedTags tags;\n+\n+\tif(dev->checkpointCurrentBlock < 0){\n+\t\tyaffs_CheckpointFindNextErasedBlock(dev);\n+\t\tdev->checkpointCurrentChunk = 0;\n+\t}\n+\n+\tif(dev->checkpointCurrentBlock < 0)\n+\t\treturn 0;\n+\n+\ttags.chunkDeleted = 0;\n+\ttags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */\n+\ttags.chunkId = dev->checkpointPageSequence + 1;\n+\ttags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;\n+\ttags.byteCount = dev->nDataBytesPerChunk;\n+\tif(dev->checkpointCurrentChunk == 0){\n+\t\t/* First chunk we write for the block? Set block state to\n+\t\t   checkpoint */\n+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointCurrentBlock);\n+\t\tbi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;\n+\t\tdev->blocksInCheckpoint++;\n+\t}\n+\n+\tchunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock + dev->checkpointCurrentChunk;\n+\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint wite buffer nand %d(%d:%d) objid %d chId %d" TENDSTR),\n+\t\tchunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk,tags.objectId,tags.chunkId));\n+\n+\trealignedChunk = chunk - dev->chunkOffset;\n+\n+\tdev->writeChunkWithTagsToNAND(dev,realignedChunk,dev->checkpointBuffer,&tags);\n+\tdev->checkpointByteOffset = 0;\n+\tdev->checkpointPageSequence++;\n+\tdev->checkpointCurrentChunk++;\n+\tif(dev->checkpointCurrentChunk >= dev->nChunksPerBlock){\n+\t\tdev->checkpointCurrentChunk = 0;\n+\t\tdev->checkpointCurrentBlock = -1;\n+\t}\n+\tmemset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);\n+\n+\treturn 1;\n+}\n+\n+\n+int yaffs_CheckpointWrite(yaffs_Device *dev,const void *data, int nBytes)\n+{\n+\tint i=0;\n+\tint ok = 1;\n+\n+\n+\t__u8 * dataBytes = (__u8 *)data;\n+\n+\n+\n+\tif(!dev->checkpointBuffer)\n+\t\treturn 0;\n+\n+\tif(!dev->checkpointOpenForWrite)\n+\t\treturn -1;\n+\n+\twhile(i < nBytes && ok) {\n+\n+\n+\n+\t\tdev->checkpointBuffer[dev->checkpointByteOffset] = *dataBytes ;\n+\t\tdev->checkpointSum += *dataBytes;\n+\t\tdev->checkpointXor ^= *dataBytes;\n+\n+\t\tdev->checkpointByteOffset++;\n+\t\ti++;\n+\t\tdataBytes++;\n+\t\tdev->checkpointByteCount++;\n+\n+\n+\t\tif(dev->checkpointByteOffset < 0 ||\n+\t\t   dev->checkpointByteOffset >= dev->nDataBytesPerChunk)\n+\t\t\tok = yaffs_CheckpointFlushBuffer(dev);\n+\n+\t}\n+\n+\treturn \ti;\n+}\n+\n+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)\n+{\n+\tint i=0;\n+\tint ok = 1;\n+\tyaffs_ExtendedTags tags;\n+\n+\n+\tint chunk;\n+\tint realignedChunk;\n+\n+\t__u8 *dataBytes = (__u8 *)data;\n+\n+\tif(!dev->checkpointBuffer)\n+\t\treturn 0;\n+\n+\tif(dev->checkpointOpenForWrite)\n+\t\treturn -1;\n+\n+\twhile(i < nBytes && ok) {\n+\n+\n+\t\tif(dev->checkpointByteOffset < 0 ||\n+\t\t   dev->checkpointByteOffset >= dev->nDataBytesPerChunk) {\n+\n+\t\t   \tif(dev->checkpointCurrentBlock < 0){\n+\t\t\t\tyaffs_CheckpointFindNextCheckpointBlock(dev);\n+\t\t\t\tdev->checkpointCurrentChunk = 0;\n+\t\t\t}\n+\n+\t\t\tif(dev->checkpointCurrentBlock < 0)\n+\t\t\t\tok = 0;\n+\t\t\telse {\n+\n+\t\t\t\tchunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock +\n+\t\t\t\t          dev->checkpointCurrentChunk;\n+\n+\t\t\t\trealignedChunk = chunk - dev->chunkOffset;\n+\n+\t   \t\t\t/* read in the next chunk */\n+\t   \t\t\t/* printf("read checkpoint page %d\\n",dev->checkpointPage); */\n+\t\t\t\tdev->readChunkWithTagsFromNAND(dev, realignedChunk,\n+\t\t\t\t\t\t\t       dev->checkpointBuffer,\n+\t\t\t\t\t\t\t      &tags);\n+\n+\t\t\t\tif(tags.chunkId != (dev->checkpointPageSequence + 1) ||\n+\t\t\t\t   tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)\n+\t\t\t\t   ok = 0;\n+\n+\t\t\t\tdev->checkpointByteOffset = 0;\n+\t\t\t\tdev->checkpointPageSequence++;\n+\t\t\t\tdev->checkpointCurrentChunk++;\n+\n+\t\t\t\tif(dev->checkpointCurrentChunk >= dev->nChunksPerBlock)\n+\t\t\t\t\tdev->checkpointCurrentBlock = -1;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif(ok){\n+\t\t\t*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];\n+\t\t\tdev->checkpointSum += *dataBytes;\n+\t\t\tdev->checkpointXor ^= *dataBytes;\n+\t\t\tdev->checkpointByteOffset++;\n+\t\t\ti++;\n+\t\t\tdataBytes++;\n+\t\t\tdev->checkpointByteCount++;\n+\t\t}\n+\t}\n+\n+\treturn \ti;\n+}\n+\n+int yaffs_CheckpointClose(yaffs_Device *dev)\n+{\n+\n+\tif(dev->checkpointOpenForWrite){\n+\t\tif(dev->checkpointByteOffset != 0)\n+\t\t\tyaffs_CheckpointFlushBuffer(dev);\n+\t} else {\n+\t\tint i;\n+\t\tfor(i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++){\n+\t\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointBlockList[i]);\n+\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_EMPTY)\n+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;\n+\t\t\telse {\n+\t\t\t\t// Todo this looks odd...\n+\t\t\t}\n+\t\t}\n+\t\tYFREE(dev->checkpointBlockList);\n+\t\tdev->checkpointBlockList = NULL;\n+\t}\n+\n+\tdev->nFreeChunks -= dev->blocksInCheckpoint * dev->nChunksPerBlock;\n+\tdev->nErasedBlocks -= dev->blocksInCheckpoint;\n+\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint byte count %d" TENDSTR),\n+\t\t\tdev->checkpointByteCount));\n+\n+\tif(dev->checkpointBuffer){\n+\t\t/* free the buffer */\n+\t\tYFREE(dev->checkpointBuffer);\n+\t\tdev->checkpointBuffer = NULL;\n+\t\treturn 1;\n+\t}\n+\telse\n+\t\treturn 0;\n+\n+}\n+\n+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)\n+{\n+\t/* Erase the first checksum block */\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("checkpoint invalidate"TENDSTR)));\n+\n+\tif(!yaffs_CheckpointSpaceOk(dev))\n+\t\treturn 0;\n+\n+\treturn yaffs_CheckpointErase(dev);\n+}\n+\n+\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h\n--- linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h\n@@ -0,0 +1,35 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_CHECKPTRW_H__\n+#define __YAFFS_CHECKPTRW_H__\n+\n+#include "yaffs_guts.h"\n+\n+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);\n+\n+int yaffs_CheckpointWrite(yaffs_Device *dev,const void *data, int nBytes);\n+\n+int yaffs_CheckpointRead(yaffs_Device *dev,void *data, int nBytes);\n+\n+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);\n+\n+int yaffs_CheckpointClose(yaffs_Device *dev);\n+\n+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev);\n+\n+\n+#endif\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_ecc.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_ecc.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c\n--- linux-2.6.23/fs/yaffs2/yaffs_ecc.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c\n@@ -0,0 +1,331 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+/*\n+ * This code implements the ECC algorithm used in SmartMedia.\n+ *\n+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.\n+ * The two unused bit are set to 1.\n+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC\n+ * blocks are used on a 512-byte NAND page.\n+ *\n+ */\n+\n+/* Table generated by gen-ecc.c\n+ * Using a table means we do not have to calculate p1..p4 and p1\'..p4\'\n+ * for each byte of data. These are instead provided in a table in bits7..2.\n+ * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore\n+ * this bytes influence on the line parity.\n+ */\n+\n+const char *yaffs_ecc_c_version =\n+    "$Id: yaffs_ecc.c,v 1.10 2007/12/13 15:35:17 wookey Exp $";\n+\n+#include "yportenv.h"\n+\n+#include "yaffs_ecc.h"\n+\n+static const unsigned char column_parity_table[] = {\n+\t0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,\n+\t0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,\n+\t0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,\n+\t0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,\n+\t0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,\n+\t0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,\n+\t0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,\n+\t0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,\n+\t0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,\n+\t0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,\n+\t0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,\n+\t0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,\n+\t0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,\n+\t0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,\n+\t0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,\n+\t0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,\n+\t0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,\n+\t0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,\n+\t0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,\n+\t0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,\n+\t0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,\n+\t0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,\n+\t0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,\n+\t0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,\n+\t0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,\n+\t0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,\n+\t0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,\n+\t0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,\n+\t0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,\n+\t0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,\n+\t0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,\n+\t0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,\n+};\n+\n+/* Count the bits in an unsigned char or a U32 */\n+\n+static int yaffs_CountBits(unsigned char x)\n+{\n+\tint r = 0;\n+\twhile (x) {\n+\t\tif (x & 1)\n+\t\t\tr++;\n+\t\tx >>= 1;\n+\t}\n+\treturn r;\n+}\n+\n+static int yaffs_CountBits32(unsigned x)\n+{\n+\tint r = 0;\n+\twhile (x) {\n+\t\tif (x & 1)\n+\t\t\tr++;\n+\t\tx >>= 1;\n+\t}\n+\treturn r;\n+}\n+\n+/* Calculate the ECC for a 256-byte block of data */\n+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)\n+{\n+\tunsigned int i;\n+\n+\tunsigned char col_parity = 0;\n+\tunsigned char line_parity = 0;\n+\tunsigned char line_parity_prime = 0;\n+\tunsigned char t;\n+\tunsigned char b;\n+\n+\tfor (i = 0; i < 256; i++) {\n+\t\tb = column_parity_table[*data++];\n+\t\tcol_parity ^= b;\n+\n+\t\tif (b & 0x01)\t// odd number of bits in the byte\n+\t\t{\n+\t\t\tline_parity ^= i;\n+\t\t\tline_parity_prime ^= ~i;\n+\t\t}\n+\n+\t}\n+\n+\tecc[2] = (~col_parity) | 0x03;\n+\n+\tt = 0;\n+\tif (line_parity & 0x80)\n+\t\tt |= 0x80;\n+\tif (line_parity_prime & 0x80)\n+\t\tt |= 0x40;\n+\tif (line_parity & 0x40)\n+\t\tt |= 0x20;\n+\tif (line_parity_prime & 0x40)\n+\t\tt |= 0x10;\n+\tif (line_parity & 0x20)\n+\t\tt |= 0x08;\n+\tif (line_parity_prime & 0x20)\n+\t\tt |= 0x04;\n+\tif (line_parity & 0x10)\n+\t\tt |= 0x02;\n+\tif (line_parity_prime & 0x10)\n+\t\tt |= 0x01;\n+\tecc[1] = ~t;\n+\n+\tt = 0;\n+\tif (line_parity & 0x08)\n+\t\tt |= 0x80;\n+\tif (line_parity_prime & 0x08)\n+\t\tt |= 0x40;\n+\tif (line_parity & 0x04)\n+\t\tt |= 0x20;\n+\tif (line_parity_prime & 0x04)\n+\t\tt |= 0x10;\n+\tif (line_parity & 0x02)\n+\t\tt |= 0x08;\n+\tif (line_parity_prime & 0x02)\n+\t\tt |= 0x04;\n+\tif (line_parity & 0x01)\n+\t\tt |= 0x02;\n+\tif (line_parity_prime & 0x01)\n+\t\tt |= 0x01;\n+\tecc[0] = ~t;\n+\n+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER\n+\t// Swap the bytes into the wrong order\n+\tt = ecc[0];\n+\tecc[0] = ecc[1];\n+\tecc[1] = t;\n+#endif\n+}\n+\n+\n+/* Correct the ECC on a 256 byte block of data */\n+\n+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,\n+\t\t     const unsigned char *test_ecc)\n+{\n+\tunsigned char d0, d1, d2;\t/* deltas */\n+\n+\td0 = read_ecc[0] ^ test_ecc[0];\n+\td1 = read_ecc[1] ^ test_ecc[1];\n+\td2 = read_ecc[2] ^ test_ecc[2];\n+\n+\tif ((d0 | d1 | d2) == 0)\n+\t\treturn 0; /* no error */\n+\n+\tif (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&\n+\t    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&\n+\t    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {\n+\t\t/* Single bit (recoverable) error in data */\n+\n+\t\tunsigned byte;\n+\t\tunsigned bit;\n+\n+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER\n+\t\t// swap the bytes to correct for the wrong order\n+\t\tunsigned char t;\n+\n+\t\tt = d0;\n+\t\td0 = d1;\n+\t\td1 = t;\n+#endif\n+\n+\t\tbit = byte = 0;\n+\n+\t\tif (d1 & 0x80)\n+\t\t\tbyte |= 0x80;\n+\t\tif (d1 & 0x20)\n+\t\t\tbyte |= 0x40;\n+\t\tif (d1 & 0x08)\n+\t\t\tbyte |= 0x20;\n+\t\tif (d1 & 0x02)\n+\t\t\tbyte |= 0x10;\n+\t\tif (d0 & 0x80)\n+\t\t\tbyte |= 0x08;\n+\t\tif (d0 & 0x20)\n+\t\t\tbyte |= 0x04;\n+\t\tif (d0 & 0x08)\n+\t\t\tbyte |= 0x02;\n+\t\tif (d0 & 0x02)\n+\t\t\tbyte |= 0x01;\n+\n+\t\tif (d2 & 0x80)\n+\t\t\tbit |= 0x04;\n+\t\tif (d2 & 0x20)\n+\t\t\tbit |= 0x02;\n+\t\tif (d2 & 0x08)\n+\t\t\tbit |= 0x01;\n+\n+\t\tdata[byte] ^= (1 << bit);\n+\n+\t\treturn 1; /* Corrected the error */\n+\t}\n+\n+\tif ((yaffs_CountBits(d0) +\n+\t     yaffs_CountBits(d1) +\n+\t     yaffs_CountBits(d2)) ==  1) {\n+\t\t/* Reccoverable error in ecc */\n+\n+\t\tread_ecc[0] = test_ecc[0];\n+\t\tread_ecc[1] = test_ecc[1];\n+\t\tread_ecc[2] = test_ecc[2];\n+\n+\t\treturn 1; /* Corrected the error */\n+\t}\n+\n+\t/* Unrecoverable error */\n+\n+\treturn -1;\n+\n+}\n+\n+\n+/*\n+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data\n+ */\n+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,\n+\t\t\t     yaffs_ECCOther * eccOther)\n+{\n+\tunsigned int i;\n+\n+\tunsigned char col_parity = 0;\n+\tunsigned line_parity = 0;\n+\tunsigned line_parity_prime = 0;\n+\tunsigned char b;\n+\n+\tfor (i = 0; i < nBytes; i++) {\n+\t\tb = column_parity_table[*data++];\n+\t\tcol_parity ^= b;\n+\n+\t\tif (b & 0x01)\t {\n+\t\t\t/* odd number of bits in the byte */\n+\t\t\tline_parity ^= i;\n+\t\t\tline_parity_prime ^= ~i;\n+\t\t}\n+\n+\t}\n+\n+\teccOther->colParity = (col_parity >> 2) & 0x3f;\n+\teccOther->lineParity = line_parity;\n+\teccOther->lineParityPrime = line_parity_prime;\n+}\n+\n+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,\n+\t\t\t  yaffs_ECCOther * read_ecc,\n+\t\t\t  const yaffs_ECCOther * test_ecc)\n+{\n+\tunsigned char cDelta;\t/* column parity delta */\n+\tunsigned lDelta;\t/* line parity delta */\n+\tunsigned lDeltaPrime;\t/* line parity delta */\n+\tunsigned bit;\n+\n+\tcDelta = read_ecc->colParity ^ test_ecc->colParity;\n+\tlDelta = read_ecc->lineParity ^ test_ecc->lineParity;\n+\tlDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;\n+\n+\tif ((cDelta | lDelta | lDeltaPrime) == 0)\n+\t\treturn 0; /* no error */\n+\n+\tif (lDelta == ~lDeltaPrime &&\n+\t    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15))\n+\t{\n+\t\t/* Single bit (recoverable) error in data */\n+\n+\t\tbit = 0;\n+\n+\t\tif (cDelta & 0x20)\n+\t\t\tbit |= 0x04;\n+\t\tif (cDelta & 0x08)\n+\t\t\tbit |= 0x02;\n+\t\tif (cDelta & 0x02)\n+\t\t\tbit |= 0x01;\n+\n+\t\tif(lDelta >= nBytes)\n+\t\t\treturn -1;\n+\n+\t\tdata[lDelta] ^= (1 << bit);\n+\n+\t\treturn 1; /* corrected */\n+\t}\n+\n+\tif ((yaffs_CountBits32(lDelta) + yaffs_CountBits32(lDeltaPrime) +\n+\t     yaffs_CountBits(cDelta)) == 1) {\n+\t\t/* Reccoverable error in ecc */\n+\n+\t\t*read_ecc = *test_ecc;\n+\t\treturn 1; /* corrected */\n+\t}\n+\n+\t/* Unrecoverable error */\n+\n+\treturn -1;\n+\n+}\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_ecc.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_ecc.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h\n--- linux-2.6.23/fs/yaffs2/yaffs_ecc.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h\n@@ -0,0 +1,44 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+ /*\n+  * This code implements the ECC algorithm used in SmartMedia.\n+  *\n+  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.\n+  * The two unused bit are set to 1.\n+  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC\n+  * blocks are used on a 512-byte NAND page.\n+  *\n+  */\n+\n+#ifndef __YAFFS_ECC_H__\n+#define __YAFFS_ECC_H__\n+\n+typedef struct {\n+\tunsigned char colParity;\n+\tunsigned lineParity;\n+\tunsigned lineParityPrime;\n+} yaffs_ECCOther;\n+\n+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);\n+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,\n+\t\t     const unsigned char *test_ecc);\n+\n+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,\n+\t\t\t     yaffs_ECCOther * ecc);\n+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,\n+\t\t\t  yaffs_ECCOther * read_ecc,\n+\t\t\t  const yaffs_ECCOther * test_ecc);\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_fs.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_fs.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c\n--- linux-2.6.23/fs/yaffs2/yaffs_fs.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c\n@@ -0,0 +1,2372 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ * Acknowledgements:\n+ * Luc van OostenRyck for numerous patches.\n+ * Nick Bane for numerous patches.\n+ * Nick Bane for 2.5/2.6 integration.\n+ * Andras Toth for mknod rdev issue.\n+ * Michael Fischer for finding the problem with inode inconsistency.\n+ * Some code bodily lifted from JFFS\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+/*\n+ *\n+ * This is the file system front-end to YAFFS that hooks it up to\n+ * the VFS.\n+ *\n+ * Special notes:\n+ * >> 2.4: sb->u.generic_sbp points to the yaffs_Device associated with\n+ *         this superblock\n+ * >> 2.6: sb->s_fs_info  points to the yaffs_Device associated with this\n+ *         superblock\n+ * >> inode->u.generic_ip points to the associated yaffs_Object.\n+ */\n+\n+const char *yaffs_fs_c_version =\n+    "$Id: yaffs_fs.c,v 1.67 2008/07/03 20:06:05 charles Exp $";\n+extern const char *yaffs_guts_c_version;\n+\n+#include <linux/version.h>\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))\n+#include <linux/config.h>\n+#endif\n+#include <linux/kernel.h>\n+#include <linux/module.h>\n+#include <linux/slab.h>\n+#include <linux/init.h>\n+#include <linux/fs.h>\n+#include <linux/proc_fs.h>\n+#include <linux/smp_lock.h>\n+#include <linux/pagemap.h>\n+#include <linux/mtd/mtd.h>\n+#include <linux/interrupt.h>\n+#include <linux/string.h>\n+#include <linux/ctype.h>\n+\n+#include "asm/div64.h"\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\n+#include <linux/statfs.h>\t/* Added NCB 15-8-2003 */\n+#include <asm/statfs.h>\n+#define UnlockPage(p) unlock_page(p)\n+#define Page_Uptodate(page)\ttest_bit(PG_uptodate, &(page)->flags)\n+\n+/* FIXME: use sb->s_id instead ? */\n+#define yaffs_devname(sb, buf)\tbdevname(sb->s_bdev, buf)\n+\n+#else\n+\n+#include <linux/locks.h>\n+#define\tBDEVNAME_SIZE\t\t0\n+#define\tyaffs_devname(sb, buf)\tkdevname(sb->s_dev)\n+\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))\n+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */\n+#define __user\n+#endif\n+\n+#endif\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+#define WRITE_SIZE_STR "writesize"\n+#define WRITE_SIZE(mtd) (mtd)->writesize\n+#else\n+#define WRITE_SIZE_STR "oobblock"\n+#define WRITE_SIZE(mtd) (mtd)->oobblock\n+#endif\n+\n+#include <asm/uaccess.h>\n+\n+#include "yportenv.h"\n+#include "yaffs_guts.h"\n+\n+#include <linux/mtd/mtd.h>\n+#include "yaffs_mtdif.h"\n+#include "yaffs_mtdif1.h"\n+#include "yaffs_mtdif2.h"\n+\n+unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS;\n+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;\n+\n+/* Module Parameters */\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+module_param(yaffs_traceMask,uint,0644);\n+module_param(yaffs_wr_attempts,uint,0644);\n+#else\n+MODULE_PARM(yaffs_traceMask,"i");\n+MODULE_PARM(yaffs_wr_attempts,"i");\n+#endif\n+\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))\n+/* use iget and read_inode */\n+#define Y_IGET(sb,inum) iget((sb),(inum))\n+static void yaffs_read_inode(struct inode *inode);\n+\n+#else\n+/* Call local equivalent */\n+#define YAFFS_USE_OWN_IGET\n+#define Y_IGET(sb,inum) yaffs_iget((sb),(inum))\n+\n+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino);\n+#endif\n+\n+/*#define T(x) printk x */\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))\n+#define yaffs_InodeToObjectLV(iptr) (iptr)->i_private\n+#else\n+#define yaffs_InodeToObjectLV(iptr) (iptr)->u.generic_ip\n+#endif\n+\n+#define yaffs_InodeToObject(iptr) ((yaffs_Object *)(yaffs_InodeToObjectLV(iptr)))\n+#define yaffs_DentryToObject(dptr) yaffs_InodeToObject((dptr)->d_inode)\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+#define yaffs_SuperToDevice(sb)\t((yaffs_Device *)sb->s_fs_info)\n+#else\n+#define yaffs_SuperToDevice(sb)\t((yaffs_Device *)sb->u.generic_sbp)\n+#endif\n+\n+static void yaffs_put_super(struct super_block *sb);\n+\n+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,\n+\t\t\t\tloff_t * pos);\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_file_flush(struct file *file, fl_owner_t id);\n+#else\n+static int yaffs_file_flush(struct file *file);\n+#endif\n+\n+static int yaffs_sync_object(struct file *file, struct dentry *dentry,\n+\t\t\t     int datasync);\n+\n+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t\tstruct nameidata *n);\n+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,\n+\t\t\t\t   struct nameidata *n);\n+#else\n+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);\n+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);\n+#endif\n+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,\n+\t\t      struct dentry *dentry);\n+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);\n+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,\n+\t\t\t const char *symname);\n+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t       dev_t dev);\n+#else\n+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t       int dev);\n+#endif\n+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n+\t\t\tstruct inode *new_dir, struct dentry *new_dentry);\n+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_sync_fs(struct super_block *sb, int wait);\n+static void yaffs_write_super(struct super_block *sb);\n+#else\n+static int yaffs_sync_fs(struct super_block *sb);\n+static int yaffs_write_super(struct super_block *sb);\n+#endif\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);\n+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);\n+#else\n+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);\n+#endif\n+\n+static void yaffs_put_inode(struct inode *inode);\n+static void yaffs_delete_inode(struct inode *);\n+static void yaffs_clear_inode(struct inode *);\n+\n+static int yaffs_readpage(struct file *file, struct page *page);\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);\n+#else\n+static int yaffs_writepage(struct page *page);\n+#endif\n+static int yaffs_prepare_write(struct file *f, struct page *pg,\n+\t\t\t       unsigned offset, unsigned to);\n+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,\n+\t\t\t      unsigned to);\n+\n+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,\n+\t\t\t  int buflen);\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))\n+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);\n+#else\n+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);\n+#endif\n+\n+static struct address_space_operations yaffs_file_address_operations = {\n+\t.readpage = yaffs_readpage,\n+\t.writepage = yaffs_writepage,\n+\t.prepare_write = yaffs_prepare_write,\n+\t.commit_write = yaffs_commit_write,\n+};\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))\n+static struct file_operations yaffs_file_operations = {\n+\t.read = do_sync_read,\n+\t.write = do_sync_write,\n+\t.aio_read = generic_file_aio_read,\n+\t.aio_write = generic_file_aio_write,\n+\t.mmap = generic_file_mmap,\n+\t.flush = yaffs_file_flush,\n+\t.fsync = yaffs_sync_object,\n+\t.splice_read = generic_file_splice_read,\n+\t.splice_write = generic_file_splice_write,\n+};\n+\n+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))\n+\n+static struct file_operations yaffs_file_operations = {\n+\t.read = do_sync_read,\n+\t.write = do_sync_write,\n+\t.aio_read = generic_file_aio_read,\n+\t.aio_write = generic_file_aio_write,\n+\t.mmap = generic_file_mmap,\n+\t.flush = yaffs_file_flush,\n+\t.fsync = yaffs_sync_object,\n+\t.sendfile = generic_file_sendfile,\n+};\n+\n+#else\n+\n+static struct file_operations yaffs_file_operations = {\n+\t.read = generic_file_read,\n+\t.write = generic_file_write,\n+\t.mmap = generic_file_mmap,\n+\t.flush = yaffs_file_flush,\n+\t.fsync = yaffs_sync_object,\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\t.sendfile = generic_file_sendfile,\n+#endif\n+};\n+#endif\n+\n+static struct inode_operations yaffs_file_inode_operations = {\n+\t.setattr = yaffs_setattr,\n+};\n+\n+static struct inode_operations yaffs_symlink_inode_operations = {\n+\t.readlink = yaffs_readlink,\n+\t.follow_link = yaffs_follow_link,\n+\t.setattr = yaffs_setattr,\n+};\n+\n+static struct inode_operations yaffs_dir_inode_operations = {\n+\t.create = yaffs_create,\n+\t.lookup = yaffs_lookup,\n+\t.link = yaffs_link,\n+\t.unlink = yaffs_unlink,\n+\t.symlink = yaffs_symlink,\n+\t.mkdir = yaffs_mkdir,\n+\t.rmdir = yaffs_unlink,\n+\t.mknod = yaffs_mknod,\n+\t.rename = yaffs_rename,\n+\t.setattr = yaffs_setattr,\n+};\n+\n+static struct file_operations yaffs_dir_operations = {\n+\t.read = generic_read_dir,\n+\t.readdir = yaffs_readdir,\n+\t.fsync = yaffs_sync_object,\n+};\n+\n+static struct super_operations yaffs_super_ops = {\n+\t.statfs = yaffs_statfs,\n+\n+#ifndef YAFFS_USE_OWN_IGET\n+\t.read_inode = yaffs_read_inode,\n+#endif\n+\t.put_inode = yaffs_put_inode,\n+\t.put_super = yaffs_put_super,\n+\t.delete_inode = yaffs_delete_inode,\n+\t.clear_inode = yaffs_clear_inode,\n+\t.sync_fs = yaffs_sync_fs,\n+\t.write_super = yaffs_write_super,\n+};\n+\n+static void yaffs_GrossLock(yaffs_Device * dev)\n+{\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs locking\\n"));\n+\n+\tdown(&dev->grossLock);\n+}\n+\n+static void yaffs_GrossUnlock(yaffs_Device * dev)\n+{\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs unlocking\\n"));\n+\tup(&dev->grossLock);\n+\n+}\n+\n+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,\n+\t\t\t  int buflen)\n+{\n+\tunsigned char *alias;\n+\tint ret;\n+\n+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\talias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (!alias)\n+\t\treturn -ENOMEM;\n+\n+\tret = vfs_readlink(dentry, buffer, buflen, alias);\n+\tkfree(alias);\n+\treturn ret;\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))\n+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)\n+#else\n+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)\n+#endif\n+{\n+\tunsigned char *alias;\n+\tint ret;\n+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\talias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (!alias)\n+        {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+        }\n+\n+\tret = vfs_follow_link(nd, alias);\n+\tkfree(alias);\n+out:\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))\n+\treturn ERR_PTR (ret);\n+#else\n+\treturn ret;\n+#endif\n+}\n+\n+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,\n+\t\t\t      yaffs_Object * obj);\n+\n+/*\n+ * Lookup is used to find objects in the fs\n+ */\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\n+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,\n+\t\t\t\t   struct nameidata *n)\n+#else\n+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)\n+#endif\n+{\n+\tyaffs_Object *obj;\n+\tstruct inode *inode = NULL;\t/* NCB 2.5/2.6 needs NULL here */\n+\n+\tyaffs_Device *dev = yaffs_InodeToObject(dir)->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_lookup for %d:%s\\n",\n+\t   yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));\n+\n+\tobj =\n+\t    yaffs_FindObjectByName(yaffs_InodeToObject(dir),\n+\t\t\t\t   dentry->d_name.name);\n+\n+\tobj = yaffs_GetEquivalentObject(obj);\t/* in case it was a hardlink */\n+\n+\t/* Can\'t hold gross lock when calling yaffs_get_inode() */\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (obj) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_lookup found %d\\n", obj->objectId));\n+\n+\t\tinode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);\n+\n+\t\tif (inode) {\n+\t\t\tT(YAFFS_TRACE_OS,\n+\t\t\t  (KERN_DEBUG "yaffs_loookup dentry \\n"));\n+/* #if 0 asserted by NCB for 2.5/6 compatability - falls through to\n+ * d_add even if NULL inode */\n+#if 0\n+\t\t\t/*dget(dentry); // try to solve directory bug */\n+\t\t\td_add(dentry, inode);\n+\n+\t\t\t/* return dentry; */\n+\t\t\treturn NULL;\n+#endif\n+\t\t}\n+\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_lookup not found\\n"));\n+\n+\t}\n+\n+/* added NCB for 2.5/6 compatability - forces add even if inode is\n+ * NULL which creates dentry hash */\n+\td_add(dentry, inode);\n+\n+\treturn NULL;\n+\t/*      return (ERR_PTR(-EIO)); */\n+\n+}\n+\n+/* For now put inode is just for debugging\n+ * Put inode is called when the inode **structure** is put.\n+ */\n+static void yaffs_put_inode(struct inode *inode)\n+{\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs_put_inode: ino %d, count %d\\n", (int)inode->i_ino,\n+\t   atomic_read(&inode->i_count)));\n+\n+}\n+\n+/* clear is called to tell the fs to release any per-inode data it holds */\n+static void yaffs_clear_inode(struct inode *inode)\n+{\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev;\n+\n+\tobj = yaffs_InodeToObject(inode);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs_clear_inode: ino %d, count %d %s\\n", (int)inode->i_ino,\n+\t   atomic_read(&inode->i_count),\n+\t   obj ? "object exists" : "null object"));\n+\n+\tif (obj) {\n+\t\tdev = obj->myDev;\n+\t\tyaffs_GrossLock(dev);\n+\n+\t\t/* Clear the association between the inode and\n+\t\t * the yaffs_Object.\n+\t\t */\n+\t\tobj->myInode = NULL;\n+\t\tyaffs_InodeToObjectLV(inode) = NULL;\n+\n+\t\t/* If the object freeing was deferred, then the real\n+\t\t * free happens now.\n+\t\t * This should fix the inode inconsistency problem.\n+\t\t */\n+\n+\t\tyaffs_HandleDeferedFree(obj);\n+\n+\t\tyaffs_GrossUnlock(dev);\n+\t}\n+\n+}\n+\n+/* delete is called when the link count is zero and the inode\n+ * is put (ie. nobody wants to know about it anymore, time to\n+ * delete the file).\n+ * NB Must call clear_inode()\n+ */\n+static void yaffs_delete_inode(struct inode *inode)\n+{\n+\tyaffs_Object *obj = yaffs_InodeToObject(inode);\n+\tyaffs_Device *dev;\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs_delete_inode: ino %d, count %d %s\\n", (int)inode->i_ino,\n+\t   atomic_read(&inode->i_count),\n+\t   obj ? "object exists" : "null object"));\n+\n+\tif (obj) {\n+\t\tdev = obj->myDev;\n+\t\tyaffs_GrossLock(dev);\n+\t\tyaffs_DeleteFile(obj);\n+\t\tyaffs_GrossUnlock(dev);\n+\t}\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))\n+        truncate_inode_pages (&inode->i_data, 0);\n+#endif\n+\tclear_inode(inode);\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_file_flush(struct file *file, fl_owner_t id)\n+#else\n+static int yaffs_file_flush(struct file *file)\n+#endif\n+{\n+\tyaffs_Object *obj = yaffs_DentryToObject(file->f_dentry);\n+\n+\tyaffs_Device *dev = obj->myDev;\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_file_flush object %d (%s)\\n", obj->objectId,\n+\t   obj->dirty ? "dirty" : "clean"));\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tyaffs_FlushFile(obj, 1);\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\treturn 0;\n+}\n+\n+static int yaffs_readpage_nolock(struct file *f, struct page *pg)\n+{\n+\t/* Lifted from jffs2 */\n+\n+\tyaffs_Object *obj;\n+\tunsigned char *pg_buf;\n+\tint ret;\n+\n+\tyaffs_Device *dev;\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage at %08x, size %08x\\n",\n+\t\t\t   (unsigned)(pg->index << PAGE_CACHE_SHIFT),\n+\t\t\t   (unsigned)PAGE_CACHE_SIZE));\n+\n+\tobj = yaffs_DentryToObject(f->f_dentry);\n+\n+\tdev = obj->myDev;\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\tBUG_ON(!PageLocked(pg));\n+#else\n+\tif (!PageLocked(pg))\n+\t\tPAGE_BUG(pg);\n+#endif\n+\n+\tpg_buf = kmap(pg);\n+\t/* FIXME: Can kmap fail? */\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tret =\n+\t    yaffs_ReadDataFromFile(obj, pg_buf, pg->index << PAGE_CACHE_SHIFT,\n+\t\t\t\t   PAGE_CACHE_SIZE);\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (ret >= 0)\n+\t\tret = 0;\n+\n+\tif (ret) {\n+\t\tClearPageUptodate(pg);\n+\t\tSetPageError(pg);\n+\t} else {\n+\t\tSetPageUptodate(pg);\n+\t\tClearPageError(pg);\n+\t}\n+\n+\tflush_dcache_page(pg);\n+\tkunmap(pg);\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_readpage done\\n"));\n+\treturn ret;\n+}\n+\n+static int yaffs_readpage_unlock(struct file *f, struct page *pg)\n+{\n+\tint ret = yaffs_readpage_nolock(f, pg);\n+\tUnlockPage(pg);\n+\treturn ret;\n+}\n+\n+static int yaffs_readpage(struct file *f, struct page *pg)\n+{\n+\treturn yaffs_readpage_unlock(f, pg);\n+}\n+\n+/* writepage inspired by/stolen from smbfs */\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)\n+#else\n+static int yaffs_writepage(struct page *page)\n+#endif\n+{\n+\tstruct address_space *mapping = page->mapping;\n+\tloff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;\n+\tstruct inode *inode;\n+\tunsigned long end_index;\n+\tchar *buffer;\n+\tyaffs_Object *obj;\n+\tint nWritten = 0;\n+\tunsigned nBytes;\n+\n+\tif (!mapping)\n+\t\tBUG();\n+\tinode = mapping->host;\n+\tif (!inode)\n+\t\tBUG();\n+\n+\tif (offset > inode->i_size) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG\n+\t\t   "yaffs_writepage at %08x, inode size = %08x!!!\\n",\n+\t\t   (unsigned)(page->index << PAGE_CACHE_SHIFT),\n+\t\t   (unsigned)inode->i_size));\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "                -> don\'t care!!\\n"));\n+\t\tunlock_page(page);\n+\t\treturn 0;\n+\t}\n+\n+\tend_index = inode->i_size >> PAGE_CACHE_SHIFT;\n+\n+\t/* easy case */\n+\tif (page->index < end_index) {\n+\t\tnBytes = PAGE_CACHE_SIZE;\n+\t} else {\n+\t\tnBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);\n+\t}\n+\n+\tget_page(page);\n+\n+\tbuffer = kmap(page);\n+\n+\tobj = yaffs_InodeToObject(inode);\n+\tyaffs_GrossLock(obj->myDev);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_writepage at %08x, size %08x\\n",\n+\t   (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "writepag0: obj = %05x, ino = %05x\\n",\n+\t   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));\n+\n+\tnWritten =\n+\t    yaffs_WriteDataToFile(obj, buffer, page->index << PAGE_CACHE_SHIFT,\n+\t\t\t\t  nBytes, 0);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "writepag1: obj = %05x, ino = %05x\\n",\n+\t   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));\n+\n+\tyaffs_GrossUnlock(obj->myDev);\n+\n+\tkunmap(page);\n+\tSetPageUptodate(page);\n+\tUnlockPage(page);\n+\tput_page(page);\n+\n+\treturn (nWritten == nBytes) ? 0 : -ENOSPC;\n+}\n+\n+static int yaffs_prepare_write(struct file *f, struct page *pg,\n+\t\t\t       unsigned offset, unsigned to)\n+{\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_prepair_write\\n"));\n+\tif (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))\n+\t\treturn yaffs_readpage_nolock(f, pg);\n+\n+\treturn 0;\n+\n+}\n+\n+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,\n+\t\t\t      unsigned to)\n+{\n+\n+\tvoid *addr = page_address(pg) + offset;\n+\tloff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;\n+\tint nBytes = to - offset;\n+\tint nWritten;\n+\n+\tunsigned spos = pos;\n+\tunsigned saddr = (unsigned)addr;\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_commit_write addr %x pos %x nBytes %d\\n", saddr,\n+\t   spos, nBytes));\n+\n+\tnWritten = yaffs_file_write(f, addr, nBytes, &pos);\n+\n+\tif (nWritten != nBytes) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG\n+\t\t   "yaffs_commit_write not same size nWritten %d  nBytes %d\\n",\n+\t\t   nWritten, nBytes));\n+\t\tSetPageError(pg);\n+\t\tClearPageUptodate(pg);\n+\t} else {\n+\t\tSetPageUptodate(pg);\n+\t}\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_commit_write returning %d\\n",\n+\t   nWritten == nBytes ? 0 : nWritten));\n+\n+\treturn nWritten == nBytes ? 0 : nWritten;\n+\n+}\n+\n+static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)\n+{\n+\tif (inode && obj) {\n+\n+\n+\t\t/* Check mode against the variant type and attempt to repair if broken. */\n+ \t\t__u32 mode = obj->yst_mode;\n+ \t\tswitch( obj->variantType ){\n+ \t\tcase YAFFS_OBJECT_TYPE_FILE :\n+ \t\t        if( ! S_ISREG(mode) ){\n+ \t\t\t        obj->yst_mode &= ~S_IFMT;\n+ \t\t\t        obj->yst_mode |= S_IFREG;\n+ \t\t\t}\n+\n+ \t\t\tbreak;\n+ \t\tcase YAFFS_OBJECT_TYPE_SYMLINK :\n+ \t\t        if( ! S_ISLNK(mode) ){\n+ \t\t\t        obj->yst_mode &= ~S_IFMT;\n+ \t\t\t\tobj->yst_mode |= S_IFLNK;\n+ \t\t\t}\n+\n+ \t\t\tbreak;\n+ \t\tcase YAFFS_OBJECT_TYPE_DIRECTORY :\n+ \t\t        if( ! S_ISDIR(mode) ){\n+ \t\t\t        obj->yst_mode &= ~S_IFMT;\n+ \t\t\t        obj->yst_mode |= S_IFDIR;\n+ \t\t\t}\n+\n+ \t\t\tbreak;\n+ \t\tcase YAFFS_OBJECT_TYPE_UNKNOWN :\n+ \t\tcase YAFFS_OBJECT_TYPE_HARDLINK :\n+ \t\tcase YAFFS_OBJECT_TYPE_SPECIAL :\n+ \t\tdefault:\n+ \t\t        /* TODO? */\n+ \t\t        break;\n+ \t\t}\n+\n+ \t\tinode->i_flags |= S_NOATIME;\n+\n+\t\tinode->i_ino = obj->objectId;\n+\t\tinode->i_mode = obj->yst_mode;\n+\t\tinode->i_uid = obj->yst_uid;\n+\t\tinode->i_gid = obj->yst_gid;\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))\n+\t\tinode->i_blksize = inode->i_sb->s_blocksize;\n+#endif\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\n+\t\tinode->i_rdev = old_decode_dev(obj->yst_rdev);\n+\t\tinode->i_atime.tv_sec = (time_t) (obj->yst_atime);\n+\t\tinode->i_atime.tv_nsec = 0;\n+\t\tinode->i_mtime.tv_sec = (time_t) obj->yst_mtime;\n+\t\tinode->i_mtime.tv_nsec = 0;\n+\t\tinode->i_ctime.tv_sec = (time_t) obj->yst_ctime;\n+\t\tinode->i_ctime.tv_nsec = 0;\n+#else\n+\t\tinode->i_rdev = obj->yst_rdev;\n+\t\tinode->i_atime = obj->yst_atime;\n+\t\tinode->i_mtime = obj->yst_mtime;\n+\t\tinode->i_ctime = obj->yst_ctime;\n+#endif\n+\t\tinode->i_size = yaffs_GetObjectFileLength(obj);\n+\t\tinode->i_blocks = (inode->i_size + 511) >> 9;\n+\n+\t\tinode->i_nlink = yaffs_GetObjectLinkCount(obj);\n+\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG\n+\t\t   "yaffs_FillInode mode %x uid %d gid %d size %d count %d\\n",\n+\t\t   inode->i_mode, inode->i_uid, inode->i_gid,\n+\t\t   (int)inode->i_size, atomic_read(&inode->i_count)));\n+\n+\t\tswitch (obj->yst_mode & S_IFMT) {\n+\t\tdefault:\t/* fifo, device or socket */\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\t\t\tinit_special_inode(inode, obj->yst_mode,\n+\t\t\t\t\t   old_decode_dev(obj->yst_rdev));\n+#else\n+\t\t\tinit_special_inode(inode, obj->yst_mode,\n+\t\t\t\t\t   (dev_t) (obj->yst_rdev));\n+#endif\n+\t\t\tbreak;\n+\t\tcase S_IFREG:\t/* file */\n+\t\t\tinode->i_op = &yaffs_file_inode_operations;\n+\t\t\tinode->i_fop = &yaffs_file_operations;\n+\t\t\tinode->i_mapping->a_ops =\n+\t\t\t    &yaffs_file_address_operations;\n+\t\t\tbreak;\n+\t\tcase S_IFDIR:\t/* directory */\n+\t\t\tinode->i_op = &yaffs_dir_inode_operations;\n+\t\t\tinode->i_fop = &yaffs_dir_operations;\n+\t\t\tbreak;\n+\t\tcase S_IFLNK:\t/* symlink */\n+\t\t\tinode->i_op = &yaffs_symlink_inode_operations;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tyaffs_InodeToObjectLV(inode) = obj;\n+\n+\t\tobj->myInode = inode;\n+\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_FileInode invalid parameters\\n"));\n+\t}\n+\n+}\n+\n+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,\n+\t\t\t      yaffs_Object * obj)\n+{\n+\tstruct inode *inode;\n+\n+\tif (!sb) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_get_inode for NULL super_block!!\\n"));\n+\t\treturn NULL;\n+\n+\t}\n+\n+\tif (!obj) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_get_inode for NULL object!!\\n"));\n+\t\treturn NULL;\n+\n+\t}\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_get_inode for object %d\\n", obj->objectId));\n+\n+\tinode = Y_IGET(sb, obj->objectId);\n+\tif(IS_ERR(inode))\n+\t  return NULL;\n+\n+\t/* NB Side effect: iget calls back to yaffs_read_inode(). */\n+\t/* iget also increments the inode\'s i_count */\n+\t/* NB You can\'t be holding grossLock or deadlock will happen! */\n+\n+\treturn inode;\n+}\n+\n+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,\n+\t\t\t\tloff_t * pos)\n+{\n+\tyaffs_Object *obj;\n+\tint nWritten, ipos;\n+\tstruct inode *inode;\n+\tyaffs_Device *dev;\n+\n+\tobj = yaffs_DentryToObject(f->f_dentry);\n+\n+\tdev = obj->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tinode = f->f_dentry->d_inode;\n+\n+\tif (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND) {\n+\t\tipos = inode->i_size;\n+\t} else {\n+\t\tipos = *pos;\n+\t}\n+\n+\tif (!obj) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_file_write: hey obj is null!\\n"));\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG\n+\t\t   "yaffs_file_write about to write writing %d bytes"\n+\t\t   "to object %d at %d\\n",\n+\t\t   n, obj->objectId, ipos));\n+\t}\n+\n+\tnWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_file_write writing %d bytes, %d written at %d\\n",\n+\t   n, nWritten, ipos));\n+\tif (nWritten > 0) {\n+\t\tipos += nWritten;\n+\t\t*pos = ipos;\n+\t\tif (ipos > inode->i_size) {\n+\t\t\tinode->i_size = ipos;\n+\t\t\tinode->i_blocks = (ipos + 511) >> 9;\n+\n+\t\t\tT(YAFFS_TRACE_OS,\n+\t\t\t  (KERN_DEBUG\n+\t\t\t   "yaffs_file_write size updated to %d bytes, "\n+\t\t\t   "%d blocks\\n",\n+\t\t\t   ipos, (int)(inode->i_blocks)));\n+\t\t}\n+\n+\t}\n+\tyaffs_GrossUnlock(dev);\n+\treturn nWritten == 0 ? -ENOSPC : nWritten;\n+}\n+\n+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)\n+{\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev;\n+\tstruct inode *inode = f->f_dentry->d_inode;\n+\tunsigned long offset, curoffs;\n+\tstruct ylist_head *i;\n+\tyaffs_Object *l;\n+\n+\tchar name[YAFFS_MAX_NAME_LENGTH + 1];\n+\n+\tobj = yaffs_DentryToObject(f->f_dentry);\n+\tdev = obj->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\toffset = f->f_pos;\n+\n+\tT(YAFFS_TRACE_OS, ("yaffs_readdir: starting at %d\\n", (int)offset));\n+\n+\tif (offset == 0) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_readdir: entry . ino %d \\n",\n+\t\t   (int)inode->i_ino));\n+\t\tif (filldir(dirent, ".", 1, offset, inode->i_ino, DT_DIR)\n+\t\t    < 0) {\n+\t\t\tgoto out;\n+\t\t}\n+\t\toffset++;\n+\t\tf->f_pos++;\n+\t}\n+\tif (offset == 1) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_readdir: entry .. ino %d \\n",\n+\t\t   (int)f->f_dentry->d_parent->d_inode->i_ino));\n+\t\tif (filldir\n+\t\t    (dirent, "..", 2, offset,\n+\t\t     f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0) {\n+\t\t\tgoto out;\n+\t\t}\n+\t\toffset++;\n+\t\tf->f_pos++;\n+\t}\n+\n+\tcuroffs = 1;\n+\n+\t/* If the directory has changed since the open or last call to\n+\t   readdir, rewind to after the 2 canned entries. */\n+\n+\tif (f->f_version != inode->i_version) {\n+\t\toffset = 2;\n+\t\tf->f_pos = offset;\n+\t\tf->f_version = inode->i_version;\n+\t}\n+\n+\tylist_for_each(i, &obj->variant.directoryVariant.children) {\n+\t\tcuroffs++;\n+\t\tif (curoffs >= offset) {\n+\t\t\tl = ylist_entry(i, yaffs_Object, siblings);\n+\n+\t\t\tyaffs_GetObjectName(l, name,\n+\t\t\t\t\t    YAFFS_MAX_NAME_LENGTH + 1);\n+\t\t\tT(YAFFS_TRACE_OS,\n+\t\t\t  (KERN_DEBUG "yaffs_readdir: %s inode %d\\n", name,\n+\t\t\t   yaffs_GetObjectInode(l)));\n+\n+\t\t\tif (filldir(dirent,\n+\t\t\t\t    name,\n+\t\t\t\t    strlen(name),\n+\t\t\t\t    offset,\n+\t\t\t\t    yaffs_GetObjectInode(l),\n+\t\t\t\t    yaffs_GetObjectType(l))\n+\t\t\t    < 0) {\n+\t\t\t\tgoto up_and_out;\n+\t\t\t}\n+\n+\t\t\toffset++;\n+\t\t\tf->f_pos++;\n+\t\t}\n+\t}\n+\n+      up_and_out:\n+      out:\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\treturn 0;\n+}\n+\n+/*\n+ * File creation. Allocate an inode, and we\'re done..\n+ */\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t       dev_t rdev)\n+#else\n+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t       int rdev)\n+#endif\n+{\n+\tstruct inode *inode;\n+\n+\tyaffs_Object *obj = NULL;\n+\tyaffs_Device *dev;\n+\n+\tyaffs_Object *parent = yaffs_InodeToObject(dir);\n+\n+\tint error = -ENOSPC;\n+\tuid_t uid = current->fsuid;\n+\tgid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;\n+\n+\tif((dir->i_mode & S_ISGID) && S_ISDIR(mode))\n+\t\tmode |= S_ISGID;\n+\n+\tif (parent) {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_mknod: parent object %d type %d\\n",\n+\t\t   parent->objectId, parent->variantType));\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_mknod: could not get parent object\\n"));\n+\t\treturn -EPERM;\n+\t}\n+\n+\tT(YAFFS_TRACE_OS, ("yaffs_mknod: making oject for %s, "\n+\t\t\t   "mode %x dev %x\\n",\n+\t\t\t   dentry->d_name.name, mode, rdev));\n+\n+\tdev = parent->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tswitch (mode & S_IFMT) {\n+\tdefault:\n+\t\t/* Special (socket, fifo, device...) */\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG\n+\t\t\t\t   "yaffs_mknod: making special\\n"));\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\t\tobj =\n+\t\t    yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,\n+\t\t\t\t       gid, old_encode_dev(rdev));\n+#else\n+\t\tobj =\n+\t\t    yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,\n+\t\t\t\t       gid, rdev);\n+#endif\n+\t\tbreak;\n+\tcase S_IFREG:\t\t/* file          */\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\\n"));\n+\t\tobj =\n+\t\t    yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,\n+\t\t\t\t    gid);\n+\t\tbreak;\n+\tcase S_IFDIR:\t\t/* directory */\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_mknod: making directory\\n"));\n+\t\tobj =\n+\t\t    yaffs_MknodDirectory(parent, dentry->d_name.name, mode,\n+\t\t\t\t\t uid, gid);\n+\t\tbreak;\n+\tcase S_IFLNK:\t\t/* symlink */\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mknod: making file\\n"));\n+\t\tobj = NULL;\t/* Do we ever get here? */\n+\t\tbreak;\n+\t}\n+\n+\t/* Can not call yaffs_get_inode() with gross lock held */\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (obj) {\n+\t\tinode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);\n+\t\td_instantiate(dentry, inode);\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_mknod created object %d count = %d\\n",\n+\t\t   obj->objectId, atomic_read(&inode->i_count)));\n+\t\terror = 0;\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_mknod failed making object\\n"));\n+\t\terror = -ENOMEM;\n+\t}\n+\n+\treturn error;\n+}\n+\n+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n+{\n+\tint retVal;\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_mkdir\\n"));\n+\tretVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);\n+#if 0\n+\t/* attempt to fix dir bug - didn\'t work */\n+\tif (!retVal) {\n+\t\tdget(dentry);\n+\t}\n+#endif\n+\treturn retVal;\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t\tstruct nameidata *n)\n+#else\n+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)\n+#endif\n+{\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_create\\n"));\n+\treturn yaffs_mknod(dir, dentry, mode | S_IFREG, 0);\n+}\n+\n+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)\n+{\n+\tint retVal;\n+\n+\tyaffs_Device *dev;\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_unlink %d:%s\\n", (int)(dir->i_ino),\n+\t   dentry->d_name.name));\n+\n+\tdev = yaffs_InodeToObject(dir)->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tretVal = yaffs_Unlink(yaffs_InodeToObject(dir), dentry->d_name.name);\n+\n+\tif (retVal == YAFFS_OK) {\n+\t\tdentry->d_inode->i_nlink--;\n+\t\tdir->i_version++;\n+\t\tyaffs_GrossUnlock(dev);\n+\t\tmark_inode_dirty(dentry->d_inode);\n+\t\treturn 0;\n+\t}\n+\tyaffs_GrossUnlock(dev);\n+\treturn -ENOTEMPTY;\n+}\n+\n+/*\n+ * Create a link...\n+ */\n+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,\n+\t\t      struct dentry *dentry)\n+{\n+\tstruct inode *inode = old_dentry->d_inode;\n+\tyaffs_Object *obj = NULL;\n+\tyaffs_Object *link = NULL;\n+\tyaffs_Device *dev;\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_link\\n"));\n+\n+\tobj = yaffs_InodeToObject(inode);\n+\tdev = obj->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tif (!S_ISDIR(inode->i_mode))\t/* Don\'t link directories */\n+\t{\n+\t\tlink =\n+\t\t    yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,\n+\t\t\t       obj);\n+\t}\n+\n+\tif (link) {\n+\t\told_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);\n+\t\td_instantiate(dentry, old_dentry->d_inode);\n+\t\tatomic_inc(&old_dentry->d_inode->i_count);\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t  (KERN_DEBUG "yaffs_link link count %d i_count %d\\n",\n+\t\t   old_dentry->d_inode->i_nlink,\n+\t\t   atomic_read(&old_dentry->d_inode->i_count)));\n+\n+\t}\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (link) {\n+\n+\t\treturn 0;\n+\t}\n+\n+\treturn -EPERM;\n+}\n+\n+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,\n+\t\t\t const char *symname)\n+{\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev;\n+\tuid_t uid = current->fsuid;\n+\tgid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_symlink\\n"));\n+\n+\tdev = yaffs_InodeToObject(dir)->myDev;\n+\tyaffs_GrossLock(dev);\n+\tobj = yaffs_MknodSymLink(yaffs_InodeToObject(dir), dentry->d_name.name,\n+\t\t\t\t S_IFLNK | S_IRWXUGO, uid, gid, symname);\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (obj) {\n+\n+\t\tstruct inode *inode;\n+\n+\t\tinode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);\n+\t\td_instantiate(dentry, inode);\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG "symlink created OK\\n"));\n+\t\treturn 0;\n+\t} else {\n+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG "symlink not created\\n"));\n+\n+\t}\n+\n+\treturn -ENOMEM;\n+}\n+\n+static int yaffs_sync_object(struct file *file, struct dentry *dentry,\n+\t\t\t     int datasync)\n+{\n+\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev;\n+\n+\tobj = yaffs_DentryToObject(dentry);\n+\n+\tdev = obj->myDev;\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_object\\n"));\n+\tyaffs_GrossLock(dev);\n+\tyaffs_FlushFile(obj, 1);\n+\tyaffs_GrossUnlock(dev);\n+\treturn 0;\n+}\n+\n+/*\n+ * The VFS layer already does all the dentry stuff for rename.\n+ *\n+ * NB: POSIX says you can rename an object over an old object of the same name\n+ */\n+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,\n+\t\t\tstruct inode *new_dir, struct dentry *new_dentry)\n+{\n+\tyaffs_Device *dev;\n+\tint retVal = YAFFS_FAIL;\n+\tyaffs_Object *target;\n+\n+        T(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_rename\\n"));\n+\tdev = yaffs_InodeToObject(old_dir)->myDev;\n+\n+\tyaffs_GrossLock(dev);\n+\n+\t/* Check if the target is an existing directory that is not empty. */\n+\ttarget =\n+\t    yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),\n+\t\t\t\t   new_dentry->d_name.name);\n+\n+\n+\n+\tif (target &&\n+\t    target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&\n+\t    !ylist_empty(&target->variant.directoryVariant.children)) {\n+\n+\t        T(YAFFS_TRACE_OS, (KERN_DEBUG "target is non-empty dir\\n"));\n+\n+\t\tretVal = YAFFS_FAIL;\n+\t} else {\n+\n+\t\t/* Now does unlinking internally using shadowing mechanism */\n+\t        T(YAFFS_TRACE_OS, (KERN_DEBUG "calling yaffs_RenameObject\\n"));\n+\n+\t\tretVal =\n+\t\t    yaffs_RenameObject(yaffs_InodeToObject(old_dir),\n+\t\t\t\t       old_dentry->d_name.name,\n+\t\t\t\t       yaffs_InodeToObject(new_dir),\n+\t\t\t\t       new_dentry->d_name.name);\n+\n+\t}\n+\tyaffs_GrossUnlock(dev);\n+\n+\tif (retVal == YAFFS_OK) {\n+\t\tif(target) {\n+\t\t\tnew_dentry->d_inode->i_nlink--;\n+\t\t\tmark_inode_dirty(new_dentry->d_inode);\n+\t\t}\n+\n+\t\treturn 0;\n+\t} else {\n+\t\treturn -ENOTEMPTY;\n+\t}\n+\n+}\n+\n+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)\n+{\n+\tstruct inode *inode = dentry->d_inode;\n+\tint error;\n+\tyaffs_Device *dev;\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_setattr of object %d\\n",\n+\t   yaffs_InodeToObject(inode)->objectId));\n+\n+\tif ((error = inode_change_ok(inode, attr)) == 0) {\n+\n+\t\tdev = yaffs_InodeToObject(inode)->myDev;\n+\t\tyaffs_GrossLock(dev);\n+\t\tif (yaffs_SetAttributes(yaffs_InodeToObject(inode), attr) ==\n+\t\t    YAFFS_OK) {\n+\t\t\terror = 0;\n+\t\t} else {\n+\t\t\terror = -EPERM;\n+\t\t}\n+\t\tyaffs_GrossUnlock(dev);\n+\t\tif (!error)\n+\t\t\terror = inode_setattr(inode, attr);\n+\t}\n+\treturn error;\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)\n+{\n+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;\n+\tstruct super_block *sb = dentry->d_sb;\n+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)\n+{\n+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);\n+#else\n+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)\n+{\n+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);\n+#endif\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_statfs\\n"));\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tbuf->f_type = YAFFS_MAGIC;\n+\tbuf->f_bsize = sb->s_blocksize;\n+\tbuf->f_namelen = 255;\n+\n+\tif(dev->nDataBytesPerChunk & (dev->nDataBytesPerChunk - 1)){\n+\t\t/* Do this if chunk size is not a power of 2 */\n+\n+\t\tuint64_t bytesInDev;\n+\t\tuint64_t bytesFree;\n+\n+\t\tbytesInDev = ((uint64_t)((dev->endBlock - dev->startBlock +1))) *\n+\t\t\t     ((uint64_t)(dev->nChunksPerBlock * dev->nDataBytesPerChunk));\n+\n+\t\tdo_div(bytesInDev,sb->s_blocksize); /* bytesInDev becomes the number of blocks */\n+\t\tbuf->f_blocks = bytesInDev;\n+\n+\t\tbytesFree  = ((uint64_t)(yaffs_GetNumberOfFreeChunks(dev))) *\n+\t\t\t     ((uint64_t)(dev->nDataBytesPerChunk));\n+\n+\t\tdo_div(bytesFree,sb->s_blocksize);\n+\n+\t\tbuf->f_bfree = bytesFree;\n+\n+\t} else if (sb->s_blocksize > dev->nDataBytesPerChunk) {\n+\n+\t\tbuf->f_blocks =\n+\t                   (dev->endBlock - dev->startBlock + 1) *\n+\t                    dev->nChunksPerBlock /\n+\t                    (sb->s_blocksize / dev->nDataBytesPerChunk);\n+\t        buf->f_bfree =\n+\t                   yaffs_GetNumberOfFreeChunks(dev) /\n+\t                   (sb->s_blocksize / dev->nDataBytesPerChunk);\n+\t} else {\n+\t       buf->f_blocks =\n+\t                   (dev->endBlock - dev->startBlock + 1) *\n+\t                   dev->nChunksPerBlock *\n+\t                   (dev->nDataBytesPerChunk / sb->s_blocksize);\n+\n+\t               buf->f_bfree =\n+\t                   yaffs_GetNumberOfFreeChunks(dev) *\n+\t                   (dev->nDataBytesPerChunk / sb->s_blocksize);\n+\t}\n+\n+\n+\tbuf->f_files = 0;\n+\tbuf->f_ffree = 0;\n+\tbuf->f_bavail = buf->f_bfree;\n+\n+\tyaffs_GrossUnlock(dev);\n+\treturn 0;\n+}\n+\n+\n+static int yaffs_do_sync_fs(struct super_block *sb)\n+{\n+\n+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_do_sync_fs\\n"));\n+\n+\tif(sb->s_dirt) {\n+\t\tyaffs_GrossLock(dev);\n+\n+\t\tif(dev){\n+\t\t\tyaffs_FlushEntireDeviceCache(dev);\n+\t\t\tyaffs_CheckpointSave(dev);\n+\t\t}\n+\n+\t\tyaffs_GrossUnlock(dev);\n+\n+\t\tsb->s_dirt = 0;\n+\t}\n+\treturn 0;\n+}\n+\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static void yaffs_write_super(struct super_block *sb)\n+#else\n+static int yaffs_write_super(struct super_block *sb)\n+#endif\n+{\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_write_super\\n"));\n+\tyaffs_do_sync_fs(sb);\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))\n+\treturn 0;\n+#endif\n+}\n+\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_sync_fs(struct super_block *sb, int wait)\n+#else\n+static int yaffs_sync_fs(struct super_block *sb)\n+#endif\n+{\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_sync_fs\\n"));\n+\n+\tyaffs_do_sync_fs(sb);\n+\n+\treturn 0;\n+\n+}\n+\n+#ifdef YAFFS_USE_OWN_IGET\n+\n+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino)\n+{\n+\tstruct inode *inode;\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_iget for %lu\\n", ino));\n+\n+\tinode = iget_locked(sb, ino);\n+\tif (!inode)\n+\t\treturn ERR_PTR(-ENOMEM);\n+\tif (!(inode->i_state & I_NEW))\n+\t\treturn inode;\n+\n+       /* NB This is called as a side effect of other functions, but\n+\t* we had to release the lock to prevent deadlocks, so\n+\t* need to lock again.\n+\t*/\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tobj = yaffs_FindObjectByNumber(dev, inode->i_ino);\n+\n+\tyaffs_FillInodeFromObject(inode, obj);\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\tunlock_new_inode(inode);\n+\treturn inode;\n+}\n+\n+#else\n+\n+static void yaffs_read_inode(struct inode *inode)\n+{\n+\t/* NB This is called as a side effect of other functions, but\n+\t * we had to release the lock to prevent deadlocks, so\n+\t * need to lock again.\n+\t */\n+\n+\tyaffs_Object *obj;\n+\tyaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  (KERN_DEBUG "yaffs_read_inode for %d\\n", (int)inode->i_ino));\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tobj = yaffs_FindObjectByNumber(dev, inode->i_ino);\n+\n+\tyaffs_FillInodeFromObject(inode, obj);\n+\n+\tyaffs_GrossUnlock(dev);\n+}\n+\n+#endif\n+\n+static YLIST_HEAD(yaffs_dev_list);\n+\n+#if 0 // not used\n+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)\n+{\n+\tyaffs_Device    *dev = yaffs_SuperToDevice(sb);\n+\n+\tif( *flags & MS_RDONLY ) {\n+\t\tstruct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;\n+\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t\t(KERN_DEBUG "yaffs_remount_fs: %s: RO\\n", dev->name ));\n+\n+\t\tyaffs_GrossLock(dev);\n+\n+\t\tyaffs_FlushEntireDeviceCache(dev);\n+\n+\t\tyaffs_CheckpointSave(dev);\n+\n+\t\tif (mtd->sync)\n+\t\t\tmtd->sync(mtd);\n+\n+\t\tyaffs_GrossUnlock(dev);\n+\t}\n+\telse {\n+\t\tT(YAFFS_TRACE_OS,\n+\t\t\t(KERN_DEBUG "yaffs_remount_fs: %s: RW\\n", dev->name ));\n+\t}\n+\n+\treturn 0;\n+}\n+#endif\n+\n+static void yaffs_put_super(struct super_block *sb)\n+{\n+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_put_super\\n"));\n+\n+\tyaffs_GrossLock(dev);\n+\n+\tyaffs_FlushEntireDeviceCache(dev);\n+\n+\tyaffs_CheckpointSave(dev);\n+\n+\tif (dev->putSuperFunc) {\n+\t\tdev->putSuperFunc(sb);\n+\t}\n+\n+\tyaffs_Deinitialise(dev);\n+\n+\tyaffs_GrossUnlock(dev);\n+\n+\t/* we assume this is protected by lock_kernel() in mount/umount */\n+\tylist_del(&dev->devList);\n+\n+\tif(dev->spareBuffer){\n+\t\tYFREE(dev->spareBuffer);\n+\t\tdev->spareBuffer = NULL;\n+\t}\n+\n+\tkfree(dev);\n+}\n+\n+\n+static void yaffs_MTDPutSuper(struct super_block *sb)\n+{\n+\n+\tstruct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;\n+\n+\tif (mtd->sync) {\n+\t\tmtd->sync(mtd);\n+\t}\n+\n+\tput_mtd_device(mtd);\n+}\n+\n+\n+static void yaffs_MarkSuperBlockDirty(void *vsb)\n+{\n+\tstruct super_block *sb = (struct super_block *)vsb;\n+\n+\tT(YAFFS_TRACE_OS, (KERN_DEBUG "yaffs_MarkSuperBlockDirty() sb = %p\\n",sb));\n+//\tif(sb)\n+//\t\tsb->s_dirt = 1;\n+}\n+\n+typedef struct {\n+\tint inband_tags;\n+\tint skip_checkpoint_read;\n+\tint skip_checkpoint_write;\n+\tint no_cache;\n+} yaffs_options;\n+\n+#define MAX_OPT_LEN 20\n+static int yaffs_parse_options(yaffs_options *options, const char *options_str)\n+{\n+\tchar cur_opt[MAX_OPT_LEN+1];\n+\tint p;\n+\tint error = 0;\n+\n+\t/* Parse through the options which is a comma seperated list */\n+\n+\twhile(options_str && *options_str && !error){\n+\t\tmemset(cur_opt,0,MAX_OPT_LEN+1);\n+\t\tp = 0;\n+\n+\t\twhile(*options_str && *options_str != \',\'){\n+\t\t\tif(p < MAX_OPT_LEN){\n+\t\t\t\tcur_opt[p] = *options_str;\n+\t\t\t\tp++;\n+\t\t\t}\n+\t\t\toptions_str++;\n+\t\t}\n+\n+\t\tif(!strcmp(cur_opt,"inband-tags"))\n+\t\t\toptions->inband_tags = 1;\n+\t\telse if(!strcmp(cur_opt,"no-cache"))\n+\t\t\toptions->no_cache = 1;\n+\t\telse if(!strcmp(cur_opt,"no-checkpoint-read"))\n+\t\t\toptions->skip_checkpoint_read = 1;\n+\t\telse if(!strcmp(cur_opt,"no-checkpoint-write"))\n+\t\t\toptions->skip_checkpoint_write = 1;\n+\t\telse if(!strcmp(cur_opt,"no-checkpoint")){\n+\t\t\toptions->skip_checkpoint_read = 1;\n+\t\t\toptions->skip_checkpoint_write = 1;\n+\t\t} else {\n+\t\t\tprintk(KERN_INFO "yaffs: Bad mount option \\"%s\\"\\n",cur_opt);\n+\t\t\terror = 1;\n+\t\t}\n+\n+\t}\n+\n+\treturn error;\n+}\n+\n+static struct super_block *yaffs_internal_read_super(int yaffsVersion,\n+\t\t\t\t\t\t     struct super_block *sb,\n+\t\t\t\t\t\t     void *data, int silent)\n+{\n+\tint nBlocks;\n+\tstruct inode *inode = NULL;\n+\tstruct dentry *root;\n+\tyaffs_Device *dev = 0;\n+\tchar devname_buf[BDEVNAME_SIZE + 1];\n+\tstruct mtd_info *mtd;\n+\tint err;\n+\tchar *data_str = (char *)data;\n+\n+\tyaffs_options options;\n+\n+\tsb->s_magic = YAFFS_MAGIC;\n+\tsb->s_op = &yaffs_super_ops;\n+\tsb->s_flags |= MS_NOATIME;\n+\n+\tif (!sb)\n+\t\tprintk(KERN_INFO "yaffs: sb is NULL\\n");\n+\telse if (!sb->s_dev)\n+\t\tprintk(KERN_INFO "yaffs: sb->s_dev is NULL\\n");\n+\telse if (!yaffs_devname(sb, devname_buf))\n+\t\tprintk(KERN_INFO "yaffs: devname is NULL\\n");\n+\telse\n+\t\tprintk(KERN_INFO "yaffs: dev is %d name is \\"%s\\"\\n",\n+\t\t       sb->s_dev,\n+\t\t       yaffs_devname(sb, devname_buf));\n+\n+\tif(!data_str)\n+\t\tdata_str = "";\n+\n+\tprintk(KERN_INFO "yaffs: passed flags \\"%s\\"\\n",data_str);\n+\n+\tmemset(&options,0,sizeof(options));\n+\n+\tif(yaffs_parse_options(&options,data_str)){\n+\t\t/* Option parsing failed */\n+\t\treturn NULL;\n+\t}\n+\n+\n+\tsb->s_blocksize = PAGE_CACHE_SIZE;\n+\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;\n+\tT(YAFFS_TRACE_OS, ("yaffs_read_super: Using yaffs%d\\n", yaffsVersion));\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs_read_super: block size %d\\n", (int)(sb->s_blocksize)));\n+\n+#ifdef CONFIG_YAFFS_DISABLE_WRITE_VERIFY\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs: Write verification disabled. All guarantees "\n+\t   "null and void\\n"));\n+#endif\n+\n+\tT(YAFFS_TRACE_ALWAYS, (KERN_INFO "yaffs: Attempting MTD mount on %u.%u, "\n+\t\t\t       "\\"%s\\"\\n",\n+\t\t\t       MAJOR(sb->s_dev), MINOR(sb->s_dev),\n+\t\t\t       yaffs_devname(sb, devname_buf)));\n+\n+\t/* Check it\'s an mtd device..... */\n+\tif (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR) {\n+\t\treturn NULL;\t/* This isn\'t an mtd device */\n+\t}\n+\t/* Get the device */\n+\tmtd = get_mtd_device(NULL, MINOR(sb->s_dev));\n+\tif (!mtd) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (KERN_WARNING "yaffs: MTD device #%u doesn\'t appear to exist\\n",\n+\t\t   MINOR(sb->s_dev)));\n+\t\treturn NULL;\n+\t}\n+\t/* Check it\'s NAND */\n+\tif (mtd->type != MTD_NANDFLASH) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (KERN_WARNING "yaffs: MTD device is not NAND it\'s type %d\\n", mtd->type));\n+\t\treturn NULL;\n+\t}\n+\n+\tT(YAFFS_TRACE_OS, (" erase %p\\n", mtd->erase));\n+\tT(YAFFS_TRACE_OS, (" read %p\\n", mtd->read));\n+\tT(YAFFS_TRACE_OS, (" write %p\\n", mtd->write));\n+\tT(YAFFS_TRACE_OS, (" readoob %p\\n", mtd->read_oob));\n+\tT(YAFFS_TRACE_OS, (" writeoob %p\\n", mtd->write_oob));\n+\tT(YAFFS_TRACE_OS, (" block_isbad %p\\n", mtd->block_isbad));\n+\tT(YAFFS_TRACE_OS, (" block_markbad %p\\n", mtd->block_markbad));\n+\tT(YAFFS_TRACE_OS, (" %s %d\\n", WRITE_SIZE_STR, WRITE_SIZE(mtd)));\n+\tT(YAFFS_TRACE_OS, (" oobsize %d\\n", mtd->oobsize));\n+\tT(YAFFS_TRACE_OS, (" erasesize %d\\n", mtd->erasesize));\n+\tT(YAFFS_TRACE_OS, (" size %d\\n", mtd->size));\n+\n+#ifdef CONFIG_YAFFS_AUTO_YAFFS2\n+\n+\tif (yaffsVersion == 1 &&\n+\t    WRITE_SIZE(mtd) >= 2048) {\n+\t    T(YAFFS_TRACE_ALWAYS,("yaffs: auto selecting yaffs2\\n"));\n+\t    yaffsVersion = 2;\n+\t}\n+\n+\t/* Added NCB 26/5/2006 for completeness */\n+\tif (yaffsVersion == 2 &&\n+\t    !options.inband_tags &&\n+\t    WRITE_SIZE(mtd) == 512){\n+\t    T(YAFFS_TRACE_ALWAYS,("yaffs: auto selecting yaffs1\\n"));\n+\t    yaffsVersion = 1;\n+\t}\n+\n+#endif\n+\n+\tif (yaffsVersion == 2) {\n+\t\t/* Check for version 2 style functions */\n+\t\tif (!mtd->erase ||\n+\t\t    !mtd->block_isbad ||\n+\t\t    !mtd->block_markbad ||\n+\t\t    !mtd->read ||\n+\t\t    !mtd->write ||\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\t\t    !mtd->read_oob || !mtd->write_oob) {\n+#else\n+\t\t    !mtd->write_ecc ||\n+\t\t    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {\n+#endif\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  ("yaffs: MTD device does not support required "\n+\t\t\t   "functions\\n"));;\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tif ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||\n+\t\t    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&\n+\t\t    !options.inband_tags) {\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  ("yaffs: MTD device does not have the "\n+\t\t\t   "right page sizes\\n"));\n+\t\t\treturn NULL;\n+\t\t}\n+\t} else {\n+\t\t/* Check for V1 style functions */\n+\t\tif (!mtd->erase ||\n+\t\t    !mtd->read ||\n+\t\t    !mtd->write ||\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\t\t    !mtd->read_oob || !mtd->write_oob) {\n+#else\n+\t\t    !mtd->write_ecc ||\n+\t\t    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {\n+#endif\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  ("yaffs: MTD device does not support required "\n+\t\t\t   "functions\\n"));;\n+\t\t\treturn NULL;\n+\t\t}\n+\n+\t\tif (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||\n+\t\t    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  ("yaffs: MTD device does not support have the "\n+\t\t\t   "right page sizes\\n"));\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\t/* OK, so if we got here, we have an MTD that\'s NAND and looks\n+\t * like it has the right capabilities\n+\t * Set the yaffs_Device up for mtd\n+\t */\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+\tsb->s_fs_info = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);\n+#else\n+\tsb->u.generic_sbp = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);\n+#endif\n+\tif (!dev) {\n+\t\t/* Deep shit could not allocate device structure */\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  ("yaffs_read_super: Failed trying to allocate "\n+\t\t   "yaffs_Device. \\n"));\n+\t\treturn NULL;\n+\t}\n+\n+\tmemset(dev, 0, sizeof(yaffs_Device));\n+\tdev->genericDevice = mtd;\n+\tdev->name = mtd->name;\n+\n+\t/* Set up the memory size parameters.... */\n+\n+\tnBlocks = mtd->size / (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);\n+\tdev->startBlock = 0;\n+\tdev->endBlock = nBlocks - 1;\n+\tdev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;\n+\tdev->totalBytesPerChunk = YAFFS_BYTES_PER_CHUNK;\n+\tdev->nReservedBlocks = 5;\n+\tdev->nShortOpCaches = (options.no_cache) ? 0 : 10;\n+\tdev->inbandTags = options.inband_tags;\n+\n+\t/* ... and the functions. */\n+\tif (yaffsVersion == 2) {\n+\t\tdev->writeChunkWithTagsToNAND =\n+\t\t    nandmtd2_WriteChunkWithTagsToNAND;\n+\t\tdev->readChunkWithTagsFromNAND =\n+\t\t    nandmtd2_ReadChunkWithTagsFromNAND;\n+\t\tdev->markNANDBlockBad = nandmtd2_MarkNANDBlockBad;\n+\t\tdev->queryNANDBlock = nandmtd2_QueryNANDBlock;\n+\t\tdev->spareBuffer = YMALLOC(mtd->oobsize);\n+\t\tdev->isYaffs2 = 1;\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\t\tdev->totalBytesPerChunk = mtd->writesize;\n+\t\tdev->nChunksPerBlock = mtd->erasesize / mtd->writesize;\n+#else\n+\t\tdev->totalBytesPerChunk = mtd->oobblock;\n+\t\tdev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;\n+#endif\n+\t\tnBlocks = mtd->size / mtd->erasesize;\n+\n+\t\tdev->startBlock = 0;\n+\t\tdev->endBlock = nBlocks - 1;\n+\t} else {\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\t\t/* use the MTD interface in yaffs_mtdif1.c */\n+\t\tdev->writeChunkWithTagsToNAND =\n+\t\t\tnandmtd1_WriteChunkWithTagsToNAND;\n+\t\tdev->readChunkWithTagsFromNAND =\n+\t\t\tnandmtd1_ReadChunkWithTagsFromNAND;\n+\t\tdev->markNANDBlockBad = nandmtd1_MarkNANDBlockBad;\n+\t\tdev->queryNANDBlock = nandmtd1_QueryNANDBlock;\n+#else\n+\t\tdev->writeChunkToNAND = nandmtd_WriteChunkToNAND;\n+\t\tdev->readChunkFromNAND = nandmtd_ReadChunkFromNAND;\n+#endif\n+\t\tdev->isYaffs2 = 0;\n+\t}\n+\t/* ... and common functions */\n+\tdev->eraseBlockInNAND = nandmtd_EraseBlockInNAND;\n+\tdev->initialiseNAND = nandmtd_InitialiseNAND;\n+\n+\tdev->putSuperFunc = yaffs_MTDPutSuper;\n+\n+\tdev->superBlock = (void *)sb;\n+\tdev->markSuperBlockDirty = yaffs_MarkSuperBlockDirty;\n+\n+\n+#ifndef CONFIG_YAFFS_DOES_ECC\n+\tdev->useNANDECC = 1;\n+#endif\n+\n+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES\n+\tdev->wideTnodesDisabled = 1;\n+#endif\n+\n+\tdev->skipCheckpointRead = options.skip_checkpoint_read;\n+\tdev->skipCheckpointWrite = options.skip_checkpoint_write;\n+\n+\t/* we assume this is protected by lock_kernel() in mount/umount */\n+\tylist_add_tail(&dev->devList, &yaffs_dev_list);\n+\n+\tinit_MUTEX(&dev->grossLock);\n+\n+\tyaffs_GrossLock(dev);\n+\n+\terr = yaffs_GutsInitialise(dev);\n+\n+\tT(YAFFS_TRACE_OS,\n+\t  ("yaffs_read_super: guts initialised %s\\n",\n+\t   (err == YAFFS_OK) ? "OK" : "FAILED"));\n+\n+\t/* Release lock before yaffs_get_inode() */\n+\tyaffs_GrossUnlock(dev);\n+\n+\t/* Create root inode */\n+\tif (err == YAFFS_OK)\n+\t\tinode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,\n+\t\t\t\t\tyaffs_Root(dev));\n+\n+\tif (!inode)\n+\t\treturn NULL;\n+\n+\tinode->i_op = &yaffs_dir_inode_operations;\n+\tinode->i_fop = &yaffs_dir_operations;\n+\n+\tT(YAFFS_TRACE_OS, ("yaffs_read_super: got root inode\\n"));\n+\n+\troot = d_alloc_root(inode);\n+\n+\tT(YAFFS_TRACE_OS, ("yaffs_read_super: d_alloc_root done\\n"));\n+\n+\tif (!root) {\n+\t\tiput(inode);\n+\t\treturn NULL;\n+\t}\n+\tsb->s_root = root;\n+\n+\tT(YAFFS_TRACE_OS, ("yaffs_read_super: done\\n"));\n+\treturn sb;\n+}\n+\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,\n+\t\t\t\t\t int silent)\n+{\n+\treturn yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs_read_super(struct file_system_type *fs,\n+\t\t\t    int flags, const char *dev_name,\n+\t\t\t    void *data, struct vfsmount *mnt)\n+{\n+\n+\treturn get_sb_bdev(fs, flags, dev_name, data,\n+\t\t\t   yaffs_internal_read_super_mtd, mnt);\n+}\n+#else\n+static struct super_block *yaffs_read_super(struct file_system_type *fs,\n+\t\t\t\t\t    int flags, const char *dev_name,\n+\t\t\t\t\t    void *data)\n+{\n+\n+\treturn get_sb_bdev(fs, flags, dev_name, data,\n+\t\t\t   yaffs_internal_read_super_mtd);\n+}\n+#endif\n+\n+static struct file_system_type yaffs_fs_type = {\n+\t.owner = THIS_MODULE,\n+\t.name = "yaffs",\n+\t.get_sb = yaffs_read_super,\n+\t.kill_sb = kill_block_super,\n+\t.fs_flags = FS_REQUIRES_DEV,\n+};\n+#else\n+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,\n+\t\t\t\t\t    int silent)\n+{\n+\treturn yaffs_internal_read_super(1, sb, data, silent);\n+}\n+\n+static DECLARE_FSTYPE(yaffs_fs_type, "yaffs", yaffs_read_super,\n+\t\t      FS_REQUIRES_DEV);\n+#endif\n+\n+\n+#ifdef CONFIG_YAFFS_YAFFS2\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,\n+\t\t\t\t\t  int silent)\n+{\n+\treturn yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;\n+}\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+static int yaffs2_read_super(struct file_system_type *fs,\n+\t\t\tint flags, const char *dev_name, void *data,\n+\t\t\tstruct vfsmount *mnt)\n+{\n+\treturn get_sb_bdev(fs, flags, dev_name, data,\n+\t\t\tyaffs2_internal_read_super_mtd, mnt);\n+}\n+#else\n+static struct super_block *yaffs2_read_super(struct file_system_type *fs,\n+\t\t\t\t\t     int flags, const char *dev_name,\n+\t\t\t\t\t     void *data)\n+{\n+\n+\treturn get_sb_bdev(fs, flags, dev_name, data,\n+\t\t\t   yaffs2_internal_read_super_mtd);\n+}\n+#endif\n+\n+static struct file_system_type yaffs2_fs_type = {\n+\t.owner = THIS_MODULE,\n+\t.name = "yaffs2",\n+\t.get_sb = yaffs2_read_super,\n+\t.kill_sb = kill_block_super,\n+\t.fs_flags = FS_REQUIRES_DEV,\n+};\n+#else\n+static struct super_block *yaffs2_read_super(struct super_block *sb,\n+\t\t\t\t\t     void *data, int silent)\n+{\n+\treturn yaffs_internal_read_super(2, sb, data, silent);\n+}\n+\n+static DECLARE_FSTYPE(yaffs2_fs_type, "yaffs2", yaffs2_read_super,\n+\t\t      FS_REQUIRES_DEV);\n+#endif\n+\n+#endif\t\t\t\t/* CONFIG_YAFFS_YAFFS2 */\n+\n+static struct proc_dir_entry *my_proc_entry;\n+\n+static char *yaffs_dump_dev(char *buf, yaffs_Device * dev)\n+{\n+\tbuf += sprintf(buf, "startBlock......... %d\\n", dev->startBlock);\n+\tbuf += sprintf(buf, "endBlock........... %d\\n", dev->endBlock);\n+\tbuf += sprintf(buf, "totalBytesPerChunk. %d\\n", dev->totalBytesPerChunk);\n+\tbuf += sprintf(buf, "nDataBytesPerChunk. %d\\n", dev->nDataBytesPerChunk);\n+\tbuf += sprintf(buf, "chunkGroupBits..... %d\\n", dev->chunkGroupBits);\n+\tbuf += sprintf(buf, "chunkGroupSize..... %d\\n", dev->chunkGroupSize);\n+\tbuf += sprintf(buf, "nErasedBlocks...... %d\\n", dev->nErasedBlocks);\n+\tbuf += sprintf(buf, "nReservedBlocks.... %d\\n", dev->nReservedBlocks);\n+\tbuf += sprintf(buf, "blocksInCheckpoint. %d\\n", dev->blocksInCheckpoint);\n+\tbuf += sprintf(buf, "nTnodesCreated..... %d\\n", dev->nTnodesCreated);\n+\tbuf += sprintf(buf, "nFreeTnodes........ %d\\n", dev->nFreeTnodes);\n+\tbuf += sprintf(buf, "nObjectsCreated.... %d\\n", dev->nObjectsCreated);\n+\tbuf += sprintf(buf, "nFreeObjects....... %d\\n", dev->nFreeObjects);\n+\tbuf += sprintf(buf, "nFreeChunks........ %d\\n", dev->nFreeChunks);\n+\tbuf += sprintf(buf, "nPageWrites........ %d\\n", dev->nPageWrites);\n+\tbuf += sprintf(buf, "nPageReads......... %d\\n", dev->nPageReads);\n+\tbuf += sprintf(buf, "nBlockErasures..... %d\\n", dev->nBlockErasures);\n+\tbuf += sprintf(buf, "nGCCopies.......... %d\\n", dev->nGCCopies);\n+\tbuf += sprintf(buf, "garbageCollections. %d\\n", dev->garbageCollections);\n+\tbuf += sprintf(buf, "passiveGCs......... %d\\n",\n+\t\t    dev->passiveGarbageCollections);\n+\tbuf += sprintf(buf, "nRetriedWrites..... %d\\n", dev->nRetriedWrites);\n+\tbuf += sprintf(buf, "nShortOpCaches..... %d\\n", dev->nShortOpCaches);\n+\tbuf += sprintf(buf, "nRetireBlocks...... %d\\n", dev->nRetiredBlocks);\n+\tbuf += sprintf(buf, "eccFixed........... %d\\n", dev->eccFixed);\n+\tbuf += sprintf(buf, "eccUnfixed......... %d\\n", dev->eccUnfixed);\n+\tbuf += sprintf(buf, "tagsEccFixed....... %d\\n", dev->tagsEccFixed);\n+\tbuf += sprintf(buf, "tagsEccUnfixed..... %d\\n", dev->tagsEccUnfixed);\n+\tbuf += sprintf(buf, "cacheHits.......... %d\\n", dev->cacheHits);\n+\tbuf += sprintf(buf, "nDeletedFiles...... %d\\n", dev->nDeletedFiles);\n+\tbuf += sprintf(buf, "nUnlinkedFiles..... %d\\n", dev->nUnlinkedFiles);\n+\tbuf +=\n+\t    sprintf(buf, "nBackgroudDeletions %d\\n", dev->nBackgroundDeletions);\n+\tbuf += sprintf(buf, "useNANDECC......... %d\\n", dev->useNANDECC);\n+\tbuf += sprintf(buf, "isYaffs2........... %d\\n", dev->isYaffs2);\n+\tbuf += sprintf(buf, "inbandTags......... %d\\n", dev->inbandTags);\n+\n+\treturn buf;\n+}\n+\n+static int yaffs_proc_read(char *page,\n+\t\t\t   char **start,\n+\t\t\t   off_t offset, int count, int *eof, void *data)\n+{\n+\tstruct ylist_head *item;\n+\tchar *buf = page;\n+\tint step = offset;\n+\tint n = 0;\n+\n+\t/* Get proc_file_read() to step \'offset\' by one on each sucessive call.\n+\t * We use \'offset\' (*ppos) to indicate where we are in devList.\n+\t * This also assumes the user has posted a read buffer large\n+\t * enough to hold the complete output; but that\'s life in /proc.\n+\t */\n+\n+\t*(int *)start = 1;\n+\n+\t/* Print header first */\n+\tif (step == 0) {\n+\t\tbuf += sprintf(buf, "YAFFS built:" __DATE__ " " __TIME__\n+\t\t\t       "\\n%s\\n%s\\n", yaffs_fs_c_version,\n+\t\t\t       yaffs_guts_c_version);\n+\t}\n+\n+\t/* hold lock_kernel while traversing yaffs_dev_list */\n+\tlock_kernel();\n+\n+\t/* Locate and print the Nth entry.  Order N-squared but N is small. */\n+\tylist_for_each(item, &yaffs_dev_list) {\n+\t\tyaffs_Device *dev = ylist_entry(item, yaffs_Device, devList);\n+\t\tif (n < step) {\n+\t\t\tn++;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tbuf += sprintf(buf, "\\nDevice %d \\"%s\\"\\n", n, dev->name);\n+\t\tbuf = yaffs_dump_dev(buf, dev);\n+\t\tbreak;\n+\t}\n+\tunlock_kernel();\n+\n+\treturn buf - page < count ? buf - page : count;\n+}\n+\n+/**\n+ * Set the verbosity of the warnings and error messages.\n+ *\n+ * Note that the names can only be a..z or _ with the current code.\n+ */\n+\n+static struct {\n+\tchar *mask_name;\n+\tunsigned mask_bitfield;\n+} mask_flags[] = {\n+\t{"allocate", YAFFS_TRACE_ALLOCATE},\n+\t{"always", YAFFS_TRACE_ALWAYS},\n+\t{"bad_blocks", YAFFS_TRACE_BAD_BLOCKS},\n+\t{"buffers", YAFFS_TRACE_BUFFERS},\n+\t{"bug", YAFFS_TRACE_BUG},\n+\t{"checkpt", YAFFS_TRACE_CHECKPOINT},\n+\t{"deletion", YAFFS_TRACE_DELETION},\n+\t{"erase", YAFFS_TRACE_ERASE},\n+\t{"error", YAFFS_TRACE_ERROR},\n+\t{"gc_detail", YAFFS_TRACE_GC_DETAIL},\n+\t{"gc", YAFFS_TRACE_GC},\n+\t{"mtd", YAFFS_TRACE_MTD},\n+\t{"nandaccess", YAFFS_TRACE_NANDACCESS},\n+\t{"os", YAFFS_TRACE_OS},\n+\t{"scan_debug", YAFFS_TRACE_SCAN_DEBUG},\n+\t{"scan", YAFFS_TRACE_SCAN},\n+\t{"tracing", YAFFS_TRACE_TRACING},\n+\n+\t{"verify", YAFFS_TRACE_VERIFY},\n+\t{"verify_nand", YAFFS_TRACE_VERIFY_NAND},\n+\t{"verify_full", YAFFS_TRACE_VERIFY_FULL},\n+\t{"verify_all", YAFFS_TRACE_VERIFY_ALL},\n+\n+\t{"write", YAFFS_TRACE_WRITE},\n+\t{"all", 0xffffffff},\n+\t{"none", 0},\n+\t{NULL, 0},\n+};\n+\n+#define MAX_MASK_NAME_LENGTH 40\n+static int yaffs_proc_write(struct file *file, const char *buf,\n+\t\t\t\t\t unsigned long count, void *data)\n+{\n+\tunsigned rg = 0, mask_bitfield;\n+\tchar *end;\n+\tchar *mask_name;\n+\tconst char *x;\n+\tchar substring[MAX_MASK_NAME_LENGTH+1];\n+\tint i;\n+\tint done = 0;\n+\tint add, len = 0;\n+\tint pos = 0;\n+\n+\trg = yaffs_traceMask;\n+\n+\twhile (!done && (pos < count)) {\n+\t\tdone = 1;\n+\t\twhile ((pos < count) && isspace(buf[pos])) {\n+\t\t\tpos++;\n+\t\t}\n+\n+\t\tswitch (buf[pos]) {\n+\t\tcase \'+\':\n+\t\tcase \'-\':\n+\t\tcase \'=\':\n+\t\t\tadd = buf[pos];\n+\t\t\tpos++;\n+\t\t\tbreak;\n+\n+\t\tdefault:\n+\t\t\tadd = \' \';\n+\t\t\tbreak;\n+\t\t}\n+\t\tmask_name = NULL;\n+\n+\t\tmask_bitfield = simple_strtoul(buf + pos, &end, 0);\n+\t\tif (end > buf + pos) {\n+\t\t\tmask_name = "numeral";\n+\t\t\tlen = end - (buf + pos);\n+\t\t\tpos += len;\n+\t\t\tdone = 0;\n+\t\t} else {\n+\t\t\tfor(x = buf + pos, i = 0;\n+\t\t\t    (*x == \'_\' || (*x >=\'a\' && *x <= \'z\')) &&\n+\t\t\t    i <MAX_MASK_NAME_LENGTH; x++, i++, pos++)\n+\t\t\t    substring[i] = *x;\n+\t\t\tsubstring[i] = \'\\0\';\n+\n+\t\t\tfor (i = 0; mask_flags[i].mask_name != NULL; i++) {\n+\t\t\t\tif(strcmp(substring,mask_flags[i].mask_name) == 0){\n+\t\t\t\t\tmask_name = mask_flags[i].mask_name;\n+\t\t\t\t\tmask_bitfield = mask_flags[i].mask_bitfield;\n+\t\t\t\t\tdone = 0;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (mask_name != NULL) {\n+\t\t\tdone = 0;\n+\t\t\tswitch(add) {\n+\t\t\tcase \'-\':\n+\t\t\t\trg &= ~mask_bitfield;\n+\t\t\t\tbreak;\n+\t\t\tcase \'+\':\n+\t\t\t\trg |= mask_bitfield;\n+\t\t\t\tbreak;\n+\t\t\tcase \'=\':\n+\t\t\t\trg = mask_bitfield;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\trg |= mask_bitfield;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tyaffs_traceMask = rg | YAFFS_TRACE_ALWAYS;\n+\n+\tprintk("new trace = 0x%08X\\n",yaffs_traceMask);\n+\n+\tif (rg & YAFFS_TRACE_ALWAYS) {\n+\t\tfor (i = 0; mask_flags[i].mask_name != NULL; i++) {\n+\t\t\tchar flag;\n+\t\t\tflag = ((rg & mask_flags[i].mask_bitfield) == mask_flags[i].mask_bitfield) ? \'+\' : \'-\';\n+\t\t\tprintk("%c%s\\n", flag, mask_flags[i].mask_name);\n+\t\t}\n+\t}\n+\n+\treturn count;\n+}\n+\n+/* Stuff to handle installation of file systems */\n+struct file_system_to_install {\n+\tstruct file_system_type *fst;\n+\tint installed;\n+};\n+\n+static struct file_system_to_install fs_to_install[] = {\n+//#ifdef CONFIG_YAFFS_YAFFS1\n+\t{&yaffs_fs_type, 0},\n+//#endif\n+//#ifdef CONFIG_YAFFS_YAFFS2\n+\t{&yaffs2_fs_type, 0},\n+//#endif\n+\t{NULL, 0}\n+};\n+\n+static int __init init_yaffs_fs(void)\n+{\n+\tint error = 0;\n+\tstruct file_system_to_install *fsinst;\n+\n+\tT(YAFFS_TRACE_ALWAYS,\n+\t  (KERN_INFO "yaffs " __DATE__ " " __TIME__ " Installing. \\n"));\n+\n+\t/* Install the proc_fs entry */\n+\tmy_proc_entry = create_proc_entry("yaffs",\n+\t\t\t\t\t       S_IRUGO | S_IFREG,\n+\t\t\t\t\t       &proc_root);\n+\n+\tif (my_proc_entry) {\n+\t\tmy_proc_entry->write_proc = yaffs_proc_write;\n+\t\tmy_proc_entry->read_proc = yaffs_proc_read;\n+\t\tmy_proc_entry->data = NULL;\n+\t} else {\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\t/* Now add the file system entries */\n+\n+\tfsinst = fs_to_install;\n+\n+\twhile (fsinst->fst && !error) {\n+\t\terror = register_filesystem(fsinst->fst);\n+\t\tif (!error) {\n+\t\t\tfsinst->installed = 1;\n+\t\t}\n+\t\tfsinst++;\n+\t}\n+\n+\t/* Any errors? uninstall  */\n+\tif (error) {\n+\t\tfsinst = fs_to_install;\n+\n+\t\twhile (fsinst->fst) {\n+\t\t\tif (fsinst->installed) {\n+\t\t\t\tunregister_filesystem(fsinst->fst);\n+\t\t\t\tfsinst->installed = 0;\n+\t\t\t}\n+\t\t\tfsinst++;\n+\t\t}\n+\t}\n+\n+\treturn error;\n+}\n+\n+static void __exit exit_yaffs_fs(void)\n+{\n+\n+\tstruct file_system_to_install *fsinst;\n+\n+\tT(YAFFS_TRACE_ALWAYS, ("yaffs " __DATE__ " " __TIME__\n+\t\t\t       " removing. \\n"));\n+\n+\tremove_proc_entry("yaffs", &proc_root);\n+\n+\tfsinst = fs_to_install;\n+\n+\twhile (fsinst->fst) {\n+\t\tif (fsinst->installed) {\n+\t\t\tunregister_filesystem(fsinst->fst);\n+\t\t\tfsinst->installed = 0;\n+\t\t}\n+\t\tfsinst++;\n+\t}\n+\n+}\n+\n+module_init(init_yaffs_fs)\n+module_exit(exit_yaffs_fs)\n+\n+MODULE_DESCRIPTION("YAFFS2 - a NAND specific flash file system");\n+MODULE_AUTHOR("Charles Manning, Aleph One Ltd., 2002-2006");\n+MODULE_LICENSE("GPL");'),
 ('linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h\n--- linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h\n@@ -0,0 +1,34 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_GETBLOCKINFO_H__\n+#define __YAFFS_GETBLOCKINFO_H__\n+\n+#include "yaffs_guts.h"\n+\n+/* Function to manipulate block info */\n+static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)\n+{\n+\tif (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR\n+\t\t   ("**>> yaffs: getBlockInfo block %d is not valid" TENDSTR),\n+\t\t   blk));\n+\t\tYBUG();\n+\t}\n+\treturn &dev->blockInfo[blk - dev->internalStartBlock];\n+}\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_guts.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_guts.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c\n--- linux-2.6.23/fs/yaffs2/yaffs_guts.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c\n@@ -0,0 +1,7531 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+const char *yaffs_guts_c_version =\n+    "$Id: yaffs_guts.c,v 1.58 2008/07/03 20:06:05 charles Exp $";\n+\n+#include "yportenv.h"\n+\n+#include "yaffsinterface.h"\n+#include "yaffs_guts.h"\n+#include "yaffs_tagsvalidity.h"\n+#include "yaffs_getblockinfo.h"\n+\n+#include "yaffs_tagscompat.h"\n+#ifndef  CONFIG_YAFFS_USE_OWN_SORT\n+#include "yaffs_qsort.h"\n+#endif\n+#include "yaffs_nand.h"\n+\n+#include "yaffs_checkptrw.h"\n+\n+#include "yaffs_nand.h"\n+#include "yaffs_packedtags2.h"\n+\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+void yfsd_LockYAFFS(BOOL fsLockOnly);\n+void yfsd_UnlockYAFFS(BOOL fsLockOnly);\n+#endif\n+\n+#define YAFFS_PASSIVE_GC_CHUNKS 2\n+\n+#include "yaffs_ecc.h"\n+\n+\n+/* Robustification (if it ever comes about...) */\n+static void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND);\n+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk);\n+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t     const __u8 * data,\n+\t\t\t\t     const yaffs_ExtendedTags * tags);\n+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t    const yaffs_ExtendedTags * tags);\n+\n+/* Other local prototypes */\n+static int yaffs_UnlinkObject( yaffs_Object *obj);\n+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);\n+\n+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);\n+\n+static int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device * dev,\n+\t\t\t\t\t     const __u8 * buffer,\n+\t\t\t\t\t     yaffs_ExtendedTags * tags,\n+\t\t\t\t\t     int useReserve);\n+static int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t  int chunkInNAND, int inScan);\n+\n+static yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,\n+\t\t\t\t\t   yaffs_ObjectType type);\n+static void yaffs_AddObjectToDirectory(yaffs_Object * directory,\n+\t\t\t\t       yaffs_Object * obj);\n+static int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name,\n+\t\t\t\t    int force, int isShrink, int shadows);\n+static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj);\n+static int yaffs_CheckStructures(void);\n+static int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,\n+\t\t\t      int chunkOffset, int *limit);\n+static int yaffs_DoGenericObjectDeletion(yaffs_Object * in);\n+\n+static yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blockNo);\n+\n+\n+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int chunkInNAND);\n+\n+static int yaffs_UnlinkWorker(yaffs_Object * obj);\n+static void yaffs_DestroyObject(yaffs_Object * obj);\n+\n+static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,\n+\t\t\t   int chunkInObject);\n+\n+loff_t yaffs_GetFileSize(yaffs_Object * obj);\n+\n+static int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr);\n+\n+static void yaffs_VerifyFreeChunks(yaffs_Device * dev);\n+\n+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);\n+\n+#ifdef YAFFS_PARANOID\n+static int yaffs_CheckFileSanity(yaffs_Object * in);\n+#else\n+#define yaffs_CheckFileSanity(in)\n+#endif\n+\n+static void yaffs_InvalidateWholeChunkCache(yaffs_Object * in);\n+static void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId);\n+\n+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev);\n+\n+static int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t yaffs_ExtendedTags * tags);\n+\n+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos);\n+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,\n+\t\t\t\t\t  yaffs_FileStructure * fStruct,\n+\t\t\t\t\t  __u32 chunkId);\n+\n+\n+/* Function to calculate chunk and offset */\n+\n+static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut, __u32 *offsetOut)\n+{\n+\tint chunk;\n+\t__u32 offset;\n+\n+\tchunk  = (__u32)(addr >> dev->chunkShift);\n+\n+\tif(dev->chunkDiv == 1)\n+\t{\n+\t\t/* easy power of 2 case */\n+\t\toffset = (__u32)(addr & dev->chunkMask);\n+\t}\n+\telse\n+\t{\n+\t\t/* Non power-of-2 case */\n+\n+\t\tloff_t chunkBase;\n+\n+\t\tchunk /= dev->chunkDiv;\n+\n+\t\tchunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;\n+\t\toffset = (__u32)(addr - chunkBase);\n+\t}\n+\n+\t*chunkOut = chunk;\n+\t*offsetOut = offset;\n+}\n+\n+/* Function to return the number of shifts for a power of 2 greater than or equal\n+ * to the given number\n+ * Note we don\'t try to cater for all possible numbers and this does not have to\n+ * be hellishly efficient.\n+ */\n+\n+static __u32 ShiftsGE(__u32 x)\n+{\n+\tint extraBits;\n+\tint nShifts;\n+\n+\tnShifts = extraBits = 0;\n+\n+\twhile(x>1){\n+\t\tif(x & 1) extraBits++;\n+\t\tx>>=1;\n+\t\tnShifts++;\n+\t}\n+\n+\tif(extraBits)\n+\t\tnShifts++;\n+\n+\treturn nShifts;\n+}\n+\n+/* Function to return the number of shifts to get a 1 in bit 0\n+ */\n+\n+static __u32 Shifts(__u32 x)\n+{\n+\tint nShifts;\n+\n+\tnShifts =  0;\n+\n+\tif(!x) return 0;\n+\n+\twhile( !(x&1)){\n+\t\tx>>=1;\n+\t\tnShifts++;\n+\t}\n+\n+\treturn nShifts;\n+}\n+\n+\n+\n+/*\n+ * Temporary buffer manipulations.\n+ */\n+\n+static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)\n+{\n+\tint i;\n+\t__u8 *buf = (__u8 *)1;\n+\n+\tmemset(dev->tempBuffer,0,sizeof(dev->tempBuffer));\n+\n+\tfor (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\tdev->tempBuffer[i].line = 0;\t/* not in use */\n+\t\tdev->tempBuffer[i].buffer = buf =\n+\t\t    YMALLOC_DMA(dev->totalBytesPerChunk);\n+\t}\n+\n+\treturn buf ? YAFFS_OK : YAFFS_FAIL;\n+\n+}\n+\n+__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo)\n+{\n+\tint i, j;\n+\n+\tdev->tempInUse++;\n+\tif(dev->tempInUse > dev->maxTemp)\n+\t\tdev->maxTemp = dev->tempInUse;\n+\n+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\tif (dev->tempBuffer[i].line == 0) {\n+\t\t\tdev->tempBuffer[i].line = lineNo;\n+\t\t\tif ((i + 1) > dev->maxTemp) {\n+\t\t\t\tdev->maxTemp = i + 1;\n+\t\t\t\tfor (j = 0; j <= i; j++)\n+\t\t\t\t\tdev->tempBuffer[j].maxLine =\n+\t\t\t\t\t    dev->tempBuffer[j].line;\n+\t\t\t}\n+\n+\t\t\treturn dev->tempBuffer[i].buffer;\n+\t\t}\n+\t}\n+\n+\tT(YAFFS_TRACE_BUFFERS,\n+\t  (TSTR("Out of temp buffers at line %d, other held by lines:"),\n+\t   lineNo));\n+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\tT(YAFFS_TRACE_BUFFERS, (TSTR(" %d "), dev->tempBuffer[i].line));\n+\t}\n+\tT(YAFFS_TRACE_BUFFERS, (TSTR(" " TENDSTR)));\n+\n+\t/*\n+\t * If we got here then we have to allocate an unmanaged one\n+\t * This is not good.\n+\t */\n+\n+\tdev->unmanagedTempAllocations++;\n+\treturn YMALLOC(dev->nDataBytesPerChunk);\n+\n+}\n+\n+void yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer,\n+\t\t\t\t    int lineNo)\n+{\n+\tint i;\n+\n+\tdev->tempInUse--;\n+\n+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\tif (dev->tempBuffer[i].buffer == buffer) {\n+\t\t\tdev->tempBuffer[i].line = 0;\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\tif (buffer) {\n+\t\t/* assume it is an unmanaged one. */\n+\t\tT(YAFFS_TRACE_BUFFERS,\n+\t\t  (TSTR("Releasing unmanaged temp buffer in line %d" TENDSTR),\n+\t\t   lineNo));\n+\t\tYFREE(buffer);\n+\t\tdev->unmanagedTempDeallocations++;\n+\t}\n+\n+}\n+\n+/*\n+ * Determine if we have a managed buffer.\n+ */\n+int yaffs_IsManagedTempBuffer(yaffs_Device * dev, const __u8 * buffer)\n+{\n+\tint i;\n+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\tif (dev->tempBuffer[i].buffer == buffer)\n+\t\t\treturn 1;\n+\n+\t}\n+\n+    for (i = 0; i < dev->nShortOpCaches; i++) {\n+        if( dev->srCache[i].data == buffer )\n+            return 1;\n+\n+    }\n+\n+    if (buffer == dev->checkpointBuffer)\n+      return 1;\n+\n+    T(YAFFS_TRACE_ALWAYS,\n+\t  (TSTR("yaffs: unmaged buffer detected.\\n" TENDSTR)));\n+    return 0;\n+}\n+\n+\n+\n+/*\n+ * Chunk bitmap manipulations\n+ */\n+\n+static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device * dev, int blk)\n+{\n+\tif (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR("**>> yaffs: BlockBits block %d is not valid" TENDSTR),\n+\t\t   blk));\n+\t\tYBUG();\n+\t}\n+\treturn dev->chunkBits +\n+\t    (dev->chunkBitmapStride * (blk - dev->internalStartBlock));\n+}\n+\n+static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)\n+{\n+\tif(blk < dev->internalStartBlock || blk > dev->internalEndBlock ||\n+\t   chunk < 0 || chunk >= dev->nChunksPerBlock) {\n+\t   T(YAFFS_TRACE_ERROR,\n+\t    (TSTR("**>> yaffs: Chunk Id (%d:%d) invalid"TENDSTR),blk,chunk));\n+\t    YBUG();\n+\t}\n+}\n+\n+static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device * dev, int blk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\n+\tmemset(blkBits, 0, dev->chunkBitmapStride);\n+}\n+\n+static Y_INLINE void yaffs_ClearChunkBit(yaffs_Device * dev, int blk, int chunk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\n+\tyaffs_VerifyChunkBitId(dev,blk,chunk);\n+\n+\tblkBits[chunk / 8] &= ~(1 << (chunk & 7));\n+}\n+\n+static Y_INLINE void yaffs_SetChunkBit(yaffs_Device * dev, int blk, int chunk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\n+\tyaffs_VerifyChunkBitId(dev,blk,chunk);\n+\n+\tblkBits[chunk / 8] |= (1 << (chunk & 7));\n+}\n+\n+static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device * dev, int blk, int chunk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\tyaffs_VerifyChunkBitId(dev,blk,chunk);\n+\n+\treturn (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;\n+}\n+\n+static Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device * dev, int blk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\tint i;\n+\tfor (i = 0; i < dev->chunkBitmapStride; i++) {\n+\t\tif (*blkBits)\n+\t\t\treturn 1;\n+\t\tblkBits++;\n+\t}\n+\treturn 0;\n+}\n+\n+static int yaffs_CountChunkBits(yaffs_Device * dev, int blk)\n+{\n+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);\n+\tint i;\n+\tint n = 0;\n+\tfor (i = 0; i < dev->chunkBitmapStride; i++) {\n+\t\t__u8 x = *blkBits;\n+\t\twhile(x){\n+\t\t\tif(x & 1)\n+\t\t\t\tn++;\n+\t\t\tx >>=1;\n+\t\t}\n+\n+\t\tblkBits++;\n+\t}\n+\treturn n;\n+}\n+\n+/*\n+ * Verification code\n+ */\n+\n+static int yaffs_SkipVerification(yaffs_Device *dev)\n+{\n+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));\n+}\n+\n+#if 0\n+static int yaffs_SkipFullVerification(yaffs_Device *dev)\n+{\n+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));\n+}\n+\n+#endif\n+\n+static int yaffs_SkipNANDVerification(yaffs_Device *dev)\n+{\n+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));\n+}\n+\n+static const char * blockStateName[] = {\n+"Unknown",\n+"Needs scanning",\n+"Scanning",\n+"Empty",\n+"Allocating",\n+"Full",\n+"Dirty",\n+"Checkpoint",\n+"Collecting",\n+"Dead"\n+};\n+\n+static void yaffs_VerifyBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)\n+{\n+\tint actuallyUsed;\n+\tint inUse;\n+\n+\tif(yaffs_SkipVerification(dev))\n+\t\treturn;\n+\n+\t/* Report illegal runtime states */\n+\tif(bi->blockState <0 || bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Block %d has undefined state %d"TENDSTR),n,bi->blockState));\n+\n+\tswitch(bi->blockState){\n+\t case YAFFS_BLOCK_STATE_UNKNOWN:\n+\t case YAFFS_BLOCK_STATE_SCANNING:\n+\t case YAFFS_BLOCK_STATE_NEEDS_SCANNING:\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Block %d has bad run-state %s"TENDSTR),\n+\t\tn,blockStateName[bi->blockState]));\n+\t}\n+\n+\t/* Check pages in use and soft deletions are legal */\n+\n+\tactuallyUsed = bi->pagesInUse - bi->softDeletions;\n+\n+\tif(bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||\n+\t   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||\n+\t   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Block %d has illegal values pagesInUsed %d softDeletions %d"TENDSTR),\n+\t\tn,bi->pagesInUse,bi->softDeletions));\n+\n+\n+\t/* Check chunk bitmap legal */\n+\tinUse = yaffs_CountChunkBits(dev,n);\n+\tif(inUse != bi->pagesInUse)\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Block %d has inconsistent values pagesInUse %d counted chunk bits %d"TENDSTR),\n+\t\t\tn,bi->pagesInUse,inUse));\n+\n+\t/* Check that the sequence number is valid.\n+\t * Ten million is legal, but is very unlikely\n+\t */\n+\tif(dev->isYaffs2 &&\n+\t   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&\n+\t   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000 ))\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Block %d has suspect sequence number of %d"TENDSTR),\n+\t\tn,bi->sequenceNumber));\n+\n+}\n+\n+static void yaffs_VerifyCollectedBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)\n+{\n+\tyaffs_VerifyBlock(dev,bi,n);\n+\n+\t/* After collection the block should be in the erased state */\n+\t/* TODO: This will need to change if we do partial gc */\n+\n+\tif(bi->blockState != YAFFS_BLOCK_STATE_EMPTY){\n+\t\tT(YAFFS_TRACE_ERROR,(TSTR("Block %d is in state %d after gc, should be erased"TENDSTR),\n+\t\t\tn,bi->blockState));\n+\t}\n+}\n+\n+static void yaffs_VerifyBlocks(yaffs_Device *dev)\n+{\n+\tint i;\n+\tint nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];\n+\tint nIllegalBlockStates = 0;\n+\n+\n+\tif(yaffs_SkipVerification(dev))\n+\t\treturn;\n+\n+\tmemset(nBlocksPerState,0,sizeof(nBlocksPerState));\n+\n+\n+\tfor(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++){\n+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);\n+\t\tyaffs_VerifyBlock(dev,bi,i);\n+\n+\t\tif(bi->blockState >=0 && bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)\n+\t\t\tnBlocksPerState[bi->blockState]++;\n+\t\telse\n+\t\t\tnIllegalBlockStates++;\n+\n+\t}\n+\n+\tT(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));\n+\tT(YAFFS_TRACE_VERIFY,(TSTR("Block summary"TENDSTR)));\n+\n+\tT(YAFFS_TRACE_VERIFY,(TSTR("%d blocks have illegal states"TENDSTR),nIllegalBlockStates));\n+\tif(nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)\n+\t\tT(YAFFS_TRACE_VERIFY,(TSTR("Too many allocating blocks"TENDSTR)));\n+\n+\tfor(i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t  (TSTR("%s %d blocks"TENDSTR),\n+\t\t  blockStateName[i],nBlocksPerState[i]));\n+\n+\tif(dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Checkpoint block count wrong dev %d count %d"TENDSTR),\n+\t\t dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));\n+\n+\tif(dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Erased block count wrong dev %d count %d"TENDSTR),\n+\t\t dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));\n+\n+\tif(nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Too many collecting blocks %d (max is 1)"TENDSTR),\n+\t\t nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));\n+\n+\tT(YAFFS_TRACE_VERIFY,(TSTR(""TENDSTR)));\n+\n+}\n+\n+/*\n+ * Verify the object header. oh must be valid, but obj and tags may be NULL in which\n+ * case those tests will not be performed.\n+ */\n+static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)\n+{\n+\tif(yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+\n+\tif(!(tags && obj && oh)){\n+\t \tT(YAFFS_TRACE_VERIFY,\n+\t\t \t\t(TSTR("Verifying object header tags %x obj %x oh %x"TENDSTR),\n+\t\t \t\t(__u32)tags,(__u32)obj,(__u32)oh));\n+\t\treturn;\n+\t}\n+\n+\tif(oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||\n+\t   oh->type > YAFFS_OBJECT_TYPE_MAX)\n+\t \tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Obj %d header type is illegal value 0x%x"TENDSTR),\n+\t\t tags->objectId, oh->type));\n+\n+\tif(tags->objectId != obj->objectId)\n+\t \tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Obj %d header mismatch objectId %d"TENDSTR),\n+\t\t tags->objectId, obj->objectId));\n+\n+\n+\t/*\n+\t * Check that the object\'s parent ids match if parentCheck requested.\n+\t *\n+\t * Tests do not apply to the root object.\n+\t */\n+\n+\tif(parentCheck && tags->objectId > 1 && !obj->parent)\n+\t \tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Obj %d header mismatch parentId %d obj->parent is NULL"TENDSTR),\n+\t \t tags->objectId, oh->parentObjectId));\n+\n+\n+\tif(parentCheck && obj->parent &&\n+\t   oh->parentObjectId != obj->parent->objectId &&\n+\t   (oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||\n+\t    obj->parent->objectId != YAFFS_OBJECTID_DELETED))\n+\t \tT(YAFFS_TRACE_VERIFY,\n+\t\t (TSTR("Obj %d header mismatch parentId %d parentObjectId %d"TENDSTR),\n+\t \t tags->objectId, oh->parentObjectId, obj->parent->objectId));\n+\n+\n+\tif(tags->objectId > 1 && oh->name[0] == 0) /* Null name */\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t(TSTR("Obj %d header name is NULL"TENDSTR),\n+\t\t obj->objectId));\n+\n+\tif(tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t(TSTR("Obj %d header name is 0xFF"TENDSTR),\n+\t\t obj->objectId));\n+}\n+\n+\n+\n+static int yaffs_VerifyTnodeWorker(yaffs_Object * obj, yaffs_Tnode * tn,\n+\t\t\t\t  \t__u32 level, int chunkOffset)\n+{\n+\tint i;\n+\tyaffs_Device *dev = obj->myDev;\n+\tint ok = 1;\n+\n+\tif (tn) {\n+\t\tif (level > 0) {\n+\n+\t\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){\n+\t\t\t\tif (tn->internal[i]) {\n+\t\t\t\t\tok = yaffs_VerifyTnodeWorker(obj,\n+\t\t\t\t\t\t\ttn->internal[i],\n+\t\t\t\t\t\t\tlevel - 1,\n+\t\t\t\t\t\t\t(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (level == 0) {\n+\t\t\tint i;\n+\t\t\tyaffs_ExtendedTags tags;\n+\t\t\t__u32 objectId = obj->objectId;\n+\n+\t\t\tchunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;\n+\n+\t\t\tfor(i = 0; i < YAFFS_NTNODES_LEVEL0; i++){\n+\t\t\t\t__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);\n+\n+\t\t\t\tif(theChunk > 0){\n+\t\t\t\t\t/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */\n+\t\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);\n+\t\t\t\t\tif(tags.objectId != objectId || tags.chunkId != chunkOffset){\n+\t\t\t\t\t\tT(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),\n+\t\t\t\t\t\t\tobjectId, chunkOffset, theChunk,\n+\t\t\t\t\t\t\ttags.objectId, tags.chunkId));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tchunkOffset++;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn ok;\n+\n+}\n+\n+\n+static void yaffs_VerifyFile(yaffs_Object *obj)\n+{\n+\tint requiredTallness;\n+\tint actualTallness;\n+\t__u32 lastChunk;\n+\t__u32 x;\n+\t__u32 i;\n+\tyaffs_Device *dev;\n+\tyaffs_ExtendedTags tags;\n+\tyaffs_Tnode *tn;\n+\t__u32 objectId;\n+\n+\tif(obj && yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+\n+\tdev = obj->myDev;\n+\tobjectId = obj->objectId;\n+\n+\t/* Check file size is consistent with tnode depth */\n+\tlastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;\n+\tx = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;\n+\trequiredTallness = 0;\n+\twhile (x> 0) {\n+\t\tx >>= YAFFS_TNODES_INTERNAL_BITS;\n+\t\trequiredTallness++;\n+\t}\n+\n+\tactualTallness = obj->variant.fileVariant.topLevel;\n+\n+\tif(requiredTallness > actualTallness )\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t(TSTR("Obj %d had tnode tallness %d, needs to be %d"TENDSTR),\n+\t\t obj->objectId,actualTallness, requiredTallness));\n+\n+\n+\t/* Check that the chunks in the tnode tree are all correct.\n+\t * We do this by scanning through the tnode tree and\n+\t * checking the tags for every chunk match.\n+\t */\n+\n+\tif(yaffs_SkipNANDVerification(dev))\n+\t\treturn;\n+\n+\tfor(i = 1; i <= lastChunk; i++){\n+\t\ttn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant,i);\n+\n+\t\tif (tn) {\n+\t\t\t__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);\n+\t\t\tif(theChunk > 0){\n+\t\t\t\t/* T(~0,(TSTR("verifying (%d:%d) %d"TENDSTR),objectId,i,theChunk)); */\n+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);\n+\t\t\t\tif(tags.objectId != objectId || tags.chunkId != i){\n+\t\t\t\t\tT(~0,(TSTR("Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)"TENDSTR),\n+\t\t\t\t\t\tobjectId, i, theChunk,\n+\t\t\t\t\t\ttags.objectId, tags.chunkId));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+}\n+\n+static void yaffs_VerifyDirectory(yaffs_Object *obj)\n+{\n+\tif(obj && yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+\n+}\n+\n+static void yaffs_VerifyHardLink(yaffs_Object *obj)\n+{\n+\tif(obj && yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+\n+\t/* Verify sane equivalent object */\n+}\n+\n+static void yaffs_VerifySymlink(yaffs_Object *obj)\n+{\n+\tif(obj && yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+\n+\t/* Verify symlink string */\n+}\n+\n+static void yaffs_VerifySpecial(yaffs_Object *obj)\n+{\n+\tif(obj && yaffs_SkipVerification(obj->myDev))\n+\t\treturn;\n+}\n+\n+static void yaffs_VerifyObject(yaffs_Object *obj)\n+{\n+\tyaffs_Device *dev;\n+\n+\t__u32 chunkMin;\n+\t__u32 chunkMax;\n+\n+\t__u32 chunkIdOk;\n+\t__u32 chunkIsLive;\n+\n+\tif(!obj)\n+\t\treturn;\n+\n+\tdev = obj->myDev;\n+\n+\tif(yaffs_SkipVerification(dev))\n+\t\treturn;\n+\n+\t/* Check sane object header chunk */\n+\n+\tchunkMin = dev->internalStartBlock * dev->nChunksPerBlock;\n+\tchunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;\n+\n+\tchunkIdOk = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);\n+\tchunkIsLive = chunkIdOk &&\n+\t\t\tyaffs_CheckChunkBit(dev,\n+\t\t\t\t\t    obj->hdrChunk / dev->nChunksPerBlock,\n+\t\t\t\t\t    obj->hdrChunk % dev->nChunksPerBlock);\n+\tif(!obj->fake &&\n+\t    (!chunkIdOk || !chunkIsLive)) {\n+\t   T(YAFFS_TRACE_VERIFY,\n+\t   (TSTR("Obj %d has chunkId %d %s %s"TENDSTR),\n+\t   obj->objectId,obj->hdrChunk,\n+\t   chunkIdOk ? "" : ",out of range",\n+\t   chunkIsLive || !chunkIdOk ? "" : ",marked as deleted"));\n+\t}\n+\n+\tif(chunkIdOk && chunkIsLive &&!yaffs_SkipNANDVerification(dev)) {\n+\t\tyaffs_ExtendedTags tags;\n+\t\tyaffs_ObjectHeader *oh;\n+\t\t__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);\n+\n+\t\toh = (yaffs_ObjectHeader *)buffer;\n+\n+\t\tyaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk,buffer, &tags);\n+\n+\t\tyaffs_VerifyObjectHeader(obj,oh,&tags,1);\n+\n+\t\tyaffs_ReleaseTempBuffer(dev,buffer,__LINE__);\n+\t}\n+\n+\t/* Verify it has a parent */\n+\tif(obj && !obj->fake &&\n+\t   (!obj->parent || obj->parent->myDev != dev)){\n+\t   T(YAFFS_TRACE_VERIFY,\n+\t   (TSTR("Obj %d has parent pointer %p which does not look like an object"TENDSTR),\n+\t   obj->objectId,obj->parent));\n+\t}\n+\n+\t/* Verify parent is a directory */\n+\tif(obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){\n+\t   T(YAFFS_TRACE_VERIFY,\n+\t   (TSTR("Obj %d\'s parent is not a directory (type %d)"TENDSTR),\n+\t   obj->objectId,obj->parent->variantType));\n+\t}\n+\n+\tswitch(obj->variantType){\n+\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\tyaffs_VerifyFile(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\tyaffs_VerifySymlink(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\tyaffs_VerifyDirectory(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\tyaffs_VerifyHardLink(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\tyaffs_VerifySpecial(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\tdefault:\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t(TSTR("Obj %d has illegaltype %d"TENDSTR),\n+\t\tobj->objectId,obj->variantType));\n+\t\tbreak;\n+\t}\n+\n+\n+}\n+\n+static void yaffs_VerifyObjects(yaffs_Device *dev)\n+{\n+        yaffs_Object *obj;\n+        int i;\n+        struct ylist_head *lh;\n+\n+        if(yaffs_SkipVerification(dev))\n+                return;\n+\n+        /* Iterate through the objects in each hash entry */\n+\n+         for(i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++){\n+                ylist_for_each(lh, &dev->objectBucket[i].list) {\n+                        if (lh) {\n+                                obj = ylist_entry(lh, yaffs_Object, hashLink);\n+                                yaffs_VerifyObject(obj);\n+                        }\n+                }\n+\t }\n+\n+}\n+\n+\n+/*\n+ *  Simple hash function. Needs to have a reasonable spread\n+ */\n+\n+static Y_INLINE int yaffs_HashFunction(int n)\n+{\n+\tn = abs(n);\n+\treturn (n % YAFFS_NOBJECT_BUCKETS);\n+}\n+\n+/*\n+ * Access functions to useful fake objects.\n+ * Note that root might have a presence in NAND if permissions are set.\n+ */\n+\n+yaffs_Object *yaffs_Root(yaffs_Device * dev)\n+{\n+\treturn dev->rootDir;\n+}\n+\n+yaffs_Object *yaffs_LostNFound(yaffs_Device * dev)\n+{\n+\treturn dev->lostNFoundDir;\n+}\n+\n+\n+/*\n+ *  Erased NAND checking functions\n+ */\n+\n+int yaffs_CheckFF(__u8 * buffer, int nBytes)\n+{\n+\t/* Horrible, slow implementation */\n+\twhile (nBytes--) {\n+\t\tif (*buffer != 0xFF)\n+\t\t\treturn 0;\n+\t\tbuffer++;\n+\t}\n+\treturn 1;\n+}\n+\n+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int chunkInNAND)\n+{\n+\n+\tint retval = YAFFS_OK;\n+\t__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);\n+\tyaffs_ExtendedTags tags;\n+\tint result;\n+\n+\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);\n+\n+\tif(tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)\n+\t\tretval = YAFFS_FAIL;\n+\n+\n+\tif (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {\n+\t\tT(YAFFS_TRACE_NANDACCESS,\n+\t\t  (TSTR("Chunk %d not erased" TENDSTR), chunkInNAND));\n+\t\tretval = YAFFS_FAIL;\n+\t}\n+\n+\tyaffs_ReleaseTempBuffer(dev, data, __LINE__);\n+\n+\treturn retval;\n+\n+}\n+\n+static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t     const __u8 * data,\n+\t\t\t\t\t     yaffs_ExtendedTags * tags,\n+\t\t\t\t\t     int useReserve)\n+{\n+\tint attempts = 0;\n+\tint writeOk = 0;\n+\tint chunk;\n+\n+\tyaffs_InvalidateCheckpoint(dev);\n+\n+\tdo {\n+\t\tyaffs_BlockInfo *bi = 0;\n+\t\tint erasedOk = 0;\n+\n+\t\tchunk = yaffs_AllocateChunk(dev, useReserve, &bi);\n+\t\tif (chunk < 0) {\n+\t\t\t/* no space */\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/* First check this chunk is erased, if it needs\n+\t\t * checking.  The checking policy (unless forced\n+\t\t * always on) is as follows:\n+\t\t *\n+\t\t * Check the first page we try to write in a block.\n+\t\t * If the check passes then we don\'t need to check any\n+\t\t * more.\tIf the check fails, we check again...\n+\t\t * If the block has been erased, we don\'t need to check.\n+\t\t *\n+\t\t * However, if the block has been prioritised for gc,\n+\t\t * then we think there might be something odd about\n+\t\t * this block and stop using it.\n+\t\t *\n+\t\t * Rationale: We should only ever see chunks that have\n+\t\t * not been erased if there was a partially written\n+\t\t * chunk due to power loss.  This checking policy should\n+\t\t * catch that case with very few checks and thus save a\n+\t\t * lot of checks that are most likely not needed.\n+\t\t */\n+\t\tif (bi->gcPrioritise) {\n+\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);\n+\t\t\t/* try another chunk */\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* let\'s give it a try */\n+\t\tattempts++;\n+\n+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED\n+\t\tbi->skipErasedCheck = 0;\n+#endif\n+\t\tif (!bi->skipErasedCheck) {\n+\t\t\terasedOk = yaffs_CheckChunkErased(dev, chunk);\n+\t\t\tif (erasedOk != YAFFS_OK) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t(TSTR ("**>> yaffs chunk %d was not erased"\n+\t\t\t\tTENDSTR), chunk));\n+\n+\t\t\t\t/* try another chunk */\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tbi->skipErasedCheck = 1;\n+\t\t}\n+\n+\t\twriteOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,\n+\t\t\t\tdata, tags);\n+\t\tif (writeOk != YAFFS_OK) {\n+\t\t\tyaffs_HandleWriteChunkError(dev, chunk, erasedOk);\n+\t\t\t/* try another chunk */\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* Copy the data into the robustification buffer */\n+\t\tyaffs_HandleWriteChunkOk(dev, chunk, data, tags);\n+\n+\t} while (writeOk != YAFFS_OK &&\n+\t        (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));\n+\n+\tif(!writeOk)\n+\t\tchunk = -1;\n+\n+\tif (attempts > 1) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t(TSTR("**>> yaffs write required %d attempts" TENDSTR),\n+\t\t\tattempts));\n+\n+\t\tdev->nRetriedWrites += (attempts - 1);\n+\t}\n+\n+\treturn chunk;\n+}\n+\n+/*\n+ * Block retiring for handling a broken block.\n+ */\n+\n+static void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND)\n+{\n+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);\n+\n+\tyaffs_InvalidateCheckpoint(dev);\n+\n+\tyaffs_MarkBlockBad(dev, blockInNAND);\n+\n+\tbi->blockState = YAFFS_BLOCK_STATE_DEAD;\n+\tbi->gcPrioritise = 0;\n+\tbi->needsRetiring = 0;\n+\n+\tdev->nRetiredBlocks++;\n+}\n+\n+/*\n+ * Functions for robustisizing TODO\n+ *\n+ */\n+\n+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t     const __u8 * data,\n+\t\t\t\t     const yaffs_ExtendedTags * tags)\n+{\n+}\n+\n+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t    const yaffs_ExtendedTags * tags)\n+{\n+}\n+\n+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)\n+{\n+\tif(!bi->gcPrioritise){\n+\t\tbi->gcPrioritise = 1;\n+\t\tdev->hasPendingPrioritisedGCs = 1;\n+\t\tbi->chunkErrorStrikes ++;\n+\n+\t\tif(bi->chunkErrorStrikes > 3){\n+\t\t\tbi->needsRetiring = 1; /* Too many stikes, so retire this */\n+\t\t\tT(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Block struck out" TENDSTR)));\n+\n+\t\t}\n+\n+\t}\n+}\n+\n+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk)\n+{\n+\n+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;\n+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);\n+\n+\tyaffs_HandleChunkError(dev,bi);\n+\n+\n+\tif(erasedOk ) {\n+\t\t/* Was an actual write failure, so mark the block for retirement  */\n+\t\tbi->needsRetiring = 1;\n+\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,\n+\t\t  (TSTR("**>> Block %d needs retiring" TENDSTR), blockInNAND));\n+\n+\n+\t}\n+\n+\t/* Delete the chunk */\n+\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);\n+}\n+\n+\n+/*---------------- Name handling functions ------------*/\n+\n+static __u16 yaffs_CalcNameSum(const YCHAR * name)\n+{\n+\t__u16 sum = 0;\n+\t__u16 i = 1;\n+\n+\tYUCHAR *bname = (YUCHAR *) name;\n+\tif (bname) {\n+\t\twhile ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {\n+\n+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE\n+\t\t\tsum += yaffs_toupper(*bname) * i;\n+#else\n+\t\t\tsum += (*bname) * i;\n+#endif\n+\t\t\ti++;\n+\t\t\tbname++;\n+\t\t}\n+\t}\n+\treturn sum;\n+}\n+\n+static void yaffs_SetObjectName(yaffs_Object * obj, const YCHAR * name)\n+{\n+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM\n+\tif (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH) {\n+\t\tyaffs_strcpy(obj->shortName, name);\n+\t} else {\n+\t\tobj->shortName[0] = _Y(\'\\0\');\n+\t}\n+#endif\n+\tobj->sum = yaffs_CalcNameSum(name);\n+}\n+\n+/*-------------------- TNODES -------------------\n+\n+ * List of spare tnodes\n+ * The list is hooked together using the first pointer\n+ * in the tnode.\n+ */\n+\n+/* yaffs_CreateTnodes creates a bunch more tnodes and\n+ * adds them to the tnode free list.\n+ * Don\'t use this function directly\n+ */\n+\n+static int yaffs_CreateTnodes(yaffs_Device * dev, int nTnodes)\n+{\n+\tint i;\n+\tint tnodeSize;\n+\tyaffs_Tnode *newTnodes;\n+\t__u8 *mem;\n+\tyaffs_Tnode *curr;\n+\tyaffs_Tnode *next;\n+\tyaffs_TnodeList *tnl;\n+\n+\tif (nTnodes < 1)\n+\t\treturn YAFFS_OK;\n+\n+\t/* Calculate the tnode size in bytes for variable width tnode support.\n+\t * Must be a multiple of 32-bits  */\n+\ttnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;\n+\n+\tif(tnodeSize < sizeof(yaffs_Tnode))\n+\t\ttnodeSize = sizeof(yaffs_Tnode);\n+\n+\n+\t/* make these things */\n+\n+\tnewTnodes = YMALLOC(nTnodes * tnodeSize);\n+\tmem = (__u8 *)newTnodes;\n+\n+\tif (!newTnodes) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR("yaffs: Could not allocate Tnodes" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* Hook them into the free list */\n+#if 0\n+\tfor (i = 0; i < nTnodes - 1; i++) {\n+\t\tnewTnodes[i].internal[0] = &newTnodes[i + 1];\n+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+\t\tnewTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;\n+#endif\n+\t}\n+\n+\tnewTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;\n+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+\tnewTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;\n+#endif\n+\tdev->freeTnodes = newTnodes;\n+#else\n+\t/* New hookup for wide tnodes */\n+\tfor(i = 0; i < nTnodes -1; i++) {\n+\t\tcurr = (yaffs_Tnode *) &mem[i * tnodeSize];\n+\t\tnext = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];\n+\t\tcurr->internal[0] = next;\n+\t}\n+\n+\tcurr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];\n+\tcurr->internal[0] = dev->freeTnodes;\n+\tdev->freeTnodes = (yaffs_Tnode *)mem;\n+\n+#endif\n+\n+\n+\tdev->nFreeTnodes += nTnodes;\n+\tdev->nTnodesCreated += nTnodes;\n+\n+\t/* Now add this bunch of tnodes to a list for freeing up.\n+\t * NB If we can\'t add this to the management list it isn\'t fatal\n+\t * but it just means we can\'t free this bunch of tnodes later.\n+\t */\n+\n+\ttnl = YMALLOC(sizeof(yaffs_TnodeList));\n+\tif (!tnl) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR\n+\t\t   ("yaffs: Could not add tnodes to management list" TENDSTR)));\n+\t\t   return YAFFS_FAIL;\n+\n+\t} else {\n+\t\ttnl->tnodes = newTnodes;\n+\t\ttnl->next = dev->allocatedTnodeList;\n+\t\tdev->allocatedTnodeList = tnl;\n+\t}\n+\n+\tT(YAFFS_TRACE_ALLOCATE, (TSTR("yaffs: Tnodes added" TENDSTR)));\n+\n+\treturn YAFFS_OK;\n+}\n+\n+/* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */\n+\n+static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device * dev)\n+{\n+\tyaffs_Tnode *tn = NULL;\n+\n+\t/* If there are none left make more */\n+\tif (!dev->freeTnodes) {\n+\t\tyaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);\n+\t}\n+\n+\tif (dev->freeTnodes) {\n+\t\ttn = dev->freeTnodes;\n+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+\t\tif (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {\n+\t\t\t/* Hoosterman, this thing looks like it isn\'t in the list */\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  (TSTR("yaffs: Tnode list bug 1" TENDSTR)));\n+\t\t}\n+#endif\n+\t\tdev->freeTnodes = dev->freeTnodes->internal[0];\n+\t\tdev->nFreeTnodes--;\n+\t}\n+\n+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n+\n+\treturn tn;\n+}\n+\n+static yaffs_Tnode *yaffs_GetTnode(yaffs_Device * dev)\n+{\n+\tyaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);\n+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;\n+\n+\tif(tnodeSize < sizeof(yaffs_Tnode))\n+\t\ttnodeSize = sizeof(yaffs_Tnode);\n+\n+\tif(tn)\n+\t\tmemset(tn, 0, tnodeSize);\n+\n+\treturn tn;\n+}\n+\n+/* FreeTnode frees up a tnode and puts it back on the free list */\n+static void yaffs_FreeTnode(yaffs_Device * dev, yaffs_Tnode * tn)\n+{\n+\tif (tn) {\n+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+\t\tif (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {\n+\t\t\t/* Hoosterman, this thing looks like it is already in the list */\n+\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t  (TSTR("yaffs: Tnode list bug 2" TENDSTR)));\n+\t\t}\n+\t\ttn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;\n+#endif\n+\t\ttn->internal[0] = dev->freeTnodes;\n+\t\tdev->freeTnodes = tn;\n+\t\tdev->nFreeTnodes++;\n+\t}\n+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n+\n+}\n+\n+static void yaffs_DeinitialiseTnodes(yaffs_Device * dev)\n+{\n+\t/* Free the list of allocated tnodes */\n+\tyaffs_TnodeList *tmp;\n+\n+\twhile (dev->allocatedTnodeList) {\n+\t\ttmp = dev->allocatedTnodeList->next;\n+\n+\t\tYFREE(dev->allocatedTnodeList->tnodes);\n+\t\tYFREE(dev->allocatedTnodeList);\n+\t\tdev->allocatedTnodeList = tmp;\n+\n+\t}\n+\n+\tdev->freeTnodes = NULL;\n+\tdev->nFreeTnodes = 0;\n+}\n+\n+static void yaffs_InitialiseTnodes(yaffs_Device * dev)\n+{\n+\tdev->allocatedTnodeList = NULL;\n+\tdev->freeTnodes = NULL;\n+\tdev->nFreeTnodes = 0;\n+\tdev->nTnodesCreated = 0;\n+\n+}\n+\n+\n+void yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos, unsigned val)\n+{\n+  __u32 *map = (__u32 *)tn;\n+  __u32 bitInMap;\n+  __u32 bitInWord;\n+  __u32 wordInMap;\n+  __u32 mask;\n+\n+  pos &= YAFFS_TNODES_LEVEL0_MASK;\n+  val >>= dev->chunkGroupBits;\n+\n+  bitInMap = pos * dev->tnodeWidth;\n+  wordInMap = bitInMap /32;\n+  bitInWord = bitInMap & (32 -1);\n+\n+  mask = dev->tnodeMask << bitInWord;\n+\n+  map[wordInMap] &= ~mask;\n+  map[wordInMap] |= (mask & (val << bitInWord));\n+\n+  if(dev->tnodeWidth > (32-bitInWord)) {\n+    bitInWord = (32 - bitInWord);\n+    wordInMap++;;\n+    mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);\n+    map[wordInMap] &= ~mask;\n+    map[wordInMap] |= (mask & (val >> bitInWord));\n+  }\n+}\n+\n+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos)\n+{\n+  __u32 *map = (__u32 *)tn;\n+  __u32 bitInMap;\n+  __u32 bitInWord;\n+  __u32 wordInMap;\n+  __u32 val;\n+\n+  pos &= YAFFS_TNODES_LEVEL0_MASK;\n+\n+  bitInMap = pos * dev->tnodeWidth;\n+  wordInMap = bitInMap /32;\n+  bitInWord = bitInMap & (32 -1);\n+\n+  val = map[wordInMap] >> bitInWord;\n+\n+  if(dev->tnodeWidth > (32-bitInWord)) {\n+    bitInWord = (32 - bitInWord);\n+    wordInMap++;;\n+    val |= (map[wordInMap] << bitInWord);\n+  }\n+\n+  val &= dev->tnodeMask;\n+  val <<= dev->chunkGroupBits;\n+\n+  return val;\n+}\n+\n+/* ------------------- End of individual tnode manipulation -----------------*/\n+\n+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------\n+ * The look up tree is represented by the top tnode and the number of topLevel\n+ * in the tree. 0 means only the level 0 tnode is in the tree.\n+ */\n+\n+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */\n+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,\n+\t\t\t\t\t  yaffs_FileStructure * fStruct,\n+\t\t\t\t\t  __u32 chunkId)\n+{\n+\n+\tyaffs_Tnode *tn = fStruct->top;\n+\t__u32 i;\n+\tint requiredTallness;\n+\tint level = fStruct->topLevel;\n+\n+\t/* Check sane level and chunk Id */\n+\tif (level < 0 || level > YAFFS_TNODES_MAX_LEVEL) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (chunkId > YAFFS_MAX_CHUNK_ID) {\n+\t\treturn NULL;\n+\t}\n+\n+\t/* First check we\'re tall enough (ie enough topLevel) */\n+\n+\ti = chunkId >> YAFFS_TNODES_LEVEL0_BITS;\n+\trequiredTallness = 0;\n+\twhile (i) {\n+\t\ti >>= YAFFS_TNODES_INTERNAL_BITS;\n+\t\trequiredTallness++;\n+\t}\n+\n+\tif (requiredTallness > fStruct->topLevel) {\n+\t\t/* Not tall enough, so we can\'t find it, return NULL. */\n+\t\treturn NULL;\n+\t}\n+\n+\t/* Traverse down to level 0 */\n+\twhile (level > 0 && tn) {\n+\t\ttn = tn->\n+\t\t    internal[(chunkId >>\n+\t\t\t       ( YAFFS_TNODES_LEVEL0_BITS +\n+\t\t\t         (level - 1) *\n+\t\t\t         YAFFS_TNODES_INTERNAL_BITS)\n+\t\t\t      ) &\n+\t\t\t     YAFFS_TNODES_INTERNAL_MASK];\n+\t\tlevel--;\n+\n+\t}\n+\n+\treturn tn;\n+}\n+\n+/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.\n+ * This happens in two steps:\n+ *  1. If the tree isn\'t tall enough, then make it taller.\n+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.\n+ *\n+ * Used when modifying the tree.\n+ *\n+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will\n+ *  be plugged into the ttree.\n+ */\n+\n+static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device * dev,\n+\t\t\t\t\t       yaffs_FileStructure * fStruct,\n+\t\t\t\t\t       __u32 chunkId,\n+\t\t\t\t\t       yaffs_Tnode *passedTn)\n+{\n+\n+\tint requiredTallness;\n+\tint i;\n+\tint l;\n+\tyaffs_Tnode *tn;\n+\n+\t__u32 x;\n+\n+\n+\t/* Check sane level and page Id */\n+\tif (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (chunkId > YAFFS_MAX_CHUNK_ID) {\n+\t\treturn NULL;\n+\t}\n+\n+\t/* First check we\'re tall enough (ie enough topLevel) */\n+\n+\tx = chunkId >> YAFFS_TNODES_LEVEL0_BITS;\n+\trequiredTallness = 0;\n+\twhile (x) {\n+\t\tx >>= YAFFS_TNODES_INTERNAL_BITS;\n+\t\trequiredTallness++;\n+\t}\n+\n+\n+\tif (requiredTallness > fStruct->topLevel) {\n+\t\t/* Not tall enough,gotta make the tree taller */\n+\t\tfor (i = fStruct->topLevel; i < requiredTallness; i++) {\n+\n+\t\t\ttn = yaffs_GetTnode(dev);\n+\n+\t\t\tif (tn) {\n+\t\t\t\ttn->internal[0] = fStruct->top;\n+\t\t\t\tfStruct->top = tn;\n+\t\t\t} else {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR("yaffs: no more tnodes" TENDSTR)));\n+\t\t\t}\n+\t\t}\n+\n+\t\tfStruct->topLevel = requiredTallness;\n+\t}\n+\n+\t/* Traverse down to level 0, adding anything we need */\n+\n+\tl = fStruct->topLevel;\n+\ttn = fStruct->top;\n+\n+\tif(l > 0) {\n+\t\twhile (l > 0 && tn) {\n+\t\t\tx = (chunkId >>\n+\t\t\t     ( YAFFS_TNODES_LEVEL0_BITS +\n+\t\t\t      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &\n+\t\t\t    YAFFS_TNODES_INTERNAL_MASK;\n+\n+\n+\t\t\tif((l>1) && !tn->internal[x]){\n+\t\t\t\t/* Add missing non-level-zero tnode */\n+\t\t\t\ttn->internal[x] = yaffs_GetTnode(dev);\n+\n+\t\t\t} else if(l == 1) {\n+\t\t\t\t/* Looking from level 1 at level 0 */\n+\t\t\t \tif (passedTn) {\n+\t\t\t\t\t/* If we already have one, then release it.*/\n+\t\t\t\t\tif(tn->internal[x])\n+\t\t\t\t\t\tyaffs_FreeTnode(dev,tn->internal[x]);\n+\t\t\t\t\ttn->internal[x] = passedTn;\n+\n+\t\t\t\t} else if(!tn->internal[x]) {\n+\t\t\t\t\t/* Don\'t have one, none passed in */\n+\t\t\t\t\ttn->internal[x] = yaffs_GetTnode(dev);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\ttn = tn->internal[x];\n+\t\t\tl--;\n+\t\t}\n+\t} else {\n+\t\t/* top is level 0 */\n+\t\tif(passedTn) {\n+\t\t\tmemcpy(tn,passedTn,(dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);\n+\t\t\tyaffs_FreeTnode(dev,passedTn);\n+\t\t}\n+\t}\n+\n+\treturn tn;\n+}\n+\n+static int yaffs_FindChunkInGroup(yaffs_Device * dev, int theChunk,\n+\t\t\t\t  yaffs_ExtendedTags * tags, int objectId,\n+\t\t\t\t  int chunkInInode)\n+{\n+\tint j;\n+\n+\tfor (j = 0; theChunk && j < dev->chunkGroupSize; j++) {\n+\t\tif (yaffs_CheckChunkBit\n+\t\t    (dev, theChunk / dev->nChunksPerBlock,\n+\t\t     theChunk % dev->nChunksPerBlock)) {\n+\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,\n+\t\t\t\t\t\t\ttags);\n+\t\t\tif (yaffs_TagsMatch(tags, objectId, chunkInInode)) {\n+\t\t\t\t/* found it; */\n+\t\t\t\treturn theChunk;\n+\n+\t\t\t}\n+\t\t}\n+\t\ttheChunk++;\n+\t}\n+\treturn -1;\n+}\n+\n+\n+/* DeleteWorker scans backwards through the tnode tree and deletes all the\n+ * chunks and tnodes in the file\n+ * Returns 1 if the tree was deleted.\n+ * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.\n+ */\n+\n+static int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,\n+\t\t\t      int chunkOffset, int *limit)\n+{\n+\tint i;\n+\tint chunkInInode;\n+\tint theChunk;\n+\tyaffs_ExtendedTags tags;\n+\tint foundChunk;\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tint allDone = 1;\n+\n+\tif (tn) {\n+\t\tif (level > 0) {\n+\n+\t\t\tfor (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;\n+\t\t\t     i--) {\n+\t\t\t\tif (tn->internal[i]) {\n+\t\t\t\t\tif (limit && (*limit) < 0) {\n+\t\t\t\t\t\tallDone = 0;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tallDone =\n+\t\t\t\t\t\t    yaffs_DeleteWorker(in,\n+\t\t\t\t\t\t\t\t       tn->\n+\t\t\t\t\t\t\t\t       internal\n+\t\t\t\t\t\t\t\t       [i],\n+\t\t\t\t\t\t\t\t       level -\n+\t\t\t\t\t\t\t\t       1,\n+\t\t\t\t\t\t\t\t       (chunkOffset\n+\t\t\t\t\t\t\t\t\t<<\n+\t\t\t\t\t\t\t\t\tYAFFS_TNODES_INTERNAL_BITS)\n+\t\t\t\t\t\t\t\t       + i,\n+\t\t\t\t\t\t\t\t       limit);\n+\t\t\t\t\t}\n+\t\t\t\t\tif (allDone) {\n+\t\t\t\t\t\tyaffs_FreeTnode(dev,\n+\t\t\t\t\t\t\t\ttn->\n+\t\t\t\t\t\t\t\tinternal[i]);\n+\t\t\t\t\t\ttn->internal[i] = NULL;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t\treturn (allDone) ? 1 : 0;\n+\t\t} else if (level == 0) {\n+\t\t\tint hitLimit = 0;\n+\n+\t\t\tfor (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;\n+\t\t\t     i--) {\n+\t\t\t        theChunk = yaffs_GetChunkGroupBase(dev,tn,i);\n+\t\t\t\tif (theChunk) {\n+\n+\t\t\t\t\tchunkInInode =\n+\t\t\t\t\t    (chunkOffset <<\n+\t\t\t\t\t     YAFFS_TNODES_LEVEL0_BITS) + i;\n+\n+\t\t\t\t\tfoundChunk =\n+\t\t\t\t\t    yaffs_FindChunkInGroup(dev,\n+\t\t\t\t\t\t\t\t   theChunk,\n+\t\t\t\t\t\t\t\t   &tags,\n+\t\t\t\t\t\t\t\t   in->objectId,\n+\t\t\t\t\t\t\t\t   chunkInInode);\n+\n+\t\t\t\t\tif (foundChunk > 0) {\n+\t\t\t\t\t\tyaffs_DeleteChunk(dev,\n+\t\t\t\t\t\t\t\t  foundChunk, 1,\n+\t\t\t\t\t\t\t\t  __LINE__);\n+\t\t\t\t\t\tin->nDataChunks--;\n+\t\t\t\t\t\tif (limit) {\n+\t\t\t\t\t\t\t*limit = *limit - 1;\n+\t\t\t\t\t\t\tif (*limit <= 0) {\n+\t\t\t\t\t\t\t\thitLimit = 1;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tyaffs_PutLevel0Tnode(dev,tn,i,0);\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t\treturn (i < 0) ? 1 : 0;\n+\n+\t\t}\n+\n+\t}\n+\n+\treturn 1;\n+\n+}\n+\n+static void yaffs_SoftDeleteChunk(yaffs_Device * dev, int chunk)\n+{\n+\n+\tyaffs_BlockInfo *theBlock;\n+\n+\tT(YAFFS_TRACE_DELETION, (TSTR("soft delete chunk %d" TENDSTR), chunk));\n+\n+\ttheBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);\n+\tif (theBlock) {\n+\t\ttheBlock->softDeletions++;\n+\t\tdev->nFreeChunks++;\n+\t}\n+}\n+\n+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.\n+ * All soft deleting does is increment the block\'s softdelete count and pulls the chunk out\n+ * of the tnode.\n+ * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.\n+ */\n+\n+static int yaffs_SoftDeleteWorker(yaffs_Object * in, yaffs_Tnode * tn,\n+\t\t\t\t  __u32 level, int chunkOffset)\n+{\n+\tint i;\n+\tint theChunk;\n+\tint allDone = 1;\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tif (tn) {\n+\t\tif (level > 0) {\n+\n+\t\t\tfor (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;\n+\t\t\t     i--) {\n+\t\t\t\tif (tn->internal[i]) {\n+\t\t\t\t\tallDone =\n+\t\t\t\t\t    yaffs_SoftDeleteWorker(in,\n+\t\t\t\t\t\t\t\t   tn->\n+\t\t\t\t\t\t\t\t   internal[i],\n+\t\t\t\t\t\t\t\t   level - 1,\n+\t\t\t\t\t\t\t\t   (chunkOffset\n+\t\t\t\t\t\t\t\t    <<\n+\t\t\t\t\t\t\t\t    YAFFS_TNODES_INTERNAL_BITS)\n+\t\t\t\t\t\t\t\t   + i);\n+\t\t\t\t\tif (allDone) {\n+\t\t\t\t\t\tyaffs_FreeTnode(dev,\n+\t\t\t\t\t\t\t\ttn->\n+\t\t\t\t\t\t\t\tinternal[i]);\n+\t\t\t\t\t\ttn->internal[i] = NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* Hoosterman... how could this happen? */\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn (allDone) ? 1 : 0;\n+\t\t} else if (level == 0) {\n+\n+\t\t\tfor (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {\n+\t\t\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,i);\n+\t\t\t\tif (theChunk) {\n+\t\t\t\t\t/* Note this does not find the real chunk, only the chunk group.\n+\t\t\t\t\t * We make an assumption that a chunk group is not larger than\n+\t\t\t\t\t * a block.\n+\t\t\t\t\t */\n+\t\t\t\t\tyaffs_SoftDeleteChunk(dev, theChunk);\n+\t\t\t\t\tyaffs_PutLevel0Tnode(dev,tn,i,0);\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t\treturn 1;\n+\n+\t\t}\n+\n+\t}\n+\n+\treturn 1;\n+\n+}\n+\n+static void yaffs_SoftDeleteFile(yaffs_Object * obj)\n+{\n+\tif (obj->deleted &&\n+\t    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {\n+\t\tif (obj->nDataChunks <= 0) {\n+\t\t\t/* Empty file with no duplicate object headers, just delete it immediately */\n+\t\t\tyaffs_FreeTnode(obj->myDev,\n+\t\t\t\t\tobj->variant.fileVariant.top);\n+\t\t\tobj->variant.fileVariant.top = NULL;\n+\t\t\tT(YAFFS_TRACE_TRACING,\n+\t\t\t  (TSTR("yaffs: Deleting empty file %d" TENDSTR),\n+\t\t\t   obj->objectId));\n+\t\t\tyaffs_DoGenericObjectDeletion(obj);\n+\t\t} else {\n+\t\t\tyaffs_SoftDeleteWorker(obj,\n+\t\t\t\t\t       obj->variant.fileVariant.top,\n+\t\t\t\t\t       obj->variant.fileVariant.\n+\t\t\t\t\t       topLevel, 0);\n+\t\t\tobj->softDeleted = 1;\n+\t\t}\n+\t}\n+}\n+\n+/* Pruning removes any part of the file structure tree that is beyond the\n+ * bounds of the file (ie that does not point to chunks).\n+ *\n+ * A file should only get pruned when its size is reduced.\n+ *\n+ * Before pruning, the chunks must be pulled from the tree and the\n+ * level 0 tnode entries must be zeroed out.\n+ * Could also use this for file deletion, but that\'s probably better handled\n+ * by a special case.\n+ */\n+\n+static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device * dev, yaffs_Tnode * tn,\n+\t\t\t\t      __u32 level, int del0)\n+{\n+\tint i;\n+\tint hasData;\n+\n+\tif (tn) {\n+\t\thasData = 0;\n+\n+\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {\n+\t\t\tif (tn->internal[i] && level > 0) {\n+\t\t\t\ttn->internal[i] =\n+\t\t\t\t    yaffs_PruneWorker(dev, tn->internal[i],\n+\t\t\t\t\t\t      level - 1,\n+\t\t\t\t\t\t      (i == 0) ? del0 : 1);\n+\t\t\t}\n+\n+\t\t\tif (tn->internal[i]) {\n+\t\t\t\thasData++;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (hasData == 0 && del0) {\n+\t\t\t/* Free and return NULL */\n+\n+\t\t\tyaffs_FreeTnode(dev, tn);\n+\t\t\ttn = NULL;\n+\t\t}\n+\n+\t}\n+\n+\treturn tn;\n+\n+}\n+\n+static int yaffs_PruneFileStructure(yaffs_Device * dev,\n+\t\t\t\t    yaffs_FileStructure * fStruct)\n+{\n+\tint i;\n+\tint hasData;\n+\tint done = 0;\n+\tyaffs_Tnode *tn;\n+\n+\tif (fStruct->topLevel > 0) {\n+\t\tfStruct->top =\n+\t\t    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);\n+\n+\t\t/* Now we have a tree with all the non-zero branches NULL but the height\n+\t\t * is the same as it was.\n+\t\t * Let\'s see if we can trim internal tnodes to shorten the tree.\n+\t\t * We can do this if only the 0th element in the tnode is in use\n+\t\t * (ie all the non-zero are NULL)\n+\t\t */\n+\n+\t\twhile (fStruct->topLevel && !done) {\n+\t\t\ttn = fStruct->top;\n+\n+\t\t\thasData = 0;\n+\t\t\tfor (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {\n+\t\t\t\tif (tn->internal[i]) {\n+\t\t\t\t\thasData++;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (!hasData) {\n+\t\t\t\tfStruct->top = tn->internal[0];\n+\t\t\t\tfStruct->topLevel--;\n+\t\t\t\tyaffs_FreeTnode(dev, tn);\n+\t\t\t} else {\n+\t\t\t\tdone = 1;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn YAFFS_OK;\n+}\n+\n+/*-------------------- End of File Structure functions.-------------------*/\n+\n+/* yaffs_CreateFreeObjects creates a bunch more objects and\n+ * adds them to the object free list.\n+ */\n+static int yaffs_CreateFreeObjects(yaffs_Device * dev, int nObjects)\n+{\n+\tint i;\n+\tyaffs_Object *newObjects;\n+\tyaffs_ObjectList *list;\n+\n+\tif (nObjects < 1)\n+\t\treturn YAFFS_OK;\n+\n+\t/* make these things */\n+\tnewObjects = YMALLOC(nObjects * sizeof(yaffs_Object));\n+\tlist = YMALLOC(sizeof(yaffs_ObjectList));\n+\n+\tif (!newObjects || !list) {\n+\t\tif(newObjects)\n+\t\t\tYFREE(newObjects);\n+\t\tif(list)\n+\t\t\tYFREE(list);\n+\t\tT(YAFFS_TRACE_ALLOCATE,\n+\t\t  (TSTR("yaffs: Could not allocate more objects" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+        /* Hook them into the free list */\n+        for (i = 0; i < nObjects - 1; i++) {\n+                newObjects[i].siblings.next =\n+                    (struct ylist_head *)(&newObjects[i + 1]);\n+        }\n+\n+        newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;\n+\tdev->freeObjects = newObjects;\n+\tdev->nFreeObjects += nObjects;\n+\tdev->nObjectsCreated += nObjects;\n+\n+\t/* Now add this bunch of Objects to a list for freeing up. */\n+\n+\tlist->objects = newObjects;\n+\tlist->next = dev->allocatedObjectList;\n+\tdev->allocatedObjectList = list;\n+\n+\treturn YAFFS_OK;\n+}\n+\n+\n+/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */\n+static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device * dev)\n+{\n+\tyaffs_Object *tn = NULL;\n+\n+\t/* If there are none left make more */\n+\tif (!dev->freeObjects) {\n+\t\tyaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);\n+\t}\n+\n+\tif (dev->freeObjects) {\n+\t\ttn = dev->freeObjects;\n+\t\tdev->freeObjects =\n+\t\t    (yaffs_Object *) (dev->freeObjects->siblings.next);\n+\t\tdev->nFreeObjects--;\n+\n+\t\t/* Now sweeten it up... */\n+\n+\t\tmemset(tn, 0, sizeof(yaffs_Object));\n+\t\ttn->myDev = dev;\n+\t\ttn->hdrChunk = 0;\n+\t\ttn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;\n+\t\tYINIT_LIST_HEAD(&(tn->hardLinks));\n+\t\tYINIT_LIST_HEAD(&(tn->hashLink));\n+\t\tYINIT_LIST_HEAD(&tn->siblings);\n+\n+                /* Add it to the lost and found directory.\n+                 * NB Can\'t put root or lostNFound in lostNFound so\n+\t\t * check if lostNFound exists first\n+\t\t */\n+\t\tif (dev->lostNFoundDir) {\n+\t\t\tyaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);\n+\t\t}\n+\t}\n+\n+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n+\n+\treturn tn;\n+}\n+\n+static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device * dev, int number,\n+\t\t\t\t\t       __u32 mode)\n+{\n+\n+\tyaffs_Object *obj =\n+\t    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);\n+\tif (obj) {\n+\t\tobj->fake = 1;\t\t/* it is fake so it might have no NAND presence... */\n+\t\tobj->renameAllowed = 0;\t/* ... and we\'re not allowed to rename it... */\n+\t\tobj->unlinkAllowed = 0;\t/* ... or unlink it */\n+\t\tobj->deleted = 0;\n+\t\tobj->unlinked = 0;\n+\t\tobj->yst_mode = mode;\n+\t\tobj->myDev = dev;\n+\t\tobj->hdrChunk = 0;\t/* Not a valid chunk. */\n+\t}\n+\n+\treturn obj;\n+\n+}\n+\n+static void yaffs_UnhashObject(yaffs_Object * tn)\n+{\n+\tint bucket;\n+        yaffs_Device *dev = tn->myDev;\n+\n+        /* If it is still linked into the bucket list, free from the list */\n+        if (!ylist_empty(&tn->hashLink)) {\n+                ylist_del_init(&tn->hashLink);\n+                bucket = yaffs_HashFunction(tn->objectId);\n+                dev->objectBucket[bucket].count--;\n+        }\n+\n+}\n+\n+/*  FreeObject frees up a Object and puts it back on the free list */\n+static void yaffs_FreeObject(yaffs_Object * tn)\n+{\n+\n+\tyaffs_Device *dev = tn->myDev;\n+\n+#ifdef  __KERNEL__\n+\tif (tn->myInode) {\n+\t\t/* We\'re still hooked up to a cached inode.\n+\t\t * Don\'t delete now, but mark for later deletion\n+\t\t */\n+\t\ttn->deferedFree = 1;\n+\t\treturn;\n+\t}\n+#endif\n+\n+        yaffs_UnhashObject(tn);\n+\n+        /* Link into the free list. */\n+        tn->siblings.next = (struct ylist_head *)(dev->freeObjects);\n+        dev->freeObjects = tn;\n+        dev->nFreeObjects++;\n+\n+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/\n+\n+}\n+\n+#ifdef __KERNEL__\n+\n+void yaffs_HandleDeferedFree(yaffs_Object * obj)\n+{\n+\tif (obj->deferedFree) {\n+\t\tyaffs_FreeObject(obj);\n+\t}\n+}\n+\n+#endif\n+\n+static void yaffs_DeinitialiseObjects(yaffs_Device * dev)\n+{\n+\t/* Free the list of allocated Objects */\n+\n+\tyaffs_ObjectList *tmp;\n+\n+\twhile (dev->allocatedObjectList) {\n+\t\ttmp = dev->allocatedObjectList->next;\n+\t\tYFREE(dev->allocatedObjectList->objects);\n+\t\tYFREE(dev->allocatedObjectList);\n+\n+\t\tdev->allocatedObjectList = tmp;\n+\t}\n+\n+\tdev->freeObjects = NULL;\n+\tdev->nFreeObjects = 0;\n+}\n+\n+static void yaffs_InitialiseObjects(yaffs_Device * dev)\n+{\n+\tint i;\n+\n+\tdev->allocatedObjectList = NULL;\n+\tdev->freeObjects = NULL;\n+        dev->nFreeObjects = 0;\n+\n+        for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {\n+                YINIT_LIST_HEAD(&dev->objectBucket[i].list);\n+                dev->objectBucket[i].count = 0;\n+        }\n+\n+}\n+\n+static int yaffs_FindNiceObjectBucket(yaffs_Device * dev)\n+{\n+\tstatic int x = 0;\n+\tint i;\n+\tint l = 999;\n+\tint lowest = 999999;\n+\n+\t/* First let\'s see if we can find one that\'s empty. */\n+\n+\tfor (i = 0; i < 10 && lowest > 0; i++) {\n+\t\tx++;\n+\t\tx %= YAFFS_NOBJECT_BUCKETS;\n+\t\tif (dev->objectBucket[x].count < lowest) {\n+\t\t\tlowest = dev->objectBucket[x].count;\n+\t\t\tl = x;\n+\t\t}\n+\n+\t}\n+\n+\t/* If we didn\'t find an empty list, then try\n+\t * looking a bit further for a short one\n+\t */\n+\n+\tfor (i = 0; i < 10 && lowest > 3; i++) {\n+\t\tx++;\n+\t\tx %= YAFFS_NOBJECT_BUCKETS;\n+\t\tif (dev->objectBucket[x].count < lowest) {\n+\t\t\tlowest = dev->objectBucket[x].count;\n+\t\t\tl = x;\n+\t\t}\n+\n+\t}\n+\n+\treturn l;\n+}\n+\n+static int yaffs_CreateNewObjectNumber(yaffs_Device * dev)\n+{\n+\tint bucket = yaffs_FindNiceObjectBucket(dev);\n+\n+\t/* Now find an object value that has not already been taken\n+\t * by scanning the list.\n+         */\n+\n+        int found = 0;\n+        struct ylist_head *i;\n+\n+        __u32 n = (__u32) bucket;\n+\n+\t/* yaffs_CheckObjectHashSanity();  */\n+\n+\twhile (!found) {\n+                found = 1;\n+                n += YAFFS_NOBJECT_BUCKETS;\n+                if (1 || dev->objectBucket[bucket].count > 0) {\n+                        ylist_for_each(i, &dev->objectBucket[bucket].list) {\n+                                /* If there is already one in the list */\n+                                if (i\n+                                    && ylist_entry(i, yaffs_Object,\n+                                                  hashLink)->objectId == n) {\n+                                        found = 0;\n+                                }\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\treturn n;\n+}\n+\n+static void yaffs_HashObject(yaffs_Object * in)\n+{\n+        int bucket = yaffs_HashFunction(in->objectId);\n+        yaffs_Device *dev = in->myDev;\n+\n+        ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);\n+        dev->objectBucket[bucket].count++;\n+\n+}\n+\n+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number)\n+{\n+        int bucket = yaffs_HashFunction(number);\n+        struct ylist_head *i;\n+        yaffs_Object *in;\n+\n+        ylist_for_each(i, &dev->objectBucket[bucket].list) {\n+                /* Look if it is in the list */\n+                if (i) {\n+                        in = ylist_entry(i, yaffs_Object, hashLink);\n+                        if (in->objectId == number) {\n+#ifdef __KERNEL__\n+                                /* Don\'t tell the VFS about this one if it is defered free */\n+\t\t\t\tif (in->deferedFree)\n+\t\t\t\t\treturn NULL;\n+#endif\n+\n+\t\t\t\treturn in;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,\n+\t\t\t\t    yaffs_ObjectType type)\n+{\n+\n+\tyaffs_Object *theObject;\n+\tyaffs_Tnode *tn = NULL;\n+\n+\tif (number < 0) {\n+\t\tnumber = yaffs_CreateNewObjectNumber(dev);\n+\t}\n+\n+\ttheObject = yaffs_AllocateEmptyObject(dev);\n+\tif(!theObject)\n+\t\treturn NULL;\n+\n+\tif(type == YAFFS_OBJECT_TYPE_FILE){\n+\t\ttn = yaffs_GetTnode(dev);\n+\t\tif(!tn){\n+\t\t\tyaffs_FreeObject(theObject);\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\n+\n+\tif (theObject) {\n+\t\ttheObject->fake = 0;\n+\t\ttheObject->renameAllowed = 1;\n+\t\ttheObject->unlinkAllowed = 1;\n+\t\ttheObject->objectId = number;\n+\t\tyaffs_HashObject(theObject);\n+\t\ttheObject->variantType = type;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\tyfsd_WinFileTimeNow(theObject->win_atime);\n+\t\ttheObject->win_ctime[0] = theObject->win_mtime[0] =\n+\t\t    theObject->win_atime[0];\n+\t\ttheObject->win_ctime[1] = theObject->win_mtime[1] =\n+\t\t    theObject->win_atime[1];\n+\n+#else\n+\n+\t\ttheObject->yst_atime = theObject->yst_mtime =\n+\t\t    theObject->yst_ctime = Y_CURRENT_TIME;\n+#endif\n+\t\tswitch (type) {\n+\t\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\t\ttheObject->variant.fileVariant.fileSize = 0;\n+\t\t\ttheObject->variant.fileVariant.scannedFileSize = 0;\n+\t\t\ttheObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;\t/* max __u32 */\n+\t\t\ttheObject->variant.fileVariant.topLevel = 0;\n+                        theObject->variant.fileVariant.top = tn;\n+                        break;\n+                case YAFFS_OBJECT_TYPE_DIRECTORY:\n+                        YINIT_LIST_HEAD(&theObject->variant.directoryVariant.\n+                                       children);\n+                        break;\n+                case YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\t\t/* No action required */\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\t\t/* todo this should not happen */\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\treturn theObject;\n+}\n+\n+static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device * dev,\n+\t\t\t\t\t\t      int number,\n+\t\t\t\t\t\t      yaffs_ObjectType type)\n+{\n+\tyaffs_Object *theObject = NULL;\n+\n+\tif (number > 0) {\n+\t\ttheObject = yaffs_FindObjectByNumber(dev, number);\n+\t}\n+\n+\tif (!theObject) {\n+\t\ttheObject = yaffs_CreateNewObject(dev, number, type);\n+\t}\n+\n+\treturn theObject;\n+\n+}\n+\n+\n+static YCHAR *yaffs_CloneString(const YCHAR * str)\n+{\n+\tYCHAR *newStr = NULL;\n+\n+\tif (str && *str) {\n+\t\tnewStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));\n+\t\tif(newStr)\n+\t\t\tyaffs_strcpy(newStr, str);\n+\t}\n+\n+\treturn newStr;\n+\n+}\n+\n+/*\n+ * Mknod (create) a new object.\n+ * equivalentObject only has meaning for a hard link;\n+ * aliasString only has meaning for a sumlink.\n+ * rdev only has meaning for devices (a subset of special objects)\n+ */\n+\n+static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,\n+\t\t\t\t       yaffs_Object * parent,\n+\t\t\t\t       const YCHAR * name,\n+\t\t\t\t       __u32 mode,\n+\t\t\t\t       __u32 uid,\n+\t\t\t\t       __u32 gid,\n+\t\t\t\t       yaffs_Object * equivalentObject,\n+\t\t\t\t       const YCHAR * aliasString, __u32 rdev)\n+{\n+\tyaffs_Object *in;\n+\tYCHAR *str = NULL;\n+\n+\tyaffs_Device *dev = parent->myDev;\n+\n+\t/* Check if the entry exists. If it does then fail the call since we don\'t want a dup.*/\n+\tif (yaffs_FindObjectByName(parent, name)) {\n+\t\treturn NULL;\n+\t}\n+\n+\tin = yaffs_CreateNewObject(dev, -1, type);\n+\n+\tif(type == YAFFS_OBJECT_TYPE_SYMLINK){\n+\t\tstr = yaffs_CloneString(aliasString);\n+\t\tif(!str){\n+\t\t\tyaffs_FreeObject(in);\n+\t\t\treturn NULL;\n+\t\t}\n+\t}\n+\n+\n+\n+\tif (in) {\n+\t\tin->hdrChunk = 0;\n+\t\tin->valid = 1;\n+\t\tin->variantType = type;\n+\n+\t\tin->yst_mode = mode;\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\tyfsd_WinFileTimeNow(in->win_atime);\n+\t\tin->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];\n+\t\tin->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];\n+\n+#else\n+\t\tin->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;\n+\n+\t\tin->yst_rdev = rdev;\n+\t\tin->yst_uid = uid;\n+\t\tin->yst_gid = gid;\n+#endif\n+\t\tin->nDataChunks = 0;\n+\n+\t\tyaffs_SetObjectName(in, name);\n+\t\tin->dirty = 1;\n+\n+\t\tyaffs_AddObjectToDirectory(parent, in);\n+\n+\t\tin->myDev = parent->myDev;\n+\n+\t\tswitch (type) {\n+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\t\tin->variant.symLinkVariant.alias = str;\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\t\tin->variant.hardLinkVariant.equivalentObject =\n+                            equivalentObject;\n+                        in->variant.hardLinkVariant.equivalentObjectId =\n+                            equivalentObject->objectId;\n+                        ylist_add(&in->hardLinks, &equivalentObject->hardLinks);\n+                        break;\n+                case YAFFS_OBJECT_TYPE_FILE:\n+                case YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\t\t/* do nothing */\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tif (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {\n+\t\t\t/* Could not create the object header, fail the creation */\n+\t\t\tyaffs_DestroyObject(in);\n+\t\t\tin = NULL;\n+\t\t}\n+\n+\t}\n+\n+\treturn in;\n+}\n+\n+yaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t      __u32 mode, __u32 uid, __u32 gid)\n+{\n+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,\n+\t\t\t\t uid, gid, NULL, NULL, 0);\n+}\n+\n+yaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t   __u32 mode, __u32 uid, __u32 gid)\n+{\n+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,\n+\t\t\t\t mode, uid, gid, NULL, NULL, 0);\n+}\n+\n+yaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t __u32 mode, __u32 uid, __u32 gid, __u32 rdev)\n+{\n+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,\n+\t\t\t\t uid, gid, NULL, NULL, rdev);\n+}\n+\n+yaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t __u32 mode, __u32 uid, __u32 gid,\n+\t\t\t\t const YCHAR * alias)\n+{\n+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,\n+\t\t\t\t uid, gid, NULL, alias, 0);\n+}\n+\n+/* yaffs_Link returns the object id of the equivalent object.*/\n+yaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t yaffs_Object * equivalentObject)\n+{\n+\t/* Get the real object in case we were fed a hard link as an equivalent object */\n+\tequivalentObject = yaffs_GetEquivalentObject(equivalentObject);\n+\n+\tif (yaffs_MknodObject\n+\t    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,\n+\t     equivalentObject, NULL, 0)) {\n+\t\treturn equivalentObject;\n+\t} else {\n+\t\treturn NULL;\n+\t}\n+\n+}\n+\n+static int yaffs_ChangeObjectName(yaffs_Object * obj, yaffs_Object * newDir,\n+\t\t\t\t  const YCHAR * newName, int force, int shadows)\n+{\n+\tint unlinkOp;\n+\tint deleteOp;\n+\n+\tyaffs_Object *existingTarget;\n+\n+\tif (newDir == NULL) {\n+\t\tnewDir = obj->parent;\t/* use the old directory */\n+\t}\n+\n+\tif (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragendy: yaffs_ChangeObjectName: newDir is not a directory"\n+\t\t    TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\n+\t/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */\n+\tif (obj->myDev->isYaffs2) {\n+\t\tunlinkOp = (newDir == obj->myDev->unlinkedDir);\n+\t} else {\n+\t\tunlinkOp = (newDir == obj->myDev->unlinkedDir\n+\t\t\t    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);\n+\t}\n+\n+\tdeleteOp = (newDir == obj->myDev->deletedDir);\n+\n+\texistingTarget = yaffs_FindObjectByName(newDir, newName);\n+\n+\t/* If the object is a file going into the unlinked directory,\n+\t *   then it is OK to just stuff it in since duplicate names are allowed.\n+\t *   else only proceed if the new name does not exist and if we\'re putting\n+\t *   it into a directory.\n+\t */\n+\tif ((unlinkOp ||\n+\t     deleteOp ||\n+\t     force ||\n+\t     (shadows > 0) ||\n+\t     !existingTarget) &&\n+\t    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {\n+\t\tyaffs_SetObjectName(obj, newName);\n+\t\tobj->dirty = 1;\n+\n+\t\tyaffs_AddObjectToDirectory(newDir, obj);\n+\n+\t\tif (unlinkOp)\n+\t\t\tobj->unlinked = 1;\n+\n+\t\t/* If it is a deletion then we mark it as a shrink for gc purposes. */\n+\t\tif (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows)>= 0)\n+\t\t\treturn YAFFS_OK;\n+\t}\n+\n+\treturn YAFFS_FAIL;\n+}\n+\n+int yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,\n+\t\t       yaffs_Object * newDir, const YCHAR * newName)\n+{\n+\tyaffs_Object *obj;\n+\tyaffs_Object *existingTarget;\n+\tint force = 0;\n+\n+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE\n+\t/* Special case for case insemsitive systems (eg. WinCE).\n+\t * While look-up is case insensitive, the name isn\'t.\n+\t * Therefore we might want to change x.txt to X.txt\n+\t*/\n+\tif (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0) {\n+\t\tforce = 1;\n+\t}\n+#endif\n+\n+\tobj = yaffs_FindObjectByName(oldDir, oldName);\n+\t/* Check new name to long. */\n+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK &&\n+\t    yaffs_strlen(newName) > YAFFS_MAX_ALIAS_LENGTH)\n+\t  /* ENAMETOOLONG */\n+\t  return YAFFS_FAIL;\n+\telse if (obj->variantType != YAFFS_OBJECT_TYPE_SYMLINK &&\n+\t\t yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)\n+\t  /* ENAMETOOLONG */\n+\t  return YAFFS_FAIL;\n+\n+\tif (obj && obj->renameAllowed) {\n+\n+\t\t/* Now do the handling for an existing target, if there is one */\n+\n+                existingTarget = yaffs_FindObjectByName(newDir, newName);\n+                if (existingTarget &&\n+                    existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&\n+                    !ylist_empty(&existingTarget->variant.directoryVariant.children)) {\n+                        /* There is a target that is a non-empty directory, so we fail */\n+                        return YAFFS_FAIL;      /* EEXIST or ENOTEMPTY */\n+                } else if (existingTarget && existingTarget != obj) {\n+\t\t\t/* Nuke the target first, using shadowing,\n+\t\t\t * but only if it isn\'t the same object\n+\t\t\t */\n+\t\t\tyaffs_ChangeObjectName(obj, newDir, newName, force,\n+\t\t\t\t\t       existingTarget->objectId);\n+\t\t\tyaffs_UnlinkObject(existingTarget);\n+\t\t}\n+\n+\t\treturn yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);\n+\t}\n+\treturn YAFFS_FAIL;\n+}\n+\n+/*------------------------- Block Management and Page Allocation ----------------*/\n+\n+static int yaffs_InitialiseBlocks(yaffs_Device * dev)\n+{\n+\tint nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;\n+\n+\tdev->blockInfo = NULL;\n+\tdev->chunkBits = NULL;\n+\n+\tdev->allocationBlock = -1;\t/* force it to get a new one */\n+\n+\t/* If the first allocation strategy fails, thry the alternate one */\n+\tdev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));\n+\tif(!dev->blockInfo){\n+\t\tdev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));\n+\t\tdev->blockInfoAlt = 1;\n+\t}\n+\telse\n+\t\tdev->blockInfoAlt = 0;\n+\n+\tif(dev->blockInfo){\n+\n+\t\t/* Set up dynamic blockinfo stuff. */\n+\t\tdev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */\n+\t\tdev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);\n+\t\tif(!dev->chunkBits){\n+\t\t\tdev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);\n+\t\t\tdev->chunkBitsAlt = 1;\n+\t\t}\n+\t\telse\n+\t\t\tdev->chunkBitsAlt = 0;\n+\t}\n+\n+\tif (dev->blockInfo && dev->chunkBits) {\n+\t\tmemset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));\n+\t\tmemset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);\n+\t\treturn YAFFS_OK;\n+\t}\n+\n+\treturn YAFFS_FAIL;\n+\n+}\n+\n+static void yaffs_DeinitialiseBlocks(yaffs_Device * dev)\n+{\n+\tif(dev->blockInfoAlt && dev->blockInfo)\n+\t\tYFREE_ALT(dev->blockInfo);\n+\telse if(dev->blockInfo)\n+\t\tYFREE(dev->blockInfo);\n+\n+\tdev->blockInfoAlt = 0;\n+\n+\tdev->blockInfo = NULL;\n+\n+\tif(dev->chunkBitsAlt && dev->chunkBits)\n+\t\tYFREE_ALT(dev->chunkBits);\n+\telse if(dev->chunkBits)\n+\t\tYFREE(dev->chunkBits);\n+\tdev->chunkBitsAlt = 0;\n+\tdev->chunkBits = NULL;\n+}\n+\n+static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device * dev,\n+\t\t\t\t\t    yaffs_BlockInfo * bi)\n+{\n+\tint i;\n+\t__u32 seq;\n+\tyaffs_BlockInfo *b;\n+\n+\tif (!dev->isYaffs2)\n+\t\treturn 1;\t/* disqualification only applies to yaffs2. */\n+\n+\tif (!bi->hasShrinkHeader)\n+\t\treturn 1;\t/* can gc */\n+\n+\t/* Find the oldest dirty sequence number if we don\'t know it and save it\n+\t * so we don\'t have to keep recomputing it.\n+\t */\n+\tif (!dev->oldestDirtySequence) {\n+\t\tseq = dev->sequenceNumber;\n+\n+\t\tfor (i = dev->internalStartBlock; i <= dev->internalEndBlock;\n+\t\t     i++) {\n+\t\t\tb = yaffs_GetBlockInfo(dev, i);\n+\t\t\tif (b->blockState == YAFFS_BLOCK_STATE_FULL &&\n+\t\t\t    (b->pagesInUse - b->softDeletions) <\n+\t\t\t    dev->nChunksPerBlock && b->sequenceNumber < seq) {\n+\t\t\t\tseq = b->sequenceNumber;\n+\t\t\t}\n+\t\t}\n+\t\tdev->oldestDirtySequence = seq;\n+\t}\n+\n+\t/* Can\'t do gc of this block if there are any blocks older than this one that have\n+\t * discarded pages.\n+\t */\n+\treturn (bi->sequenceNumber <= dev->oldestDirtySequence);\n+\n+}\n+\n+/* FindDiretiestBlock is used to select the dirtiest block (or close enough)\n+ * for garbage collection.\n+ */\n+\n+static int yaffs_FindBlockForGarbageCollection(yaffs_Device * dev,\n+\t\t\t\t\t       int aggressive)\n+{\n+\n+\tint b = dev->currentDirtyChecker;\n+\n+\tint i;\n+\tint iterations;\n+\tint dirtiest = -1;\n+\tint pagesInUse = 0;\n+\tint prioritised=0;\n+\tyaffs_BlockInfo *bi;\n+\tint pendingPrioritisedExist = 0;\n+\n+\t/* First let\'s see if we need to grab a prioritised block */\n+\tif(dev->hasPendingPrioritisedGCs){\n+\t\tfor(i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++){\n+\n+\t\t\tbi = yaffs_GetBlockInfo(dev, i);\n+\t\t\t//yaffs_VerifyBlock(dev,bi,i);\n+\n+\t\t\tif(bi->gcPrioritise) {\n+\t\t\t\tpendingPrioritisedExist = 1;\n+\t\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_FULL &&\n+\t\t\t\t   yaffs_BlockNotDisqualifiedFromGC(dev, bi)){\n+\t\t\t\t\tpagesInUse = (bi->pagesInUse - bi->softDeletions);\n+\t\t\t\t\tdirtiest = i;\n+\t\t\t\t\tprioritised = 1;\n+\t\t\t\t\taggressive = 1; /* Fool the non-aggressive skip logiv below */\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif(!pendingPrioritisedExist) /* None found, so we can clear this */\n+\t\t\tdev->hasPendingPrioritisedGCs = 0;\n+\t}\n+\n+\t/* If we\'re doing aggressive GC then we are happy to take a less-dirty block, and\n+\t * search harder.\n+\t * else (we\'re doing a leasurely gc), then we only bother to do this if the\n+\t * block has only a few pages in use.\n+\t */\n+\n+\tdev->nonAggressiveSkip--;\n+\n+\tif (!aggressive && (dev->nonAggressiveSkip > 0)) {\n+\t\treturn -1;\n+\t}\n+\n+\tif(!prioritised)\n+\t\tpagesInUse =\n+\t    \t\t(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;\n+\n+\tif (aggressive) {\n+\t\titerations =\n+\t\t    dev->internalEndBlock - dev->internalStartBlock + 1;\n+\t} else {\n+\t\titerations =\n+\t\t    dev->internalEndBlock - dev->internalStartBlock + 1;\n+\t\titerations = iterations / 16;\n+\t\tif (iterations > 200) {\n+\t\t\titerations = 200;\n+\t\t}\n+\t}\n+\n+\tfor (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {\n+\t\tb++;\n+\t\tif (b < dev->internalStartBlock || b > dev->internalEndBlock) {\n+\t\t\tb = dev->internalStartBlock;\n+\t\t}\n+\n+\t\tif (b < dev->internalStartBlock || b > dev->internalEndBlock) {\n+\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t  (TSTR("**>> Block %d is not valid" TENDSTR), b));\n+\t\t\tYBUG();\n+\t\t}\n+\n+\t\tbi = yaffs_GetBlockInfo(dev, b);\n+\n+#if 0\n+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {\n+\t\t\tdirtiest = b;\n+\t\t\tpagesInUse = 0;\n+\t\t}\n+\t\telse\n+#endif\n+\n+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_FULL &&\n+\t\t       (bi->pagesInUse - bi->softDeletions) < pagesInUse &&\n+\t\t        yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {\n+\t\t\tdirtiest = b;\n+\t\t\tpagesInUse = (bi->pagesInUse - bi->softDeletions);\n+\t\t}\n+\t}\n+\n+\tdev->currentDirtyChecker = b;\n+\n+\tif (dirtiest > 0) {\n+\t\tT(YAFFS_TRACE_GC,\n+\t\t  (TSTR("GC Selected block %d with %d free, prioritised:%d" TENDSTR), dirtiest,\n+\t\t   dev->nChunksPerBlock - pagesInUse,prioritised));\n+\t}\n+\n+\tdev->oldestDirtySequence = 0;\n+\n+\tif (dirtiest > 0) {\n+\t\tdev->nonAggressiveSkip = 4;\n+\t}\n+\n+\treturn dirtiest;\n+}\n+\n+static void yaffs_BlockBecameDirty(yaffs_Device * dev, int blockNo)\n+{\n+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);\n+\n+\tint erasedOk = 0;\n+\n+\t/* If the block is still healthy erase it and mark as clean.\n+\t * If the block has had a data failure, then retire it.\n+\t */\n+\n+\tT(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,\n+\t\t(TSTR("yaffs_BlockBecameDirty block %d state %d %s"TENDSTR),\n+\t\tblockNo, bi->blockState, (bi->needsRetiring) ? "needs retiring" : ""));\n+\n+\tbi->blockState = YAFFS_BLOCK_STATE_DIRTY;\n+\n+\tif (!bi->needsRetiring) {\n+\t\tyaffs_InvalidateCheckpoint(dev);\n+\t\terasedOk = yaffs_EraseBlockInNAND(dev, blockNo);\n+\t\tif (!erasedOk) {\n+\t\t\tdev->nErasureFailures++;\n+\t\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,\n+\t\t\t  (TSTR("**>> Erasure failed %d" TENDSTR), blockNo));\n+\t\t}\n+\t}\n+\n+\tif (erasedOk &&\n+\t    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {\n+\t\tint i;\n+\t\tfor (i = 0; i < dev->nChunksPerBlock; i++) {\n+\t\t\tif (!yaffs_CheckChunkErased\n+\t\t\t    (dev, blockNo * dev->nChunksPerBlock + i)) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   (">>Block %d erasure supposedly OK, but chunk %d not erased"\n+\t\t\t\t    TENDSTR), blockNo, i));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (erasedOk) {\n+\t\t/* Clean it up... */\n+\t\tbi->blockState = YAFFS_BLOCK_STATE_EMPTY;\n+\t\tdev->nErasedBlocks++;\n+\t\tbi->pagesInUse = 0;\n+\t\tbi->softDeletions = 0;\n+\t\tbi->hasShrinkHeader = 0;\n+\t\tbi->skipErasedCheck = 1;  /* This is clean, so no need to check */\n+\t\tbi->gcPrioritise = 0;\n+\t\tyaffs_ClearChunkBits(dev, blockNo);\n+\n+\t\tT(YAFFS_TRACE_ERASE,\n+\t\t  (TSTR("Erased block %d" TENDSTR), blockNo));\n+\t} else {\n+\t\tdev->nFreeChunks -= dev->nChunksPerBlock;\t/* We lost a block of free space */\n+\n+\t\tyaffs_RetireBlock(dev, blockNo);\n+\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,\n+\t\t  (TSTR("**>> Block %d retired" TENDSTR), blockNo));\n+\t}\n+}\n+\n+static int yaffs_FindBlockForAllocation(yaffs_Device * dev)\n+{\n+\tint i;\n+\n+\tyaffs_BlockInfo *bi;\n+\n+\tif (dev->nErasedBlocks < 1) {\n+\t\t/* Hoosterman we\'ve got a problem.\n+\t\t * Can\'t get space to gc\n+\t\t */\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR("yaffs tragedy: no more eraased blocks" TENDSTR)));\n+\n+\t\treturn -1;\n+\t}\n+\n+\t/* Find an empty block. */\n+\n+\tfor (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {\n+\t\tdev->allocationBlockFinder++;\n+\t\tif (dev->allocationBlockFinder < dev->internalStartBlock\n+\t\t    || dev->allocationBlockFinder > dev->internalEndBlock) {\n+\t\t\tdev->allocationBlockFinder = dev->internalStartBlock;\n+\t\t}\n+\n+\t\tbi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);\n+\n+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {\n+\t\t\tbi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;\n+\t\t\tdev->sequenceNumber++;\n+\t\t\tbi->sequenceNumber = dev->sequenceNumber;\n+\t\t\tdev->nErasedBlocks--;\n+\t\t\tT(YAFFS_TRACE_ALLOCATE,\n+\t\t\t  (TSTR("Allocated block %d, seq  %d, %d left" TENDSTR),\n+\t\t\t   dev->allocationBlockFinder, dev->sequenceNumber,\n+\t\t\t   dev->nErasedBlocks));\n+\t\t\treturn dev->allocationBlockFinder;\n+\t\t}\n+\t}\n+\n+\tT(YAFFS_TRACE_ALWAYS,\n+\t  (TSTR\n+\t   ("yaffs tragedy: no more eraased blocks, but there should have been %d"\n+\t    TENDSTR), dev->nErasedBlocks));\n+\n+\treturn -1;\n+}\n+\n+\n+\n+static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)\n+{\n+\tif(!dev->nCheckpointBlocksRequired){\n+\t\t/* Not a valid value so recalculate */\n+\t\tint nBytes = 0;\n+\t\tint nBlocks;\n+\t\tint devBlocks = (dev->endBlock - dev->startBlock + 1);\n+\t\tint tnodeSize;\n+\n+\t\ttnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;\n+\n+\t\tif(tnodeSize < sizeof(yaffs_Tnode))\n+\t\t\ttnodeSize = sizeof(yaffs_Tnode);\n+\n+\t\tnBytes += sizeof(yaffs_CheckpointValidity);\n+\t\tnBytes += sizeof(yaffs_CheckpointDevice);\n+\t\tnBytes += devBlocks * sizeof(yaffs_BlockInfo);\n+\t\tnBytes += devBlocks * dev->chunkBitmapStride;\n+\t\tnBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);\n+\t\tnBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);\n+\t\tnBytes += sizeof(yaffs_CheckpointValidity);\n+\t\tnBytes += sizeof(__u32); /* checksum*/\n+\n+\t\t/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */\n+\n+\t\tnBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;\n+\n+\t\tdev->nCheckpointBlocksRequired = nBlocks;\n+\t}\n+\n+\treturn dev->nCheckpointBlocksRequired;\n+}\n+\n+// Check if there\'s space to allocate...\n+// Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?\n+static int yaffs_CheckSpaceForAllocation(yaffs_Device * dev)\n+{\n+\tint reservedChunks;\n+\tint reservedBlocks = dev->nReservedBlocks;\n+\tint checkpointBlocks;\n+\n+\tcheckpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;\n+\tif(checkpointBlocks < 0)\n+\t\tcheckpointBlocks = 0;\n+\n+\treservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);\n+\n+\treturn (dev->nFreeChunks > reservedChunks);\n+}\n+\n+static int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr)\n+{\n+\tint retVal;\n+\tyaffs_BlockInfo *bi;\n+\n+\tif (dev->allocationBlock < 0) {\n+\t\t/* Get next block to allocate off */\n+\t\tdev->allocationBlock = yaffs_FindBlockForAllocation(dev);\n+\t\tdev->allocationPage = 0;\n+\t}\n+\n+\tif (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {\n+\t\t/* Not enough space to allocate unless we\'re allowed to use the reserve. */\n+\t\treturn -1;\n+\t}\n+\n+\tif (dev->nErasedBlocks < dev->nReservedBlocks\n+\t    && dev->allocationPage == 0) {\n+\t\tT(YAFFS_TRACE_ALLOCATE, (TSTR("Allocating reserve" TENDSTR)));\n+\t}\n+\n+\t/* Next page please.... */\n+\tif (dev->allocationBlock >= 0) {\n+\t\tbi = yaffs_GetBlockInfo(dev, dev->allocationBlock);\n+\n+\t\tretVal = (dev->allocationBlock * dev->nChunksPerBlock) +\n+\t\t    dev->allocationPage;\n+\t\tbi->pagesInUse++;\n+\t\tyaffs_SetChunkBit(dev, dev->allocationBlock,\n+\t\t\t\t  dev->allocationPage);\n+\n+\t\tdev->allocationPage++;\n+\n+\t\tdev->nFreeChunks--;\n+\n+\t\t/* If the block is full set the state to full */\n+\t\tif (dev->allocationPage >= dev->nChunksPerBlock) {\n+\t\t\tbi->blockState = YAFFS_BLOCK_STATE_FULL;\n+\t\t\tdev->allocationBlock = -1;\n+\t\t}\n+\n+\t\tif(blockUsedPtr)\n+\t\t\t*blockUsedPtr = bi;\n+\n+\t\treturn retVal;\n+\t}\n+\n+\tT(YAFFS_TRACE_ERROR,\n+\t  (TSTR("!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!" TENDSTR)));\n+\n+\treturn -1;\n+}\n+\n+static int yaffs_GetErasedChunks(yaffs_Device * dev)\n+{\n+\tint n;\n+\n+\tn = dev->nErasedBlocks * dev->nChunksPerBlock;\n+\n+\tif (dev->allocationBlock > 0) {\n+\t\tn += (dev->nChunksPerBlock - dev->allocationPage);\n+\t}\n+\n+\treturn n;\n+\n+}\n+\n+static int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block)\n+{\n+\tint oldChunk;\n+\tint newChunk;\n+\tint chunkInBlock;\n+\tint markNAND;\n+\tint retVal = YAFFS_OK;\n+\tint cleanups = 0;\n+\tint i;\n+\tint isCheckpointBlock;\n+\tint matchingChunk;\n+\n+\tint chunksBefore = yaffs_GetErasedChunks(dev);\n+\tint chunksAfter;\n+\n+\tyaffs_ExtendedTags tags;\n+\n+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);\n+\n+\tyaffs_Object *object;\n+\n+\tisCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);\n+\n+\tbi->blockState = YAFFS_BLOCK_STATE_COLLECTING;\n+\n+\tT(YAFFS_TRACE_TRACING,\n+\t  (TSTR("Collecting block %d, in use %d, shrink %d, " TENDSTR), block,\n+\t   bi->pagesInUse, bi->hasShrinkHeader));\n+\n+\t/*yaffs_VerifyFreeChunks(dev); */\n+\n+\tbi->hasShrinkHeader = 0;\t/* clear the flag so that the block can erase */\n+\n+\t/* Take off the number of soft deleted entries because\n+\t * they\'re going to get really deleted during GC.\n+\t */\n+\tdev->nFreeChunks -= bi->softDeletions;\n+\n+\tdev->isDoingGC = 1;\n+\n+\tif (isCheckpointBlock ||\n+\t    !yaffs_StillSomeChunkBits(dev, block)) {\n+\t\tT(YAFFS_TRACE_TRACING,\n+\t\t  (TSTR\n+\t\t   ("Collecting block %d that has no chunks in use" TENDSTR),\n+\t\t   block));\n+\t\tyaffs_BlockBecameDirty(dev, block);\n+\t} else {\n+\n+\t\t__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t\tyaffs_VerifyBlock(dev,bi,block);\n+\n+\t\tfor (chunkInBlock = 0, oldChunk = block * dev->nChunksPerBlock;\n+\t\t     chunkInBlock < dev->nChunksPerBlock\n+\t\t     && yaffs_StillSomeChunkBits(dev, block);\n+\t\t     chunkInBlock++, oldChunk++) {\n+\t\t\tif (yaffs_CheckChunkBit(dev, block, chunkInBlock)) {\n+\n+\t\t\t\t/* This page is in use and might need to be copied off */\n+\n+\t\t\t\tmarkNAND = 1;\n+\n+\t\t\t\tyaffs_InitialiseTags(&tags);\n+\n+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,\n+\t\t\t\t\t\t\t\tbuffer, &tags);\n+\n+\t\t\t\tobject =\n+\t\t\t\t    yaffs_FindObjectByNumber(dev,\n+\t\t\t\t\t\t\t     tags.objectId);\n+\n+\t\t\t\tT(YAFFS_TRACE_GC_DETAIL,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("Collecting page %d, %d %d %d " TENDSTR),\n+\t\t\t\t   chunkInBlock, tags.objectId, tags.chunkId,\n+\t\t\t\t   tags.byteCount));\n+\n+\t\t\t\tif(object && !yaffs_SkipVerification(dev)){\n+\t\t\t\t\tif(tags.chunkId == 0)\n+\t\t\t\t\t\tmatchingChunk = object->hdrChunk;\n+\t\t\t\t\telse if(object->softDeleted)\n+\t\t\t\t\t\tmatchingChunk = oldChunk; /* Defeat the test */\n+\t\t\t\t\telse\n+\t\t\t\t\t\tmatchingChunk = yaffs_FindChunkInFile(object,tags.chunkId,NULL);\n+\n+\t\t\t\t\tif(oldChunk != matchingChunk)\n+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t\t\t  (TSTR("gc: page in gc mismatch: %d %d %d %d"TENDSTR),\n+\t\t\t\t\t\t  oldChunk,matchingChunk,tags.objectId, tags.chunkId));\n+\n+\t\t\t\t}\n+\n+\t\t\t\tif (!object) {\n+\t\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t\t  (TSTR\n+\t\t\t\t\t   ("page %d in gc has no object: %d %d %d "\n+\t\t\t\t\t    TENDSTR), oldChunk,\n+\t\t\t\t\t    tags.objectId, tags.chunkId, tags.byteCount));\n+\t\t\t\t}\n+\n+\t\t\t\tif (object && object->deleted\n+\t\t\t\t    && tags.chunkId != 0) {\n+\t\t\t\t\t/* Data chunk in a deleted file, throw it away\n+\t\t\t\t\t * It\'s a soft deleted data chunk,\n+\t\t\t\t\t * No need to copy this, just forget about it and\n+\t\t\t\t\t * fix up the object.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tobject->nDataChunks--;\n+\n+\t\t\t\t\tif (object->nDataChunks <= 0) {\n+\t\t\t\t\t\t/* remeber to clean up the object */\n+\t\t\t\t\t\tdev->gcCleanupList[cleanups] =\n+\t\t\t\t\t\t    tags.objectId;\n+\t\t\t\t\t\tcleanups++;\n+\t\t\t\t\t}\n+\t\t\t\t\tmarkNAND = 0;\n+\t\t\t\t} else if (0\n+\t\t\t\t\t   /* Todo object && object->deleted && object->nDataChunks == 0 */\n+\t\t\t\t\t   ) {\n+\t\t\t\t\t/* Deleted object header with no data chunks.\n+\t\t\t\t\t * Can be discarded and the file deleted.\n+\t\t\t\t\t */\n+\t\t\t\t\tobject->hdrChunk = 0;\n+\t\t\t\t\tyaffs_FreeTnode(object->myDev,\n+\t\t\t\t\t\t\tobject->variant.\n+\t\t\t\t\t\t\tfileVariant.top);\n+\t\t\t\t\tobject->variant.fileVariant.top = NULL;\n+\t\t\t\t\tyaffs_DoGenericObjectDeletion(object);\n+\n+\t\t\t\t} else if (object) {\n+\t\t\t\t\t/* It\'s either a data chunk in a live file or\n+\t\t\t\t\t * an ObjectHeader, so we\'re interested in it.\n+\t\t\t\t\t * NB Need to keep the ObjectHeaders of deleted files\n+\t\t\t\t\t * until the whole file has been deleted off\n+\t\t\t\t\t */\n+\t\t\t\t\ttags.serialNumber++;\n+\n+\t\t\t\t\tdev->nGCCopies++;\n+\n+\t\t\t\t\tif (tags.chunkId == 0) {\n+\t\t\t\t\t\t/* It is an object Id,\n+\t\t\t\t\t\t * We need to nuke the shrinkheader flags first\n+\t\t\t\t\t\t * We no longer want the shrinkHeader flag since its work is done\n+\t\t\t\t\t\t * and if it is left in place it will mess up scanning.\n+\t\t\t\t\t\t * Also, clear out any shadowing stuff\n+\t\t\t\t\t\t */\n+\n+\t\t\t\t\t\tyaffs_ObjectHeader *oh;\n+\t\t\t\t\t\toh = (yaffs_ObjectHeader *)buffer;\n+\t\t\t\t\t\toh->isShrink = 0;\n+\t\t\t\t\t\toh->shadowsObject = oh->inbandShadowsObject = -1;\n+\t\t\t\t\t\ttags.extraShadows = 0;\n+\t\t\t\t\t\ttags.extraIsShrinkHeader = 0;\n+\n+\t\t\t\t\t\tyaffs_VerifyObjectHeader(object,oh,&tags,1);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tnewChunk =\n+\t\t\t\t\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);\n+\n+\t\t\t\t\tif (newChunk < 0) {\n+\t\t\t\t\t\tretVal = YAFFS_FAIL;\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\t/* Ok, now fix up the Tnodes etc. */\n+\n+\t\t\t\t\t\tif (tags.chunkId == 0) {\n+\t\t\t\t\t\t\t/* It\'s a header */\n+\t\t\t\t\t\t\tobject->hdrChunk =  newChunk;\n+\t\t\t\t\t\t\tobject->serial =   tags.serialNumber;\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t/* It\'s a data chunk */\n+\t\t\t\t\t\t\tyaffs_PutChunkIntoFile\n+\t\t\t\t\t\t\t    (object,\n+\t\t\t\t\t\t\t     tags.chunkId,\n+\t\t\t\t\t\t\t     newChunk, 0);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tyaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\tyaffs_ReleaseTempBuffer(dev, buffer, __LINE__);\n+\n+\n+\t\t/* Do any required cleanups */\n+\t\tfor (i = 0; i < cleanups; i++) {\n+\t\t\t/* Time to delete the file too */\n+\t\t\tobject =\n+\t\t\t    yaffs_FindObjectByNumber(dev,\n+\t\t\t\t\t\t     dev->gcCleanupList[i]);\n+\t\t\tif (object) {\n+\t\t\t\tyaffs_FreeTnode(dev,\n+\t\t\t\t\t\tobject->variant.fileVariant.\n+\t\t\t\t\t\ttop);\n+\t\t\t\tobject->variant.fileVariant.top = NULL;\n+\t\t\t\tT(YAFFS_TRACE_GC,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("yaffs: About to finally delete object %d"\n+\t\t\t\t    TENDSTR), object->objectId));\n+\t\t\t\tyaffs_DoGenericObjectDeletion(object);\n+\t\t\t\tobject->myDev->nDeletedFiles--;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t}\n+\n+\tyaffs_VerifyCollectedBlock(dev,bi,block);\n+\n+\tif (chunksBefore >= (chunksAfter = yaffs_GetErasedChunks(dev))) {\n+\t\tT(YAFFS_TRACE_GC,\n+\t\t  (TSTR\n+\t\t   ("gc did not increase free chunks before %d after %d"\n+\t\t    TENDSTR), chunksBefore, chunksAfter));\n+\t}\n+\n+\tdev->isDoingGC = 0;\n+\n+\treturn YAFFS_OK;\n+}\n+\n+/* New garbage collector\n+ * If we\'re very low on erased blocks then we do aggressive garbage collection\n+ * otherwise we do "leasurely" garbage collection.\n+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.\n+ * Passive gc only inspects smaller areas and will only accept more dirty blocks.\n+ *\n+ * The idea is to help clear out space in a more spread-out manner.\n+ * Dunno if it really does anything useful.\n+ */\n+static int yaffs_CheckGarbageCollection(yaffs_Device * dev)\n+{\n+\tint block;\n+\tint aggressive;\n+\tint gcOk = YAFFS_OK;\n+\tint maxTries = 0;\n+\n+\tint checkpointBlockAdjust;\n+\n+\tif (dev->isDoingGC) {\n+\t\t/* Bail out so we don\'t get recursive gc */\n+\t\treturn YAFFS_OK;\n+\t}\n+\n+\t/* This loop should pass the first time.\n+\t * We\'ll only see looping here if the erase of the collected block fails.\n+\t */\n+\n+\tdo {\n+\t\tmaxTries++;\n+\n+\t\tcheckpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;\n+\t\tif(checkpointBlockAdjust < 0)\n+\t\t\tcheckpointBlockAdjust = 0;\n+\n+\t\tif (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {\n+\t\t\t/* We need a block soon...*/\n+\t\t\taggressive = 1;\n+\t\t} else {\n+\t\t\t/* We\'re in no hurry */\n+\t\t\taggressive = 0;\n+\t\t}\n+\n+\t\tblock = yaffs_FindBlockForGarbageCollection(dev, aggressive);\n+\n+\t\tif (block > 0) {\n+\t\t\tdev->garbageCollections++;\n+\t\t\tif (!aggressive) {\n+\t\t\t\tdev->passiveGarbageCollections++;\n+\t\t\t}\n+\n+\t\t\tT(YAFFS_TRACE_GC,\n+\t\t\t  (TSTR\n+\t\t\t   ("yaffs: GC erasedBlocks %d aggressive %d" TENDSTR),\n+\t\t\t   dev->nErasedBlocks, aggressive));\n+\n+\t\t\tgcOk = yaffs_GarbageCollectBlock(dev, block);\n+\t\t}\n+\n+\t\tif (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {\n+\t\t\tT(YAFFS_TRACE_GC,\n+\t\t\t  (TSTR\n+\t\t\t   ("yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d"\n+\t\t\t    TENDSTR), dev->nErasedBlocks, maxTries, block));\n+\t\t}\n+\t} while ((dev->nErasedBlocks < dev->nReservedBlocks) && (block > 0)\n+\t\t && (maxTries < 2));\n+\n+\treturn aggressive ? gcOk : YAFFS_OK;\n+}\n+\n+/*-------------------------  TAGS --------------------------------*/\n+\n+static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,\n+\t\t\t   int chunkInObject)\n+{\n+\treturn (tags->chunkId == chunkInObject &&\n+\t\ttags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;\n+\n+}\n+\n+\n+/*-------------------- Data file manipulation -----------------*/\n+\n+static int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t yaffs_ExtendedTags * tags)\n+{\n+\t/*Get the Tnode, then get the level 0 offset chunk offset */\n+\tyaffs_Tnode *tn;\n+\tint theChunk = -1;\n+\tyaffs_ExtendedTags localTags;\n+\tint retVal = -1;\n+\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tif (!tags) {\n+\t\t/* Passed a NULL, so use our own tags space */\n+\t\ttags = &localTags;\n+\t}\n+\n+\ttn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);\n+\n+\tif (tn) {\n+\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);\n+\n+\t\tretVal =\n+\t\t    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,\n+\t\t\t\t\t   chunkInInode);\n+\t}\n+\treturn retVal;\n+}\n+\n+static int yaffs_FindAndDeleteChunkInFile(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t\t  yaffs_ExtendedTags * tags)\n+{\n+\t/* Get the Tnode, then get the level 0 offset chunk offset */\n+\tyaffs_Tnode *tn;\n+\tint theChunk = -1;\n+\tyaffs_ExtendedTags localTags;\n+\n+\tyaffs_Device *dev = in->myDev;\n+\tint retVal = -1;\n+\n+\tif (!tags) {\n+\t\t/* Passed a NULL, so use our own tags space */\n+\t\ttags = &localTags;\n+\t}\n+\n+\ttn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);\n+\n+\tif (tn) {\n+\n+\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);\n+\n+\t\tretVal =\n+\t\t    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,\n+\t\t\t\t\t   chunkInInode);\n+\n+\t\t/* Delete the entry in the filestructure (if found) */\n+\t\tif (retVal != -1) {\n+\t\t\tyaffs_PutLevel0Tnode(dev,tn,chunkInInode,0);\n+\t\t}\n+\t} else {\n+\t\t/*T(("No level 0 found for %d\\n", chunkInInode)); */\n+\t}\n+\n+\tif (retVal == -1) {\n+\t\t/* T(("Could not find %d to delete\\n",chunkInInode)); */\n+\t}\n+\treturn retVal;\n+}\n+\n+#ifdef YAFFS_PARANOID\n+\n+static int yaffs_CheckFileSanity(yaffs_Object * in)\n+{\n+\tint chunk;\n+\tint nChunks;\n+\tint fSize;\n+\tint failed = 0;\n+\tint objId;\n+\tyaffs_Tnode *tn;\n+\tyaffs_Tags localTags;\n+\tyaffs_Tags *tags = &localTags;\n+\tint theChunk;\n+\tint chunkDeleted;\n+\n+\tif (in->variantType != YAFFS_OBJECT_TYPE_FILE) {\n+\t\t/* T(("Object not a file\\n")); */\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tobjId = in->objectId;\n+\tfSize = in->variant.fileVariant.fileSize;\n+\tnChunks =\n+\t    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;\n+\n+\tfor (chunk = 1; chunk <= nChunks; chunk++) {\n+\t\ttn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,\n+\t\t\t\t\t   chunk);\n+\n+\t\tif (tn) {\n+\n+\t\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunk);\n+\n+\t\t\tif (yaffs_CheckChunkBits\n+\t\t\t    (dev, theChunk / dev->nChunksPerBlock,\n+\t\t\t     theChunk % dev->nChunksPerBlock)) {\n+\n+\t\t\t\tyaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,\n+\t\t\t\t\t\t\t    tags,\n+\t\t\t\t\t\t\t    &chunkDeleted);\n+\t\t\t\tif (yaffs_TagsMatch\n+\t\t\t\t    (tags, in->objectId, chunk, chunkDeleted)) {\n+\t\t\t\t\t/* found it; */\n+\n+\t\t\t\t}\n+\t\t\t} else {\n+\n+\t\t\t\tfailed = 1;\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t/* T(("No level 0 found for %d\\n", chunk)); */\n+\t\t}\n+\t}\n+\n+\treturn failed ? YAFFS_FAIL : YAFFS_OK;\n+}\n+\n+#endif\n+\n+static int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t  int chunkInNAND, int inScan)\n+{\n+\t/* NB inScan is zero unless scanning.\n+\t * For forward scanning, inScan is > 0;\n+\t * for backward scanning inScan is < 0\n+\t */\n+\n+\tyaffs_Tnode *tn;\n+\tyaffs_Device *dev = in->myDev;\n+\tint existingChunk;\n+\tyaffs_ExtendedTags existingTags;\n+\tyaffs_ExtendedTags newTags;\n+\tunsigned existingSerial, newSerial;\n+\n+\tif (in->variantType != YAFFS_OBJECT_TYPE_FILE) {\n+\t\t/* Just ignore an attempt at putting a chunk into a non-file during scanning\n+\t\t * If it is not during Scanning then something went wrong!\n+\t\t */\n+\t\tif (!inScan) {\n+\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t  (TSTR\n+\t\t\t   ("yaffs tragedy:attempt to put data chunk into a non-file"\n+\t\t\t    TENDSTR)));\n+\t\t\tYBUG();\n+\t\t}\n+\n+\t\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);\n+\t\treturn YAFFS_OK;\n+\t}\n+\n+\ttn = yaffs_AddOrFindLevel0Tnode(dev,\n+\t\t\t\t\t&in->variant.fileVariant,\n+\t\t\t\t\tchunkInInode,\n+\t\t\t\t\tNULL);\n+\tif (!tn) {\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\texistingChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);\n+\n+\tif (inScan != 0) {\n+\t\t/* If we\'re scanning then we need to test for duplicates\n+\t\t * NB This does not need to be efficient since it should only ever\n+\t\t * happen when the power fails during a write, then only one\n+\t\t * chunk should ever be affected.\n+\t\t *\n+\t\t * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO\n+\t\t * Update: For backward scanning we don\'t need to re-read tags so this is quite cheap.\n+\t\t */\n+\n+\t\tif (existingChunk > 0) {\n+\t\t\t/* NB Right now existing chunk will not be real chunkId if the device >= 32MB\n+\t\t\t *    thus we have to do a FindChunkInFile to get the real chunk id.\n+\t\t\t *\n+\t\t\t * We have a duplicate now we need to decide which one to use:\n+\t\t\t *\n+\t\t\t * Backwards scanning YAFFS2: The old one is what we use, dump the new one.\n+\t\t\t * Forward scanning YAFFS2: The new one is what we use, dump the old one.\n+\t\t\t * YAFFS1: Get both sets of tags and compare serial numbers.\n+\t\t\t */\n+\n+\t\t\tif (inScan > 0) {\n+\t\t\t\t/* Only do this for forward scanning */\n+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,\n+\t\t\t\t\t\t\t\tchunkInNAND,\n+\t\t\t\t\t\t\t\tNULL, &newTags);\n+\n+\t\t\t\t/* Do a proper find */\n+\t\t\t\texistingChunk =\n+\t\t\t\t    yaffs_FindChunkInFile(in, chunkInInode,\n+\t\t\t\t\t\t\t  &existingTags);\n+\t\t\t}\n+\n+\t\t\tif (existingChunk <= 0) {\n+\t\t\t\t/*Hoosterman - how did this happen? */\n+\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("yaffs tragedy: existing chunk < 0 in scan"\n+\t\t\t\t    TENDSTR)));\n+\n+\t\t\t}\n+\n+\t\t\t/* NB The deleted flags should be false, otherwise the chunks will\n+\t\t\t * not be loaded during a scan\n+\t\t\t */\n+\n+\t\t\tnewSerial = newTags.serialNumber;\n+\t\t\texistingSerial = existingTags.serialNumber;\n+\n+\t\t\tif ((inScan > 0) &&\n+\t\t\t    (in->myDev->isYaffs2 ||\n+\t\t\t     existingChunk <= 0 ||\n+\t\t\t     ((existingSerial + 1) & 3) == newSerial)) {\n+\t\t\t\t/* Forward scanning.\n+\t\t\t\t * Use new\n+\t\t\t\t * Delete the old one and drop through to update the tnode\n+\t\t\t\t */\n+\t\t\t\tyaffs_DeleteChunk(dev, existingChunk, 1,\n+\t\t\t\t\t\t  __LINE__);\n+\t\t\t} else {\n+\t\t\t\t/* Backward scanning or we want to use the existing one\n+\t\t\t\t * Use existing.\n+\t\t\t\t * Delete the new one and return early so that the tnode isn\'t changed\n+\t\t\t\t */\n+\t\t\t\tyaffs_DeleteChunk(dev, chunkInNAND, 1,\n+\t\t\t\t\t\t  __LINE__);\n+\t\t\t\treturn YAFFS_OK;\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+\tif (existingChunk == 0) {\n+\t\tin->nDataChunks++;\n+\t}\n+\n+\tyaffs_PutLevel0Tnode(dev,tn,chunkInInode,chunkInNAND);\n+\n+\treturn YAFFS_OK;\n+}\n+\n+static int yaffs_ReadChunkDataFromObject(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t\t __u8 * buffer)\n+{\n+\tint chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);\n+\n+\tif (chunkInNAND >= 0) {\n+\t\treturn yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND,\n+\t\t\t\t\t\t       buffer,NULL);\n+\t} else {\n+\t\tT(YAFFS_TRACE_NANDACCESS,\n+\t\t  (TSTR("Chunk %d not found zero instead" TENDSTR),\n+\t\t   chunkInNAND));\n+\t\t/* get sane (zero) data if you read a hole */\n+\t\tmemset(buffer, 0, in->myDev->nDataBytesPerChunk);\n+\t\treturn 0;\n+\t}\n+\n+}\n+\n+void yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn)\n+{\n+\tint block;\n+\tint page;\n+\tyaffs_ExtendedTags tags;\n+\tyaffs_BlockInfo *bi;\n+\n+\tif (chunkId <= 0)\n+\t\treturn;\n+\n+\n+\tdev->nDeletions++;\n+\tblock = chunkId / dev->nChunksPerBlock;\n+\tpage = chunkId % dev->nChunksPerBlock;\n+\n+\n+\tif(!yaffs_CheckChunkBit(dev,block,page))\n+\t\tT(YAFFS_TRACE_VERIFY,\n+\t\t \t(TSTR("Deleting invalid chunk %d"TENDSTR),\n+\t\t \t chunkId));\n+\n+\tbi = yaffs_GetBlockInfo(dev, block);\n+\n+\tT(YAFFS_TRACE_DELETION,\n+\t  (TSTR("line %d delete of chunk %d" TENDSTR), lyn, chunkId));\n+\n+\tif (markNAND &&\n+\t    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {\n+\n+\t\tyaffs_InitialiseTags(&tags);\n+\n+\t\ttags.chunkDeleted = 1;\n+\n+\t\tyaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);\n+\t\tyaffs_HandleUpdateChunk(dev, chunkId, &tags);\n+\t} else {\n+\t\tdev->nUnmarkedDeletions++;\n+\t}\n+\n+\t/* Pull out of the management area.\n+\t * If the whole block became dirty, this will kick off an erasure.\n+\t */\n+\tif (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||\n+\t    bi->blockState == YAFFS_BLOCK_STATE_FULL ||\n+\t    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||\n+\t    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {\n+\t\tdev->nFreeChunks++;\n+\n+\t\tyaffs_ClearChunkBit(dev, block, page);\n+\n+\t\tbi->pagesInUse--;\n+\n+\t\tif (bi->pagesInUse == 0 &&\n+\t\t    !bi->hasShrinkHeader &&\n+\t\t    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&\n+\t\t    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {\n+\t\t\tyaffs_BlockBecameDirty(dev, block);\n+\t\t}\n+\n+\t} else {\n+\t\t/* T(("Bad news deleting chunk %d\\n",chunkId)); */\n+\t}\n+\n+}\n+\n+static int yaffs_WriteChunkDataToObject(yaffs_Object * in, int chunkInInode,\n+\t\t\t\t\tconst __u8 * buffer, int nBytes,\n+\t\t\t\t\tint useReserve)\n+{\n+\t/* Find old chunk Need to do this to get serial number\n+\t * Write new one and patch into tree.\n+\t * Invalidate old tags.\n+\t */\n+\n+\tint prevChunkId;\n+\tyaffs_ExtendedTags prevTags;\n+\n+\tint newChunkId;\n+\tyaffs_ExtendedTags newTags;\n+\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tyaffs_CheckGarbageCollection(dev);\n+\n+\t/* Get the previous chunk at this location in the file if it exists */\n+\tprevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);\n+\n+\t/* Set up new tags */\n+\tyaffs_InitialiseTags(&newTags);\n+\n+\tnewTags.chunkId = chunkInInode;\n+\tnewTags.objectId = in->objectId;\n+\tnewTags.serialNumber =\n+\t    (prevChunkId >= 0) ? prevTags.serialNumber + 1 : 1;\n+\tnewTags.byteCount = nBytes;\n+\n+\tnewChunkId =\n+\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,\n+\t\t\t\t\t      useReserve);\n+\n+\tif (newChunkId >= 0) {\n+\t\tyaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);\n+\n+\t\tif (prevChunkId >= 0) {\n+\t\t\tyaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);\n+\n+\t\t}\n+\n+\t\tyaffs_CheckFileSanity(in);\n+\t}\n+\treturn newChunkId;\n+\n+}\n+\n+/* UpdateObjectHeader updates the header on NAND for an object.\n+ * If name is not NULL, then that new name is used.\n+ */\n+int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name, int force,\n+\t\t\t     int isShrink, int shadows)\n+{\n+\n+\tyaffs_BlockInfo *bi;\n+\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tint prevChunkId;\n+\tint retVal = 0;\n+\tint result = 0;\n+\n+\tint newChunkId;\n+\tyaffs_ExtendedTags newTags;\n+\tyaffs_ExtendedTags oldTags;\n+\n+\t__u8 *buffer = NULL;\n+\tYCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];\n+\n+        yaffs_ObjectHeader *oh = NULL;\n+\n+        yaffs_strcpy(oldName,_Y("silly old name"));\n+\n+\n+\tif (!in->fake ||\n+\t    in == dev->rootDir || /* The rootDir should also be saved */\n+\t    force) {\n+\n+\t\tyaffs_CheckGarbageCollection(dev);\n+\t\tyaffs_CheckObjectDetailsLoaded(in);\n+\n+\t\tbuffer = yaffs_GetTempBuffer(in->myDev, __LINE__);\n+\t\toh = (yaffs_ObjectHeader *) buffer;\n+\n+\t\tprevChunkId = in->hdrChunk;\n+\n+\t\tif (prevChunkId > 0) {\n+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,\n+\t\t\t\t\t\t\tbuffer, &oldTags);\n+\n+\t\t\tyaffs_VerifyObjectHeader(in,oh,&oldTags,0);\n+\n+\t\t\tmemcpy(oldName, oh->name, sizeof(oh->name));\n+\t\t}\n+\n+\t\tmemset(buffer, 0xFF, dev->nDataBytesPerChunk);\n+\n+\t\toh->type = in->variantType;\n+\t\toh->yst_mode = in->yst_mode;\n+\t\toh->shadowsObject = oh->inbandShadowsObject = shadows;\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\toh->win_atime[0] = in->win_atime[0];\n+\t\toh->win_ctime[0] = in->win_ctime[0];\n+\t\toh->win_mtime[0] = in->win_mtime[0];\n+\t\toh->win_atime[1] = in->win_atime[1];\n+\t\toh->win_ctime[1] = in->win_ctime[1];\n+\t\toh->win_mtime[1] = in->win_mtime[1];\n+#else\n+\t\toh->yst_uid = in->yst_uid;\n+\t\toh->yst_gid = in->yst_gid;\n+\t\toh->yst_atime = in->yst_atime;\n+\t\toh->yst_mtime = in->yst_mtime;\n+\t\toh->yst_ctime = in->yst_ctime;\n+\t\toh->yst_rdev = in->yst_rdev;\n+#endif\n+\t\tif (in->parent) {\n+\t\t\toh->parentObjectId = in->parent->objectId;\n+\t\t} else {\n+\t\t\toh->parentObjectId = 0;\n+\t\t}\n+\n+\t\tif (name && *name) {\n+\t\t\tmemset(oh->name, 0, sizeof(oh->name));\n+\t\t\tyaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);\n+\t\t} else if (prevChunkId>=0) {\n+\t\t\tmemcpy(oh->name, oldName, sizeof(oh->name));\n+\t\t} else {\n+\t\t\tmemset(oh->name, 0, sizeof(oh->name));\n+\t\t}\n+\n+\t\toh->isShrink = isShrink;\n+\n+\t\tswitch (in->variantType) {\n+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\t\t/* Should not happen */\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\t\toh->fileSize =\n+\t\t\t    (oh->parentObjectId == YAFFS_OBJECTID_DELETED\n+\t\t\t     || oh->parentObjectId ==\n+\t\t\t     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.\n+\t\t\t    fileVariant.fileSize;\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\t\toh->equivalentObjectId =\n+\t\t\t    in->variant.hardLinkVariant.equivalentObjectId;\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\t\t/* Do nothing */\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\t\t/* Do nothing */\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\t\tyaffs_strncpy(oh->alias,\n+\t\t\t\t      in->variant.symLinkVariant.alias,\n+\t\t\t\t      YAFFS_MAX_ALIAS_LENGTH);\n+\t\t\toh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/* Tags */\n+\t\tyaffs_InitialiseTags(&newTags);\n+\t\tin->serial++;\n+\t\tnewTags.chunkId = 0;\n+\t\tnewTags.objectId = in->objectId;\n+\t\tnewTags.serialNumber = in->serial;\n+\n+\t\t/* Add extra info for file header */\n+\n+\t\tnewTags.extraHeaderInfoAvailable = 1;\n+\t\tnewTags.extraParentObjectId = oh->parentObjectId;\n+\t\tnewTags.extraFileLength = oh->fileSize;\n+\t\tnewTags.extraIsShrinkHeader = oh->isShrink;\n+\t\tnewTags.extraEquivalentObjectId = oh->equivalentObjectId;\n+\t\tnewTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;\n+\t\tnewTags.extraObjectType = in->variantType;\n+\n+\t\tyaffs_VerifyObjectHeader(in,oh,&newTags,1);\n+\n+\t\t/* Create new chunk in NAND */\n+\t\tnewChunkId =\n+\t\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,\n+\t\t\t\t\t\t      (prevChunkId >= 0) ? 1 : 0);\n+\n+\t\tif (newChunkId >= 0) {\n+\n+\t\t\tin->hdrChunk = newChunkId;\n+\n+\t\t\tif (prevChunkId >= 0) {\n+\t\t\t\tyaffs_DeleteChunk(dev, prevChunkId, 1,\n+\t\t\t\t\t\t  __LINE__);\n+\t\t\t}\n+\n+\t\t\tif(!yaffs_ObjectHasCachedWriteData(in))\n+\t\t\t\tin->dirty = 0;\n+\n+\t\t\t/* If this was a shrink, then mark the block that the chunk lives on */\n+\t\t\tif (isShrink) {\n+\t\t\t\tbi = yaffs_GetBlockInfo(in->myDev,\n+\t\t\t\t\t\t\tnewChunkId /in->myDev->\tnChunksPerBlock);\n+\t\t\t\tbi->hasShrinkHeader = 1;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\tretVal = newChunkId;\n+\n+\t}\n+\n+\tif (buffer)\n+\t\tyaffs_ReleaseTempBuffer(dev, buffer, __LINE__);\n+\n+\treturn retVal;\n+}\n+\n+/*------------------------ Short Operations Cache ----------------------------------------\n+ *   In many situations where there is no high level buffering (eg WinCE) a lot of\n+ *   reads might be short sequential reads, and a lot of writes may be short\n+ *   sequential writes. eg. scanning/writing a jpeg file.\n+ *   In these cases, a short read/write cache can provide a huge perfomance benefit\n+ *   with dumb-as-a-rock code.\n+ *   In Linux, the page cache provides read buffering aand the short op cache provides write\n+ *   buffering.\n+ *\n+ *   There are a limited number (~10) of cache chunks per device so that we don\'t\n+ *   need a very intelligent search.\n+ */\n+\n+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)\n+{\n+\tyaffs_Device *dev = obj->myDev;\n+\tint i;\n+\tyaffs_ChunkCache *cache;\n+\tint nCaches = obj->myDev->nShortOpCaches;\n+\n+\tfor(i = 0; i < nCaches; i++){\n+\t\tcache = &dev->srCache[i];\n+\t\tif (cache->object == obj &&\n+\t\t    cache->dirty)\n+\t\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+static void yaffs_FlushFilesChunkCache(yaffs_Object * obj)\n+{\n+\tyaffs_Device *dev = obj->myDev;\n+\tint lowest = -99;\t/* Stop compiler whining. */\n+\tint i;\n+\tyaffs_ChunkCache *cache;\n+\tint chunkWritten = 0;\n+\tint nCaches = obj->myDev->nShortOpCaches;\n+\n+\tif (nCaches > 0) {\n+\t\tdo {\n+\t\t\tcache = NULL;\n+\n+\t\t\t/* Find the dirty cache for this object with the lowest chunk id. */\n+\t\t\tfor (i = 0; i < nCaches; i++) {\n+\t\t\t\tif (dev->srCache[i].object == obj &&\n+\t\t\t\t    dev->srCache[i].dirty) {\n+\t\t\t\t\tif (!cache\n+\t\t\t\t\t    || dev->srCache[i].chunkId <\n+\t\t\t\t\t    lowest) {\n+\t\t\t\t\t\tcache = &dev->srCache[i];\n+\t\t\t\t\t\tlowest = cache->chunkId;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (cache && !cache->locked) {\n+\t\t\t\t/* Write it out and free it up */\n+\n+\t\t\t\tchunkWritten =\n+\t\t\t\t    yaffs_WriteChunkDataToObject(cache->object,\n+\t\t\t\t\t\t\t\t cache->chunkId,\n+\t\t\t\t\t\t\t\t cache->data,\n+\t\t\t\t\t\t\t\t cache->nBytes,\n+\t\t\t\t\t\t\t\t 1);\n+\t\t\t\tcache->dirty = 0;\n+\t\t\t\tcache->object = NULL;\n+\t\t\t}\n+\n+\t\t} while (cache && chunkWritten > 0);\n+\n+\t\tif (cache) {\n+\t\t\t/* Hoosterman, disk full while writing cache out. */\n+\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t  (TSTR("yaffs tragedy: no space during cache write" TENDSTR)));\n+\n+\t\t}\n+\t}\n+\n+}\n+\n+/*yaffs_FlushEntireDeviceCache(dev)\n+ *\n+ *\n+ */\n+\n+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev)\n+{\n+\tyaffs_Object *obj;\n+\tint nCaches = dev->nShortOpCaches;\n+\tint i;\n+\n+\t/* Find a dirty object in the cache and flush it...\n+\t * until there are no further dirty objects.\n+\t */\n+\tdo {\n+\t\tobj = NULL;\n+\t\tfor( i = 0; i < nCaches && !obj; i++) {\n+\t\t\tif (dev->srCache[i].object &&\n+\t\t\t    dev->srCache[i].dirty)\n+\t\t\t\tobj = dev->srCache[i].object;\n+\n+\t\t}\n+\t\tif(obj)\n+\t\t\tyaffs_FlushFilesChunkCache(obj);\n+\n+\t} while(obj);\n+\n+}\n+\n+\n+/* Grab us a cache chunk for use.\n+ * First look for an empty one.\n+ * Then look for the least recently used non-dirty one.\n+ * Then look for the least recently used dirty one...., flush and look again.\n+ */\n+static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device * dev)\n+{\n+\tint i;\n+\tint usage;\n+\tint theOne;\n+\n+\tif (dev->nShortOpCaches > 0) {\n+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\tif (!dev->srCache[i].object)\n+\t\t\t\treturn &dev->srCache[i];\n+\t\t}\n+\n+\t\treturn NULL;\n+\n+\t\ttheOne = -1;\n+\t\tusage = 0;\t/* just to stop the compiler grizzling */\n+\n+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\tif (!dev->srCache[i].dirty &&\n+\t\t\t    ((dev->srCache[i].lastUse < usage && theOne >= 0) ||\n+\t\t\t     theOne < 0)) {\n+\t\t\t\tusage = dev->srCache[i].lastUse;\n+\t\t\t\ttheOne = i;\n+\t\t\t}\n+\t\t}\n+\n+\n+\t\treturn theOne >= 0 ? &dev->srCache[theOne] : NULL;\n+\t} else {\n+\t\treturn NULL;\n+\t}\n+\n+}\n+\n+static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device * dev)\n+{\n+\tyaffs_ChunkCache *cache;\n+\tyaffs_Object *theObj;\n+\tint usage;\n+\tint i;\n+\tint pushout;\n+\n+\tif (dev->nShortOpCaches > 0) {\n+\t\t/* Try find a non-dirty one... */\n+\n+\t\tcache = yaffs_GrabChunkCacheWorker(dev);\n+\n+\t\tif (!cache) {\n+\t\t\t/* They were all dirty, find the last recently used object and flush\n+\t\t\t * its cache, then  find again.\n+\t\t\t * NB what\'s here is not very accurate, we actually flush the object\n+\t\t\t * the last recently used page.\n+\t\t\t */\n+\n+\t\t\t/* With locking we can\'t assume we can use entry zero */\n+\n+\t\t\ttheObj = NULL;\n+\t\t\tusage = -1;\n+\t\t\tcache = NULL;\n+\t\t\tpushout = -1;\n+\n+\t\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\t\tif (dev->srCache[i].object &&\n+\t\t\t\t    !dev->srCache[i].locked &&\n+\t\t\t\t    (dev->srCache[i].lastUse < usage || !cache))\n+\t\t\t\t{\n+\t\t\t\t\tusage = dev->srCache[i].lastUse;\n+\t\t\t\t\ttheObj = dev->srCache[i].object;\n+\t\t\t\t\tcache = &dev->srCache[i];\n+\t\t\t\t\tpushout = i;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (!cache || cache->dirty) {\n+\t\t\t\t/* Flush and try again */\n+\t\t\t\tyaffs_FlushFilesChunkCache(theObj);\n+\t\t\t\tcache = yaffs_GrabChunkCacheWorker(dev);\n+\t\t\t}\n+\n+\t\t}\n+\t\treturn cache;\n+\t} else\n+\t\treturn NULL;\n+\n+}\n+\n+/* Find a cached chunk */\n+static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object * obj,\n+\t\t\t\t\t      int chunkId)\n+{\n+\tyaffs_Device *dev = obj->myDev;\n+\tint i;\n+\tif (dev->nShortOpCaches > 0) {\n+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\tif (dev->srCache[i].object == obj &&\n+\t\t\t    dev->srCache[i].chunkId == chunkId) {\n+\t\t\t\tdev->cacheHits++;\n+\n+\t\t\t\treturn &dev->srCache[i];\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn NULL;\n+}\n+\n+/* Mark the chunk for the least recently used algorithym */\n+static void yaffs_UseChunkCache(yaffs_Device * dev, yaffs_ChunkCache * cache,\n+\t\t\t\tint isAWrite)\n+{\n+\n+\tif (dev->nShortOpCaches > 0) {\n+\t\tif (dev->srLastUse < 0 || dev->srLastUse > 100000000) {\n+\t\t\t/* Reset the cache usages */\n+\t\t\tint i;\n+\t\t\tfor (i = 1; i < dev->nShortOpCaches; i++) {\n+\t\t\t\tdev->srCache[i].lastUse = 0;\n+\t\t\t}\n+\t\t\tdev->srLastUse = 0;\n+\t\t}\n+\n+\t\tdev->srLastUse++;\n+\n+\t\tcache->lastUse = dev->srLastUse;\n+\n+\t\tif (isAWrite) {\n+\t\t\tcache->dirty = 1;\n+\t\t}\n+\t}\n+}\n+\n+/* Invalidate a single cache page.\n+ * Do this when a whole page gets written,\n+ * ie the short cache for this page is no longer valid.\n+ */\n+static void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId)\n+{\n+\tif (object->myDev->nShortOpCaches > 0) {\n+\t\tyaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);\n+\n+\t\tif (cache) {\n+\t\t\tcache->object = NULL;\n+\t\t}\n+\t}\n+}\n+\n+/* Invalidate all the cache pages associated with this object\n+ * Do this whenever ther file is deleted or resized.\n+ */\n+static void yaffs_InvalidateWholeChunkCache(yaffs_Object * in)\n+{\n+\tint i;\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tif (dev->nShortOpCaches > 0) {\n+\t\t/* Invalidate it. */\n+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\tif (dev->srCache[i].object == in) {\n+\t\t\t\tdev->srCache[i].object = NULL;\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+/*--------------------- Checkpointing --------------------*/\n+\n+\n+static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev,int head)\n+{\n+\tyaffs_CheckpointValidity cp;\n+\n+\tmemset(&cp,0,sizeof(cp));\n+\n+\tcp.structType = sizeof(cp);\n+\tcp.magic = YAFFS_MAGIC;\n+\tcp.version = YAFFS_CHECKPOINT_VERSION;\n+\tcp.head = (head) ? 1 : 0;\n+\n+\treturn (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp))?\n+\t\t1 : 0;\n+}\n+\n+static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)\n+{\n+\tyaffs_CheckpointValidity cp;\n+\tint ok;\n+\n+\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\n+\tif(ok)\n+\t\tok = (cp.structType == sizeof(cp)) &&\n+\t\t     (cp.magic == YAFFS_MAGIC) &&\n+\t\t     (cp.version == YAFFS_CHECKPOINT_VERSION) &&\n+\t\t     (cp.head == ((head) ? 1 : 0));\n+\treturn ok ? 1 : 0;\n+}\n+\n+static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp,\n+\t\t\t\t\t   yaffs_Device *dev)\n+{\n+\tcp->nErasedBlocks = dev->nErasedBlocks;\n+\tcp->allocationBlock = dev->allocationBlock;\n+\tcp->allocationPage = dev->allocationPage;\n+\tcp->nFreeChunks = dev->nFreeChunks;\n+\n+\tcp->nDeletedFiles = dev->nDeletedFiles;\n+\tcp->nUnlinkedFiles = dev->nUnlinkedFiles;\n+\tcp->nBackgroundDeletions = dev->nBackgroundDeletions;\n+\tcp->sequenceNumber = dev->sequenceNumber;\n+\tcp->oldestDirtySequence = dev->oldestDirtySequence;\n+\n+}\n+\n+static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,\n+\t\t\t\t\t   yaffs_CheckpointDevice *cp)\n+{\n+\tdev->nErasedBlocks = cp->nErasedBlocks;\n+\tdev->allocationBlock = cp->allocationBlock;\n+\tdev->allocationPage = cp->allocationPage;\n+\tdev->nFreeChunks = cp->nFreeChunks;\n+\n+\tdev->nDeletedFiles = cp->nDeletedFiles;\n+\tdev->nUnlinkedFiles = cp->nUnlinkedFiles;\n+\tdev->nBackgroundDeletions = cp->nBackgroundDeletions;\n+\tdev->sequenceNumber = cp->sequenceNumber;\n+\tdev->oldestDirtySequence = cp->oldestDirtySequence;\n+}\n+\n+\n+static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)\n+{\n+\tyaffs_CheckpointDevice cp;\n+\t__u32 nBytes;\n+\t__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);\n+\n+\tint ok;\n+\n+\t/* Write device runtime values*/\n+\tyaffs_DeviceToCheckpointDevice(&cp,dev);\n+\tcp.structType = sizeof(cp);\n+\n+\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\n+\t/* Write block info */\n+\tif(ok) {\n+\t\tnBytes = nBlocks * sizeof(yaffs_BlockInfo);\n+\t\tok = (yaffs_CheckpointWrite(dev,dev->blockInfo,nBytes) == nBytes);\n+\t}\n+\n+\t/* Write chunk bits */\n+\tif(ok) {\n+\t\tnBytes = nBlocks * dev->chunkBitmapStride;\n+\t\tok = (yaffs_CheckpointWrite(dev,dev->chunkBits,nBytes) == nBytes);\n+\t}\n+\treturn\t ok ? 1 : 0;\n+\n+}\n+\n+static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)\n+{\n+\tyaffs_CheckpointDevice cp;\n+\t__u32 nBytes;\n+\t__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);\n+\n+\tint ok;\n+\n+\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\tif(!ok)\n+\t\treturn 0;\n+\n+\tif(cp.structType != sizeof(cp))\n+\t\treturn 0;\n+\n+\n+\tyaffs_CheckpointDeviceToDevice(dev,&cp);\n+\n+\tnBytes = nBlocks * sizeof(yaffs_BlockInfo);\n+\n+\tok = (yaffs_CheckpointRead(dev,dev->blockInfo,nBytes) == nBytes);\n+\n+\tif(!ok)\n+\t\treturn 0;\n+\tnBytes = nBlocks * dev->chunkBitmapStride;\n+\n+\tok = (yaffs_CheckpointRead(dev,dev->chunkBits,nBytes) == nBytes);\n+\n+\treturn ok ? 1 : 0;\n+}\n+\n+static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,\n+\t\t\t\t\t   yaffs_Object *obj)\n+{\n+\n+\tcp->objectId = obj->objectId;\n+\tcp->parentId = (obj->parent) ? obj->parent->objectId : 0;\n+\tcp->hdrChunk = obj->hdrChunk;\n+\tcp->variantType = obj->variantType;\n+\tcp->deleted = obj->deleted;\n+\tcp->softDeleted = obj->softDeleted;\n+\tcp->unlinked = obj->unlinked;\n+\tcp->fake = obj->fake;\n+\tcp->renameAllowed = obj->renameAllowed;\n+\tcp->unlinkAllowed = obj->unlinkAllowed;\n+\tcp->serial = obj->serial;\n+\tcp->nDataChunks = obj->nDataChunks;\n+\n+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE)\n+\t\tcp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;\n+\telse if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)\n+\t\tcp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;\n+}\n+\n+static void yaffs_CheckpointObjectToObject( yaffs_Object *obj,yaffs_CheckpointObject *cp)\n+{\n+\n+\tyaffs_Object *parent;\n+\n+\tobj->objectId = cp->objectId;\n+\n+\tif(cp->parentId)\n+\t\tparent = yaffs_FindOrCreateObjectByNumber(\n+\t\t\t\t\tobj->myDev,\n+\t\t\t\t\tcp->parentId,\n+\t\t\t\t\tYAFFS_OBJECT_TYPE_DIRECTORY);\n+\telse\n+\t\tparent = NULL;\n+\n+\tif(parent)\n+\t\tyaffs_AddObjectToDirectory(parent, obj);\n+\n+\tobj->hdrChunk = cp->hdrChunk;\n+\tobj->variantType = cp->variantType;\n+\tobj->deleted = cp->deleted;\n+\tobj->softDeleted = cp->softDeleted;\n+\tobj->unlinked = cp->unlinked;\n+\tobj->fake = cp->fake;\n+\tobj->renameAllowed = cp->renameAllowed;\n+\tobj->unlinkAllowed = cp->unlinkAllowed;\n+\tobj->serial = cp->serial;\n+\tobj->nDataChunks = cp->nDataChunks;\n+\n+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE)\n+\t\tobj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;\n+\telse if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)\n+\t\tobj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;\n+\n+\tif(obj->hdrChunk > 0)\n+\t\tobj->lazyLoaded = 1;\n+}\n+\n+\n+\n+static int yaffs_CheckpointTnodeWorker(yaffs_Object * in, yaffs_Tnode * tn,\n+\t\t\t\t  \t__u32 level, int chunkOffset)\n+{\n+\tint i;\n+\tyaffs_Device *dev = in->myDev;\n+\tint ok = 1;\n+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;\n+\n+\tif(tnodeSize < sizeof(yaffs_Tnode))\n+\t\ttnodeSize = sizeof(yaffs_Tnode);\n+\n+\n+\tif (tn) {\n+\t\tif (level > 0) {\n+\n+\t\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){\n+\t\t\t\tif (tn->internal[i]) {\n+\t\t\t\t\tok = yaffs_CheckpointTnodeWorker(in,\n+\t\t\t\t\t\t\ttn->internal[i],\n+\t\t\t\t\t\t\tlevel - 1,\n+\t\t\t\t\t\t\t(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (level == 0) {\n+\t\t\t__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;\n+\t\t\t/* printf("write tnode at %d\\n",baseOffset); */\n+\t\t\tok = (yaffs_CheckpointWrite(dev,&baseOffset,sizeof(baseOffset)) == sizeof(baseOffset));\n+\t\t\tif(ok)\n+\t\t\t\tok = (yaffs_CheckpointWrite(dev,tn,tnodeSize) == tnodeSize);\n+\t\t}\n+\t}\n+\n+\treturn ok;\n+\n+}\n+\n+static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)\n+{\n+\t__u32 endMarker = ~0;\n+\tint ok = 1;\n+\n+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE){\n+\t\tok = yaffs_CheckpointTnodeWorker(obj,\n+\t\t\t\t\t    obj->variant.fileVariant.top,\n+\t\t\t\t\t    obj->variant.fileVariant.topLevel,\n+\t\t\t\t\t    0);\n+\t\tif(ok)\n+\t\t\tok = (yaffs_CheckpointWrite(obj->myDev,&endMarker,sizeof(endMarker)) ==\n+\t\t\t\tsizeof(endMarker));\n+\t}\n+\n+\treturn ok ? 1 : 0;\n+}\n+\n+static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)\n+{\n+\t__u32 baseChunk;\n+\tint ok = 1;\n+\tyaffs_Device *dev = obj->myDev;\n+\tyaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;\n+\tyaffs_Tnode *tn;\n+\tint nread = 0;\n+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;\n+\n+\tif(tnodeSize < sizeof(yaffs_Tnode))\n+\t\ttnodeSize = sizeof(yaffs_Tnode);\n+\n+\tok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));\n+\n+\twhile(ok && (~baseChunk)){\n+\t\tnread++;\n+\t\t/* Read level 0 tnode */\n+\n+\n+\t\t/* printf("read  tnode at %d\\n",baseChunk); */\n+\t\ttn = yaffs_GetTnodeRaw(dev);\n+\t\tif(tn)\n+\t\t\tok = (yaffs_CheckpointRead(dev,tn,tnodeSize) == tnodeSize);\n+\t\telse\n+\t\t\tok = 0;\n+\n+\t\tif(tn && ok){\n+\t\t\tok = yaffs_AddOrFindLevel0Tnode(dev,\n+\t\t\t\t\t       \t\tfileStructPtr,\n+\t\t\t\t\t       \t\tbaseChunk,\n+\t\t\t\t\t       \t\ttn) ? 1 : 0;\n+\n+\t\t}\n+\n+\t\tif(ok)\n+\t\t\tok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));\n+\n+\t}\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(\n+\t\tTSTR("Checkpoint read tnodes %d records, last %d. ok %d" TENDSTR),\n+\t\tnread,baseChunk,ok));\n+\n+\treturn ok ? 1 : 0;\n+}\n+\n+\n+static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)\n+{\n+\tyaffs_Object *obj;\n+        yaffs_CheckpointObject cp;\n+        int i;\n+        int ok = 1;\n+        struct ylist_head *lh;\n+\n+\n+        /* Iterate through the objects in each hash entry,\n+\t * dumping them to the checkpointing stream.\n+         */\n+\n+         for(i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++){\n+                ylist_for_each(lh, &dev->objectBucket[i].list) {\n+                        if (lh) {\n+                                obj = ylist_entry(lh, yaffs_Object, hashLink);\n+                                if (!obj->deferedFree) {\n+                                        yaffs_ObjectToCheckpointObject(&cp,obj);\n+                                        cp.structType = sizeof(cp);\n+\n+\t\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(\n+\t\t\t\t\t\tTSTR("Checkpoint write object %d parent %d type %d chunk %d obj addr %x" TENDSTR),\n+\t\t\t\t\t\tcp.objectId,cp.parentId,cp.variantType,cp.hdrChunk,(unsigned) obj));\n+\n+\t\t\t\t\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\n+\t\t\t\t\tif(ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE){\n+\t\t\t\t\t\tok = yaffs_WriteCheckpointTnodes(obj);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t }\n+\n+\t /* Dump end of list */\n+\tmemset(&cp,0xFF,sizeof(yaffs_CheckpointObject));\n+\tcp.structType = sizeof(cp);\n+\n+\tif(ok)\n+\t\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\n+\treturn ok ? 1 : 0;\n+}\n+\n+static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)\n+{\n+\tyaffs_Object *obj;\n+\tyaffs_CheckpointObject cp;\n+\tint ok = 1;\n+\tint done = 0;\n+\tyaffs_Object *hardList = NULL;\n+\n+\twhile(ok && !done) {\n+\t\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));\n+\t\tif(cp.structType != sizeof(cp)) {\n+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("struct size %d instead of %d ok %d"TENDSTR),\n+\t\t\t\tcp.structType,sizeof(cp),ok));\n+\t\t\tok = 0;\n+\t\t}\n+\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("Checkpoint read object %d parent %d type %d chunk %d " TENDSTR),\n+\t\t\tcp.objectId,cp.parentId,cp.variantType,cp.hdrChunk));\n+\n+\t\tif(ok && cp.objectId == ~0)\n+\t\t\tdone = 1;\n+\t\telse if(ok){\n+\t\t\tobj = yaffs_FindOrCreateObjectByNumber(dev,cp.objectId, cp.variantType);\n+\t\t\tif(obj) {\n+\t\t\t\tyaffs_CheckpointObjectToObject(obj,&cp);\n+\t\t\t\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE) {\n+                                        ok = yaffs_ReadCheckpointTnodes(obj);\n+                                } else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {\n+                                        obj->hardLinks.next =\n+                                                    (struct ylist_head *)\n+                                                    hardList;\n+                                        hardList = obj;\n+                                }\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif(ok)\n+\t\tyaffs_HardlinkFixup(dev,hardList);\n+\n+\treturn ok ? 1 : 0;\n+}\n+\n+static int yaffs_WriteCheckpointSum(yaffs_Device *dev)\n+{\n+\t__u32 checkpointSum;\n+\tint ok;\n+\n+\tyaffs_GetCheckpointSum(dev,&checkpointSum);\n+\n+\tok = (yaffs_CheckpointWrite(dev,&checkpointSum,sizeof(checkpointSum)) == sizeof(checkpointSum));\n+\n+\tif(!ok)\n+\t\treturn 0;\n+\n+\treturn 1;\n+}\n+\n+static int yaffs_ReadCheckpointSum(yaffs_Device *dev)\n+{\n+\t__u32 checkpointSum0;\n+\t__u32 checkpointSum1;\n+\tint ok;\n+\n+\tyaffs_GetCheckpointSum(dev,&checkpointSum0);\n+\n+\tok = (yaffs_CheckpointRead(dev,&checkpointSum1,sizeof(checkpointSum1)) == sizeof(checkpointSum1));\n+\n+\tif(!ok)\n+\t\treturn 0;\n+\n+\tif(checkpointSum0 != checkpointSum1)\n+\t\treturn 0;\n+\n+\treturn 1;\n+}\n+\n+\n+static int yaffs_WriteCheckpointData(yaffs_Device *dev)\n+{\n+\n+\tint ok = 1;\n+\n+\tif(dev->skipCheckpointWrite || !dev->isYaffs2){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint write" TENDSTR)));\n+\t\tok = 0;\n+\t}\n+\n+\tif(ok)\n+\t\tok = yaffs_CheckpointOpen(dev,1);\n+\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));\n+\t\tok = yaffs_WriteCheckpointValidityMarker(dev,1);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint device" TENDSTR)));\n+\t\tok = yaffs_WriteCheckpointDevice(dev);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint objects" TENDSTR)));\n+\t\tok = yaffs_WriteCheckpointObjects(dev);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("write checkpoint validity" TENDSTR)));\n+\t\tok = yaffs_WriteCheckpointValidityMarker(dev,0);\n+\t}\n+\n+\tif(ok){\n+\t\tok = yaffs_WriteCheckpointSum(dev);\n+\t}\n+\n+\n+\tif(!yaffs_CheckpointClose(dev))\n+\t\t ok = 0;\n+\n+\tif(ok)\n+\t    \tdev->isCheckpointed = 1;\n+\t else\n+\t \tdev->isCheckpointed = 0;\n+\n+\treturn dev->isCheckpointed;\n+}\n+\n+static int yaffs_ReadCheckpointData(yaffs_Device *dev)\n+{\n+\tint ok = 1;\n+\n+\tif(dev->skipCheckpointRead || !dev->isYaffs2){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("skipping checkpoint read" TENDSTR)));\n+\t\tok = 0;\n+\t}\n+\n+\tif(ok)\n+\t\tok = yaffs_CheckpointOpen(dev,0); /* open for read */\n+\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));\n+\t\tok = yaffs_ReadCheckpointValidityMarker(dev,1);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint device" TENDSTR)));\n+\t\tok = yaffs_ReadCheckpointDevice(dev);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint objects" TENDSTR)));\n+\t\tok = yaffs_ReadCheckpointObjects(dev);\n+\t}\n+\tif(ok){\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint validity" TENDSTR)));\n+\t\tok = yaffs_ReadCheckpointValidityMarker(dev,0);\n+\t}\n+\n+\tif(ok){\n+\t\tok = yaffs_ReadCheckpointSum(dev);\n+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("read checkpoint checksum %d" TENDSTR),ok));\n+\t}\n+\n+\tif(!yaffs_CheckpointClose(dev))\n+\t\tok = 0;\n+\n+\tif(ok)\n+\t    \tdev->isCheckpointed = 1;\n+\t else\n+\t \tdev->isCheckpointed = 0;\n+\n+\treturn ok ? 1 : 0;\n+\n+}\n+\n+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)\n+{\n+\tif(dev->isCheckpointed ||\n+\t   dev->blocksInCheckpoint > 0){\n+\t\tdev->isCheckpointed = 0;\n+\t\tyaffs_CheckpointInvalidateStream(dev);\n+\t\tif(dev->superBlock && dev->markSuperBlockDirty)\n+\t\t\tdev->markSuperBlockDirty(dev->superBlock);\n+\t}\n+}\n+\n+\n+int yaffs_CheckpointSave(yaffs_Device *dev)\n+{\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("save entry: isCheckpointed %d"TENDSTR),dev->isCheckpointed));\n+\n+\tyaffs_VerifyObjects(dev);\n+\tyaffs_VerifyBlocks(dev);\n+\tyaffs_VerifyFreeChunks(dev);\n+\n+\tif(!dev->isCheckpointed) {\n+\t\tyaffs_InvalidateCheckpoint(dev);\n+\t\tyaffs_WriteCheckpointData(dev);\n+\t}\n+\n+\tT(YAFFS_TRACE_ALWAYS,(TSTR("save exit: isCheckpointed %d"TENDSTR),dev->isCheckpointed));\n+\n+\treturn dev->isCheckpointed;\n+}\n+\n+int yaffs_CheckpointRestore(yaffs_Device *dev)\n+{\n+\tint retval;\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("restore entry: isCheckpointed %d"TENDSTR),dev->isCheckpointed));\n+\n+\tretval = yaffs_ReadCheckpointData(dev);\n+\n+\tif(dev->isCheckpointed){\n+\t\tyaffs_VerifyObjects(dev);\n+\t\tyaffs_VerifyBlocks(dev);\n+\t\tyaffs_VerifyFreeChunks(dev);\n+\t}\n+\n+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR("restore exit: isCheckpointed %d"TENDSTR),dev->isCheckpointed));\n+\n+\treturn retval;\n+}\n+\n+/*--------------------- File read/write ------------------------\n+ * Read and write have very similar structures.\n+ * In general the read/write has three parts to it\n+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)\n+ * Some complete chunks\n+ * An incomplete chunk to end off with\n+ *\n+ * Curve-balls: the first chunk might also be the last chunk.\n+ */\n+\n+int yaffs_ReadDataFromFile(yaffs_Object * in, __u8 * buffer, loff_t offset,\n+\t\t\t   int nBytes)\n+{\n+\n+\tint chunk;\n+\t__u32 start;\n+\tint nToCopy;\n+\tint n = nBytes;\n+\tint nDone = 0;\n+\tyaffs_ChunkCache *cache;\n+\n+\tyaffs_Device *dev;\n+\n+\tdev = in->myDev;\n+\n+\twhile (n > 0) {\n+\t\t//chunk = offset / dev->nDataBytesPerChunk + 1;\n+\t\t//start = offset % dev->nDataBytesPerChunk;\n+\t\tyaffs_AddrToChunk(dev,offset,&chunk,&start);\n+\t\tchunk++;\n+\n+\t\t/* OK now check for the curveball where the start and end are in\n+\t\t * the same chunk.\n+\t\t */\n+\t\tif ((start + n) < dev->nDataBytesPerChunk) {\n+\t\t\tnToCopy = n;\n+\t\t} else {\n+\t\t\tnToCopy = dev->nDataBytesPerChunk - start;\n+\t\t}\n+\n+\t\tcache = yaffs_FindChunkCache(in, chunk);\n+\n+\t\t/* If the chunk is already in the cache or it is less than a whole chunk\n+\t\t * or we\'re using inband tags then use the cache (if there is caching)\n+\t\t * else bypass the cache.\n+\t\t */\n+\t\tif (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {\n+\t\t\tif (dev->nShortOpCaches > 0) {\n+\n+\t\t\t\t/* If we can\'t find the data in the cache, then load it up. */\n+\n+\t\t\t\tif (!cache) {\n+\t\t\t\t\tcache = yaffs_GrabChunkCache(in->myDev);\n+\t\t\t\t\tcache->object = in;\n+\t\t\t\t\tcache->chunkId = chunk;\n+\t\t\t\t\tcache->dirty = 0;\n+\t\t\t\t\tcache->locked = 0;\n+\t\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,\n+\t\t\t\t\t\t\t\t      cache->\n+\t\t\t\t\t\t\t\t      data);\n+\t\t\t\t\tcache->nBytes = 0;\n+\t\t\t\t}\n+\n+\t\t\t\tyaffs_UseChunkCache(dev, cache, 0);\n+\n+\t\t\t\tcache->locked = 1;\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\t\t\t\tmemcpy(buffer, &cache->data[start], nToCopy);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_LockYAFFS(TRUE);\n+#endif\n+\t\t\t\tcache->locked = 0;\n+\t\t\t} else {\n+\t\t\t\t/* Read into the local buffer then copy..*/\n+\n+\t\t\t\t__u8 *localBuffer =\n+\t\t\t\t    yaffs_GetTempBuffer(dev, __LINE__);\n+\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,\n+\t\t\t\t\t\t\t      localBuffer);\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\t\t\t\tmemcpy(buffer, &localBuffer[start], nToCopy);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_LockYAFFS(TRUE);\n+#endif\n+\t\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer,\n+\t\t\t\t\t\t\t__LINE__);\n+\t\t\t}\n+\n+\t\t} else {\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t\t\t/* Under WinCE can\'t do direct transfer. Need to use a local buffer.\n+\t\t\t * This is because we otherwise screw up WinCE\'s memory mapper\n+\t\t\t */\n+\t\t\tyaffs_ReadChunkDataFromObject(in, chunk, localBuffer);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\t\t\tmemcpy(buffer, localBuffer, dev->nDataBytesPerChunk);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\tyfsd_LockYAFFS(TRUE);\n+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);\n+#endif\n+\n+#else\n+\t\t\t/* A full chunk. Read directly into the supplied buffer. */\n+\t\t\tyaffs_ReadChunkDataFromObject(in, chunk, buffer);\n+#endif\n+\t\t}\n+\n+\t\tn -= nToCopy;\n+\t\toffset += nToCopy;\n+\t\tbuffer += nToCopy;\n+\t\tnDone += nToCopy;\n+\n+\t}\n+\n+\treturn nDone;\n+}\n+\n+int yaffs_WriteDataToFile(yaffs_Object * in, const __u8 * buffer, loff_t offset,\n+\t\t\t  int nBytes, int writeThrough)\n+{\n+\n+\tint chunk;\n+\t__u32 start;\n+\tint nToCopy;\n+        int n = nBytes;\n+        int nDone = 0;\n+        int nToWriteBack;\n+        int startOfWrite = offset;\n+        int chunkWritten = 0;\n+        int nBytesRead;\n+\n+\tyaffs_Device *dev;\n+\n+\tdev = in->myDev;\n+\n+\twhile (n > 0 && chunkWritten >= 0) {\n+\t\t//chunk = offset / dev->nDataBytesPerChunk + 1;\n+\t\t//start = offset % dev->nDataBytesPerChunk;\n+\t\tyaffs_AddrToChunk(dev,offset,&chunk,&start);\n+\t\tchunk++;\n+\n+\t\t/* OK now check for the curveball where the start and end are in\n+\t\t * the same chunk.\n+\t\t */\n+\n+\t\tif ((start + n) < dev->nDataBytesPerChunk) {\n+\t\t\tnToCopy = n;\n+\n+\t\t\t/* Now folks, to calculate how many bytes to write back....\n+\t\t\t * If we\'re overwriting and not writing to then end of file then\n+\t\t\t * we need to write back as much as was there before.\n+\t\t\t */\n+\n+\t\t\tnBytesRead =\n+\t\t\t    in->variant.fileVariant.fileSize -\n+\t\t\t    ((chunk - 1) * dev->nDataBytesPerChunk);\n+\n+\t\t\tif (nBytesRead > dev->nDataBytesPerChunk) {\n+\t\t\t\tnBytesRead = dev->nDataBytesPerChunk;\n+\t\t\t}\n+\n+\t\t\tnToWriteBack =\n+\t\t\t    (nBytesRead >\n+\t\t\t     (start + n)) ? nBytesRead : (start + n);\n+\n+\t\t} else {\n+\t\t\tnToCopy = dev->nDataBytesPerChunk - start;\n+\t\t\tnToWriteBack = dev->nDataBytesPerChunk;\n+\t\t}\n+\n+\t\tif (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {\n+\t\t\t/* An incomplete start or end chunk (or maybe both start and end chunk),\n+\t\t\t * or we\'re using inband tags, so we want to use the cache buffers.\n+\t\t\t */\n+\t\t\tif (dev->nShortOpCaches > 0) {\n+\t\t\t\tyaffs_ChunkCache *cache;\n+\t\t\t\t/* If we can\'t find the data in the cache, then load the cache */\n+\t\t\t\tcache = yaffs_FindChunkCache(in, chunk);\n+\n+\t\t\t\tif (!cache\n+\t\t\t\t    && yaffs_CheckSpaceForAllocation(in->\n+\t\t\t\t\t\t\t\t     myDev)) {\n+\t\t\t\t\tcache = yaffs_GrabChunkCache(in->myDev);\n+\t\t\t\t\tcache->object = in;\n+\t\t\t\t\tcache->chunkId = chunk;\n+\t\t\t\t\tcache->dirty = 0;\n+\t\t\t\t\tcache->locked = 0;\n+\t\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,\n+\t\t\t\t\t\t\t\t      cache->\n+\t\t\t\t\t\t\t\t      data);\n+\t\t\t\t}\n+\t\t\t\telse if(cache &&\n+\t\t\t\t        !cache->dirty &&\n+\t\t\t\t\t!yaffs_CheckSpaceForAllocation(in->myDev)){\n+\t\t\t\t\t/* Drop the cache if it was a read cache item and\n+\t\t\t\t\t * no space check has been made for it.\n+\t\t\t\t\t */\n+\t\t\t\t\t cache = NULL;\n+\t\t\t\t}\n+\n+\t\t\t\tif (cache) {\n+\t\t\t\t\tyaffs_UseChunkCache(dev, cache, 1);\n+\t\t\t\t\tcache->locked = 1;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\n+\t\t\t\t\tmemcpy(&cache->data[start], buffer,\n+\t\t\t\t\t       nToCopy);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\tyfsd_LockYAFFS(TRUE);\n+#endif\n+\t\t\t\t\tcache->locked = 0;\n+\t\t\t\t\tcache->nBytes = nToWriteBack;\n+\n+\t\t\t\t\tif (writeThrough) {\n+\t\t\t\t\t\tchunkWritten =\n+\t\t\t\t\t\t    yaffs_WriteChunkDataToObject\n+\t\t\t\t\t\t    (cache->object,\n+\t\t\t\t\t\t     cache->chunkId,\n+\t\t\t\t\t\t     cache->data, cache->nBytes,\n+\t\t\t\t\t\t     1);\n+\t\t\t\t\t\tcache->dirty = 0;\n+\t\t\t\t\t}\n+\n+\t\t\t\t} else {\n+\t\t\t\t\tchunkWritten = -1;\t/* fail the write */\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t/* An incomplete start or end chunk (or maybe both start and end chunk)\n+\t\t\t\t * Read into the local buffer then copy, then copy over and write back.\n+\t\t\t\t */\n+\n+\t\t\t\t__u8 *localBuffer =\n+\t\t\t\t    yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,\n+\t\t\t\t\t\t\t      localBuffer);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\n+\t\t\t\tmemcpy(&localBuffer[start], buffer, nToCopy);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\tyfsd_LockYAFFS(TRUE);\n+#endif\n+\t\t\t\tchunkWritten =\n+\t\t\t\t    yaffs_WriteChunkDataToObject(in, chunk,\n+\t\t\t\t\t\t\t\t localBuffer,\n+\t\t\t\t\t\t\t\t nToWriteBack,\n+\t\t\t\t\t\t\t\t 0);\n+\n+\t\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer,\n+\t\t\t\t\t\t\t__LINE__);\n+\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\t/* A full chunk. Write directly from the supplied buffer. */\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t/* Under WinCE can\'t do direct transfer. Need to use a local buffer.\n+\t\t\t * This is because we otherwise screw up WinCE\'s memory mapper\n+\t\t\t */\n+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\tyfsd_UnlockYAFFS(TRUE);\n+#endif\n+\t\t\tmemcpy(localBuffer, buffer, dev->nDataBytesPerChunk);\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\tyfsd_LockYAFFS(TRUE);\n+#endif\n+\t\t\tchunkWritten =\n+\t\t\t    yaffs_WriteChunkDataToObject(in, chunk, localBuffer,\n+\t\t\t\t\t\t\t dev->nDataBytesPerChunk,\n+\t\t\t\t\t\t\t 0);\n+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);\n+#else\n+\n+\t\t\tchunkWritten =\n+\t\t\t    yaffs_WriteChunkDataToObject(in, chunk, buffer,\n+\t\t\t\t\t\t\t dev->nDataBytesPerChunk,\n+\t\t\t\t\t\t\t 0);\n+#endif\n+\t\t\t/* Since we\'ve overwritten the cached data, we better invalidate it. */\n+\t\t\tyaffs_InvalidateChunkCache(in, chunk);\n+\t\t}\n+\n+\t\tif (chunkWritten >= 0) {\n+\t\t\tn -= nToCopy;\n+\t\t\toffset += nToCopy;\n+\t\t\tbuffer += nToCopy;\n+\t\t\tnDone += nToCopy;\n+\t\t}\n+\n+\t}\n+\n+\t/* Update file object */\n+\n+\tif ((startOfWrite + nDone) > in->variant.fileVariant.fileSize) {\n+\t\tin->variant.fileVariant.fileSize = (startOfWrite + nDone);\n+\t}\n+\n+\tin->dirty = 1;\n+\n+\treturn nDone;\n+}\n+\n+\n+/* ---------------------- File resizing stuff ------------------ */\n+\n+static void yaffs_PruneResizedChunks(yaffs_Object * in, int newSize)\n+{\n+\n+\tyaffs_Device *dev = in->myDev;\n+\tint oldFileSize = in->variant.fileVariant.fileSize;\n+\n+\tint lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;\n+\n+\tint startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /\n+\t    dev->nDataBytesPerChunk;\n+\tint i;\n+\tint chunkId;\n+\n+\t/* Delete backwards so that we don\'t end up with holes if\n+\t * power is lost part-way through the operation.\n+\t */\n+\tfor (i = lastDel; i >= startDel; i--) {\n+\t\t/* NB this could be optimised somewhat,\n+\t\t * eg. could retrieve the tags and write them without\n+\t\t * using yaffs_DeleteChunk\n+\t\t */\n+\n+\t\tchunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);\n+\t\tif (chunkId > 0) {\n+\t\t\tif (chunkId <\n+\t\t\t    (dev->internalStartBlock * dev->nChunksPerBlock)\n+\t\t\t    || chunkId >=\n+\t\t\t    ((dev->internalEndBlock +\n+\t\t\t      1) * dev->nChunksPerBlock)) {\n+\t\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t\t  (TSTR("Found daft chunkId %d for %d" TENDSTR),\n+\t\t\t\t   chunkId, i));\n+\t\t\t} else {\n+\t\t\t\tin->nDataChunks--;\n+\t\t\t\tyaffs_DeleteChunk(dev, chunkId, 1, __LINE__);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+}\n+\n+int yaffs_ResizeFile(yaffs_Object * in, loff_t newSize)\n+{\n+\n+\tint oldFileSize = in->variant.fileVariant.fileSize;\n+\t__u32 newSizeOfPartialChunk;\n+\tint newFullChunks;\n+\n+\tyaffs_Device *dev = in->myDev;\n+\n+\tyaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);\n+\n+\tyaffs_FlushFilesChunkCache(in);\n+\tyaffs_InvalidateWholeChunkCache(in);\n+\n+        yaffs_CheckGarbageCollection(dev);\n+\n+        if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {\n+                return YAFFS_FAIL;\n+        }\n+\n+        if (newSize == oldFileSize) {\n+                return YAFFS_OK;\n+        }\n+\n+        if (newSize < oldFileSize) {\n+\n+\t\tyaffs_PruneResizedChunks(in, newSize);\n+\n+\t\tif (newSizeOfPartialChunk != 0) {\n+\t\t\tint lastChunk = 1 + newFullChunks;\n+\n+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t\t\t/* Got to read and rewrite the last chunk with its new size and zero pad */\n+\t\t\tyaffs_ReadChunkDataFromObject(in, lastChunk,\n+\t\t\t\t\t\t      localBuffer);\n+\n+\t\t\tmemset(localBuffer + newSizeOfPartialChunk, 0,\n+\t\t\t       dev->nDataBytesPerChunk - newSizeOfPartialChunk);\n+\n+\t\t\tyaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,\n+\t\t\t\t\t\t     newSizeOfPartialChunk, 1);\n+\n+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);\n+\t\t}\n+\n+\t\tin->variant.fileVariant.fileSize = newSize;\n+\n+\t\tyaffs_PruneFileStructure(dev, &in->variant.fileVariant);\n+\t} else {\n+\t\t/* newsSize > oldFileSize */\n+\t\tin->variant.fileVariant.fileSize = newSize;\n+\t}\n+\n+\n+\n+\t/* Write a new object header.\n+\t * show we\'ve shrunk the file, if need be\n+\t * Do this only if the file is not in the deleted directories.\n+\t */\n+\tif (in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&\n+\t    in->parent->objectId != YAFFS_OBJECTID_DELETED) {\n+\t\tyaffs_UpdateObjectHeader(in, NULL, 0,\n+\t\t\t\t\t (newSize < oldFileSize) ? 1 : 0, 0);\n+\t}\n+\n+\treturn YAFFS_OK;\n+}\n+\n+loff_t yaffs_GetFileSize(yaffs_Object * obj)\n+{\n+\tobj = yaffs_GetEquivalentObject(obj);\n+\n+\tswitch (obj->variantType) {\n+\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\treturn obj->variant.fileVariant.fileSize;\n+\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\treturn yaffs_strlen(obj->variant.symLinkVariant.alias);\n+\tdefault:\n+\t\treturn 0;\n+\t}\n+}\n+\n+\n+\n+int yaffs_FlushFile(yaffs_Object * in, int updateTime)\n+{\n+\tint retVal;\n+\tif (in->dirty) {\n+\t\tyaffs_FlushFilesChunkCache(in);\n+\t\tif (updateTime) {\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\tyfsd_WinFileTimeNow(in->win_mtime);\n+#else\n+\n+\t\t\tin->yst_mtime = Y_CURRENT_TIME;\n+\n+#endif\n+\t\t}\n+\n+\t\tretVal =\n+\t\t    (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=\n+\t\t     0) ? YAFFS_OK : YAFFS_FAIL;\n+\t} else {\n+\t\tretVal = YAFFS_OK;\n+\t}\n+\n+\treturn retVal;\n+\n+}\n+\n+static int yaffs_DoGenericObjectDeletion(yaffs_Object * in)\n+{\n+\n+\t/* First off, invalidate the file\'s data in the cache, without flushing. */\n+\tyaffs_InvalidateWholeChunkCache(in);\n+\n+\tif (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {\n+\t\t/* Move to the unlinked directory so we have a record that it was deleted. */\n+\t\tyaffs_ChangeObjectName(in, in->myDev->deletedDir,_Y("deleted"), 0, 0);\n+\n+\t}\n+\n+\tyaffs_RemoveObjectFromDirectory(in);\n+\tyaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);\n+\tin->hdrChunk = 0;\n+\n+\tyaffs_FreeObject(in);\n+\treturn YAFFS_OK;\n+\n+}\n+\n+/* yaffs_DeleteFile deletes the whole file data\n+ * and the inode associated with the file.\n+ * It does not delete the links associated with the file.\n+ */\n+static int yaffs_UnlinkFile(yaffs_Object * in)\n+{\n+\n+\tint retVal;\n+\tint immediateDeletion = 0;\n+\n+\tif (1) {\n+#ifdef __KERNEL__\n+\t\tif (!in->myInode) {\n+\t\t\timmediateDeletion = 1;\n+\n+\t\t}\n+#else\n+\t\tif (in->inUse <= 0) {\n+\t\t\timmediateDeletion = 1;\n+\n+\t\t}\n+#endif\n+\t\tif (immediateDeletion) {\n+\t\t\tretVal =\n+\t\t\t    yaffs_ChangeObjectName(in, in->myDev->deletedDir,\n+\t\t\t\t\t\t   _Y("deleted"), 0, 0);\n+\t\t\tT(YAFFS_TRACE_TRACING,\n+\t\t\t  (TSTR("yaffs: immediate deletion of file %d" TENDSTR),\n+\t\t\t   in->objectId));\n+\t\t\tin->deleted = 1;\n+\t\t\tin->myDev->nDeletedFiles++;\n+\t\t\tif (0 && in->myDev->isYaffs2) {\n+\t\t\t\tyaffs_ResizeFile(in, 0);\n+\t\t\t}\n+\t\t\tyaffs_SoftDeleteFile(in);\n+\t\t} else {\n+\t\t\tretVal =\n+\t\t\t    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,\n+\t\t\t\t\t\t   _Y("unlinked"), 0, 0);\n+\t\t}\n+\n+\t}\n+\treturn retVal;\n+}\n+\n+int yaffs_DeleteFile(yaffs_Object * in)\n+{\n+\tint retVal = YAFFS_OK;\n+\n+\tif (in->nDataChunks > 0) {\n+\t\t/* Use soft deletion if there is data in the file */\n+\t\tif (!in->unlinked) {\n+\t\t\tretVal = yaffs_UnlinkFile(in);\n+\t\t}\n+\t\tif (retVal == YAFFS_OK && in->unlinked && !in->deleted) {\n+\t\t\tin->deleted = 1;\n+\t\t\tin->myDev->nDeletedFiles++;\n+\t\t\tyaffs_SoftDeleteFile(in);\n+\t\t}\n+\t\treturn in->deleted ? YAFFS_OK : YAFFS_FAIL;\n+\t} else {\n+\t\t/* The file has no data chunks so we toss it immediately */\n+\t\tyaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);\n+\t\tin->variant.fileVariant.top = NULL;\n+\t\tyaffs_DoGenericObjectDeletion(in);\n+\n+\t\treturn YAFFS_OK;\n+\t}\n+}\n+\n+static int yaffs_DeleteDirectory(yaffs_Object * in)\n+{\n+        /* First check that the directory is empty. */\n+        if (ylist_empty(&in->variant.directoryVariant.children)) {\n+                return yaffs_DoGenericObjectDeletion(in);\n+        }\n+\n+\treturn YAFFS_FAIL;\n+\n+}\n+\n+static int yaffs_DeleteSymLink(yaffs_Object * in)\n+{\n+\tYFREE(in->variant.symLinkVariant.alias);\n+\n+\treturn yaffs_DoGenericObjectDeletion(in);\n+}\n+\n+static int yaffs_DeleteHardLink(yaffs_Object * in)\n+{\n+        /* remove this hardlink from the list assocaited with the equivalent\n+         * object\n+         */\n+        ylist_del(&in->hardLinks);\n+        return yaffs_DoGenericObjectDeletion(in);\n+}\n+\n+static void yaffs_DestroyObject(yaffs_Object * obj)\n+{\n+\tswitch (obj->variantType) {\n+\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\tyaffs_DeleteFile(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\tyaffs_DeleteDirectory(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\tyaffs_DeleteSymLink(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\tyaffs_DeleteHardLink(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\tyaffs_DoGenericObjectDeletion(obj);\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\tbreak;\t\t/* should not happen. */\n+\t}\n+}\n+\n+static int yaffs_UnlinkWorker(yaffs_Object * obj)\n+{\n+\n+        if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {\n+                return yaffs_DeleteHardLink(obj);\n+        } else if (!ylist_empty(&obj->hardLinks)) {\n+                /* Curve ball: We\'re unlinking an object that has a hardlink.\n+                 *\n+                 * This problem arises because we are not strictly following\n+\t\t * The Linux link/inode model.\n+\t\t *\n+\t\t * We can\'t really delete the object.\n+\t\t * Instead, we do the following:\n+\t\t * - Select a hardlink.\n+\t\t * - Unhook it from the hard links\n+\t\t * - Unhook it from its parent directory (so that the rename can work)\n+\t\t * - Rename the object to the hardlink\'s name.\n+\t\t * - Delete the hardlink\n+\t\t */\n+\n+\t\tyaffs_Object *hl;\n+                int retVal;\n+                YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];\n+\n+                hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);\n+\n+                ylist_del_init(&hl->hardLinks);\n+                ylist_del_init(&hl->siblings);\n+\n+                yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);\n+\n+\t\tretVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);\n+\n+\t\tif (retVal == YAFFS_OK) {\n+\t\t\tretVal = yaffs_DoGenericObjectDeletion(hl);\n+\t\t}\n+\t\treturn retVal;\n+\n+\t} else {\n+\t\tswitch (obj->variantType) {\n+\t\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\t\treturn yaffs_UnlinkFile(obj);\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\t\treturn yaffs_DeleteDirectory(obj);\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\t\treturn yaffs_DeleteSymLink(obj);\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\t\treturn yaffs_DoGenericObjectDeletion(obj);\n+\t\t\tbreak;\n+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\tdefault:\n+\t\t\treturn YAFFS_FAIL;\n+\t\t}\n+\t}\n+}\n+\n+\n+static int yaffs_UnlinkObject( yaffs_Object *obj)\n+{\n+\n+\tif (obj && obj->unlinkAllowed) {\n+\t\treturn yaffs_UnlinkWorker(obj);\n+\t}\n+\n+\treturn YAFFS_FAIL;\n+\n+}\n+int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name)\n+{\n+\tyaffs_Object *obj;\n+\n+\tobj = yaffs_FindObjectByName(dir, name);\n+\treturn yaffs_UnlinkObject(obj);\n+}\n+\n+/*----------------------- Initialisation Scanning ---------------------- */\n+\n+static void yaffs_HandleShadowedObject(yaffs_Device * dev, int objId,\n+\t\t\t\t       int backwardScanning)\n+{\n+\tyaffs_Object *obj;\n+\n+\tif (!backwardScanning) {\n+\t\t/* Handle YAFFS1 forward scanning case\n+\t\t * For YAFFS1 we always do the deletion\n+\t\t */\n+\n+\t} else {\n+\t\t/* Handle YAFFS2 case (backward scanning)\n+\t\t * If the shadowed object exists then ignore.\n+\t\t */\n+\t\tif (yaffs_FindObjectByNumber(dev, objId)) {\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\t/* Let\'s create it (if it does not exist) assuming it is a file so that it can do shrinking etc.\n+\t * We put it in unlinked dir to be cleaned up after the scanning\n+\t */\n+\tobj =\n+\t    yaffs_FindOrCreateObjectByNumber(dev, objId,\n+\t\t\t\t\t     YAFFS_OBJECT_TYPE_FILE);\n+\tyaffs_AddObjectToDirectory(dev->unlinkedDir, obj);\n+\tobj->variant.fileVariant.shrinkSize = 0;\n+\tobj->valid = 1;\t\t/* So that we don\'t read any other info for this file */\n+\n+}\n+\n+typedef struct {\n+\tint seq;\n+\tint block;\n+} yaffs_BlockIndex;\n+\n+\n+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)\n+{\n+\tyaffs_Object *hl;\n+\tyaffs_Object *in;\n+\n+\twhile (hardList) {\n+\t\thl = hardList;\n+\t\thardList = (yaffs_Object *) (hardList->hardLinks.next);\n+\n+\t\tin = yaffs_FindObjectByNumber(dev,\n+\t\t\t\t\t      hl->variant.hardLinkVariant.\n+\t\t\t\t\t      equivalentObjectId);\n+\n+                if (in) {\n+                        /* Add the hardlink pointers */\n+                        hl->variant.hardLinkVariant.equivalentObject = in;\n+                        ylist_add(&hl->hardLinks, &in->hardLinks);\n+                } else {\n+                        /* Todo Need to report/handle this better.\n+                         * Got a problem... hardlink to a non-existant object\n+                         */\n+                        hl->variant.hardLinkVariant.equivalentObject = NULL;\n+                        YINIT_LIST_HEAD(&hl->hardLinks);\n+\n+                }\n+\n+\t}\n+\n+}\n+\n+\n+\n+\n+\n+static int ybicmp(const void *a, const void *b){\n+    register int aseq = ((yaffs_BlockIndex *)a)->seq;\n+    register int bseq = ((yaffs_BlockIndex *)b)->seq;\n+    register int ablock = ((yaffs_BlockIndex *)a)->block;\n+    register int bblock = ((yaffs_BlockIndex *)b)->block;\n+    if( aseq == bseq )\n+        return ablock - bblock;\n+    else\n+        return aseq - bseq;\n+\n+}\n+\n+\n+struct yaffs_ShadowFixerStruct {\n+\tint objectId;\n+\tint shadowedId;\n+\tstruct yaffs_ShadowFixerStruct *next;\n+};\n+\n+static int yaffs_Scan(yaffs_Device * dev)\n+{\n+\tyaffs_ExtendedTags tags;\n+\tint blk;\n+\tint blockIterator;\n+\tint startIterator;\n+\tint endIterator;\n+\tint result;\n+\n+\tint chunk;\n+\tint c;\n+\tint deleted;\n+\tyaffs_BlockState state;\n+\tyaffs_Object *hardList = NULL;\n+\tyaffs_BlockInfo *bi;\n+\t__u32 sequenceNumber;\n+\tyaffs_ObjectHeader *oh;\n+\tyaffs_Object *in;\n+\tyaffs_Object *parent;\n+\n+\tint alloc_failed = 0;\n+\n+\tstruct yaffs_ShadowFixerStruct *shadowFixerList = NULL;\n+\n+\n+\t__u8 *chunkData;\n+\n+\n+\t//TODO  Throw all the yaffs2 stuuf out of yaffs_Scan since it is only for yaffs1 format.\n+\n+\tT(YAFFS_TRACE_SCAN,\n+\t  (TSTR("yaffs_Scan starts  intstartblk %d intendblk %d..." TENDSTR),\n+\t   dev->internalStartBlock, dev->internalEndBlock));\n+\n+\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\tdev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;\n+\n+\t/* Scan all the blocks to determine their state */\n+\tfor (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {\n+\t\tbi = yaffs_GetBlockInfo(dev, blk);\n+\t\tyaffs_ClearChunkBits(dev, blk);\n+\t\tbi->pagesInUse = 0;\n+\t\tbi->softDeletions = 0;\n+\n+\t\tyaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);\n+\n+\t\tbi->blockState = state;\n+\t\tbi->sequenceNumber = sequenceNumber;\n+\n+\t\tT(YAFFS_TRACE_SCAN_DEBUG,\n+\t\t  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,\n+\t\t   state, sequenceNumber));\n+\n+\t\tif (state == YAFFS_BLOCK_STATE_DEAD) {\n+\t\t\tT(YAFFS_TRACE_BAD_BLOCKS,\n+\t\t\t  (TSTR("block %d is bad" TENDSTR), blk));\n+\t\t} else if (state == YAFFS_BLOCK_STATE_EMPTY) {\n+\t\t\tT(YAFFS_TRACE_SCAN_DEBUG,\n+\t\t\t  (TSTR("Block empty " TENDSTR)));\n+\t\t\tdev->nErasedBlocks++;\n+\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;\n+\t\t}\n+\t}\n+\n+\tstartIterator = dev->internalStartBlock;\n+\tendIterator = dev->internalEndBlock;\n+\n+\t/* For each block.... */\n+\tfor (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;\n+\t     blockIterator++) {\n+\n+\t\tYYIELD();\n+\n+\t     \tYYIELD();\n+\n+\t\tblk = blockIterator;\n+\n+\t\tbi = yaffs_GetBlockInfo(dev, blk);\n+\t\tstate = bi->blockState;\n+\n+\t\tdeleted = 0;\n+\n+\t\t/* For each chunk in each block that needs scanning....*/\n+\t\tfor (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&\n+\t\t     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {\n+\t\t\t/* Read the tags and decide what to do */\n+\t\t\tchunk = blk * dev->nChunksPerBlock + c;\n+\n+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,\n+\t\t\t\t\t\t\t&tags);\n+\n+\t\t\t/* Let\'s have a good look at this chunk... */\n+\n+\t\t\tif (!dev->isYaffs2 && tags.chunkDeleted) {\n+\t\t\t\t/* YAFFS1 only...\n+\t\t\t\t * A deleted chunk\n+\t\t\t\t */\n+\t\t\t\tdeleted++;\n+\t\t\t\tdev->nFreeChunks++;\n+\t\t\t\t/*T((" %d %d deleted\\n",blk,c)); */\n+\t\t\t} else if (!tags.chunkUsed) {\n+\t\t\t\t/* An unassigned chunk in the block\n+\t\t\t\t * This means that either the block is empty or\n+\t\t\t\t * this is the one being allocated from\n+\t\t\t\t */\n+\n+\t\t\t\tif (c == 0) {\n+\t\t\t\t\t/* We\'re looking at the first chunk in the block so the block is unused */\n+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_EMPTY;\n+\t\t\t\t\tdev->nErasedBlocks++;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* this is the block being allocated from */\n+\t\t\t\t\tT(YAFFS_TRACE_SCAN,\n+\t\t\t\t\t  (TSTR\n+\t\t\t\t\t   (" Allocating from %d %d" TENDSTR),\n+\t\t\t\t\t   blk, c));\n+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_ALLOCATING;\n+\t\t\t\t\tdev->allocationBlock = blk;\n+\t\t\t\t\tdev->allocationPage = c;\n+\t\t\t\t\tdev->allocationBlockFinder = blk;\n+\t\t\t\t\t/* Set it to here to encourage the allocator to go forth from here. */\n+\n+\t\t\t\t\t/* Yaffs2 sanity check:\n+\t\t\t\t\t * This should be the one with the highest sequence number\n+\t\t\t\t\t */\n+\t\t\t\t\tif (dev->isYaffs2\n+\t\t\t\t\t    && (dev->sequenceNumber !=\n+\t\t\t\t\t\tbi->sequenceNumber)) {\n+\t\t\t\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t\t\t\t  (TSTR\n+\t\t\t\t\t\t   ("yaffs: Allocation block %d was not highest sequence id: block seq = %d, dev seq = %d"\n+\t\t\t\t\t\t    TENDSTR), blk,bi->sequenceNumber,dev->sequenceNumber));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tdev->nFreeChunks += (dev->nChunksPerBlock - c);\n+\t\t\t} else if (tags.chunkId > 0) {\n+\t\t\t\t/* chunkId > 0 so it is a data chunk... */\n+\t\t\t\tunsigned int endpos;\n+\n+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);\n+\t\t\t\tbi->pagesInUse++;\n+\n+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,\n+\t\t\t\t\t\t\t\t      tags.\n+\t\t\t\t\t\t\t\t      objectId,\n+\t\t\t\t\t\t\t\t      YAFFS_OBJECT_TYPE_FILE);\n+\t\t\t\t/* PutChunkIntoFile checks for a clash (two data chunks with\n+\t\t\t\t * the same chunkId).\n+\t\t\t\t */\n+\n+\t\t\t\tif(!in)\n+\t\t\t\t\talloc_failed = 1;\n+\n+\t\t\t\tif(in){\n+\t\t\t\t\tif(!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk,1))\n+\t\t\t\t\t\talloc_failed = 1;\n+\t\t\t\t}\n+\n+\t\t\t\tendpos =\n+\t\t\t\t    (tags.chunkId - 1) * dev->nDataBytesPerChunk +\n+\t\t\t\t    tags.byteCount;\n+\t\t\t\tif (in &&\n+\t\t\t\t    in->variantType == YAFFS_OBJECT_TYPE_FILE\n+\t\t\t\t    && in->variant.fileVariant.scannedFileSize <\n+\t\t\t\t    endpos) {\n+\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t    scannedFileSize = endpos;\n+\t\t\t\t\tif (!dev->useHeaderFileSize) {\n+\t\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t\t    fileSize =\n+\t\t\t\t\t\t    in->variant.fileVariant.\n+\t\t\t\t\t\t    scannedFileSize;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t\t/* T((" %d %d data %d %d\\n",blk,c,tags.objectId,tags.chunkId));   */\n+\t\t\t} else {\n+\t\t\t\t/* chunkId == 0, so it is an ObjectHeader.\n+\t\t\t\t * Thus, we read in the object header and make the object\n+\t\t\t\t */\n+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);\n+\t\t\t\tbi->pagesInUse++;\n+\n+\t\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,\n+\t\t\t\t\t\t\t\tchunkData,\n+\t\t\t\t\t\t\t\tNULL);\n+\n+\t\t\t\toh = (yaffs_ObjectHeader *) chunkData;\n+\n+\t\t\t\tin = yaffs_FindObjectByNumber(dev,\n+\t\t\t\t\t\t\t      tags.objectId);\n+\t\t\t\tif (in && in->variantType != oh->type) {\n+\t\t\t\t\t/* This should not happen, but somehow\n+\t\t\t\t\t * Wev\'e ended up with an objectId that has been reused but not yet\n+\t\t\t\t\t * deleted, and worse still it has changed type. Delete the old object.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tyaffs_DestroyObject(in);\n+\n+\t\t\t\t\tin = 0;\n+\t\t\t\t}\n+\n+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,\n+\t\t\t\t\t\t\t\t      tags.\n+\t\t\t\t\t\t\t\t      objectId,\n+\t\t\t\t\t\t\t\t      oh->type);\n+\n+\t\t\t\tif(!in)\n+\t\t\t\t\talloc_failed = 1;\n+\n+\t\t\t\tif (in && oh->shadowsObject > 0) {\n+\n+\t\t\t\t\tstruct yaffs_ShadowFixerStruct *fixer;\n+\t\t\t\t\tfixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));\n+\t\t\t\t\tif(fixer){\n+\t\t\t\t\t\tfixer-> next = shadowFixerList;\n+\t\t\t\t\t\tshadowFixerList = fixer;\n+\t\t\t\t\t\tfixer->objectId = tags.objectId;\n+\t\t\t\t\t\tfixer->shadowedId = oh->shadowsObject;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\n+\t\t\t\tif (in && in->valid) {\n+\t\t\t\t\t/* We have already filled this one. We have a duplicate and need to resolve it. */\n+\n+\t\t\t\t\tunsigned existingSerial = in->serial;\n+\t\t\t\t\tunsigned newSerial = tags.serialNumber;\n+\n+\t\t\t\t\tif (dev->isYaffs2 ||\n+\t\t\t\t\t    ((existingSerial + 1) & 3) ==\n+\t\t\t\t\t    newSerial) {\n+\t\t\t\t\t\t/* Use new one - destroy the exisiting one */\n+\t\t\t\t\t\tyaffs_DeleteChunk(dev,\n+\t\t\t\t\t\t\t\t  in->hdrChunk,\n+\t\t\t\t\t\t\t\t  1, __LINE__);\n+\t\t\t\t\t\tin->valid = 0;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t/* Use existing - destroy this one. */\n+\t\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1,\n+\t\t\t\t\t\t\t\t  __LINE__);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (in && !in->valid &&\n+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||\n+\t\t\t\t     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {\n+\t\t\t\t\t/* We only load some info, don\'t fiddle with directory structure */\n+\t\t\t\t\tin->valid = 1;\n+\t\t\t\t\tin->variantType = oh->type;\n+\n+\t\t\t\t\tin->yst_mode = oh->yst_mode;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];\n+\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];\n+\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];\n+\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];\n+\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];\n+\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];\n+#else\n+\t\t\t\t\tin->yst_uid = oh->yst_uid;\n+\t\t\t\t\tin->yst_gid = oh->yst_gid;\n+\t\t\t\t\tin->yst_atime = oh->yst_atime;\n+\t\t\t\t\tin->yst_mtime = oh->yst_mtime;\n+\t\t\t\t\tin->yst_ctime = oh->yst_ctime;\n+\t\t\t\t\tin->yst_rdev = oh->yst_rdev;\n+#endif\n+\t\t\t\t\tin->hdrChunk = chunk;\n+\n+\t\t\t\t} else if (in && !in->valid) {\n+\t\t\t\t\t/* we need to load this info */\n+\n+\t\t\t\t\tin->valid = 1;\n+\t\t\t\t\tin->variantType = oh->type;\n+\n+\t\t\t\t\tin->yst_mode = oh->yst_mode;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];\n+\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];\n+\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];\n+\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];\n+\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];\n+\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];\n+#else\n+\t\t\t\t\tin->yst_uid = oh->yst_uid;\n+\t\t\t\t\tin->yst_gid = oh->yst_gid;\n+\t\t\t\t\tin->yst_atime = oh->yst_atime;\n+\t\t\t\t\tin->yst_mtime = oh->yst_mtime;\n+\t\t\t\t\tin->yst_ctime = oh->yst_ctime;\n+\t\t\t\t\tin->yst_rdev = oh->yst_rdev;\n+#endif\n+\t\t\t\t\tin->hdrChunk = chunk;\n+\n+\t\t\t\t\tyaffs_SetObjectName(in, oh->name);\n+\t\t\t\t\tin->dirty = 0;\n+\n+\t\t\t\t\t/* directory stuff...\n+\t\t\t\t\t * hook up to parent\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tparent =\n+\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber\n+\t\t\t\t\t    (dev, oh->parentObjectId,\n+\t\t\t\t\t     YAFFS_OBJECT_TYPE_DIRECTORY);\n+\t\t\t\t\tif (parent->variantType ==\n+\t\t\t\t\t    YAFFS_OBJECT_TYPE_UNKNOWN) {\n+                                                /* Set up as a directory */\n+                                                parent->variantType =\n+                                                    YAFFS_OBJECT_TYPE_DIRECTORY;\n+                                                YINIT_LIST_HEAD(&parent->variant.\n+                                                               directoryVariant.\n+                                                               children);\n+                                        } else if (parent->variantType !=\n+\t\t\t\t\t\t   YAFFS_OBJECT_TYPE_DIRECTORY)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t/* Hoosterman, another problem....\n+\t\t\t\t\t\t * We\'re trying to use a non-directory as a directory\n+\t\t\t\t\t\t */\n+\n+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t\t\t  (TSTR\n+\t\t\t\t\t\t   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."\n+\t\t\t\t\t\t    TENDSTR)));\n+\t\t\t\t\t\tparent = dev->lostNFoundDir;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tyaffs_AddObjectToDirectory(parent, in);\n+\n+\t\t\t\t\tif (0 && (parent == dev->deletedDir ||\n+\t\t\t\t\t\t  parent == dev->unlinkedDir)) {\n+\t\t\t\t\t\tin->deleted = 1;\t/* If it is unlinked at start up then it wants deleting */\n+\t\t\t\t\t\tdev->nDeletedFiles++;\n+\t\t\t\t\t}\n+\t\t\t\t\t/* Note re hardlinks.\n+\t\t\t\t\t * Since we might scan a hardlink before its equivalent object is scanned\n+\t\t\t\t\t * we put them all in a list.\n+\t\t\t\t\t * After scanning is complete, we should have all the objects, so we run through this\n+\t\t\t\t\t * list and fix up all the chains.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tswitch (in->variantType) {\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\t\t\t\t\t/* Todo got a problem */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\t\t\t\t\tif (dev->isYaffs2\n+\t\t\t\t\t\t    && oh->isShrink) {\n+\t\t\t\t\t\t\t/* Prune back the shrunken chunks */\n+\t\t\t\t\t\t\tyaffs_PruneResizedChunks\n+\t\t\t\t\t\t\t    (in, oh->fileSize);\n+\t\t\t\t\t\t\t/* Mark the block as having a shrinkHeader */\n+\t\t\t\t\t\t\tbi->hasShrinkHeader = 1;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (dev->useHeaderFileSize)\n+\n+\t\t\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t\t\t    fileSize =\n+\t\t\t\t\t\t\t    oh->fileSize;\n+\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\t\t\t\t\tin->variant.hardLinkVariant.\n+                                                    equivalentObjectId =\n+                                                    oh->equivalentObjectId;\n+                                                in->hardLinks.next =\n+                                                    (struct ylist_head *)\n+                                                    hardList;\n+                                                hardList = in;\n+                                                break;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\t\t\t\t\t/* Do nothing */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\t\t\t\t\t/* Do nothing */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\t\t\t\t\tin->variant.symLinkVariant.alias =\n+\t\t\t\t\t\t    yaffs_CloneString(oh->alias);\n+\t\t\t\t\t\tif(!in->variant.symLinkVariant.alias)\n+\t\t\t\t\t\t\talloc_failed = 1;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (parent == dev->deletedDir) {\n+\t\t\t\t\t\tyaffs_DestroyObject(in);\n+\t\t\t\t\t\tbi->hasShrinkHeader = 1;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {\n+\t\t\t/* If we got this far while scanning, then the block is fully allocated.*/\n+\t\t\tstate = YAFFS_BLOCK_STATE_FULL;\n+\t\t}\n+\n+\t\tbi->blockState = state;\n+\n+\t\t/* Now let\'s see if it was dirty */\n+\t\tif (bi->pagesInUse == 0 &&\n+\t\t    !bi->hasShrinkHeader &&\n+\t\t    bi->blockState == YAFFS_BLOCK_STATE_FULL) {\n+\t\t\tyaffs_BlockBecameDirty(dev, blk);\n+\t\t}\n+\n+\t}\n+\n+\n+\t/* Ok, we\'ve done all the scanning.\n+\t * Fix up the hard link chains.\n+\t * We should now have scanned all the objects, now it\'s time to add these\n+\t * hardlinks.\n+\t */\n+\n+\tyaffs_HardlinkFixup(dev,hardList);\n+\n+\t/* Handle the unlinked files. Since they were left in an unlinked state we should\n+         * just delete them.\n+         */\n+        {\n+                struct ylist_head *i;\n+                struct ylist_head *n;\n+\n+                yaffs_Object *l;\n+                /* Soft delete all the unlinked files */\n+                ylist_for_each_safe(i, n,\n+                                   &dev->unlinkedDir->variant.directoryVariant.\n+                                   children) {\n+                        if (i) {\n+                                l = ylist_entry(i, yaffs_Object, siblings);\n+                                yaffs_DestroyObject(l);\n+                        }\n+                }\n+\t}\n+\n+\t/* Fix up any shadowed objects */\n+\t{\n+\t\tstruct yaffs_ShadowFixerStruct *fixer;\n+\t\tyaffs_Object *obj;\n+\n+\t\twhile(shadowFixerList){\n+\t\t\tfixer = shadowFixerList;\n+\t\t\tshadowFixerList = fixer->next;\n+\t\t\t/* Complete the rename transaction by deleting the shadowed object\n+\t\t\t * then setting the object header to unshadowed.\n+\t\t\t */\n+\t\t\tobj = yaffs_FindObjectByNumber(dev,fixer->shadowedId);\n+\t\t\tif(obj)\n+\t\t\t\tyaffs_DestroyObject(obj);\n+\n+\t\t\tobj = yaffs_FindObjectByNumber(dev,fixer->objectId);\n+\t\t\tif(obj){\n+\t\t\t\tyaffs_UpdateObjectHeader(obj,NULL,1,0,0);\n+\t\t\t}\n+\n+\t\t\tYFREE(fixer);\n+\t\t}\n+\t}\n+\n+\tyaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);\n+\n+\tif(alloc_failed){\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tT(YAFFS_TRACE_SCAN, (TSTR("yaffs_Scan ends" TENDSTR)));\n+\n+\n+\treturn YAFFS_OK;\n+}\n+\n+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)\n+{\n+\t__u8 *chunkData;\n+\tyaffs_ObjectHeader *oh;\n+\tyaffs_Device *dev = in->myDev;\n+\tyaffs_ExtendedTags tags;\n+\tint result;\n+\tint alloc_failed = 0;\n+\n+\tif(!in)\n+\t\treturn;\n+\n+#if 0\n+\tT(YAFFS_TRACE_SCAN,(TSTR("details for object %d %s loaded" TENDSTR),\n+\t\tin->objectId,\n+\t\tin->lazyLoaded ? "not yet" : "already"));\n+#endif\n+\n+\tif(in->lazyLoaded && in->hdrChunk > 0){\n+\t\tin->lazyLoaded = 0;\n+\t\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev,in->hdrChunk,chunkData,&tags);\n+\t\toh = (yaffs_ObjectHeader *) chunkData;\n+\n+\t\tin->yst_mode = oh->yst_mode;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\tin->win_atime[0] = oh->win_atime[0];\n+\t\tin->win_ctime[0] = oh->win_ctime[0];\n+\t\tin->win_mtime[0] = oh->win_mtime[0];\n+\t\tin->win_atime[1] = oh->win_atime[1];\n+\t\tin->win_ctime[1] = oh->win_ctime[1];\n+\t\tin->win_mtime[1] = oh->win_mtime[1];\n+#else\n+\t\tin->yst_uid = oh->yst_uid;\n+\t\tin->yst_gid = oh->yst_gid;\n+\t\tin->yst_atime = oh->yst_atime;\n+\t\tin->yst_mtime = oh->yst_mtime;\n+\t\tin->yst_ctime = oh->yst_ctime;\n+\t\tin->yst_rdev = oh->yst_rdev;\n+\n+#endif\n+\t\tyaffs_SetObjectName(in, oh->name);\n+\n+\t\tif(in->variantType == YAFFS_OBJECT_TYPE_SYMLINK){\n+\t\t\t in->variant.symLinkVariant.alias =\n+\t\t\t\t\t\t    yaffs_CloneString(oh->alias);\n+\t\t\tif(!in->variant.symLinkVariant.alias)\n+\t\t\t\talloc_failed = 1; /* Not returned to caller */\n+\t\t}\n+\n+\t\tyaffs_ReleaseTempBuffer(dev,chunkData, __LINE__);\n+\t}\n+}\n+\n+static int yaffs_ScanBackwards(yaffs_Device * dev)\n+{\n+\tyaffs_ExtendedTags tags;\n+\tint blk;\n+\tint blockIterator;\n+\tint startIterator;\n+\tint endIterator;\n+\tint nBlocksToScan = 0;\n+\n+\tint chunk;\n+\tint result;\n+\tint c;\n+\tint deleted;\n+\tyaffs_BlockState state;\n+\tyaffs_Object *hardList = NULL;\n+\tyaffs_BlockInfo *bi;\n+\t__u32 sequenceNumber;\n+\tyaffs_ObjectHeader *oh;\n+\tyaffs_Object *in;\n+\tyaffs_Object *parent;\n+\tint nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;\n+\tint itsUnlinked;\n+\t__u8 *chunkData;\n+\n+\tint fileSize;\n+\tint isShrink;\n+\tint foundChunksInBlock;\n+\tint equivalentObjectId;\n+\tint alloc_failed = 0;\n+\n+\n+\tyaffs_BlockIndex *blockIndex = NULL;\n+\tint altBlockIndex = 0;\n+\n+\tif (!dev->isYaffs2) {\n+\t\tT(YAFFS_TRACE_SCAN,\n+\t\t  (TSTR("yaffs_ScanBackwards is only for YAFFS2!" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tT(YAFFS_TRACE_SCAN,\n+\t  (TSTR\n+\t   ("yaffs_ScanBackwards starts  intstartblk %d intendblk %d..."\n+\t    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));\n+\n+\n+\tdev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;\n+\n+\tblockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));\n+\n+\tif(!blockIndex) {\n+\t\tblockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));\n+\t\taltBlockIndex = 1;\n+\t}\n+\n+\tif(!blockIndex) {\n+\t\tT(YAFFS_TRACE_SCAN,\n+\t\t  (TSTR("yaffs_Scan() could not allocate block index!" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tdev->blocksInCheckpoint = 0;\n+\n+\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);\n+\n+\t/* Scan all the blocks to determine their state */\n+\tfor (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {\n+\t\tbi = yaffs_GetBlockInfo(dev, blk);\n+\t\tyaffs_ClearChunkBits(dev, blk);\n+\t\tbi->pagesInUse = 0;\n+\t\tbi->softDeletions = 0;\n+\n+\t\tyaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);\n+\n+\t\tbi->blockState = state;\n+\t\tbi->sequenceNumber = sequenceNumber;\n+\n+\t\tif(bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)\n+\t\t\tbi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;\n+\n+\t\tT(YAFFS_TRACE_SCAN_DEBUG,\n+\t\t  (TSTR("Block scanning block %d state %d seq %d" TENDSTR), blk,\n+\t\t   state, sequenceNumber));\n+\n+\n+\t\tif(state == YAFFS_BLOCK_STATE_CHECKPOINT){\n+\t\t\tdev->blocksInCheckpoint++;\n+\n+\t\t} else if (state == YAFFS_BLOCK_STATE_DEAD) {\n+\t\t\tT(YAFFS_TRACE_BAD_BLOCKS,\n+\t\t\t  (TSTR("block %d is bad" TENDSTR), blk));\n+\t\t} else if (state == YAFFS_BLOCK_STATE_EMPTY) {\n+\t\t\tT(YAFFS_TRACE_SCAN_DEBUG,\n+\t\t\t  (TSTR("Block empty " TENDSTR)));\n+\t\t\tdev->nErasedBlocks++;\n+\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;\n+\t\t} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {\n+\n+\t\t\t/* Determine the highest sequence number */\n+\t\t\tif (dev->isYaffs2 &&\n+\t\t\t    sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&\n+\t\t\t    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {\n+\n+\t\t\t\tblockIndex[nBlocksToScan].seq = sequenceNumber;\n+\t\t\t\tblockIndex[nBlocksToScan].block = blk;\n+\n+\t\t\t\tnBlocksToScan++;\n+\n+\t\t\t\tif (sequenceNumber >= dev->sequenceNumber) {\n+\t\t\t\t\tdev->sequenceNumber = sequenceNumber;\n+\t\t\t\t}\n+\t\t\t} else if (dev->isYaffs2) {\n+\t\t\t\t/* TODO: Nasty sequence number! */\n+\t\t\t\tT(YAFFS_TRACE_SCAN,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("Block scanning block %d has bad sequence number %d"\n+\t\t\t\t    TENDSTR), blk, sequenceNumber));\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tT(YAFFS_TRACE_SCAN,\n+\t(TSTR("%d blocks to be sorted..." TENDSTR), nBlocksToScan));\n+\n+\n+\n+\tYYIELD();\n+\n+\t/* Sort the blocks */\n+#ifndef CONFIG_YAFFS_USE_OWN_SORT\n+\t{\n+\t\t/* Use qsort now. */\n+\t\tyaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);\n+\t}\n+#else\n+\t{\n+\t \t/* Dungy old bubble sort... */\n+\n+\t\tyaffs_BlockIndex temp;\n+\t\tint i;\n+\t\tint j;\n+\n+\t\tfor (i = 0; i < nBlocksToScan; i++)\n+\t\t\tfor (j = i + 1; j < nBlocksToScan; j++)\n+\t\t\t\tif (blockIndex[i].seq > blockIndex[j].seq) {\n+\t\t\t\t\ttemp = blockIndex[j];\n+\t\t\t\t\tblockIndex[j] = blockIndex[i];\n+\t\t\t\t\tblockIndex[i] = temp;\n+\t\t\t\t}\n+\t}\n+#endif\n+\n+\tYYIELD();\n+\n+    \tT(YAFFS_TRACE_SCAN, (TSTR("...done" TENDSTR)));\n+\n+\t/* Now scan the blocks looking at the data. */\n+\tstartIterator = 0;\n+\tendIterator = nBlocksToScan - 1;\n+\tT(YAFFS_TRACE_SCAN_DEBUG,\n+\t  (TSTR("%d blocks to be scanned" TENDSTR), nBlocksToScan));\n+\n+\t/* For each block.... backwards */\n+\tfor (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;\n+\t     blockIterator--) {\n+\t        /* Cooperative multitasking! This loop can run for so\n+\t\t   long that watchdog timers expire. */\n+\t        YYIELD();\n+\n+\t\t/* get the block to scan in the correct order */\n+\t\tblk = blockIndex[blockIterator].block;\n+\n+\t\tbi = yaffs_GetBlockInfo(dev, blk);\n+\n+\n+\t\tstate = bi->blockState;\n+\n+\t\tdeleted = 0;\n+\n+\t\t/* For each chunk in each block that needs scanning.... */\n+\t\tfoundChunksInBlock = 0;\n+\t\tfor (c = dev->nChunksPerBlock - 1;\n+\t\t     !alloc_failed && c >= 0 &&\n+\t\t     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||\n+\t\t      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {\n+\t\t\t/* Scan backwards...\n+\t\t\t * Read the tags and decide what to do\n+\t\t\t */\n+\n+\t\t\tchunk = blk * dev->nChunksPerBlock + c;\n+\n+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,\n+\t\t\t\t\t\t\t&tags);\n+\n+\t\t\t/* Let\'s have a good look at this chunk... */\n+\n+\t\t\tif (!tags.chunkUsed) {\n+\t\t\t\t/* An unassigned chunk in the block.\n+\t\t\t\t * If there are used chunks after this one, then\n+\t\t\t\t * it is a chunk that was skipped due to failing the erased\n+\t\t\t\t * check. Just skip it so that it can be deleted.\n+\t\t\t\t * But, more typically, We get here when this is an unallocated\n+\t\t\t\t * chunk and his means that either the block is empty or\n+\t\t\t\t * this is the one being allocated from\n+\t\t\t\t */\n+\n+\t\t\t\tif(foundChunksInBlock)\n+\t\t\t\t{\n+\t\t\t\t\t/* This is a chunk that was skipped due to failing the erased check */\n+\n+\t\t\t\t} else if (c == 0) {\n+\t\t\t\t\t/* We\'re looking at the first chunk in the block so the block is unused */\n+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_EMPTY;\n+\t\t\t\t\tdev->nErasedBlocks++;\n+\t\t\t\t} else {\n+\t\t\t\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||\n+\t\t\t\t\t    state == YAFFS_BLOCK_STATE_ALLOCATING) {\n+\t\t\t\t\t    \tif(dev->sequenceNumber == bi->sequenceNumber) {\n+\t\t\t\t\t\t\t/* this is the block being allocated from */\n+\n+\t\t\t\t\t\t\tT(YAFFS_TRACE_SCAN,\n+\t\t\t\t\t\t\t  (TSTR\n+\t\t\t\t\t\t\t   (" Allocating from %d %d"\n+\t\t\t\t\t\t\t    TENDSTR), blk, c));\n+\n+\t\t\t\t\t\t\tstate = YAFFS_BLOCK_STATE_ALLOCATING;\n+\t\t\t\t\t\t\tdev->allocationBlock = blk;\n+\t\t\t\t\t\t\tdev->allocationPage = c;\n+\t\t\t\t\t\t\tdev->allocationBlockFinder = blk;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t/* This is a partially written block that is not\n+\t\t\t\t\t\t\t * the current allocation block. This block must have\n+\t\t\t\t\t\t\t * had a write failure, so set up for retirement.\n+\t\t\t\t\t\t\t */\n+\n+\t\t\t\t\t\t\t bi->needsRetiring = 1;\n+\t\t\t\t\t\t\t bi->gcPrioritise = 1;\n+\n+\t\t\t\t\t\t\t T(YAFFS_TRACE_ALWAYS,\n+\t\t\t\t\t\t\t (TSTR("Partially written block %d being set for retirement" TENDSTR),\n+\t\t\t\t\t\t\t blk));\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\n+\t\t\t\tdev->nFreeChunks++;\n+\n+\t\t\t} else if (tags.chunkId > 0) {\n+\t\t\t\t/* chunkId > 0 so it is a data chunk... */\n+\t\t\t\tunsigned int endpos;\n+\t\t\t\t__u32 chunkBase =\n+\t\t\t\t    (tags.chunkId - 1) * dev->nDataBytesPerChunk;\n+\n+\t\t\t\tfoundChunksInBlock = 1;\n+\n+\n+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);\n+\t\t\t\tbi->pagesInUse++;\n+\n+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,\n+\t\t\t\t\t\t\t\t      tags.\n+\t\t\t\t\t\t\t\t      objectId,\n+\t\t\t\t\t\t\t\t      YAFFS_OBJECT_TYPE_FILE);\n+\t\t\t\tif(!in){\n+\t\t\t\t\t/* Out of memory */\n+\t\t\t\t\talloc_failed = 1;\n+\t\t\t\t}\n+\n+\t\t\t\tif (in &&\n+\t\t\t\t    in->variantType == YAFFS_OBJECT_TYPE_FILE\n+\t\t\t\t    && chunkBase <\n+\t\t\t\t    in->variant.fileVariant.shrinkSize) {\n+\t\t\t\t\t/* This has not been invalidated by a resize */\n+\t\t\t\t\tif(!yaffs_PutChunkIntoFile(in, tags.chunkId,\n+\t\t\t\t\t\t\t       chunk, -1)){\n+\t\t\t\t\t\talloc_failed = 1;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* File size is calculated by looking at the data chunks if we have not\n+\t\t\t\t\t * seen an object header yet. Stop this practice once we find an object header.\n+\t\t\t\t\t */\n+\t\t\t\t\tendpos =\n+\t\t\t\t\t    (tags.chunkId -\n+\t\t\t\t\t     1) * dev->nDataBytesPerChunk +\n+\t\t\t\t\t    tags.byteCount;\n+\n+\t\t\t\t\tif (!in->valid &&\t/* have not got an object header yet */\n+\t\t\t\t\t    in->variant.fileVariant.\n+\t\t\t\t\t    scannedFileSize < endpos) {\n+\t\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t\t    scannedFileSize = endpos;\n+\t\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t\t    fileSize =\n+\t\t\t\t\t\t    in->variant.fileVariant.\n+\t\t\t\t\t\t    scannedFileSize;\n+\t\t\t\t\t}\n+\n+\t\t\t\t} else if(in) {\n+\t\t\t\t\t/* This chunk has been invalidated by a resize, so delete */\n+\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);\n+\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t/* chunkId == 0, so it is an ObjectHeader.\n+\t\t\t\t * Thus, we read in the object header and make the object\n+\t\t\t\t */\n+\t\t\t\tfoundChunksInBlock = 1;\n+\n+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);\n+\t\t\t\tbi->pagesInUse++;\n+\n+\t\t\t\toh = NULL;\n+\t\t\t\tin = NULL;\n+\n+\t\t\t\tif (tags.extraHeaderInfoAvailable) {\n+\t\t\t\t\tin = yaffs_FindOrCreateObjectByNumber\n+\t\t\t\t\t    (dev, tags.objectId,\n+\t\t\t\t\t     tags.extraObjectType);\n+\t\t\t\t}\n+\n+\t\t\t\tif (!in ||\n+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD\n+\t\t\t\t    !in->valid ||\n+#endif\n+\t\t\t\t    tags.extraShadows ||\n+\t\t\t\t    (!in->valid &&\n+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||\n+\t\t\t\t     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))\n+\t\t\t\t    ) {\n+\n+\t\t\t\t\t/* If we don\'t have  valid info then we need to read the chunk\n+\t\t\t\t\t * TODO In future we can probably defer reading the chunk and\n+\t\t\t\t\t * living with invalid data until needed.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev,\n+\t\t\t\t\t\t\t\t\tchunk,\n+\t\t\t\t\t\t\t\t\tchunkData,\n+\t\t\t\t\t\t\t\t\tNULL);\n+\n+\t\t\t\t\toh = (yaffs_ObjectHeader *) chunkData;\n+\n+\t\t\t\t\tif(dev->inbandTags){\n+\t\t\t\t\t\t/* Fix up the header if they got corrupted by inband tags */\n+\t\t\t\t\t\toh->shadowsObject = oh->inbandShadowsObject;\n+\t\t\t\t\t\toh->isShrink = oh->inbandIsShrink;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tif (!in)\n+\t\t\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);\n+\n+\t\t\t\t}\n+\n+\t\t\t\tif (!in) {\n+\t\t\t\t\t/* TODO Hoosterman we have a problem! */\n+\t\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t\t  (TSTR\n+\t\t\t\t\t   ("yaffs tragedy: Could not make object for object  %d at chunk %d during scan"\n+\t\t\t\t\t    TENDSTR), tags.objectId, chunk));\n+\n+\t\t\t\t}\n+\n+\t\t\t\tif (in->valid) {\n+\t\t\t\t\t/* We have already filled this one.\n+\t\t\t\t\t * We have a duplicate that will be discarded, but\n+\t\t\t\t\t * we first have to suck out resize info if it is a file.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tif ((in->variantType == YAFFS_OBJECT_TYPE_FILE) &&\n+\t\t\t\t\t     ((oh &&\n+\t\t\t\t\t       oh-> type == YAFFS_OBJECT_TYPE_FILE)||\n+\t\t\t\t\t      (tags.extraHeaderInfoAvailable  &&\n+\t\t\t\t\t       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))\n+\t\t\t\t\t    ) {\n+\t\t\t\t\t\t__u32 thisSize =\n+\t\t\t\t\t\t    (oh) ? oh->fileSize : tags.\n+\t\t\t\t\t\t    extraFileLength;\n+\t\t\t\t\t\t__u32 parentObjectId =\n+\t\t\t\t\t\t    (oh) ? oh->\n+\t\t\t\t\t\t    parentObjectId : tags.\n+\t\t\t\t\t\t    extraParentObjectId;\n+\t\t\t\t\t\tunsigned isShrink =\n+\t\t\t\t\t\t    (oh) ? oh->isShrink : tags.\n+\t\t\t\t\t\t    extraIsShrinkHeader;\n+\n+\t\t\t\t\t\t/* If it is deleted (unlinked at start also means deleted)\n+\t\t\t\t\t\t * we treat the file size as being zeroed at this point.\n+\t\t\t\t\t\t */\n+\t\t\t\t\t\tif (parentObjectId ==\n+\t\t\t\t\t\t    YAFFS_OBJECTID_DELETED\n+\t\t\t\t\t\t    || parentObjectId ==\n+\t\t\t\t\t\t    YAFFS_OBJECTID_UNLINKED) {\n+\t\t\t\t\t\t\tthisSize = 0;\n+\t\t\t\t\t\t\tisShrink = 1;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (isShrink &&\n+\t\t\t\t\t\t    in->variant.fileVariant.\n+\t\t\t\t\t\t    shrinkSize > thisSize) {\n+\t\t\t\t\t\t\tin->variant.fileVariant.\n+\t\t\t\t\t\t\t    shrinkSize =\n+\t\t\t\t\t\t\t    thisSize;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (isShrink) {\n+\t\t\t\t\t\t\tbi->hasShrinkHeader = 1;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t}\n+\t\t\t\t\t/* Use existing - destroy this one. */\n+\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);\n+\n+\t\t\t\t}\n+\n+\t\t\t\tif (!in->valid &&\n+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||\n+\t\t\t\t     tags.objectId ==\n+\t\t\t\t     YAFFS_OBJECTID_LOSTNFOUND)) {\n+\t\t\t\t\t/* We only load some info, don\'t fiddle with directory structure */\n+\t\t\t\t\tin->valid = 1;\n+\n+\t\t\t\t\tif(oh) {\n+\t\t\t\t\t\tin->variantType = oh->type;\n+\n+\t\t\t\t\t\tin->yst_mode = oh->yst_mode;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];\n+\t\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];\n+\t\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];\n+\t\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];\n+\t\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];\n+\t\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];\n+#else\n+\t\t\t\t\t\tin->yst_uid = oh->yst_uid;\n+\t\t\t\t\t\tin->yst_gid = oh->yst_gid;\n+\t\t\t\t\t\tin->yst_atime = oh->yst_atime;\n+\t\t\t\t\t\tin->yst_mtime = oh->yst_mtime;\n+\t\t\t\t\t\tin->yst_ctime = oh->yst_ctime;\n+\t\t\t\t\t\tin->yst_rdev = oh->yst_rdev;\n+\n+#endif\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tin->variantType = tags.extraObjectType;\n+\t\t\t\t\t\tin->lazyLoaded = 1;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tin->hdrChunk = chunk;\n+\n+\t\t\t\t} else if (!in->valid) {\n+\t\t\t\t\t/* we need to load this info */\n+\n+\t\t\t\t\tin->valid = 1;\n+\t\t\t\t\tin->hdrChunk = chunk;\n+\n+\t\t\t\t\tif(oh) {\n+\t\t\t\t\t\tin->variantType = oh->type;\n+\n+\t\t\t\t\t\tin->yst_mode = oh->yst_mode;\n+#ifdef CONFIG_YAFFS_WINCE\n+\t\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];\n+\t\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];\n+\t\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];\n+\t\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];\n+\t\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];\n+\t\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];\n+#else\n+\t\t\t\t\t\tin->yst_uid = oh->yst_uid;\n+\t\t\t\t\t\tin->yst_gid = oh->yst_gid;\n+\t\t\t\t\t\tin->yst_atime = oh->yst_atime;\n+\t\t\t\t\t\tin->yst_mtime = oh->yst_mtime;\n+\t\t\t\t\t\tin->yst_ctime = oh->yst_ctime;\n+\t\t\t\t\t\tin->yst_rdev = oh->yst_rdev;\n+#endif\n+\n+\t\t\t\t\t\tif (oh->shadowsObject > 0)\n+\t\t\t\t\t\t\tyaffs_HandleShadowedObject(dev,\n+\t\t\t\t\t\t\t\t\t   oh->\n+\t\t\t\t\t\t\t\t\t   shadowsObject,\n+\t\t\t\t\t\t\t\t\t   1);\n+\n+\n+\t\t\t\t\t\tyaffs_SetObjectName(in, oh->name);\n+\t\t\t\t\t\tparent =\n+\t\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber\n+\t\t\t\t\t    \t\t(dev, oh->parentObjectId,\n+\t\t\t\t\t     \t\t YAFFS_OBJECT_TYPE_DIRECTORY);\n+\n+\t\t\t\t\t\t fileSize = oh->fileSize;\n+ \t\t\t\t\t\t isShrink = oh->isShrink;\n+\t\t\t\t\t\t equivalentObjectId = oh->equivalentObjectId;\n+\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tin->variantType = tags.extraObjectType;\n+\t\t\t\t\t\tparent =\n+\t\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber\n+\t\t\t\t\t    \t\t(dev, tags.extraParentObjectId,\n+\t\t\t\t\t     \t\t YAFFS_OBJECT_TYPE_DIRECTORY);\n+\t\t\t\t\t\t fileSize = tags.extraFileLength;\n+\t\t\t\t\t\t isShrink = tags.extraIsShrinkHeader;\n+\t\t\t\t\t\t equivalentObjectId = tags.extraEquivalentObjectId;\n+\t\t\t\t\t\tin->lazyLoaded = 1;\n+\n+\t\t\t\t\t}\n+\t\t\t\t\tin->dirty = 0;\n+\n+\t\t\t\t\t/* directory stuff...\n+\t\t\t\t\t * hook up to parent\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tif (parent->variantType ==\n+\t\t\t\t\t    YAFFS_OBJECT_TYPE_UNKNOWN) {\n+                                                /* Set up as a directory */\n+                                                parent->variantType =\n+                                                    YAFFS_OBJECT_TYPE_DIRECTORY;\n+                                                YINIT_LIST_HEAD(&parent->variant.\n+                                                               directoryVariant.\n+                                                               children);\n+                                        } else if (parent->variantType !=\n+\t\t\t\t\t\t   YAFFS_OBJECT_TYPE_DIRECTORY)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t/* Hoosterman, another problem....\n+\t\t\t\t\t\t * We\'re trying to use a non-directory as a directory\n+\t\t\t\t\t\t */\n+\n+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t\t\t  (TSTR\n+\t\t\t\t\t\t   ("yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found."\n+\t\t\t\t\t\t    TENDSTR)));\n+\t\t\t\t\t\tparent = dev->lostNFoundDir;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tyaffs_AddObjectToDirectory(parent, in);\n+\n+\t\t\t\t\titsUnlinked = (parent == dev->deletedDir) ||\n+\t\t\t\t\t\t      (parent == dev->unlinkedDir);\n+\n+\t\t\t\t\tif (isShrink) {\n+\t\t\t\t\t\t/* Mark the block as having a shrinkHeader */\n+\t\t\t\t\t\tbi->hasShrinkHeader = 1;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t/* Note re hardlinks.\n+\t\t\t\t\t * Since we might scan a hardlink before its equivalent object is scanned\n+\t\t\t\t\t * we put them all in a list.\n+\t\t\t\t\t * After scanning is complete, we should have all the objects, so we run\n+\t\t\t\t\t * through this list and fix up all the chains.\n+\t\t\t\t\t */\n+\n+\t\t\t\t\tswitch (in->variantType) {\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:\n+\t\t\t\t\t\t/* Todo got a problem */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_FILE:\n+\n+\t\t\t\t\t\tif (in->variant.fileVariant.\n+\t\t\t\t\t\t    scannedFileSize < fileSize) {\n+\t\t\t\t\t\t\t/* This covers the case where the file size is greater\n+\t\t\t\t\t\t\t * than where the data is\n+\t\t\t\t\t\t\t * This will happen if the file is resized to be larger\n+\t\t\t\t\t\t\t * than its current data extents.\n+\t\t\t\t\t\t\t */\n+\t\t\t\t\t\t\tin->variant.fileVariant.fileSize = fileSize;\n+\t\t\t\t\t\t\tin->variant.fileVariant.scannedFileSize =\n+\t\t\t\t\t\t\t    in->variant.fileVariant.fileSize;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tif (isShrink &&\n+\t\t\t\t\t\t    in->variant.fileVariant.shrinkSize > fileSize) {\n+\t\t\t\t\t\t\tin->variant.fileVariant.shrinkSize = fileSize;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\t\t\t\t\tif(!itsUnlinked) {\n+                                                  in->variant.hardLinkVariant.equivalentObjectId =\n+                                                    equivalentObjectId;\n+                                                  in->hardLinks.next =\n+                                                    (struct ylist_head *) hardList;\n+                                                  hardList = in;\n+                                                }\n+                                                break;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\t\t\t\t\t/* Do nothing */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\t\t\t\t\t/* Do nothing */\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\t\t\t\t\tif(oh){\n+\t\t\t\t\t\t   in->variant.symLinkVariant.alias =\n+\t\t\t\t\t\t    yaffs_CloneString(oh->\n+\t\t\t\t\t\t\t\t      alias);\n+\t\t\t\t\t\t   if(!in->variant.symLinkVariant.alias)\n+\t\t\t\t\t\t   \talloc_failed = 1;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\t\t} /* End of scanning for each chunk */\n+\n+\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {\n+\t\t\t/* If we got this far while scanning, then the block is fully allocated. */\n+\t\t\tstate = YAFFS_BLOCK_STATE_FULL;\n+\t\t}\n+\n+\t\tbi->blockState = state;\n+\n+\t\t/* Now let\'s see if it was dirty */\n+\t\tif (bi->pagesInUse == 0 &&\n+\t\t    !bi->hasShrinkHeader &&\n+\t\t    bi->blockState == YAFFS_BLOCK_STATE_FULL) {\n+\t\t\tyaffs_BlockBecameDirty(dev, blk);\n+\t\t}\n+\n+\t}\n+\n+\tif (altBlockIndex)\n+\t\tYFREE_ALT(blockIndex);\n+\telse\n+\t\tYFREE(blockIndex);\n+\n+\t/* Ok, we\'ve done all the scanning.\n+\t * Fix up the hard link chains.\n+\t * We should now have scanned all the objects, now it\'s time to add these\n+\t * hardlinks.\n+\t */\n+\tyaffs_HardlinkFixup(dev,hardList);\n+\n+\n+\t/*\n+        *  Sort out state of unlinked and deleted objects.\n+        */\n+        {\n+                struct ylist_head *i;\n+                struct ylist_head *n;\n+\n+                yaffs_Object *l;\n+\n+                /* Soft delete all the unlinked files */\n+                ylist_for_each_safe(i, n,\n+                                   &dev->unlinkedDir->variant.directoryVariant.\n+                                   children) {\n+                        if (i) {\n+                                l = ylist_entry(i, yaffs_Object, siblings);\n+                                yaffs_DestroyObject(l);\n+                        }\n+                }\n+\n+                /* Soft delete all the deletedDir files */\n+                ylist_for_each_safe(i, n,\n+                                   &dev->deletedDir->variant.directoryVariant.\n+                                   children) {\n+                        if (i) {\n+                                l = ylist_entry(i, yaffs_Object, siblings);\n+                                yaffs_DestroyObject(l);\n+\n+                        }\n+\t\t}\n+\t}\n+\n+\tyaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);\n+\n+\tif(alloc_failed){\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tT(YAFFS_TRACE_SCAN, (TSTR("yaffs_ScanBackwards ends" TENDSTR)));\n+\n+\treturn YAFFS_OK;\n+}\n+\n+/*------------------------------  Directory Functions ----------------------------- */\n+\n+static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj)\n+{\n+\tyaffs_Device *dev = obj->myDev;\n+\n+        if(dev && dev->removeObjectCallback)\n+                dev->removeObjectCallback(obj);\n+\n+        ylist_del_init(&obj->siblings);\n+        obj->parent = NULL;\n+}\n+\n+\n+static void yaffs_AddObjectToDirectory(yaffs_Object * directory,\n+\t\t\t\t       yaffs_Object * obj)\n+{\n+\n+\tif (!directory) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: Trying to add an object to a null pointer directory"\n+\t\t    TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\tif (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: Trying to add an object to a non-directory"\n+\t\t    TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\n+        if (obj->siblings.prev == NULL) {\n+                /* Not initialised */\n+                YINIT_LIST_HEAD(&obj->siblings);\n+\n+        } else if (!ylist_empty(&obj->siblings)) {\n+                /* If it is holed up somewhere else, un hook it */\n+                yaffs_RemoveObjectFromDirectory(obj);\n+        }\n+        /* Now add it */\n+        ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);\n+        obj->parent = directory;\n+\n+        if (directory == obj->myDev->unlinkedDir\n+\t    || directory == obj->myDev->deletedDir) {\n+\t\tobj->unlinked = 1;\n+\t\tobj->myDev->nUnlinkedFiles++;\n+\t\tobj->renameAllowed = 0;\n+\t}\n+}\n+\n+yaffs_Object *yaffs_FindObjectByName(yaffs_Object * directory,\n+\t\t\t\t     const YCHAR * name)\n+{\n+        int sum;\n+\n+        struct ylist_head *i;\n+        YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];\n+\n+        yaffs_Object *l;\n+\n+\tif (!name) {\n+\t\treturn NULL;\n+\t}\n+\n+\tif (!directory) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: yaffs_FindObjectByName: null pointer directory"\n+\t\t    TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\tif (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\n+        sum = yaffs_CalcNameSum(name);\n+\n+        ylist_for_each(i, &directory->variant.directoryVariant.children) {\n+                if (i) {\n+                        l = ylist_entry(i, yaffs_Object, siblings);\n+\n+                        yaffs_CheckObjectDetailsLoaded(l);\n+\n+\t\t\t/* Special case for lost-n-found */\n+\t\t\tif (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {\n+\t\t\t\tif (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0) {\n+\t\t\t\t\treturn l;\n+\t\t\t\t}\n+\t\t\t} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0){\n+\t\t\t\t/* LostnFound chunk called Objxxx\n+\t\t\t\t * Do a real check\n+\t\t\t\t */\n+\t\t\t\tyaffs_GetObjectName(l, buffer,\n+\t\t\t\t\t\t    YAFFS_MAX_NAME_LENGTH);\n+\t\t\t\tif (yaffs_strncmp(name, buffer,YAFFS_MAX_NAME_LENGTH) == 0) {\n+\t\t\t\t\treturn l;\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+\n+#if 0\n+int yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,\n+                                   int (*fn) (yaffs_Object *))\n+{\n+        struct ylist_head *i;\n+        yaffs_Object *l;\n+\n+        if (!theDir) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: yaffs_FindObjectByName: null pointer directory"\n+\t\t    TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\tif (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("tragedy: yaffs_FindObjectByName: non-directory" TENDSTR)));\n+                YBUG();\n+        }\n+\n+        ylist_for_each(i, &theDir->variant.directoryVariant.children) {\n+                if (i) {\n+                        l = ylist_entry(i, yaffs_Object, siblings);\n+                        if (l && !fn(l)) {\n+                                return YAFFS_FAIL;\n+                        }\n+\t\t}\n+\t}\n+\n+\treturn YAFFS_OK;\n+\n+}\n+#endif\n+\n+/* GetEquivalentObject dereferences any hard links to get to the\n+ * actual object.\n+ */\n+\n+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj)\n+{\n+\tif (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {\n+\t\t/* We want the object id of the equivalent object, not this one */\n+\t\tobj = obj->variant.hardLinkVariant.equivalentObject;\n+\t\tyaffs_CheckObjectDetailsLoaded(obj);\n+\t}\n+\treturn obj;\n+\n+}\n+\n+int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize)\n+{\n+\tmemset(name, 0, buffSize * sizeof(YCHAR));\n+\n+\tyaffs_CheckObjectDetailsLoaded(obj);\n+\n+\tif (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {\n+\t\tyaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);\n+\t} else if (obj->hdrChunk <= 0) {\n+\t\tYCHAR locName[20];\n+\t\t/* make up a name */\n+\t\tyaffs_sprintf(locName, _Y("%s%d"), YAFFS_LOSTNFOUND_PREFIX,\n+\t\t\t      obj->objectId);\n+\t\tyaffs_strncpy(name, locName, buffSize - 1);\n+\n+\t}\n+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM\n+\telse if (obj->shortName[0]) {\n+\t\tyaffs_strcpy(name, obj->shortName);\n+\t}\n+#endif\n+\telse {\n+\t\tint result;\n+\t\t__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);\n+\n+\t\tyaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;\n+\n+\t\tmemset(buffer, 0, obj->myDev->nDataBytesPerChunk);\n+\n+\t\tif (obj->hdrChunk > 0) {\n+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,\n+\t\t\t\t\t\t\tobj->hdrChunk, buffer,\n+\t\t\t\t\t\t\tNULL);\n+\t\t}\n+\t\tyaffs_strncpy(name, oh->name, buffSize - 1);\n+\n+\t\tyaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);\n+\t}\n+\n+\treturn yaffs_strlen(name);\n+}\n+\n+int yaffs_GetObjectFileLength(yaffs_Object * obj)\n+{\n+\n+\t/* Dereference any hard linking */\n+\tobj = yaffs_GetEquivalentObject(obj);\n+\n+\tif (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {\n+\t\treturn obj->variant.fileVariant.fileSize;\n+\t}\n+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {\n+\t\treturn yaffs_strlen(obj->variant.symLinkVariant.alias);\n+\t} else {\n+\t\t/* Only a directory should drop through to here */\n+\t\treturn obj->myDev->nDataBytesPerChunk;\n+\t}\n+}\n+\n+int yaffs_GetObjectLinkCount(yaffs_Object * obj)\n+{\n+        int count = 0;\n+        struct ylist_head *i;\n+\n+        if (!obj->unlinked) {\n+                count++;        /* the object itself */\n+        }\n+        ylist_for_each(i, &obj->hardLinks) {\n+                count++;        /* add the hard links; */\n+        }\n+        return count;\n+\n+}\n+\n+int yaffs_GetObjectInode(yaffs_Object * obj)\n+{\n+\tobj = yaffs_GetEquivalentObject(obj);\n+\n+\treturn obj->objectId;\n+}\n+\n+unsigned yaffs_GetObjectType(yaffs_Object * obj)\n+{\n+\tobj = yaffs_GetEquivalentObject(obj);\n+\n+\tswitch (obj->variantType) {\n+\tcase YAFFS_OBJECT_TYPE_FILE:\n+\t\treturn DT_REG;\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:\n+\t\treturn DT_DIR;\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SYMLINK:\n+\t\treturn DT_LNK;\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_HARDLINK:\n+\t\treturn DT_REG;\n+\t\tbreak;\n+\tcase YAFFS_OBJECT_TYPE_SPECIAL:\n+\t\tif (S_ISFIFO(obj->yst_mode))\n+\t\t\treturn DT_FIFO;\n+\t\tif (S_ISCHR(obj->yst_mode))\n+\t\t\treturn DT_CHR;\n+\t\tif (S_ISBLK(obj->yst_mode))\n+\t\t\treturn DT_BLK;\n+\t\tif (S_ISSOCK(obj->yst_mode))\n+\t\t\treturn DT_SOCK;\n+\tdefault:\n+\t\treturn DT_REG;\n+\t\tbreak;\n+\t}\n+}\n+\n+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj)\n+{\n+\tobj = yaffs_GetEquivalentObject(obj);\n+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {\n+\t\treturn yaffs_CloneString(obj->variant.symLinkVariant.alias);\n+\t} else {\n+\t\treturn yaffs_CloneString(_Y(""));\n+\t}\n+}\n+\n+#ifndef CONFIG_YAFFS_WINCE\n+\n+int yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr)\n+{\n+\tunsigned int valid = attr->ia_valid;\n+\n+\tif (valid & ATTR_MODE)\n+\t\tobj->yst_mode = attr->ia_mode;\n+\tif (valid & ATTR_UID)\n+\t\tobj->yst_uid = attr->ia_uid;\n+\tif (valid & ATTR_GID)\n+\t\tobj->yst_gid = attr->ia_gid;\n+\n+\tif (valid & ATTR_ATIME)\n+\t\tobj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);\n+\tif (valid & ATTR_CTIME)\n+\t\tobj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);\n+\tif (valid & ATTR_MTIME)\n+\t\tobj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);\n+\n+\tif (valid & ATTR_SIZE)\n+\t\tyaffs_ResizeFile(obj, attr->ia_size);\n+\n+\tyaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);\n+\n+\treturn YAFFS_OK;\n+\n+}\n+int yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr)\n+{\n+\tunsigned int valid = 0;\n+\n+\tattr->ia_mode = obj->yst_mode;\n+\tvalid |= ATTR_MODE;\n+\tattr->ia_uid = obj->yst_uid;\n+\tvalid |= ATTR_UID;\n+\tattr->ia_gid = obj->yst_gid;\n+\tvalid |= ATTR_GID;\n+\n+\tY_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;\n+\tvalid |= ATTR_ATIME;\n+\tY_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;\n+\tvalid |= ATTR_CTIME;\n+\tY_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;\n+\tvalid |= ATTR_MTIME;\n+\n+\tattr->ia_size = yaffs_GetFileSize(obj);\n+\tvalid |= ATTR_SIZE;\n+\n+\tattr->ia_valid = valid;\n+\n+\treturn YAFFS_OK;\n+\n+}\n+\n+#endif\n+\n+#if 0\n+int yaffs_DumpObject(yaffs_Object * obj)\n+{\n+\tYCHAR name[257];\n+\n+\tyaffs_GetObjectName(obj, name, 256);\n+\n+\tT(YAFFS_TRACE_ALWAYS,\n+\t  (TSTR\n+\t   ("Object %d, inode %d \\"%s\\"\\n dirty %d valid %d serial %d sum %d"\n+\t    " chunk %d type %d size %d\\n"\n+\t    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,\n+\t   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,\n+\t   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));\n+\n+\treturn YAFFS_OK;\n+}\n+#endif\n+\n+/*---------------------------- Initialisation code -------------------------------------- */\n+\n+static int yaffs_CheckDevFunctions(const yaffs_Device * dev)\n+{\n+\n+\t/* Common functions, gotta have */\n+\tif (!dev->eraseBlockInNAND || !dev->initialiseNAND)\n+\t\treturn 0;\n+\n+#ifdef CONFIG_YAFFS_YAFFS2\n+\n+\t/* Can use the "with tags" style interface for yaffs1 or yaffs2 */\n+\tif (dev->writeChunkWithTagsToNAND &&\n+\t    dev->readChunkWithTagsFromNAND &&\n+\t    !dev->writeChunkToNAND &&\n+\t    !dev->readChunkFromNAND &&\n+\t    dev->markNANDBlockBad && dev->queryNANDBlock)\n+\t\treturn 1;\n+#endif\n+\n+\t/* Can use the "spare" style interface for yaffs1 */\n+\tif (!dev->isYaffs2 &&\n+\t    !dev->writeChunkWithTagsToNAND &&\n+\t    !dev->readChunkWithTagsFromNAND &&\n+\t    dev->writeChunkToNAND &&\n+\t    dev->readChunkFromNAND &&\n+\t    !dev->markNANDBlockBad && !dev->queryNANDBlock)\n+\t\treturn 1;\n+\n+\treturn 0;\t\t/* bad */\n+}\n+\n+\n+static int yaffs_CreateInitialDirectories(yaffs_Device *dev)\n+{\n+\t/* Initialise the unlinked, deleted, root and lost and found directories */\n+\n+\tdev->lostNFoundDir = dev->rootDir =  NULL;\n+\tdev->unlinkedDir = dev->deletedDir = NULL;\n+\n+\tdev->unlinkedDir =\n+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);\n+\n+\tdev->deletedDir =\n+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);\n+\n+\tdev->rootDir =\n+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,\n+\t\t\t\t      YAFFS_ROOT_MODE | S_IFDIR);\n+\tdev->lostNFoundDir =\n+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,\n+\t\t\t\t      YAFFS_LOSTNFOUND_MODE | S_IFDIR);\n+\n+\tif(dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir){\n+\t\tyaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);\n+\t\treturn YAFFS_OK;\n+\t}\n+\n+\treturn YAFFS_FAIL;\n+}\n+\n+int yaffs_GutsInitialise(yaffs_Device * dev)\n+{\n+\tint init_failed = 0;\n+\tunsigned x;\n+\tint bits;\n+\n+\tT(YAFFS_TRACE_TRACING, (TSTR("yaffs: yaffs_GutsInitialise()" TENDSTR)));\n+\n+\t/* Check stuff that must be set */\n+\n+\tif (!dev) {\n+\t\tT(YAFFS_TRACE_ALWAYS, (TSTR("yaffs: Need a device" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tdev->internalStartBlock = dev->startBlock;\n+\tdev->internalEndBlock = dev->endBlock;\n+\tdev->blockOffset = 0;\n+\tdev->chunkOffset = 0;\n+\tdev->nFreeChunks = 0;\n+\n+\tif (dev->startBlock == 0) {\n+\t\tdev->internalStartBlock = dev->startBlock + 1;\n+\t\tdev->internalEndBlock = dev->endBlock + 1;\n+\t\tdev->blockOffset = 1;\n+\t\tdev->chunkOffset = dev->nChunksPerBlock;\n+\t}\n+\n+\t/* Check geometry parameters. */\n+\n+\tif ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) ||\n+\t    (!dev->isYaffs2 && dev->totalBytesPerChunk != 512) ||\n+\t    (dev->inbandTags && !dev->isYaffs2 ) ||\n+\t     dev->nChunksPerBlock < 2 ||\n+\t     dev->nReservedBlocks < 2 ||\n+\t     dev->internalStartBlock <= 0 ||\n+\t     dev->internalEndBlock <= 0 ||\n+\t     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)\t// otherwise it is too small\n+\t    ) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inbandTags %d "\n+\t\t    TENDSTR), dev->totalBytesPerChunk, dev->isYaffs2 ? "2" : "", dev->inbandTags));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tif (yaffs_InitialiseNAND(dev) != YAFFS_OK) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR("yaffs: InitialiseNAND failed" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* Sort out space for inband tags, if required */\n+\tif(dev->inbandTags)\n+\t\tdev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);\n+\telse\n+\t\tdev->nDataBytesPerChunk = dev->totalBytesPerChunk;\n+\n+\t/* Got the right mix of functions? */\n+\tif (!yaffs_CheckDevFunctions(dev)) {\n+\t\t/* Function missing */\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR\n+\t\t   ("yaffs: device function(s) missing or wrong\\n" TENDSTR)));\n+\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* This is really a compilation check. */\n+\tif (!yaffs_CheckStructures()) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR("yaffs_CheckStructures failed\\n" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tif (dev->isMounted) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR("yaffs: device already mounted\\n" TENDSTR)));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* Finished with most checks. One or two more checks happen later on too. */\n+\n+\tdev->isMounted = 1;\n+\n+\n+\n+\t/* OK now calculate a few things for the device */\n+\n+\t/*\n+\t *  Calculate all the chunk size manipulation numbers:\n+\t */\n+ \t {\n+\t\t__u32 x = dev->nDataBytesPerChunk;\n+\t\t /* We always use dev->chunkShift and dev->chunkDiv */\n+\t\t dev->chunkShift = Shifts(x);\n+\t\t x >>= dev->chunkShift;\n+\t\t dev->chunkDiv = x;\n+\t\t /* We only use chunk mask if chunkDiv is 1 */\n+\t\t dev->chunkMask = (1<<dev->chunkShift) - 1;\n+\t}\n+\n+\n+\t/*\n+\t * Calculate chunkGroupBits.\n+\t * We need to find the next power of 2 > than internalEndBlock\n+\t */\n+\n+\tx = dev->nChunksPerBlock * (dev->internalEndBlock + 1);\n+\n+\tbits = ShiftsGE(x);\n+\n+\t/* Set up tnode width if wide tnodes are enabled. */\n+\tif(!dev->wideTnodesDisabled){\n+\t\t/* bits must be even so that we end up with 32-bit words */\n+\t\tif(bits & 1)\n+\t\t\tbits++;\n+\t\tif(bits < 16)\n+\t\t\tdev->tnodeWidth = 16;\n+\t\telse\n+\t\t\tdev->tnodeWidth = bits;\n+\t}\n+\telse\n+\t\tdev->tnodeWidth = 16;\n+\n+\tdev->tnodeMask = (1<<dev->tnodeWidth)-1;\n+\n+\t/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),\n+\t * so if the bitwidth of the\n+\t * chunk range we\'re using is greater than 16 we need\n+\t * to figure out chunk shift and chunkGroupSize\n+\t */\n+\n+\tif (bits <= dev->tnodeWidth)\n+\t\tdev->chunkGroupBits = 0;\n+\telse\n+\t\tdev->chunkGroupBits = bits - dev->tnodeWidth;\n+\n+\n+\tdev->chunkGroupSize = 1 << dev->chunkGroupBits;\n+\n+\tif (dev->nChunksPerBlock < dev->chunkGroupSize) {\n+\t\t/* We have a problem because the soft delete won\'t work if\n+\t\t * the chunk group size > chunks per block.\n+\t\t * This can be remedied by using larger "virtual blocks".\n+\t\t */\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR("yaffs: chunk group too large\\n" TENDSTR)));\n+\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* OK, we\'ve finished verifying the device, lets continue with initialisation */\n+\n+\t/* More device initialisation */\n+\tdev->garbageCollections = 0;\n+\tdev->passiveGarbageCollections = 0;\n+\tdev->currentDirtyChecker = 0;\n+\tdev->bufferedBlock = -1;\n+\tdev->doingBufferedBlockRewrite = 0;\n+\tdev->nDeletedFiles = 0;\n+\tdev->nBackgroundDeletions = 0;\n+\tdev->nUnlinkedFiles = 0;\n+\tdev->eccFixed = 0;\n+\tdev->eccUnfixed = 0;\n+\tdev->tagsEccFixed = 0;\n+\tdev->tagsEccUnfixed = 0;\n+\tdev->nErasureFailures = 0;\n+\tdev->nErasedBlocks = 0;\n+\tdev->isDoingGC = 0;\n+\tdev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */\n+\n+\t/* Initialise temporary buffers and caches. */\n+\tif(!yaffs_InitialiseTempBuffers(dev))\n+\t\tinit_failed = 1;\n+\n+\tdev->srCache = NULL;\n+\tdev->gcCleanupList = NULL;\n+\n+\n+\tif (!init_failed &&\n+\t    dev->nShortOpCaches > 0) {\n+\t\tint i;\n+\t\tvoid *buf;\n+\t\tint srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);\n+\n+\t\tif (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES) {\n+\t\t\tdev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;\n+\t\t}\n+\n+\t\tbuf = dev->srCache =  YMALLOC(srCacheBytes);\n+\n+\t\tif(dev->srCache)\n+\t\t\tmemset(dev->srCache,0,srCacheBytes);\n+\n+\t\tfor (i = 0; i < dev->nShortOpCaches && buf; i++) {\n+\t\t\tdev->srCache[i].object = NULL;\n+\t\t\tdev->srCache[i].lastUse = 0;\n+\t\t\tdev->srCache[i].dirty = 0;\n+\t\t\tdev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);\n+\t\t}\n+\t\tif(!buf)\n+\t\t\tinit_failed = 1;\n+\n+\t\tdev->srLastUse = 0;\n+\t}\n+\n+\tdev->cacheHits = 0;\n+\n+\tif(!init_failed){\n+\t\tdev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));\n+\t\tif(!dev->gcCleanupList)\n+\t\t\tinit_failed = 1;\n+\t}\n+\n+\tif (dev->isYaffs2) {\n+\t\tdev->useHeaderFileSize = 1;\n+\t}\n+\tif(!init_failed && !yaffs_InitialiseBlocks(dev))\n+\t\tinit_failed = 1;\n+\n+\tyaffs_InitialiseTnodes(dev);\n+\tyaffs_InitialiseObjects(dev);\n+\n+\tif(!init_failed && !yaffs_CreateInitialDirectories(dev))\n+\t\tinit_failed = 1;\n+\n+\n+\tif(!init_failed){\n+\t\t/* Now scan the flash. */\n+\t\tif (dev->isYaffs2) {\n+\t\t\tif(yaffs_CheckpointRestore(dev)) {\n+\t\t\t\tyaffs_CheckObjectDetailsLoaded(dev->rootDir);\n+\t\t\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t\t\t  (TSTR("yaffs: restored from checkpoint" TENDSTR)));\n+\t\t\t} else {\n+\n+\t\t\t\t/* Clean up the mess caused by an aborted checkpoint load\n+\t\t\t\t * and scan backwards.\n+\t\t\t\t */\n+\t\t\t\tyaffs_DeinitialiseBlocks(dev);\n+\t\t\t\tyaffs_DeinitialiseTnodes(dev);\n+\t\t\t\tyaffs_DeinitialiseObjects(dev);\n+\n+\n+\t\t\t\tdev->nErasedBlocks = 0;\n+\t\t\t\tdev->nFreeChunks = 0;\n+\t\t\t\tdev->allocationBlock = -1;\n+\t\t\t\tdev->allocationPage = -1;\n+\t\t\t\tdev->nDeletedFiles = 0;\n+\t\t\t\tdev->nUnlinkedFiles = 0;\n+\t\t\t\tdev->nBackgroundDeletions = 0;\n+\t\t\t\tdev->oldestDirtySequence = 0;\n+\n+\t\t\t\tif(!init_failed && !yaffs_InitialiseBlocks(dev))\n+\t\t\t\t\tinit_failed = 1;\n+\n+\t\t\t\tyaffs_InitialiseTnodes(dev);\n+\t\t\t\tyaffs_InitialiseObjects(dev);\n+\n+\t\t\t\tif(!init_failed && !yaffs_CreateInitialDirectories(dev))\n+\t\t\t\t\tinit_failed = 1;\n+\n+\t\t\t\tif(!init_failed && !yaffs_ScanBackwards(dev))\n+\t\t\t\t\tinit_failed = 1;\n+\t\t\t}\n+\t\t}else\n+\t\t\tif(!yaffs_Scan(dev))\n+\t\t\t\tinit_failed = 1;\n+\t}\n+\n+\tif(init_failed){\n+\t\t/* Clean up the mess */\n+\t\tT(YAFFS_TRACE_TRACING,\n+\t\t  (TSTR("yaffs: yaffs_GutsInitialise() aborted.\\n" TENDSTR)));\n+\n+\t\tyaffs_Deinitialise(dev);\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* Zero out stats */\n+\tdev->nPageReads = 0;\n+\tdev->nPageWrites = 0;\n+\tdev->nBlockErasures = 0;\n+\tdev->nGCCopies = 0;\n+\tdev->nRetriedWrites = 0;\n+\n+\tdev->nRetiredBlocks = 0;\n+\n+\tyaffs_VerifyFreeChunks(dev);\n+\tyaffs_VerifyBlocks(dev);\n+\n+\n+\tT(YAFFS_TRACE_TRACING,\n+\t  (TSTR("yaffs: yaffs_GutsInitialise() done.\\n" TENDSTR)));\n+\treturn YAFFS_OK;\n+\n+}\n+\n+void yaffs_Deinitialise(yaffs_Device * dev)\n+{\n+\tif (dev->isMounted) {\n+\t\tint i;\n+\n+\t\tyaffs_DeinitialiseBlocks(dev);\n+\t\tyaffs_DeinitialiseTnodes(dev);\n+\t\tyaffs_DeinitialiseObjects(dev);\n+\t\tif (dev->nShortOpCaches > 0 &&\n+\t\t    dev->srCache) {\n+\n+\t\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\t\tif(dev->srCache[i].data)\n+\t\t\t\t\tYFREE(dev->srCache[i].data);\n+\t\t\t\tdev->srCache[i].data = NULL;\n+\t\t\t}\n+\n+\t\t\tYFREE(dev->srCache);\n+\t\t\tdev->srCache = NULL;\n+\t\t}\n+\n+\t\tYFREE(dev->gcCleanupList);\n+\n+\t\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {\n+\t\t\tYFREE(dev->tempBuffer[i].buffer);\n+\t\t}\n+\n+\n+\t\tdev->isMounted = 0;\n+\t}\n+\n+}\n+\n+static int yaffs_CountFreeChunks(yaffs_Device * dev)\n+{\n+\tint nFree;\n+\tint b;\n+\n+\tyaffs_BlockInfo *blk;\n+\n+\tfor (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;\n+\t     b++) {\n+\t\tblk = yaffs_GetBlockInfo(dev, b);\n+\n+\t\tswitch (blk->blockState) {\n+\t\tcase YAFFS_BLOCK_STATE_EMPTY:\n+\t\tcase YAFFS_BLOCK_STATE_ALLOCATING:\n+\t\tcase YAFFS_BLOCK_STATE_COLLECTING:\n+\t\tcase YAFFS_BLOCK_STATE_FULL:\n+\t\t\tnFree +=\n+\t\t\t    (dev->nChunksPerBlock - blk->pagesInUse +\n+\t\t\t     blk->softDeletions);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\n+\t}\n+\n+\treturn nFree;\n+}\n+\n+int yaffs_GetNumberOfFreeChunks(yaffs_Device * dev)\n+{\n+\t/* This is what we report to the outside world */\n+\n+\tint nFree;\n+\tint nDirtyCacheChunks;\n+\tint blocksForCheckpoint;\n+\n+#if 1\n+\tnFree = dev->nFreeChunks;\n+#else\n+\tnFree = yaffs_CountFreeChunks(dev);\n+#endif\n+\n+\tnFree += dev->nDeletedFiles;\n+\n+\t/* Now count the number of dirty chunks in the cache and subtract those */\n+\n+\t{\n+\t\tint i;\n+\t\tfor (nDirtyCacheChunks = 0, i = 0; i < dev->nShortOpCaches; i++) {\n+\t\t\tif (dev->srCache[i].dirty)\n+\t\t\t\tnDirtyCacheChunks++;\n+\t\t}\n+\t}\n+\n+\tnFree -= nDirtyCacheChunks;\n+\n+\tnFree -= ((dev->nReservedBlocks + 1) * dev->nChunksPerBlock);\n+\n+\t/* Now we figure out how much to reserve for the checkpoint and report that... */\n+\tblocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;\n+\tif(blocksForCheckpoint < 0)\n+\t\tblocksForCheckpoint = 0;\n+\n+\tnFree -= (blocksForCheckpoint * dev->nChunksPerBlock);\n+\n+\tif (nFree < 0)\n+\t\tnFree = 0;\n+\n+\treturn nFree;\n+\n+}\n+\n+static int yaffs_freeVerificationFailures;\n+\n+static void yaffs_VerifyFreeChunks(yaffs_Device * dev)\n+{\n+\tint counted;\n+\tint difference;\n+\n+\tif(yaffs_SkipVerification(dev))\n+\t\treturn;\n+\n+\tcounted = yaffs_CountFreeChunks(dev);\n+\n+\tdifference = dev->nFreeChunks - counted;\n+\n+\tif (difference) {\n+\t\tT(YAFFS_TRACE_ALWAYS,\n+\t\t  (TSTR("Freechunks verification failure %d %d %d" TENDSTR),\n+\t\t   dev->nFreeChunks, counted, difference));\n+\t\tyaffs_freeVerificationFailures++;\n+\t}\n+}\n+\n+/*---------------------------------------- YAFFS test code ----------------------*/\n+\n+#define yaffs_CheckStruct(structure,syze, name) \\\n+\tdo { \\\n+           if(sizeof(structure) != syze) \\\n+\t       { \\\n+\t         T(YAFFS_TRACE_ALWAYS,(TSTR("%s should be %d but is %d\\n" TENDSTR),\\\n+\t\t name,syze,sizeof(structure))); \\\n+\t         return YAFFS_FAIL; \\\n+\t\t} \\\n+\t} while(0)\n+\n+static int yaffs_CheckStructures(void)\n+{\n+/*      yaffs_CheckStruct(yaffs_Tags,8,"yaffs_Tags"); */\n+/*      yaffs_CheckStruct(yaffs_TagsUnion,8,"yaffs_TagsUnion"); */\n+/*      yaffs_CheckStruct(yaffs_Spare,16,"yaffs_Spare"); */\n+#ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+        yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, "yaffs_Tnode");\n+#endif\n+#ifndef CONFIG_YAFFS_WINCE\n+\t\tyaffs_CheckStruct(yaffs_ObjectHeader, 512, "yaffs_ObjectHeader");\n+#endif\n+\t    return YAFFS_OK;\n+}'),
 ('linux-2.6.23/fs/yaffs2/yaffs_guts.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_guts.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h\n--- linux-2.6.23/fs/yaffs2/yaffs_guts.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h\n@@ -0,0 +1,901 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_GUTS_H__\n+#define __YAFFS_GUTS_H__\n+\n+#include "devextras.h"\n+#include "yportenv.h"\n+\n+#define YAFFS_OK\t1\n+#define YAFFS_FAIL  0\n+\n+/* Give us a  Y=0x59,\n+ * Give us an A=0x41,\n+ * Give us an FF=0xFF\n+ * Give us an S=0x53\n+ * And what have we got...\n+ */\n+#define YAFFS_MAGIC\t\t\t0x5941FF53\n+\n+#define YAFFS_NTNODES_LEVEL0\t  \t16\n+#define YAFFS_TNODES_LEVEL0_BITS\t4\n+#define YAFFS_TNODES_LEVEL0_MASK\t0xf\n+\n+#define YAFFS_NTNODES_INTERNAL \t\t(YAFFS_NTNODES_LEVEL0 / 2)\n+#define YAFFS_TNODES_INTERNAL_BITS \t(YAFFS_TNODES_LEVEL0_BITS - 1)\n+#define YAFFS_TNODES_INTERNAL_MASK\t0x7\n+#define YAFFS_TNODES_MAX_LEVEL\t\t6\n+\n+#ifndef CONFIG_YAFFS_NO_YAFFS1\n+#define YAFFS_BYTES_PER_SPARE\t\t16\n+#define YAFFS_BYTES_PER_CHUNK\t\t512\n+#define YAFFS_CHUNK_SIZE_SHIFT\t\t9\n+#define YAFFS_CHUNKS_PER_BLOCK\t\t32\n+#define YAFFS_BYTES_PER_BLOCK\t\t(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)\n+#endif\n+\n+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE \t1024\n+#define YAFFS_MIN_YAFFS2_SPARE_SIZE\t32\n+\n+#define YAFFS_MAX_CHUNK_ID\t\t0x000FFFFF\n+\n+#define YAFFS_UNUSED_OBJECT_ID\t\t0x0003FFFF\n+\n+#define YAFFS_ALLOCATION_NOBJECTS\t100\n+#define YAFFS_ALLOCATION_NTNODES\t100\n+#define YAFFS_ALLOCATION_NLINKS\t\t100\n+\n+#define YAFFS_NOBJECT_BUCKETS\t\t256\n+\n+\n+#define YAFFS_OBJECT_SPACE\t\t0x40000\n+\n+#define YAFFS_CHECKPOINT_VERSION \t3\n+\n+#ifdef CONFIG_YAFFS_UNICODE\n+#define YAFFS_MAX_NAME_LENGTH\t\t127\n+#define YAFFS_MAX_ALIAS_LENGTH\t\t79\n+#else\n+#define YAFFS_MAX_NAME_LENGTH\t\t255\n+#define YAFFS_MAX_ALIAS_LENGTH\t\t159\n+#endif\n+\n+#define YAFFS_SHORT_NAME_LENGTH\t\t15\n+\n+/* Some special object ids for pseudo objects */\n+#define YAFFS_OBJECTID_ROOT\t\t1\n+#define YAFFS_OBJECTID_LOSTNFOUND\t2\n+#define YAFFS_OBJECTID_UNLINKED\t\t3\n+#define YAFFS_OBJECTID_DELETED\t\t4\n+\n+/* Sseudo object ids for checkpointing */\n+#define YAFFS_OBJECTID_SB_HEADER\t0x10\n+#define YAFFS_OBJECTID_CHECKPOINT_DATA\t0x20\n+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21\n+\n+/* */\n+\n+#define YAFFS_MAX_SHORT_OP_CACHES\t20\n+\n+#define YAFFS_N_TEMP_BUFFERS\t\t6\n+\n+/* We limit the number attempts at sucessfully saving a chunk of data.\n+ * Small-page devices have 32 pages per block; large-page devices have 64.\n+ * Default to something in the order of 5 to 10 blocks worth of chunks.\n+ */\n+#define YAFFS_WR_ATTEMPTS\t\t(5*64)\n+\n+/* Sequence numbers are used in YAFFS2 to determine block allocation order.\n+ * The range is limited slightly to help distinguish bad numbers from good.\n+ * This also allows us to perhaps in the future use special numbers for\n+ * special purposes.\n+ * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,\n+ * and is a larger number than the lifetime of a 2GB device.\n+ */\n+#define YAFFS_LOWEST_SEQUENCE_NUMBER\t0x00001000\n+#define YAFFS_HIGHEST_SEQUENCE_NUMBER\t0xEFFFFF00\n+\n+/* ChunkCache is used for short read/write operations.*/\n+typedef struct {\n+\tstruct yaffs_ObjectStruct *object;\n+\tint chunkId;\n+\tint lastUse;\n+\tint dirty;\n+\tint nBytes;\t\t/* Only valid if the cache is dirty */\n+\tint locked;\t\t/* Can\'t push out or flush while locked. */\n+#ifdef CONFIG_YAFFS_YAFFS2\n+\t__u8 *data;\n+#else\n+\t__u8 data[YAFFS_BYTES_PER_CHUNK];\n+#endif\n+} yaffs_ChunkCache;\n+\n+\n+\n+/* Tags structures in RAM\n+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise\n+ * the structure size will get blown out.\n+ */\n+\n+#ifndef CONFIG_YAFFS_NO_YAFFS1\n+typedef struct {\n+\tunsigned chunkId:20;\n+\tunsigned serialNumber:2;\n+\tunsigned byteCount:10;\n+\tunsigned objectId:18;\n+\tunsigned ecc:12;\n+\tunsigned unusedStuff:2;\n+\n+} yaffs_Tags;\n+\n+typedef union {\n+\tyaffs_Tags asTags;\n+\t__u8 asBytes[8];\n+} yaffs_TagsUnion;\n+\n+#endif\n+\n+/* Stuff used for extended tags in YAFFS2 */\n+\n+typedef enum {\n+\tYAFFS_ECC_RESULT_UNKNOWN,\n+\tYAFFS_ECC_RESULT_NO_ERROR,\n+\tYAFFS_ECC_RESULT_FIXED,\n+\tYAFFS_ECC_RESULT_UNFIXED\n+} yaffs_ECCResult;\n+\n+typedef enum {\n+\tYAFFS_OBJECT_TYPE_UNKNOWN,\n+\tYAFFS_OBJECT_TYPE_FILE,\n+\tYAFFS_OBJECT_TYPE_SYMLINK,\n+\tYAFFS_OBJECT_TYPE_DIRECTORY,\n+\tYAFFS_OBJECT_TYPE_HARDLINK,\n+\tYAFFS_OBJECT_TYPE_SPECIAL\n+} yaffs_ObjectType;\n+\n+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL\n+\n+typedef struct {\n+\n+\tunsigned validMarker0;\n+\tunsigned chunkUsed;\t/*  Status of the chunk: used or unused */\n+\tunsigned objectId;\t/* If 0 then this is not part of an object (unused) */\n+\tunsigned chunkId;\t/* If 0 then this is a header, else a data chunk */\n+\tunsigned byteCount;\t/* Only valid for data chunks */\n+\n+\t/* The following stuff only has meaning when we read */\n+\tyaffs_ECCResult eccResult;\n+\tunsigned blockBad;\n+\n+\t/* YAFFS 1 stuff */\n+\tunsigned chunkDeleted;\t/* The chunk is marked deleted */\n+\tunsigned serialNumber;\t/* Yaffs1 2-bit serial number */\n+\n+\t/* YAFFS2 stuff */\n+\tunsigned sequenceNumber;\t/* The sequence number of this block */\n+\n+\t/* Extra info if this is an object header (YAFFS2 only) */\n+\n+\tunsigned extraHeaderInfoAvailable;\t/* There is extra info available if this is not zero */\n+\tunsigned extraParentObjectId;\t/* The parent object */\n+\tunsigned extraIsShrinkHeader;\t/* Is it a shrink header? */\n+\tunsigned extraShadows;\t\t/* Does this shadow another object? */\n+\n+\tyaffs_ObjectType extraObjectType;\t/* What object type? */\n+\n+\tunsigned extraFileLength;\t\t/* Length if it is a file */\n+\tunsigned extraEquivalentObjectId;\t/* Equivalent object Id if it is a hard link */\n+\n+\tunsigned validMarker1;\n+\n+} yaffs_ExtendedTags;\n+\n+/* Spare structure for YAFFS1 */\n+typedef struct {\n+\t__u8 tagByte0;\n+\t__u8 tagByte1;\n+\t__u8 tagByte2;\n+\t__u8 tagByte3;\n+\t__u8 pageStatus;\t/* set to 0 to delete the chunk */\n+\t__u8 blockStatus;\n+\t__u8 tagByte4;\n+\t__u8 tagByte5;\n+\t__u8 ecc1[3];\n+\t__u8 tagByte6;\n+\t__u8 tagByte7;\n+\t__u8 ecc2[3];\n+} yaffs_Spare;\n+\n+/*Special structure for passing through to mtd */\n+struct yaffs_NANDSpare {\n+\tyaffs_Spare spare;\n+\tint eccres1;\n+\tint eccres2;\n+};\n+\n+/* Block data in RAM */\n+\n+typedef enum {\n+\tYAFFS_BLOCK_STATE_UNKNOWN = 0,\n+\n+\tYAFFS_BLOCK_STATE_SCANNING,\n+\tYAFFS_BLOCK_STATE_NEEDS_SCANNING,\n+\t/* The block might have something on it (ie it is allocating or full, perhaps empty)\n+\t * but it needs to be scanned to determine its true state.\n+\t * This state is only valid during yaffs_Scan.\n+\t * NB We tolerate empty because the pre-scanner might be incapable of deciding\n+\t * However, if this state is returned on a YAFFS2 device, then we expect a sequence number\n+\t */\n+\n+\tYAFFS_BLOCK_STATE_EMPTY,\n+\t/* This block is empty */\n+\n+\tYAFFS_BLOCK_STATE_ALLOCATING,\n+\t/* This block is partially allocated.\n+\t * At least one page holds valid data.\n+\t * This is the one currently being used for page\n+\t * allocation. Should never be more than one of these\n+\t */\n+\n+\tYAFFS_BLOCK_STATE_FULL,\n+\t/* All the pages in this block have been allocated.\n+\t */\n+\n+\tYAFFS_BLOCK_STATE_DIRTY,\n+\t/* All pages have been allocated and deleted.\n+\t * Erase me, reuse me.\n+\t */\n+\n+\tYAFFS_BLOCK_STATE_CHECKPOINT,\n+\t/* This block is assigned to holding checkpoint data.\n+\t */\n+\n+\tYAFFS_BLOCK_STATE_COLLECTING,\n+\t/* This block is being garbage collected */\n+\n+\tYAFFS_BLOCK_STATE_DEAD\n+\t/* This block has failed and is not in use */\n+} yaffs_BlockState;\n+\n+#define\tYAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)\n+\n+\n+typedef struct {\n+\n+\tint softDeletions:10;\t/* number of soft deleted pages */\n+\tint pagesInUse:10;\t/* number of pages in use */\n+\tunsigned blockState:4;\t/* One of the above block states. NB use unsigned because enum is sometimes an int */\n+\t__u32 needsRetiring:1;\t/* Data has failed on this block, need to get valid data off */\n+                        \t/* and retire the block. */\n+\t__u32 skipErasedCheck: 1; /* If this is set we can skip the erased check on this block */\n+\t__u32 gcPrioritise: 1; \t/* An ECC check or blank check has failed on this block.\n+\t\t\t\t   It should be prioritised for GC */\n+        __u32 chunkErrorStrikes:3; /* How many times we\'ve had ecc etc failures on this block and tried to reuse it */\n+\n+#ifdef CONFIG_YAFFS_YAFFS2\n+\t__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */\n+\t__u32 sequenceNumber;\t /* block sequence number for yaffs2 */\n+#endif\n+\n+} yaffs_BlockInfo;\n+\n+/* -------------------------- Object structure -------------------------------*/\n+/* This is the object structure as stored on NAND */\n+\n+typedef struct {\n+\tyaffs_ObjectType type;\n+\n+\t/* Apply to everything  */\n+\tint parentObjectId;\n+        __u16 sum__NoLongerUsed;        /* checksum of name. No longer used */\n+        YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];\n+\n+        /* The following apply to directories, files, symlinks - not hard links */\n+        __u32 yst_mode;         /* protection */\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t__u32 notForWinCE[5];\n+#else\n+\t__u32 yst_uid;\n+\t__u32 yst_gid;\n+\t__u32 yst_atime;\n+\t__u32 yst_mtime;\n+\t__u32 yst_ctime;\n+#endif\n+\n+\t/* File size  applies to files only */\n+\tint fileSize;\n+\n+\t/* Equivalent object id applies to hard links only. */\n+\tint equivalentObjectId;\n+\n+\t/* Alias is for symlinks only. */\n+\tYCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];\n+\n+\t__u32 yst_rdev;\t\t/* device stuff for block and char devices (major/min) */\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t__u32 win_ctime[2];\n+\t__u32 win_atime[2];\n+\t__u32 win_mtime[2];\n+#else\n+\t__u32 roomToGrow[6];\n+\n+#endif\n+\t__u32 inbandShadowsObject;\n+\t__u32 inbandIsShrink;\n+\n+\t__u32 reservedSpace[2];\n+\tint shadowsObject;\t/* This object header shadows the specified object if > 0 */\n+\n+\t/* isShrink applies to object headers written when we shrink the file (ie resize) */\n+\t__u32 isShrink;\n+\n+} yaffs_ObjectHeader;\n+\n+/*--------------------------- Tnode -------------------------- */\n+\n+union yaffs_Tnode_union {\n+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG\n+\tunion yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];\n+#else\n+\tunion yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];\n+#endif\n+/*\t__u16 level0[YAFFS_NTNODES_LEVEL0]; */\n+\n+};\n+\n+typedef union yaffs_Tnode_union yaffs_Tnode;\n+\n+struct yaffs_TnodeList_struct {\n+\tstruct yaffs_TnodeList_struct *next;\n+\tyaffs_Tnode *tnodes;\n+};\n+\n+typedef struct yaffs_TnodeList_struct yaffs_TnodeList;\n+\n+/*------------------------  Object -----------------------------*/\n+/* An object can be one of:\n+ * - a directory (no data, has children links\n+ * - a regular file (data.... not prunes :->).\n+ * - a symlink [symbolic link] (the alias).\n+ * - a hard link\n+ */\n+\n+typedef struct {\n+\t__u32 fileSize;\n+\t__u32 scannedFileSize;\n+\t__u32 shrinkSize;\n+\tint topLevel;\n+\tyaffs_Tnode *top;\n+} yaffs_FileStructure;\n+\n+typedef struct {\n+        struct ylist_head children;     /* list of child links */\n+} yaffs_DirectoryStructure;\n+\n+typedef struct {\n+\tYCHAR *alias;\n+} yaffs_SymLinkStructure;\n+\n+typedef struct {\n+\tstruct yaffs_ObjectStruct *equivalentObject;\n+\t__u32 equivalentObjectId;\n+} yaffs_HardLinkStructure;\n+\n+typedef union {\n+\tyaffs_FileStructure fileVariant;\n+\tyaffs_DirectoryStructure directoryVariant;\n+\tyaffs_SymLinkStructure symLinkVariant;\n+\tyaffs_HardLinkStructure hardLinkVariant;\n+} yaffs_ObjectVariant;\n+\n+struct yaffs_ObjectStruct {\n+\t__u8 deleted:1;\t\t/* This should only apply to unlinked files. */\n+\t__u8 softDeleted:1;\t/* it has also been soft deleted */\n+\t__u8 unlinked:1;\t/* An unlinked file. The file should be in the unlinked directory.*/\n+\t__u8 fake:1;\t\t/* A fake object has no presence on NAND. */\n+\t__u8 renameAllowed:1;\t/* Some objects are not allowed to be renamed. */\n+\t__u8 unlinkAllowed:1;\n+\t__u8 dirty:1;\t\t/* the object needs to be written to flash */\n+\t__u8 valid:1;\t\t/* When the file system is being loaded up, this\n+\t\t\t\t * object might be created before the data\n+\t\t\t\t * is available (ie. file data records appear before the header).\n+\t\t\t\t */\n+\t__u8 lazyLoaded:1;\t/* This object has been lazy loaded and is missing some detail */\n+\n+\t__u8 deferedFree:1;\t/* For Linux kernel. Object is removed from NAND, but is\n+\t\t\t\t * still in the inode cache. Free of object is defered.\n+\t\t\t\t * until the inode is released.\n+\t\t\t\t */\n+\n+\t__u8 serial;\t\t/* serial number of chunk in NAND. Cached here */\n+\t__u16 sum;\t\t/* sum of the name to speed searching */\n+\n+        struct yaffs_DeviceStruct *myDev;       /* The device I\'m on */\n+\n+        struct ylist_head hashLink;     /* list of objects in this hash bucket */\n+\n+        struct ylist_head hardLinks;    /* all the equivalent hard linked objects */\n+\n+        /* directory structure stuff */\n+        /* also used for linking up the free list */\n+        struct yaffs_ObjectStruct *parent;\n+        struct ylist_head siblings;\n+\n+\t/* Where\'s my object header in NAND? */\n+\tint hdrChunk;\n+\n+\tint nDataChunks;\t/* Number of data chunks attached to the file. */\n+\n+\t__u32 objectId;\t\t/* the object id value */\n+\n+\t__u32 yst_mode;\n+\n+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM\n+\tYCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];\n+#endif\n+\n+#ifndef __KERNEL__\n+\t__u32 inUse;\n+#endif\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+\t__u32 win_ctime[2];\n+\t__u32 win_mtime[2];\n+\t__u32 win_atime[2];\n+#else\n+\t__u32 yst_uid;\n+\t__u32 yst_gid;\n+\t__u32 yst_atime;\n+\t__u32 yst_mtime;\n+\t__u32 yst_ctime;\n+#endif\n+\n+\t__u32 yst_rdev;\n+\n+#ifdef __KERNEL__\n+\tstruct inode *myInode;\n+\n+#endif\n+\n+\tyaffs_ObjectType variantType;\n+\n+\tyaffs_ObjectVariant variant;\n+\n+};\n+\n+typedef struct yaffs_ObjectStruct yaffs_Object;\n+\n+struct yaffs_ObjectList_struct {\n+\tyaffs_Object *objects;\n+\tstruct yaffs_ObjectList_struct *next;\n+};\n+\n+typedef struct yaffs_ObjectList_struct yaffs_ObjectList;\n+\n+typedef struct {\n+        struct ylist_head list;\n+        int count;\n+} yaffs_ObjectBucket;\n+\n+\n+/* yaffs_CheckpointObject holds the definition of an object as dumped\n+ * by checkpointing.\n+ */\n+\n+typedef struct {\n+        int structType;\n+\t__u32 objectId;\n+\t__u32 parentId;\n+\tint hdrChunk;\n+\tyaffs_ObjectType variantType:3;\n+\t__u8 deleted:1;\n+\t__u8 softDeleted:1;\n+\t__u8 unlinked:1;\n+\t__u8 fake:1;\n+\t__u8 renameAllowed:1;\n+\t__u8 unlinkAllowed:1;\n+\t__u8 serial;\n+\n+\tint nDataChunks;\n+\t__u32 fileSizeOrEquivalentObjectId;\n+\n+}yaffs_CheckpointObject;\n+\n+/*--------------------- Temporary buffers ----------------\n+ *\n+ * These are chunk-sized working buffers. Each device has a few\n+ */\n+\n+typedef struct {\n+\t__u8 *buffer;\n+\tint line;\t/* track from whence this buffer was allocated */\n+\tint maxLine;\n+} yaffs_TempBuffer;\n+\n+/*----------------- Device ---------------------------------*/\n+\n+struct yaffs_DeviceStruct {\n+        struct ylist_head devList;\n+        const char *name;\n+\n+        /* Entry parameters set up way early. Yaffs sets up the rest.*/\n+        int nDataBytesPerChunk; /* Should be a power of 2 >= 512 */\n+        int nChunksPerBlock;    /* does not need to be a power of 2 */\n+        int spareBytesPerChunk;/* spare area size */\n+        int startBlock;         /* Start block we\'re allowed to use */\n+        int endBlock;           /* End block we\'re allowed to use */\n+        int nReservedBlocks;    /* We want this tuneable so that we can reduce */\n+\t\t\t\t/* reserved blocks on NOR and RAM. */\n+\n+\n+\t/* Stuff used by the shared space checkpointing mechanism */\n+\t/* If this value is zero, then this mechanism is disabled */\n+\n+//\tint nCheckpointReservedBlocks; /* Blocks to reserve for checkpoint data */\n+\n+\n+\n+\n+\tint nShortOpCaches;\t/* If <= 0, then short op caching is disabled, else\n+\t\t\t\t * the number of short op caches (don\'t use too many)\n+\t\t\t\t */\n+\n+\tint useHeaderFileSize;\t/* Flag to determine if we should use file sizes from the header */\n+\n+\tint useNANDECC;\t\t/* Flag to decide whether or not to use NANDECC */\n+\n+\tvoid *genericDevice;\t/* Pointer to device context\n+\t\t\t\t * On an mtd this holds the mtd pointer.\n+\t\t\t\t */\n+        void *superBlock;\n+\n+\t/* NAND access functions (Must be set before calling YAFFS)*/\n+\n+\tint (*writeChunkToNAND) (struct yaffs_DeviceStruct * dev,\n+\t\t\t\t int chunkInNAND, const __u8 * data,\n+\t\t\t\t const yaffs_Spare * spare);\n+\tint (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,\n+\t\t\t\t  int chunkInNAND, __u8 * data,\n+\t\t\t\t  yaffs_Spare * spare);\n+\tint (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev,\n+\t\t\t\t int blockInNAND);\n+\tint (*initialiseNAND) (struct yaffs_DeviceStruct * dev);\n+\n+#ifdef CONFIG_YAFFS_YAFFS2\n+\tint (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev,\n+\t\t\t\t\t int chunkInNAND, const __u8 * data,\n+\t\t\t\t\t const yaffs_ExtendedTags * tags);\n+\tint (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct * dev,\n+\t\t\t\t\t  int chunkInNAND, __u8 * data,\n+\t\t\t\t\t  yaffs_ExtendedTags * tags);\n+\tint (*markNANDBlockBad) (struct yaffs_DeviceStruct * dev, int blockNo);\n+\tint (*queryNANDBlock) (struct yaffs_DeviceStruct * dev, int blockNo,\n+\t\t\t       yaffs_BlockState * state, __u32 *sequenceNumber);\n+#endif\n+\n+\tint isYaffs2;\n+\n+\t/* The removeObjectCallback function must be supplied by OS flavours that\n+\t * need it. The Linux kernel does not use this, but yaffs direct does use\n+\t * it to implement the faster readdir\n+\t */\n+\tvoid (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);\n+\n+\t/* Callback to mark the superblock dirsty */\n+\tvoid (*markSuperBlockDirty)(void * superblock);\n+\n+\tint wideTnodesDisabled; /* Set to disable wide tnodes */\n+\n+\tYCHAR *pathDividers;\t/* String of legal path dividers */\n+\n+\n+\t/* End of stuff that must be set before initialisation. */\n+\n+\t/* Checkpoint control. Can be set before or after initialisation */\n+\t__u8 skipCheckpointRead;\n+\t__u8 skipCheckpointWrite;\n+\n+\t/* Runtime parameters. Set up by YAFFS. */\n+\n+\t__u16 chunkGroupBits;\t/* 0 for devices <= 32MB. else log2(nchunks) - 16 */\n+\t__u16 chunkGroupSize;\t/* == 2^^chunkGroupBits */\n+\n+\t/* Stuff to support wide tnodes */\n+\t__u32 tnodeWidth;\n+\t__u32 tnodeMask;\n+\n+\t/* Stuff for figuring out file offset to chunk conversions */\n+\t__u32 chunkShift; /* Shift value */\n+\t__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */\n+\t__u32 chunkMask;  /* Mask to use for power-of-2 case */\n+\n+\t/* Stuff to handle inband tags */\n+\tint inbandTags;\n+\t__u32 totalBytesPerChunk;\n+\n+#ifdef __KERNEL__\n+\n+\tstruct semaphore sem;\t/* Semaphore for waiting on erasure.*/\n+\tstruct semaphore grossLock;\t/* Gross locking semaphore */\n+\t__u8 *spareBuffer;\t/* For mtdif2 use. Don\'t know the size of the buffer\n+\t\t\t\t * at compile time so we have to allocate it.\n+\t\t\t\t */\n+\tvoid (*putSuperFunc) (struct super_block * sb);\n+#endif\n+\n+\tint isMounted;\n+\n+\tint isCheckpointed;\n+\n+\n+\t/* Stuff to support block offsetting to support start block zero */\n+\tint internalStartBlock;\n+\tint internalEndBlock;\n+\tint blockOffset;\n+\tint chunkOffset;\n+\n+\n+\t/* Runtime checkpointing stuff */\n+\tint checkpointPageSequence;   /* running sequence number of checkpoint pages */\n+\tint checkpointByteCount;\n+\tint checkpointByteOffset;\n+\t__u8 *checkpointBuffer;\n+\tint checkpointOpenForWrite;\n+\tint blocksInCheckpoint;\n+\tint checkpointCurrentChunk;\n+\tint checkpointCurrentBlock;\n+\tint checkpointNextBlock;\n+\tint *checkpointBlockList;\n+\tint checkpointMaxBlocks;\n+\t__u32 checkpointSum;\n+\t__u32 checkpointXor;\n+\n+\tint nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */\n+\n+\t/* Block Info */\n+\tyaffs_BlockInfo *blockInfo;\n+\t__u8 *chunkBits;\t/* bitmap of chunks in use */\n+\tunsigned blockInfoAlt:1;\t/* was allocated using alternative strategy */\n+\tunsigned chunkBitsAlt:1;\t/* was allocated using alternative strategy */\n+\tint chunkBitmapStride;\t/* Number of bytes of chunkBits per block.\n+\t\t\t\t * Must be consistent with nChunksPerBlock.\n+\t\t\t\t */\n+\n+\tint nErasedBlocks;\n+\tint allocationBlock;\t/* Current block being allocated off */\n+\t__u32 allocationPage;\n+\tint allocationBlockFinder;\t/* Used to search for next allocation block */\n+\n+\t/* Runtime state */\n+\tint nTnodesCreated;\n+\tyaffs_Tnode *freeTnodes;\n+\tint nFreeTnodes;\n+\tyaffs_TnodeList *allocatedTnodeList;\n+\n+\tint isDoingGC;\n+\n+\tint nObjectsCreated;\n+\tyaffs_Object *freeObjects;\n+\tint nFreeObjects;\n+\n+\tint nHardLinks;\n+\n+\tyaffs_ObjectList *allocatedObjectList;\n+\n+\tyaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];\n+\n+\tint nFreeChunks;\n+\n+\tint currentDirtyChecker;\t/* Used to find current dirtiest block */\n+\n+\t__u32 *gcCleanupList;\t/* objects to delete at the end of a GC. */\n+\tint nonAggressiveSkip;\t/* GC state/mode */\n+\n+\t/* Statistcs */\n+\tint nPageWrites;\n+\tint nPageReads;\n+\tint nBlockErasures;\n+\tint nErasureFailures;\n+\tint nGCCopies;\n+\tint garbageCollections;\n+\tint passiveGarbageCollections;\n+\tint nRetriedWrites;\n+\tint nRetiredBlocks;\n+\tint eccFixed;\n+\tint eccUnfixed;\n+\tint tagsEccFixed;\n+\tint tagsEccUnfixed;\n+\tint nDeletions;\n+\tint nUnmarkedDeletions;\n+\n+\tint hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */\n+\n+\t/* Special directories */\n+\tyaffs_Object *rootDir;\n+\tyaffs_Object *lostNFoundDir;\n+\n+\t/* Buffer areas for storing data to recover from write failures TODO\n+\t *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];\n+\t *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];\n+\t */\n+\n+\tint bufferedBlock;\t/* Which block is buffered here? */\n+\tint doingBufferedBlockRewrite;\n+\n+\tyaffs_ChunkCache *srCache;\n+\tint srLastUse;\n+\n+\tint cacheHits;\n+\n+\t/* Stuff for background deletion and unlinked files.*/\n+\tyaffs_Object *unlinkedDir;\t/* Directory where unlinked and deleted files live. */\n+\tyaffs_Object *deletedDir;\t/* Directory where deleted objects are sent to disappear. */\n+\tyaffs_Object *unlinkedDeletion;\t/* Current file being background deleted.*/\n+\tint nDeletedFiles;\t\t/* Count of files awaiting deletion;*/\n+\tint nUnlinkedFiles;\t\t/* Count of unlinked files. */\n+\tint nBackgroundDeletions;\t/* Count of background deletions. */\n+\n+\n+\t/* Temporary buffer management */\n+\tyaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];\n+\tint maxTemp;\n+\tint tempInUse;\n+\tint unmanagedTempAllocations;\n+\tint unmanagedTempDeallocations;\n+\n+\t/* yaffs2 runtime stuff */\n+\tunsigned sequenceNumber;\t/* Sequence number of currently allocating block */\n+\tunsigned oldestDirtySequence;\n+\n+};\n+\n+typedef struct yaffs_DeviceStruct yaffs_Device;\n+\n+/* The static layout of block usage etc is stored in the super block header */\n+typedef struct {\n+        int StructType;\n+        int version;\n+\tint checkpointStartBlock;\n+\tint checkpointEndBlock;\n+\tint startBlock;\n+\tint endBlock;\n+\tint rfu[100];\n+} yaffs_SuperBlockHeader;\n+\n+/* The CheckpointDevice structure holds the device information that changes at runtime and\n+ * must be preserved over unmount/mount cycles.\n+ */\n+typedef struct {\n+        int structType;\n+\tint nErasedBlocks;\n+\tint allocationBlock;\t/* Current block being allocated off */\n+\t__u32 allocationPage;\n+\tint nFreeChunks;\n+\n+\tint nDeletedFiles;\t\t/* Count of files awaiting deletion;*/\n+\tint nUnlinkedFiles;\t\t/* Count of unlinked files. */\n+\tint nBackgroundDeletions;\t/* Count of background deletions. */\n+\n+\t/* yaffs2 runtime stuff */\n+\tunsigned sequenceNumber;\t/* Sequence number of currently allocating block */\n+\tunsigned oldestDirtySequence;\n+\n+} yaffs_CheckpointDevice;\n+\n+\n+typedef struct {\n+    int structType;\n+    __u32 magic;\n+    __u32 version;\n+    __u32 head;\n+} yaffs_CheckpointValidity;\n+\n+\n+/*----------------------- YAFFS Functions -----------------------*/\n+\n+int yaffs_GutsInitialise(yaffs_Device * dev);\n+void yaffs_Deinitialise(yaffs_Device * dev);\n+\n+int yaffs_GetNumberOfFreeChunks(yaffs_Device * dev);\n+\n+int yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,\n+\t\t       yaffs_Object * newDir, const YCHAR * newName);\n+\n+int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);\n+int yaffs_DeleteFile(yaffs_Object * obj);\n+\n+int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);\n+int yaffs_GetObjectFileLength(yaffs_Object * obj);\n+int yaffs_GetObjectInode(yaffs_Object * obj);\n+unsigned yaffs_GetObjectType(yaffs_Object * obj);\n+int yaffs_GetObjectLinkCount(yaffs_Object * obj);\n+\n+int yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr);\n+int yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr);\n+\n+/* File operations */\n+int yaffs_ReadDataFromFile(yaffs_Object * obj, __u8 * buffer, loff_t offset,\n+                           int nBytes);\n+int yaffs_WriteDataToFile(yaffs_Object * obj, const __u8 * buffer, loff_t offset,\n+                          int nBytes, int writeThrough);\n+int yaffs_ResizeFile(yaffs_Object * obj, loff_t newSize);\n+\n+yaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,\n+                              __u32 mode, __u32 uid, __u32 gid);\n+int yaffs_FlushFile(yaffs_Object * obj, int updateTime);\n+\n+/* Flushing and checkpointing */\n+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev);\n+\n+int yaffs_CheckpointSave(yaffs_Device *dev);\n+int yaffs_CheckpointRestore(yaffs_Device *dev);\n+\n+/* Directory operations */\n+yaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t   __u32 mode, __u32 uid, __u32 gid);\n+yaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const YCHAR * name);\n+int yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,\n+\t\t\t\t   int (*fn) (yaffs_Object *));\n+\n+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number);\n+\n+/* Link operations */\n+yaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t yaffs_Object * equivalentObject);\n+\n+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj);\n+\n+/* Symlink operations */\n+yaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t __u32 mode, __u32 uid, __u32 gid,\n+\t\t\t\t const YCHAR * alias);\n+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj);\n+\n+/* Special inodes (fifos, sockets and devices) */\n+yaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,\n+\t\t\t\t __u32 mode, __u32 uid, __u32 gid, __u32 rdev);\n+\n+/* Special directories */\n+yaffs_Object *yaffs_Root(yaffs_Device * dev);\n+yaffs_Object *yaffs_LostNFound(yaffs_Device * dev);\n+\n+#ifdef CONFIG_YAFFS_WINCE\n+/* CONFIG_YAFFS_WINCE special stuff */\n+void yfsd_WinFileTimeNow(__u32 target[2]);\n+#endif\n+\n+#ifdef __KERNEL__\n+\n+void yaffs_HandleDeferedFree(yaffs_Object * obj);\n+#endif\n+\n+/* Debug dump  */\n+int yaffs_DumpObject(yaffs_Object * obj);\n+\n+void yaffs_GutsTest(yaffs_Device * dev);\n+\n+/* A few useful functions */\n+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags);\n+void yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn);\n+int yaffs_CheckFF(__u8 * buffer, int nBytes);\n+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);\n+\n+__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo);\n+void yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer, int lineNo);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffsinterface.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffsinterface.h linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h\n--- linux-2.6.23/fs/yaffs2/yaffsinterface.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h\n@@ -0,0 +1,21 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFSINTERFACE_H__\n+#define __YAFFSINTERFACE_H__\n+\n+int yaffs_Initialise(unsigned nBlocks);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c\n@@ -0,0 +1,369 @@\n+/*\n+ * YAFFS: Yet another FFS. A NAND-flash specific file system.\n+ * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.\n+ *\n+ * Copyright (C) 2002 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+/*\n+ * This module provides the interface between yaffs_nand.c and the\n+ * MTD API.  This version is used when the MTD interface supports the\n+ * \'mtd_oob_ops\' style calls to read_oob and write_oob, circa 2.6.17,\n+ * and we have small-page NAND device.\n+ *\n+ * These functions are invoked via function pointers in yaffs_nand.c.\n+ * This replaces functionality provided by functions in yaffs_mtdif.c\n+ * and the yaffs_TagsCompatability functions in yaffs_tagscompat.c that are\n+ * called in yaffs_mtdif.c when the function pointers are NULL.\n+ * We assume the MTD layer is performing ECC (useNANDECC is true).\n+ */\n+\n+#include "yportenv.h"\n+#include "yaffs_guts.h"\n+#include "yaffs_packedtags1.h"\n+#include "yaffs_tagscompat.h"\t// for yaffs_CalcTagsECC\n+\n+#include "linux/kernel.h"\n+#include "linux/version.h"\n+#include "linux/types.h"\n+#include "linux/mtd/mtd.h"\n+\n+/* Don\'t compile this module if we don\'t have MTD\'s mtd_oob_ops interface */\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\n+const char *yaffs_mtdif1_c_version = "$Id: yaffs_mtdif1.c,v 1.7 2007/12/13 15:35:18 wookey Exp $";\n+\n+#ifndef CONFIG_YAFFS_9BYTE_TAGS\n+# define YTAG1_SIZE 8\n+#else\n+# define YTAG1_SIZE 9\n+#endif\n+\n+#if 0\n+/* Use the following nand_ecclayout with MTD when using\n+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.\n+ * If you have existing Yaffs images and the byte order differs from this,\n+ * adjust \'oobfree\' to match your existing Yaffs data.\n+ *\n+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the\n+ * pageStatus byte (at NAND spare offset 4) scattered/gathered from/to\n+ * the 9th byte.\n+ *\n+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5\n+ * We have/need PackedTags1 plus pageStatus: T0,T1,T2,T3,T4,T5,T6,T7,P\n+ * where Tn are the tag bytes, En are MTD\'s ECC bytes, P is the pageStatus\n+ * byte and B is the small-page bad-block indicator byte.\n+ */\n+static struct nand_ecclayout nand_oob_16 = {\n+\t.eccbytes = 6,\n+\t.eccpos = { 8, 9, 10, 13, 14, 15 },\n+\t.oobavail = 9,\n+\t.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }\n+};\n+#endif\n+\n+/* Write a chunk (page) of data to NAND.\n+ *\n+ * Caller always provides ExtendedTags data which are converted to a more\n+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the\n+ * contents of the tags meta-data; used to valid the tags when read.\n+ *\n+ *  - Pack ExtendedTags to PackedTags1 form\n+ *  - Compute mini-ECC for PackedTags1\n+ *  - Write data and packed tags to NAND.\n+ *\n+ * Note: Due to the use of the PackedTags1 meta-data which does not include\n+ * a full sequence number (as found in the larger PackedTags2 form) it is\n+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as\n+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed\n+ * to be written just once.  When Yaffs performs this operation, this\n+ * function is called with a NULL data pointer -- calling MTD write_oob\n+ * without data is valid usage (2.6.17).\n+ *\n+ * Any underlying MTD error results in YAFFS_FAIL.\n+ * Returns YAFFS_OK or YAFFS_FAIL.\n+ */\n+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev,\n+\tint chunkInNAND, const __u8 * data, const yaffs_ExtendedTags * etags)\n+{\n+\tstruct mtd_info * mtd = dev->genericDevice;\n+\tint chunkBytes = dev->nDataBytesPerChunk;\n+\tloff_t addr = ((loff_t)chunkInNAND) * chunkBytes;\n+\tstruct mtd_oob_ops ops;\n+\tyaffs_PackedTags1 pt1;\n+\tint retval;\n+\n+\t/* we assume that PackedTags1 and yaffs_Tags are compatible */\n+\tcompile_time_assertion(sizeof(yaffs_PackedTags1) == 12);\n+\tcompile_time_assertion(sizeof(yaffs_Tags) == 8);\n+\n+\tdev->nPageWrites++;\n+\n+\tyaffs_PackTags1(&pt1, etags);\n+\tyaffs_CalcTagsECC((yaffs_Tags *)&pt1);\n+\n+\t/* When deleting a chunk, the upper layer provides only skeletal\n+\t * etags, one with chunkDeleted set.  However, we need to update the\n+\t * tags, not erase them completely.  So we use the NAND write property\n+\t * that only zeroed-bits stick and set tag bytes to all-ones and\n+\t * zero just the (not) deleted bit.\n+\t */\n+#ifndef CONFIG_YAFFS_9BYTE_TAGS\n+\tif (etags->chunkDeleted) {\n+\t\tmemset(&pt1, 0xff, 8);\n+\t\t/* clear delete status bit to indicate deleted */\n+\t\tpt1.deleted = 0;\n+\t}\n+#else\n+\t((__u8 *)&pt1)[8] = 0xff;\n+\tif (etags->chunkDeleted) {\n+\t\tmemset(&pt1, 0xff, 8);\n+\t\t/* zero pageStatus byte to indicate deleted */\n+\t\t((__u8 *)&pt1)[8] = 0;\n+\t}\n+#endif\n+\n+\tmemset(&ops, 0, sizeof(ops));\n+\tops.mode = MTD_OOB_AUTO;\n+\tops.len = (data) ? chunkBytes : 0;\n+\tops.ooblen = YTAG1_SIZE;\n+\tops.datbuf = (__u8 *)data;\n+\tops.oobbuf = (__u8 *)&pt1;\n+\n+\tretval = mtd->write_oob(mtd, addr, &ops);\n+\tif (retval) {\n+\t\tyaffs_trace(YAFFS_TRACE_MTD,\n+\t\t\t"write_oob failed, chunk %d, mtd error %d\\n",\n+\t\t\tchunkInNAND, retval);\n+\t}\n+\treturn retval ? YAFFS_FAIL : YAFFS_OK;\n+}\n+\n+/* Return with empty ExtendedTags but add eccResult.\n+ */\n+static int rettags(yaffs_ExtendedTags * etags, int eccResult, int retval)\n+{\n+\tif (etags) {\n+\t\tmemset(etags, 0, sizeof(*etags));\n+\t\tetags->eccResult = eccResult;\n+\t}\n+\treturn retval;\n+}\n+\n+/* Read a chunk (page) from NAND.\n+ *\n+ * Caller expects ExtendedTags data to be usable even on error; that is,\n+ * all members except eccResult and blockBad are zeroed.\n+ *\n+ *  - Check ECC results for data (if applicable)\n+ *  - Check for blank/erased block (return empty ExtendedTags if blank)\n+ *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)\n+ *  - Convert PackedTags1 to ExtendedTags\n+ *  - Update eccResult and blockBad members to refect state.\n+ *\n+ * Returns YAFFS_OK or YAFFS_FAIL.\n+ */\n+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev,\n+\tint chunkInNAND, __u8 * data, yaffs_ExtendedTags * etags)\n+{\n+\tstruct mtd_info * mtd = dev->genericDevice;\n+\tint chunkBytes = dev->nDataBytesPerChunk;\n+\tloff_t addr = ((loff_t)chunkInNAND) * chunkBytes;\n+\tint eccres = YAFFS_ECC_RESULT_NO_ERROR;\n+\tstruct mtd_oob_ops ops;\n+\tyaffs_PackedTags1 pt1;\n+\tint retval;\n+\tint deleted;\n+\n+\tdev->nPageReads++;\n+\n+\tmemset(&ops, 0, sizeof(ops));\n+\tops.mode = MTD_OOB_AUTO;\n+\tops.len = (data) ? chunkBytes : 0;\n+\tops.ooblen = YTAG1_SIZE;\n+\tops.datbuf = data;\n+\tops.oobbuf = (__u8 *)&pt1;\n+\n+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,20))\n+\t/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;\n+\t * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.\n+\t */\n+\tops.len = (ops.datbuf) ? ops.len : ops.ooblen;\n+#endif\n+\t/* Read page and oob using MTD.\n+\t * Check status and determine ECC result.\n+\t */\n+\tretval = mtd->read_oob(mtd, addr, &ops);\n+\tif (retval) {\n+\t\tyaffs_trace(YAFFS_TRACE_MTD,\n+\t\t\t"read_oob failed, chunk %d, mtd error %d\\n",\n+\t\t\tchunkInNAND, retval);\n+\t}\n+\n+\tswitch (retval) {\n+\tcase 0:\n+\t\t/* no error */\n+\t\tbreak;\n+\n+\tcase -EUCLEAN:\n+\t\t/* MTD\'s ECC fixed the data */\n+\t\teccres = YAFFS_ECC_RESULT_FIXED;\n+\t\tdev->eccFixed++;\n+\t\tbreak;\n+\n+\tcase -EBADMSG:\n+\t\t/* MTD\'s ECC could not fix the data */\n+\t\tdev->eccUnfixed++;\n+\t\t/* fall into... */\n+\tdefault:\n+\t\trettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);\n+\t\tetags->blockBad = (mtd->block_isbad)(mtd, addr);\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\t/* Check for a blank/erased chunk.\n+\t */\n+\tif (yaffs_CheckFF((__u8 *)&pt1, 8)) {\n+\t\t/* when blank, upper layers want eccResult to be <= NO_ERROR */\n+\t\treturn rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);\n+\t}\n+\n+#ifndef CONFIG_YAFFS_9BYTE_TAGS\n+\t/* Read deleted status (bit) then return it to it\'s non-deleted\n+\t * state before performing tags mini-ECC check. pt1.deleted is\n+\t * inverted.\n+\t */\n+\tdeleted = !pt1.deleted;\n+\tpt1.deleted = 1;\n+#else\n+\tdeleted = (yaffs_CountBits(((__u8 *)&pt1)[8]) < 7);\n+#endif\n+\n+\t/* Check the packed tags mini-ECC and correct if necessary/possible.\n+\t */\n+\tretval = yaffs_CheckECCOnTags((yaffs_Tags *)&pt1);\n+\tswitch (retval) {\n+\tcase 0:\n+\t\t/* no tags error, use MTD result */\n+\t\tbreak;\n+\tcase 1:\n+\t\t/* recovered tags-ECC error */\n+\t\tdev->tagsEccFixed++;\n+\t\tif (eccres == YAFFS_ECC_RESULT_NO_ERROR)\n+\t\t\teccres = YAFFS_ECC_RESULT_FIXED;\n+\t\tbreak;\n+\tdefault:\n+\t\t/* unrecovered tags-ECC error */\n+\t\tdev->tagsEccUnfixed++;\n+\t\treturn rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);\n+\t}\n+\n+\t/* Unpack the tags to extended form and set ECC result.\n+\t * [set shouldBeFF just to keep yaffs_UnpackTags1 happy]\n+\t */\n+\tpt1.shouldBeFF = 0xFFFFFFFF;\n+\tyaffs_UnpackTags1(etags, &pt1);\n+\tetags->eccResult = eccres;\n+\n+\t/* Set deleted state */\n+\tetags->chunkDeleted = deleted;\n+\treturn YAFFS_OK;\n+}\n+\n+/* Mark a block bad.\n+ *\n+ * This is a persistant state.\n+ * Use of this function should be rare.\n+ *\n+ * Returns YAFFS_OK or YAFFS_FAIL.\n+ */\n+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)\n+{\n+\tstruct mtd_info * mtd = dev->genericDevice;\n+\tint blocksize = dev->nChunksPerBlock * dev->nDataBytesPerChunk;\n+\tint retval;\n+\n+\tyaffs_trace(YAFFS_TRACE_BAD_BLOCKS, "marking block %d bad\\n", blockNo);\n+\n+\tretval = mtd->block_markbad(mtd, (loff_t)blocksize * blockNo);\n+\treturn (retval) ? YAFFS_FAIL : YAFFS_OK;\n+}\n+\n+/* Check any MTD prerequists.\n+ *\n+ * Returns YAFFS_OK or YAFFS_FAIL.\n+ */\n+static int nandmtd1_TestPrerequists(struct mtd_info * mtd)\n+{\n+\t/* 2.6.18 has mtd->ecclayout->oobavail */\n+\t/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */\n+\tint oobavail = mtd->ecclayout->oobavail;\n+\n+\tif (oobavail < YTAG1_SIZE) {\n+\t\tyaffs_trace(YAFFS_TRACE_ERROR,\n+\t\t\t"mtd device has only %d bytes for tags, need %d\\n",\n+\t\t\toobavail, YTAG1_SIZE);\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\treturn YAFFS_OK;\n+}\n+\n+/* Query for the current state of a specific block.\n+ *\n+ * Examine the tags of the first chunk of the block and return the state:\n+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad\n+ *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use\n+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean\n+ *\n+ * Always returns YAFFS_OK.\n+ */\n+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,\n+\tyaffs_BlockState * pState, int *pSequenceNumber)\n+{\n+\tstruct mtd_info * mtd = dev->genericDevice;\n+\tint chunkNo = blockNo * dev->nChunksPerBlock;\n+\tloff_t addr = (loff_t)chunkNo * dev->nDataBytesPerChunk;\n+\tyaffs_ExtendedTags etags;\n+\tint state = YAFFS_BLOCK_STATE_DEAD;\n+\tint seqnum = 0;\n+\tint retval;\n+\n+\t/* We don\'t yet have a good place to test for MTD config prerequists.\n+\t * Do it here as we are called during the initial scan.\n+\t */\n+\tif (nandmtd1_TestPrerequists(mtd) != YAFFS_OK) {\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tretval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);\n+\tetags.blockBad = (mtd->block_isbad)(mtd, addr);\n+\tif (etags.blockBad) {\n+\t\tyaffs_trace(YAFFS_TRACE_BAD_BLOCKS,\n+\t\t\tKERN_WARNING "block %d is marked bad\\n", blockNo);\n+\t\tstate = YAFFS_BLOCK_STATE_DEAD;\n+\t}\n+\telse if (etags.eccResult != YAFFS_ECC_RESULT_NO_ERROR) {\n+\t\t/* bad tags, need to look more closely */\n+\t\tstate = YAFFS_BLOCK_STATE_NEEDS_SCANNING;\n+\t}\n+\telse if (etags.chunkUsed) {\n+\t\tstate = YAFFS_BLOCK_STATE_NEEDS_SCANNING;\n+\t\tseqnum = etags.sequenceNumber;\n+\t}\n+\telse {\n+\t\tstate = YAFFS_BLOCK_STATE_EMPTY;\n+\t}\n+\n+\t*pState = state;\n+\t*pSequenceNumber = seqnum;\n+\n+\t/* query always succeeds */\n+\treturn YAFFS_OK;\n+}\n+\n+#endif /*MTD_VERSION*/'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h\n@@ -0,0 +1,28 @@\n+/*\n+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_MTDIF1_H__\n+#define __YAFFS_MTDIF1_H__\n+\n+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,\n+\tconst __u8 * data, const yaffs_ExtendedTags * tags);\n+\n+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,\n+\t__u8 * data, yaffs_ExtendedTags * tags);\n+\n+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);\n+\n+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,\n+\tyaffs_BlockState * state, int *sequenceNumber);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c\n@@ -0,0 +1,248 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+/* mtd interface for YAFFS2 */\n+\n+const char *yaffs_mtdif2_c_version =\n+    "$Id: yaffs_mtdif2.c,v 1.20 2008/05/05 07:58:58 charles Exp $";\n+\n+#include "yportenv.h"\n+\n+\n+#include "yaffs_mtdif2.h"\n+\n+#include "linux/mtd/mtd.h"\n+#include "linux/types.h"\n+#include "linux/time.h"\n+\n+#include "yaffs_packedtags2.h"\n+\n+/* NB For use with inband tags....\n+ * We assume that the data buffer is of size totalBytersPerChunk so that we can also\n+ * use it to load the tags.\n+ */\n+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t      const __u8 * data,\n+\t\t\t\t      const yaffs_ExtendedTags * tags)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\tstruct mtd_oob_ops ops;\n+#else\n+\tsize_t dummy;\n+#endif\n+\tint retval = 0;\n+\n+\tloff_t addr;\n+\n+\tyaffs_PackedTags2 pt;\n+\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR\n+\t   ("nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p"\n+\t    TENDSTR), chunkInNAND, data, tags));\n+\n+\n+\taddr  = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;\n+\n+\t/* For yaffs2 writing there must be both data and tags.\n+\t * If we\'re using inband tags, then the tags are stuffed into\n+\t * the end of the data buffer.\n+\t */\n+\tif(!data || !tags)\n+\t\tBUG();\n+\telse if(dev->inbandTags){\n+\t\tyaffs_PackedTags2TagsPart *pt2tp;\n+\t\tpt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->nDataBytesPerChunk);\n+\t\tyaffs_PackTags2TagsPart(pt2tp,tags);\n+\t}\n+\telse\n+\t\tyaffs_PackTags2(&pt, tags);\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\tops.mode = MTD_OOB_AUTO;\n+\tops.ooblen = (dev->inbandTags) ? 0 : sizeof(pt);\n+\tops.len = dev->totalBytesPerChunk;\n+\tops.ooboffs = 0;\n+\tops.datbuf = (__u8 *)data;\n+\tops.oobbuf = (dev->inbandTags) ? NULL : (void *)&pt;\n+\tretval = mtd->write_oob(mtd, addr, &ops);\n+\n+#else\n+\tif (!dev->inbandTags) {\n+\t\tretval =\n+\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t   &dummy, data, (__u8 *) & pt, NULL);\n+\t} else {\n+\t\tretval =\n+\t\t    mtd->write(mtd, addr, dev->totalBytesPerChunk, &dummy,\n+\t\t\t       data);\n+\t}\n+#endif\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+\n+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t       __u8 * data, yaffs_ExtendedTags * tags)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\tstruct mtd_oob_ops ops;\n+#endif\n+\tsize_t dummy;\n+\tint retval = 0;\n+\tint localData = 0;\n+\n+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;\n+\n+\tyaffs_PackedTags2 pt;\n+\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR\n+\t   ("nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p"\n+\t    TENDSTR), chunkInNAND, data, tags));\n+\n+\tif(dev->inbandTags){\n+\n+\t\tif(!data) {\n+\t\t\tlocalData = 1;\n+\t\t\tdata = yaffs_GetTempBuffer(dev,__LINE__);\n+\t\t}\n+\n+\n+\t}\n+\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))\n+\tif (dev->inbandTags || (data && !tags))\n+\t\tretval = mtd->read(mtd, addr, dev->totalBytesPerChunk,\n+\t\t\t\t&dummy, data);\n+\telse if (tags) {\n+\t\tops.mode = MTD_OOB_AUTO;\n+\t\tops.ooblen = sizeof(pt);\n+\t\tops.len = data ? dev->nDataBytesPerChunk : sizeof(pt);\n+\t\tops.ooboffs = 0;\n+\t\tops.datbuf = data;\n+\t\tops.oobbuf = dev->spareBuffer;\n+\t\tretval = mtd->read_oob(mtd, addr, &ops);\n+\t}\n+#else\n+\tif (!dev->inbandTags && data && tags) {\n+\n+\t\tretval = mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t\t  &dummy, data, dev->spareBuffer,\n+\t\t\t\t\t  NULL);\n+\t} else {\n+\t\tif (data)\n+\t\t\tretval =\n+\t\t\t    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,\n+\t\t\t\t      data);\n+\t\tif (!dev->inbandTags && tags)\n+\t\t\tretval =\n+\t\t\t    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,\n+\t\t\t\t\t  dev->spareBuffer);\n+\t}\n+#endif\n+\n+\n+\tif(dev->inbandTags){\n+\t\tif(tags){\n+\t\t\tyaffs_PackedTags2TagsPart * pt2tp;\n+\t\t\tpt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->nDataBytesPerChunk];\n+\t\t\tyaffs_UnpackTags2TagsPart(tags,pt2tp);\n+\t\t}\n+\t}\n+\telse {\n+\t\tif (tags){\n+\t\t\tmemcpy(&pt, dev->spareBuffer, sizeof(pt));\n+\t\t\tyaffs_UnpackTags2(tags, &pt);\n+\t\t}\n+\t}\n+\n+\tif(localData)\n+\t\tyaffs_ReleaseTempBuffer(dev,data,__LINE__);\n+\n+\tif(tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR)\n+\t\ttags->eccResult = YAFFS_ECC_RESULT_UNFIXED;\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+\n+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+\tint retval;\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR("nandmtd2_MarkNANDBlockBad %d" TENDSTR), blockNo));\n+\n+\tretval =\n+\t    mtd->block_markbad(mtd,\n+\t\t\t       blockNo * dev->nChunksPerBlock *\n+\t\t\t       dev->nDataBytesPerChunk);\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+\n+}\n+\n+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,\n+\t\t\t    yaffs_BlockState * state, int *sequenceNumber)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+\tint retval;\n+\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR("nandmtd2_QueryNANDBlock %d" TENDSTR), blockNo));\n+\tretval =\n+\t    mtd->block_isbad(mtd,\n+\t\t\t     blockNo * dev->nChunksPerBlock *\n+\t\t\t     dev->nDataBytesPerChunk);\n+\n+\tif (retval) {\n+\t\tT(YAFFS_TRACE_MTD, (TSTR("block is bad" TENDSTR)));\n+\n+\t\t*state = YAFFS_BLOCK_STATE_DEAD;\n+\t\t*sequenceNumber = 0;\n+\t} else {\n+\t\tyaffs_ExtendedTags t;\n+\t\tnandmtd2_ReadChunkWithTagsFromNAND(dev,\n+\t\t\t\t\t\t   blockNo *\n+\t\t\t\t\t\t   dev->nChunksPerBlock, NULL,\n+\t\t\t\t\t\t   &t);\n+\n+\t\tif (t.chunkUsed) {\n+\t\t\t*sequenceNumber = t.sequenceNumber;\n+\t\t\t*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;\n+\t\t} else {\n+\t\t\t*sequenceNumber = 0;\n+\t\t\t*state = YAFFS_BLOCK_STATE_EMPTY;\n+\t\t}\n+\t}\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR("block is bad seq %d state %d" TENDSTR), *sequenceNumber,\n+\t   *state));\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h\n@@ -0,0 +1,29 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_MTDIF2_H__\n+#define __YAFFS_MTDIF2_H__\n+\n+#include "yaffs_guts.h"\n+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t      const __u8 * data,\n+\t\t\t\t      const yaffs_ExtendedTags * tags);\n+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t       __u8 * data, yaffs_ExtendedTags * tags);\n+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);\n+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,\n+\t\t\t    yaffs_BlockState * state, int *sequenceNumber);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c\n@@ -0,0 +1,241 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+const char *yaffs_mtdif_c_version =\n+    "$Id: yaffs_mtdif.c,v 1.21 2007/12/13 15:35:18 wookey Exp $";\n+\n+#include "yportenv.h"\n+\n+\n+#include "yaffs_mtdif.h"\n+\n+#include "linux/mtd/mtd.h"\n+#include "linux/types.h"\n+#include "linux/time.h"\n+#include "linux/mtd/nand.h"\n+\n+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,18))\n+static struct nand_oobinfo yaffs_oobinfo = {\n+\t.useecc = 1,\n+\t.eccbytes = 6,\n+\t.eccpos = {8, 9, 10, 13, 14, 15}\n+};\n+\n+static struct nand_oobinfo yaffs_noeccinfo = {\n+\t.useecc = 0,\n+};\n+#endif\n+\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+static inline void translate_spare2oob(const yaffs_Spare *spare, __u8 *oob)\n+{\n+\toob[0] = spare->tagByte0;\n+\toob[1] = spare->tagByte1;\n+\toob[2] = spare->tagByte2;\n+\toob[3] = spare->tagByte3;\n+\toob[4] = spare->tagByte4;\n+\toob[5] = spare->tagByte5 & 0x3f;\n+\toob[5] |= spare->blockStatus == \'Y\' ? 0: 0x80;\n+\toob[5] |= spare->pageStatus == 0 ? 0: 0x40;\n+\toob[6] = spare->tagByte6;\n+\toob[7] = spare->tagByte7;\n+}\n+\n+static inline void translate_oob2spare(yaffs_Spare *spare, __u8 *oob)\n+{\n+\tstruct yaffs_NANDSpare *nspare = (struct yaffs_NANDSpare *)spare;\n+\tspare->tagByte0 = oob[0];\n+\tspare->tagByte1 = oob[1];\n+\tspare->tagByte2 = oob[2];\n+\tspare->tagByte3 = oob[3];\n+\tspare->tagByte4 = oob[4];\n+\tspare->tagByte5 = oob[5] == 0xff ? 0xff : oob[5] & 0x3f;\n+\tspare->blockStatus = oob[5] & 0x80 ? 0xff : \'Y\';\n+\tspare->pageStatus = oob[5] & 0x40 ? 0xff : 0;\n+\tspare->ecc1[0] = spare->ecc1[1] = spare->ecc1[2] = 0xff;\n+\tspare->tagByte6 = oob[6];\n+\tspare->tagByte7 = oob[7];\n+\tspare->ecc2[0] = spare->ecc2[1] = spare->ecc2[2] = 0xff;\n+\n+\tnspare->eccres1 = nspare->eccres2 = 0; /* FIXME */\n+}\n+#endif\n+\n+int nandmtd_WriteChunkToNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t     const __u8 * data, const yaffs_Spare * spare)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\tstruct mtd_oob_ops ops;\n+#endif\n+\tsize_t dummy;\n+\tint retval = 0;\n+\n+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\t__u8 spareAsBytes[8]; /* OOB */\n+\n+\tif (data && !spare)\n+\t\tretval = mtd->write(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t&dummy, data);\n+\telse if (spare) {\n+\t\tif (dev->useNANDECC) {\n+\t\t\ttranslate_spare2oob(spare, spareAsBytes);\n+\t\t\tops.mode = MTD_OOB_AUTO;\n+\t\t\tops.ooblen = 8; /* temp hack */\n+\t\t} else {\n+\t\t\tops.mode = MTD_OOB_RAW;\n+\t\t\tops.ooblen = YAFFS_BYTES_PER_SPARE;\n+\t\t}\n+\t\tops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;\n+\t\tops.datbuf = (u8 *)data;\n+\t\tops.ooboffs = 0;\n+\t\tops.oobbuf = spareAsBytes;\n+\t\tretval = mtd->write_oob(mtd, addr, &ops);\n+\t}\n+#else\n+\t__u8 *spareAsBytes = (__u8 *) spare;\n+\n+\tif (data && spare) {\n+\t\tif (dev->useNANDECC)\n+\t\t\tretval =\n+\t\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t\t   &dummy, data, spareAsBytes,\n+\t\t\t\t\t   &yaffs_oobinfo);\n+\t\telse\n+\t\t\tretval =\n+\t\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t\t   &dummy, data, spareAsBytes,\n+\t\t\t\t\t   &yaffs_noeccinfo);\n+\t} else {\n+\t\tif (data)\n+\t\t\tretval =\n+\t\t\t    mtd->write(mtd, addr, dev->nDataBytesPerChunk, &dummy,\n+\t\t\t\t       data);\n+\t\tif (spare)\n+\t\t\tretval =\n+\t\t\t    mtd->write_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,\n+\t\t\t\t\t   &dummy, spareAsBytes);\n+\t}\n+#endif\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+\n+int nandmtd_ReadChunkFromNAND(yaffs_Device * dev, int chunkInNAND, __u8 * data,\n+\t\t\t      yaffs_Spare * spare)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\tstruct mtd_oob_ops ops;\n+#endif\n+\tsize_t dummy;\n+\tint retval = 0;\n+\n+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;\n+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))\n+\t__u8 spareAsBytes[8]; /* OOB */\n+\n+\tif (data && !spare)\n+\t\tretval = mtd->read(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t&dummy, data);\n+\telse if (spare) {\n+\t\tif (dev->useNANDECC) {\n+\t\t\tops.mode = MTD_OOB_AUTO;\n+\t\t\tops.ooblen = 8; /* temp hack */\n+\t\t} else {\n+\t\t\tops.mode = MTD_OOB_RAW;\n+\t\t\tops.ooblen = YAFFS_BYTES_PER_SPARE;\n+\t\t}\n+\t\tops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;\n+\t\tops.datbuf = data;\n+\t\tops.ooboffs = 0;\n+\t\tops.oobbuf = spareAsBytes;\n+\t\tretval = mtd->read_oob(mtd, addr, &ops);\n+\t\tif (dev->useNANDECC)\n+\t\t\ttranslate_oob2spare(spare, spareAsBytes);\n+\t}\n+#else\n+\t__u8 *spareAsBytes = (__u8 *) spare;\n+\n+\tif (data && spare) {\n+\t\tif (dev->useNANDECC) {\n+\t\t\t/* Careful, this call adds 2 ints */\n+\t\t\t/* to the end of the spare data.  Calling function */\n+\t\t\t/* should allocate enough memory for spare, */\n+\t\t\t/* i.e. [YAFFS_BYTES_PER_SPARE+2*sizeof(int)]. */\n+\t\t\tretval =\n+\t\t\t    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t\t  &dummy, data, spareAsBytes,\n+\t\t\t\t\t  &yaffs_oobinfo);\n+\t\t} else {\n+\t\t\tretval =\n+\t\t\t    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,\n+\t\t\t\t\t  &dummy, data, spareAsBytes,\n+\t\t\t\t\t  &yaffs_noeccinfo);\n+\t\t}\n+\t} else {\n+\t\tif (data)\n+\t\t\tretval =\n+\t\t\t    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,\n+\t\t\t\t      data);\n+\t\tif (spare)\n+\t\t\tretval =\n+\t\t\t    mtd->read_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,\n+\t\t\t\t\t  &dummy, spareAsBytes);\n+\t}\n+#endif\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+\n+int nandmtd_EraseBlockInNAND(yaffs_Device * dev, int blockNumber)\n+{\n+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);\n+\t__u32 addr =\n+\t    ((loff_t) blockNumber) * dev->nDataBytesPerChunk\n+\t\t* dev->nChunksPerBlock;\n+\tstruct erase_info ei;\n+\tint retval = 0;\n+\n+\tei.mtd = mtd;\n+\tei.addr = addr;\n+\tei.len = dev->nDataBytesPerChunk * dev->nChunksPerBlock;\n+\tei.time = 1000;\n+\tei.retries = 2;\n+\tei.callback = NULL;\n+\tei.priv = (u_long) dev;\n+\n+\t/* Todo finish off the ei if required */\n+\n+\tsema_init(&dev->sem, 0);\n+\n+\tretval = mtd->erase(mtd, &ei);\n+\n+\tif (retval == 0)\n+\t\treturn YAFFS_OK;\n+\telse\n+\t\treturn YAFFS_FAIL;\n+}\n+\n+int nandmtd_InitialiseNAND(yaffs_Device * dev)\n+{\n+\treturn YAFFS_OK;\n+}\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_mtdif.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h\n--- linux-2.6.23/fs/yaffs2/yaffs_mtdif.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h\n@@ -0,0 +1,32 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_MTDIF_H__\n+#define __YAFFS_MTDIF_H__\n+\n+#include "yaffs_guts.h"\n+\n+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,18))\n+extern struct nand_oobinfo yaffs_oobinfo;\n+extern struct nand_oobinfo yaffs_noeccinfo;\n+#endif\n+\n+int nandmtd_WriteChunkToNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t     const __u8 * data, const yaffs_Spare * spare);\n+int nandmtd_ReadChunkFromNAND(yaffs_Device * dev, int chunkInNAND, __u8 * data,\n+\t\t\t      yaffs_Spare * spare);\n+int nandmtd_EraseBlockInNAND(yaffs_Device * dev, int blockNumber);\n+int nandmtd_InitialiseNAND(yaffs_Device * dev);\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_nand.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nand.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c\n--- linux-2.6.23/fs/yaffs2/yaffs_nand.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c\n@@ -0,0 +1,135 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+const char *yaffs_nand_c_version =\n+    "$Id: yaffs_nand.c,v 1.9 2008/05/05 07:58:58 charles Exp $";\n+\n+#include "yaffs_nand.h"\n+#include "yaffs_tagscompat.h"\n+#include "yaffs_tagsvalidity.h"\n+\n+#include "yaffs_getblockinfo.h"\n+\n+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t\t   __u8 * buffer,\n+\t\t\t\t\t   yaffs_ExtendedTags * tags)\n+{\n+\tint result;\n+\tyaffs_ExtendedTags localTags;\n+\n+\tint realignedChunkInNAND = chunkInNAND - dev->chunkOffset;\n+\n+\t/* If there are no tags provided, use local tags to get prioritised gc working */\n+\tif(!tags)\n+\t\ttags = &localTags;\n+\n+\tif (dev->readChunkWithTagsFromNAND)\n+\t\tresult = dev->readChunkWithTagsFromNAND(dev, realignedChunkInNAND, buffer,\n+\t\t\t\t\t\t      tags);\n+\telse\n+\t\tresult = yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(dev,\n+\t\t\t\t\t\t\t\t\trealignedChunkInNAND,\n+\t\t\t\t\t\t\t\t\tbuffer,\n+\t\t\t\t\t\t\t\t\ttags);\n+\tif(tags &&\n+\t   tags->eccResult > YAFFS_ECC_RESULT_NO_ERROR){\n+\n+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, chunkInNAND/dev->nChunksPerBlock);\n+                yaffs_HandleChunkError(dev,bi);\n+\t}\n+\n+\treturn result;\n+}\n+\n+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t   int chunkInNAND,\n+\t\t\t\t\t\t   const __u8 * buffer,\n+\t\t\t\t\t\t   yaffs_ExtendedTags * tags)\n+{\n+\tchunkInNAND -= dev->chunkOffset;\n+\n+\n+\tif (tags) {\n+\t\ttags->sequenceNumber = dev->sequenceNumber;\n+\t\ttags->chunkUsed = 1;\n+\t\tif (!yaffs_ValidateTags(tags)) {\n+\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t  (TSTR("Writing uninitialised tags" TENDSTR)));\n+\t\t\tYBUG();\n+\t\t}\n+\t\tT(YAFFS_TRACE_WRITE,\n+\t\t  (TSTR("Writing chunk %d tags %d %d" TENDSTR), chunkInNAND,\n+\t\t   tags->objectId, tags->chunkId));\n+\t} else {\n+\t\tT(YAFFS_TRACE_ERROR, (TSTR("Writing with no tags" TENDSTR)));\n+\t\tYBUG();\n+\t}\n+\n+\tif (dev->writeChunkWithTagsToNAND)\n+\t\treturn dev->writeChunkWithTagsToNAND(dev, chunkInNAND, buffer,\n+\t\t\t\t\t\t     tags);\n+\telse\n+\t\treturn yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(dev,\n+\t\t\t\t\t\t\t\t       chunkInNAND,\n+\t\t\t\t\t\t\t\t       buffer,\n+\t\t\t\t\t\t\t\t       tags);\n+}\n+\n+int yaffs_MarkBlockBad(yaffs_Device * dev, int blockNo)\n+{\n+\tblockNo -= dev->blockOffset;\n+\n+;\n+\tif (dev->markNANDBlockBad)\n+\t\treturn dev->markNANDBlockBad(dev, blockNo);\n+\telse\n+\t\treturn yaffs_TagsCompatabilityMarkNANDBlockBad(dev, blockNo);\n+}\n+\n+int yaffs_QueryInitialBlockState(yaffs_Device * dev,\n+\t\t\t\t\t\t int blockNo,\n+\t\t\t\t\t\t yaffs_BlockState * state,\n+\t\t\t\t\t\t __u32 *sequenceNumber)\n+{\n+\tblockNo -= dev->blockOffset;\n+\n+\tif (dev->queryNANDBlock)\n+\t\treturn dev->queryNANDBlock(dev, blockNo, state, sequenceNumber);\n+\telse\n+\t\treturn yaffs_TagsCompatabilityQueryNANDBlock(dev, blockNo,\n+\t\t\t\t\t\t\t     state,\n+\t\t\t\t\t\t\t     sequenceNumber);\n+}\n+\n+\n+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int blockInNAND)\n+{\n+\tint result;\n+\n+\tblockInNAND -= dev->blockOffset;\n+\n+\n+\tdev->nBlockErasures++;\n+\tresult = dev->eraseBlockInNAND(dev, blockInNAND);\n+\n+\treturn result;\n+}\n+\n+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev)\n+{\n+\treturn dev->initialiseNAND(dev);\n+}\n+\n+\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h\n--- linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h\n@@ -0,0 +1,39 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+/* Interface to emulated NAND functions (2k page size) */\n+\n+#ifndef __YAFFS_NANDEMUL2K_H__\n+#define __YAFFS_NANDEMUL2K_H__\n+\n+#include "yaffs_guts.h"\n+\n+int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\tint chunkInNAND, const __u8 * data,\n+\t\t\t\t\tconst yaffs_ExtendedTags * tags);\n+int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t int chunkInNAND, __u8 * data,\n+\t\t\t\t\t yaffs_ExtendedTags * tags);\n+int nandemul2k_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);\n+int nandemul2k_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,\n+\t\t\t      yaffs_BlockState * state, __u32 *sequenceNumber);\n+int nandemul2k_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\tint blockInNAND);\n+int nandemul2k_InitialiseNAND(struct yaffs_DeviceStruct *dev);\n+int nandemul2k_GetBytesPerChunk(void);\n+int nandemul2k_GetChunksPerBlock(void);\n+int nandemul2k_GetNumberOfBlocks(void);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_nand.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nand.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h\n--- linux-2.6.23/fs/yaffs2/yaffs_nand.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h\n@@ -0,0 +1,44 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_NAND_H__\n+#define __YAFFS_NAND_H__\n+#include "yaffs_guts.h"\n+\n+\n+\n+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t\t   __u8 * buffer,\n+\t\t\t\t\t   yaffs_ExtendedTags * tags);\n+\n+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t   int chunkInNAND,\n+\t\t\t\t\t\t   const __u8 * buffer,\n+\t\t\t\t\t\t   yaffs_ExtendedTags * tags);\n+\n+int yaffs_MarkBlockBad(yaffs_Device * dev, int blockNo);\n+\n+int yaffs_QueryInitialBlockState(yaffs_Device * dev,\n+\t\t\t\t\t\t int blockNo,\n+\t\t\t\t\t\t yaffs_BlockState * state,\n+\t\t\t\t\t\t unsigned *sequenceNumber);\n+\n+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int blockInNAND);\n+\n+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev);\n+\n+#endif\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c\n--- linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c\n@@ -0,0 +1,52 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "yaffs_packedtags1.h"\n+#include "yportenv.h"\n+\n+void yaffs_PackTags1(yaffs_PackedTags1 * pt, const yaffs_ExtendedTags * t)\n+{\n+\tpt->chunkId = t->chunkId;\n+\tpt->serialNumber = t->serialNumber;\n+\tpt->byteCount = t->byteCount;\n+\tpt->objectId = t->objectId;\n+\tpt->ecc = 0;\n+\tpt->deleted = (t->chunkDeleted) ? 0 : 1;\n+\tpt->unusedStuff = 0;\n+\tpt->shouldBeFF = 0xFFFFFFFF;\n+\n+}\n+\n+void yaffs_UnpackTags1(yaffs_ExtendedTags * t, const yaffs_PackedTags1 * pt)\n+{\n+\tstatic const __u8 allFF[] =\n+\t    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+0xff };\n+\n+\tif (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {\n+\t\tt->blockBad = 0;\n+\t\tif (pt->shouldBeFF != 0xFFFFFFFF) {\n+\t\t\tt->blockBad = 1;\n+\t\t}\n+\t\tt->chunkUsed = 1;\n+\t\tt->objectId = pt->objectId;\n+\t\tt->chunkId = pt->chunkId;\n+\t\tt->byteCount = pt->byteCount;\n+\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;\n+\t\tt->chunkDeleted = (pt->deleted) ? 0 : 1;\n+\t\tt->serialNumber = pt->serialNumber;\n+\t} else {\n+\t\tmemset(t, 0, sizeof(yaffs_ExtendedTags));\n+\n+\t}\n+}'),
 ('linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h\n--- linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h\n@@ -0,0 +1,37 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */\n+\n+#ifndef __YAFFS_PACKEDTAGS1_H__\n+#define __YAFFS_PACKEDTAGS1_H__\n+\n+#include "yaffs_guts.h"\n+\n+typedef struct {\n+\tunsigned chunkId:20;\n+\tunsigned serialNumber:2;\n+\tunsigned byteCount:10;\n+\tunsigned objectId:18;\n+\tunsigned ecc:12;\n+\tunsigned deleted:1;\n+\tunsigned unusedStuff:1;\n+\tunsigned shouldBeFF;\n+\n+} yaffs_PackedTags1;\n+\n+void yaffs_PackTags1(yaffs_PackedTags1 * pt, const yaffs_ExtendedTags * t);\n+void yaffs_UnpackTags1(yaffs_ExtendedTags * t, const yaffs_PackedTags1 * pt);\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c\n--- linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c\n@@ -0,0 +1,208 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "yaffs_packedtags2.h"\n+#include "yportenv.h"\n+#include "yaffs_tagsvalidity.h"\n+\n+/* This code packs a set of extended tags into a binary structure for\n+ * NAND storage\n+ */\n+\n+/* Some of the information is "extra" struff which can be packed in to\n+ * speed scanning\n+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.\n+ */\n+\n+/* Extra flags applied to chunkId */\n+\n+#define EXTRA_HEADER_INFO_FLAG\t0x80000000\n+#define EXTRA_SHRINK_FLAG\t0x40000000\n+#define EXTRA_SHADOWS_FLAG\t0x20000000\n+#define EXTRA_SPARE_FLAGS\t0x10000000\n+\n+#define ALL_EXTRA_FLAGS\t\t0xF0000000\n+\n+/* Also, the top 4 bits of the object Id are set to the object type. */\n+#define EXTRA_OBJECT_TYPE_SHIFT (28)\n+#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)\n+\n+\n+static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart * ptt)\n+{\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR("packed tags obj %d chunk %d byte %d seq %d" TENDSTR),\n+\t   ptt->objectId, ptt->chunkId, ptt->byteCount,\n+\t   ptt->sequenceNumber));\n+}\n+static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 * pt)\n+{\n+\tyaffs_DumpPackedTags2TagsPart(&pt->t);\n+}\n+\n+static void yaffs_DumpTags2(const yaffs_ExtendedTags * t)\n+{\n+\tT(YAFFS_TRACE_MTD,\n+\t  (TSTR\n+\t   ("ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d"\n+\t    TENDSTR), t->eccResult, t->blockBad, t->chunkUsed, t->objectId,\n+\t   t->chunkId, t->byteCount, t->chunkDeleted, t->serialNumber,\n+\t   t->sequenceNumber));\n+\n+}\n+\n+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart * ptt, const yaffs_ExtendedTags * t)\n+{\n+\tptt->chunkId = t->chunkId;\n+\tptt->sequenceNumber = t->sequenceNumber;\n+\tptt->byteCount = t->byteCount;\n+\tptt->objectId = t->objectId;\n+\n+\tif (t->chunkId == 0 && t->extraHeaderInfoAvailable) {\n+\t\t/* Store the extra header info instead */\n+\t\t/* We save the parent object in the chunkId */\n+\t\tptt->chunkId = EXTRA_HEADER_INFO_FLAG\n+\t\t\t| t->extraParentObjectId;\n+\t\tif (t->extraIsShrinkHeader) {\n+\t\t\tptt->chunkId |= EXTRA_SHRINK_FLAG;\n+\t\t}\n+\t\tif (t->extraShadows) {\n+\t\t\tptt->chunkId |= EXTRA_SHADOWS_FLAG;\n+\t\t}\n+\n+\t\tptt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;\n+\t\tptt->objectId |=\n+\t\t    (t->extraObjectType << EXTRA_OBJECT_TYPE_SHIFT);\n+\n+\t\tif (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK) {\n+\t\t\tptt->byteCount = t->extraEquivalentObjectId;\n+\t\t} else if (t->extraObjectType == YAFFS_OBJECT_TYPE_FILE) {\n+\t\t\tptt->byteCount = t->extraFileLength;\n+\t\t} else {\n+\t\t\tptt->byteCount = 0;\n+\t\t}\n+\t}\n+\n+\tyaffs_DumpPackedTags2TagsPart(ptt);\n+\tyaffs_DumpTags2(t);\n+}\n+\n+\n+void yaffs_PackTags2(yaffs_PackedTags2 * pt, const yaffs_ExtendedTags * t)\n+{\n+\tyaffs_PackTags2TagsPart(&pt->t,t);\n+\n+#ifndef YAFFS_IGNORE_TAGS_ECC\n+\t{\n+\t\tyaffs_ECCCalculateOther((unsigned char *)&pt->t,\n+\t\t\t\t\tsizeof(yaffs_PackedTags2TagsPart),\n+\t\t\t\t\t&pt->ecc);\n+\t}\n+#endif\n+}\n+\n+\n+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags * t, yaffs_PackedTags2TagsPart * ptt)\n+{\n+\n+\tmemset(t, 0, sizeof(yaffs_ExtendedTags));\n+\n+\tyaffs_InitialiseTags(t);\n+\n+\tif (ptt->sequenceNumber != 0xFFFFFFFF) {\n+\t\tt->blockBad = 0;\n+\t\tt->chunkUsed = 1;\n+\t\tt->objectId = ptt->objectId;\n+\t\tt->chunkId = ptt->chunkId;\n+\t\tt->byteCount = ptt->byteCount;\n+\t\tt->chunkDeleted = 0;\n+\t\tt->serialNumber = 0;\n+\t\tt->sequenceNumber = ptt->sequenceNumber;\n+\n+\t\t/* Do extra header info stuff */\n+\n+\t\tif (ptt->chunkId & EXTRA_HEADER_INFO_FLAG) {\n+\t\t\tt->chunkId = 0;\n+\t\t\tt->byteCount = 0;\n+\n+\t\t\tt->extraHeaderInfoAvailable = 1;\n+\t\t\tt->extraParentObjectId =\n+\t\t\t    ptt->chunkId & (~(ALL_EXTRA_FLAGS));\n+\t\t\tt->extraIsShrinkHeader =\n+\t\t\t    (ptt->chunkId & EXTRA_SHRINK_FLAG) ? 1 : 0;\n+\t\t\tt->extraShadows =\n+\t\t\t    (ptt->chunkId & EXTRA_SHADOWS_FLAG) ? 1 : 0;\n+\t\t\tt->extraObjectType =\n+\t\t\t    ptt->objectId >> EXTRA_OBJECT_TYPE_SHIFT;\n+\t\t\tt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;\n+\n+\t\t\tif (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK) {\n+\t\t\t\tt->extraEquivalentObjectId = ptt->byteCount;\n+\t\t\t} else {\n+\t\t\t\tt->extraFileLength = ptt->byteCount;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tyaffs_DumpPackedTags2TagsPart(ptt);\n+\tyaffs_DumpTags2(t);\n+\n+}\n+\n+\n+void yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt)\n+{\n+\n+\tyaffs_UnpackTags2TagsPart(t,&pt->t);\n+\n+\tif (pt->t.sequenceNumber != 0xFFFFFFFF) {\n+\t\t/* Page is in use */\n+#ifdef YAFFS_IGNORE_TAGS_ECC\n+\t\t{\n+\t\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;\n+\t\t}\n+#else\n+\t\t{\n+\t\t\tyaffs_ECCOther ecc;\n+\t\t\tint result;\n+\t\t\tyaffs_ECCCalculateOther((unsigned char *)&pt->t,\n+\t\t\t\t\t\tsizeof\n+\t\t\t\t\t\t(yaffs_PackedTags2TagsPart),\n+\t\t\t\t\t\t&ecc);\n+\t\t\tresult =\n+\t\t\t    yaffs_ECCCorrectOther((unsigned char *)&pt->t,\n+\t\t\t\t\t\t  sizeof\n+\t\t\t\t\t\t  (yaffs_PackedTags2TagsPart),\n+\t\t\t\t\t\t  &pt->ecc, &ecc);\n+\t\t\tswitch(result){\n+\t\t\t\tcase 0:\n+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 1:\n+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_FIXED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase -1:\n+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_UNFIXED;\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_UNKNOWN;\n+\t\t\t}\n+\t\t}\n+#endif\n+\t}\n+\n+\tyaffs_DumpPackedTags2(pt);\n+\tyaffs_DumpTags2(t);\n+\n+}\n+'),
 ('linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h\n--- linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h\n@@ -0,0 +1,43 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */\n+\n+#ifndef __YAFFS_PACKEDTAGS2_H__\n+#define __YAFFS_PACKEDTAGS2_H__\n+\n+#include "yaffs_guts.h"\n+#include "yaffs_ecc.h"\n+\n+typedef struct {\n+\tunsigned sequenceNumber;\n+\tunsigned objectId;\n+\tunsigned chunkId;\n+\tunsigned byteCount;\n+} yaffs_PackedTags2TagsPart;\n+\n+typedef struct {\n+\tyaffs_PackedTags2TagsPart t;\n+\tyaffs_ECCOther ecc;\n+} yaffs_PackedTags2;\n+\n+/* Full packed tags with ECC, used for oob tags */\n+void yaffs_PackTags2(yaffs_PackedTags2 * pt, const yaffs_ExtendedTags * t);\n+void yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt);\n+\n+/* Only the tags part (no ECC for use with inband tags */\n+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart * pt, const yaffs_ExtendedTags * t);\n+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags * t, yaffs_PackedTags2TagsPart * pt);\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_qsort.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_qsort.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c\n--- linux-2.6.23/fs/yaffs2/yaffs_qsort.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c\n@@ -0,0 +1,160 @@\n+/*\n+ * Copyright (c) 1992, 1993\n+ *\tThe Regents of the University of California.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ * 3. Neither the name of the University nor the names of its contributors\n+ *    may be used to endorse or promote products derived from this software\n+ *    without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS\'\' AND\n+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ */\n+\n+#include "yportenv.h"\n+//#include <linux/string.h>\n+\n+/*\n+ * Qsort routine from Bentley & McIlroy\'s "Engineering a Sort Function".\n+ */\n+#define swapcode(TYPE, parmi, parmj, n) { \t\t\\\n+\tlong i = (n) / sizeof (TYPE); \t\t\t\\\n+\tregister TYPE *pi = (TYPE *) (parmi); \t\t\\\n+\tregister TYPE *pj = (TYPE *) (parmj); \t\t\\\n+\tdo { \t\t\t\t\t\t\\\n+\t\tregister TYPE\tt = *pi;\t\t\\\n+\t\t*pi++ = *pj;\t\t\t\t\\\n+\t\t*pj++ = t;\t\t\t\t\\\n+        } while (--i > 0);\t\t\t\t\\\n+}\n+\n+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \\\n+\tes % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;\n+\n+static __inline void\n+swapfunc(char *a, char *b, int n, int swaptype)\n+{\n+\tif (swaptype <= 1)\n+\t\tswapcode(long, a, b, n)\n+\telse\n+\t\tswapcode(char, a, b, n)\n+}\n+\n+#define swap(a, b)\t\t\t\t\t\\\n+\tif (swaptype == 0) {\t\t\t\t\\\n+\t\tlong t = *(long *)(a);\t\t\t\\\n+\t\t*(long *)(a) = *(long *)(b);\t\t\\\n+\t\t*(long *)(b) = t;\t\t\t\\\n+\t} else\t\t\t\t\t\t\\\n+\t\tswapfunc(a, b, es, swaptype)\n+\n+#define vecswap(a, b, n) \tif ((n) > 0) swapfunc(a, b, n, swaptype)\n+\n+static __inline char *\n+med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))\n+{\n+\treturn cmp(a, b) < 0 ?\n+\t       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))\n+              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));\n+}\n+\n+#ifndef min\n+#define min(a,b) (((a) < (b)) ? (a) : (b))\n+#endif\n+\n+void\n+yaffs_qsort(void *aa, size_t n, size_t es,\n+\tint (*cmp)(const void *, const void *))\n+{\n+\tchar *pa, *pb, *pc, *pd, *pl, *pm, *pn;\n+\tint d, r, swaptype, swap_cnt;\n+\tregister char *a = aa;\n+\n+loop:\tSWAPINIT(a, es);\n+\tswap_cnt = 0;\n+\tif (n < 7) {\n+\t\tfor (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)\n+\t\t\tfor (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;\n+\t\t\t     pl -= es)\n+\t\t\t\tswap(pl, pl - es);\n+\t\treturn;\n+\t}\n+\tpm = (char *)a + (n / 2) * es;\n+\tif (n > 7) {\n+\t\tpl = (char *)a;\n+\t\tpn = (char *)a + (n - 1) * es;\n+\t\tif (n > 40) {\n+\t\t\td = (n / 8) * es;\n+\t\t\tpl = med3(pl, pl + d, pl + 2 * d, cmp);\n+\t\t\tpm = med3(pm - d, pm, pm + d, cmp);\n+\t\t\tpn = med3(pn - 2 * d, pn - d, pn, cmp);\n+\t\t}\n+\t\tpm = med3(pl, pm, pn, cmp);\n+\t}\n+\tswap(a, pm);\n+\tpa = pb = (char *)a + es;\n+\n+\tpc = pd = (char *)a + (n - 1) * es;\n+\tfor (;;) {\n+\t\twhile (pb <= pc && (r = cmp(pb, a)) <= 0) {\n+\t\t\tif (r == 0) {\n+\t\t\t\tswap_cnt = 1;\n+\t\t\t\tswap(pa, pb);\n+\t\t\t\tpa += es;\n+\t\t\t}\n+\t\t\tpb += es;\n+\t\t}\n+\t\twhile (pb <= pc && (r = cmp(pc, a)) >= 0) {\n+\t\t\tif (r == 0) {\n+\t\t\t\tswap_cnt = 1;\n+\t\t\t\tswap(pc, pd);\n+\t\t\t\tpd -= es;\n+\t\t\t}\n+\t\t\tpc -= es;\n+\t\t}\n+\t\tif (pb > pc)\n+\t\t\tbreak;\n+\t\tswap(pb, pc);\n+\t\tswap_cnt = 1;\n+\t\tpb += es;\n+\t\tpc -= es;\n+\t}\n+\tif (swap_cnt == 0) {  /* Switch to insertion sort */\n+\t\tfor (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)\n+\t\t\tfor (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;\n+\t\t\t     pl -= es)\n+\t\t\t\tswap(pl, pl - es);\n+\t\treturn;\n+\t}\n+\n+\tpn = (char *)a + n * es;\n+\tr = min(pa - (char *)a, pb - pa);\n+\tvecswap(a, pb - r, r);\n+\tr = min((long)(pd - pc), (long)(pn - pd - es));\n+\tvecswap(pb, pn - r, r);\n+\tif ((r = pb - pa) > es)\n+\t\tyaffs_qsort(a, r / es, es, cmp);\n+\tif ((r = pd - pc) > es) {\n+\t\t/* Iterate rather than recurse to save stack space */\n+\t\ta = pn - r;\n+\t\tn = r / es;\n+\t\tgoto loop;\n+\t}\n+/*\t\tyaffs_qsort(pn - r, r / es, es, cmp);*/\n+}'),
 ('linux-2.6.23/fs/yaffs2/yaffs_qsort.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_qsort.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h\n--- linux-2.6.23/fs/yaffs2/yaffs_qsort.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h\n@@ -0,0 +1,23 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+\n+#ifndef __YAFFS_QSORT_H__\n+#define __YAFFS_QSORT_H__\n+\n+extern void yaffs_qsort (void *const base, size_t total_elems, size_t size,\n+                   int (*cmp)(const void *, const void *));\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c\n--- linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c\n@@ -0,0 +1,534 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "yaffs_guts.h"\n+#include "yaffs_tagscompat.h"\n+#include "yaffs_ecc.h"\n+#include "yaffs_getblockinfo.h"\n+\n+static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND);\n+#ifdef NOTYET\n+static void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND);\n+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t     const __u8 * data,\n+\t\t\t\t     const yaffs_Spare * spare);\n+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t    const yaffs_Spare * spare);\n+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND);\n+#endif\n+\n+static const char yaffs_countBitsTable[256] = {\n+\t0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+\t4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n+};\n+\n+int yaffs_CountBits(__u8 x)\n+{\n+\tint retVal;\n+\tretVal = yaffs_countBitsTable[x];\n+\treturn retVal;\n+}\n+\n+/********** Tags ECC calculations  *********/\n+\n+void yaffs_CalcECC(const __u8 * data, yaffs_Spare * spare)\n+{\n+\tyaffs_ECCCalculate(data, spare->ecc1);\n+\tyaffs_ECCCalculate(&data[256], spare->ecc2);\n+}\n+\n+void yaffs_CalcTagsECC(yaffs_Tags * tags)\n+{\n+\t/* Calculate an ecc */\n+\n+\tunsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;\n+\tunsigned i, j;\n+\tunsigned ecc = 0;\n+\tunsigned bit = 0;\n+\n+\ttags->ecc = 0;\n+\n+\tfor (i = 0; i < 8; i++) {\n+\t\tfor (j = 1; j & 0xff; j <<= 1) {\n+\t\t\tbit++;\n+\t\t\tif (b[i] & j) {\n+\t\t\t\tecc ^= bit;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\ttags->ecc = ecc;\n+\n+}\n+\n+int yaffs_CheckECCOnTags(yaffs_Tags * tags)\n+{\n+\tunsigned ecc = tags->ecc;\n+\n+\tyaffs_CalcTagsECC(tags);\n+\n+\tecc ^= tags->ecc;\n+\n+\tif (ecc && ecc <= 64) {\n+\t\t/* TODO: Handle the failure better. Retire? */\n+\t\tunsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;\n+\n+\t\tecc--;\n+\n+\t\tb[ecc / 8] ^= (1 << (ecc & 7));\n+\n+\t\t/* Now recvalc the ecc */\n+\t\tyaffs_CalcTagsECC(tags);\n+\n+\t\treturn 1;\t/* recovered error */\n+\t} else if (ecc) {\n+\t\t/* Wierd ecc failure value */\n+\t\t/* TODO Need to do somethiong here */\n+\t\treturn -1;\t/* unrecovered error */\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/********** Tags **********/\n+\n+static void yaffs_LoadTagsIntoSpare(yaffs_Spare * sparePtr,\n+\t\t\t\t    yaffs_Tags * tagsPtr)\n+{\n+\tyaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;\n+\n+\tyaffs_CalcTagsECC(tagsPtr);\n+\n+\tsparePtr->tagByte0 = tu->asBytes[0];\n+\tsparePtr->tagByte1 = tu->asBytes[1];\n+\tsparePtr->tagByte2 = tu->asBytes[2];\n+\tsparePtr->tagByte3 = tu->asBytes[3];\n+\tsparePtr->tagByte4 = tu->asBytes[4];\n+\tsparePtr->tagByte5 = tu->asBytes[5];\n+\tsparePtr->tagByte6 = tu->asBytes[6];\n+\tsparePtr->tagByte7 = tu->asBytes[7];\n+}\n+\n+static void yaffs_GetTagsFromSpare(yaffs_Device * dev, yaffs_Spare * sparePtr,\n+\t\t\t\t   yaffs_Tags * tagsPtr)\n+{\n+\tyaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;\n+\tint result;\n+\n+\ttu->asBytes[0] = sparePtr->tagByte0;\n+\ttu->asBytes[1] = sparePtr->tagByte1;\n+\ttu->asBytes[2] = sparePtr->tagByte2;\n+\ttu->asBytes[3] = sparePtr->tagByte3;\n+\ttu->asBytes[4] = sparePtr->tagByte4;\n+\ttu->asBytes[5] = sparePtr->tagByte5;\n+\ttu->asBytes[6] = sparePtr->tagByte6;\n+\ttu->asBytes[7] = sparePtr->tagByte7;\n+\n+\tresult = yaffs_CheckECCOnTags(tagsPtr);\n+\tif (result > 0) {\n+\t\tdev->tagsEccFixed++;\n+\t} else if (result < 0) {\n+\t\tdev->tagsEccUnfixed++;\n+\t}\n+}\n+\n+static void yaffs_SpareInitialise(yaffs_Spare * spare)\n+{\n+\tmemset(spare, 0xFF, sizeof(yaffs_Spare));\n+}\n+\n+static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int chunkInNAND, const __u8 * data,\n+\t\t\t\t  yaffs_Spare * spare)\n+{\n+\tif (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {\n+\t\tT(YAFFS_TRACE_ERROR,\n+\t\t  (TSTR("**>> yaffs chunk %d is not valid" TENDSTR),\n+\t\t   chunkInNAND));\n+\t\treturn YAFFS_FAIL;\n+\t}\n+\n+\tdev->nPageWrites++;\n+\treturn dev->writeChunkToNAND(dev, chunkInNAND, data, spare);\n+}\n+\n+static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t   int chunkInNAND,\n+\t\t\t\t   __u8 * data,\n+\t\t\t\t   yaffs_Spare * spare,\n+\t\t\t\t   yaffs_ECCResult * eccResult,\n+\t\t\t\t   int doErrorCorrection)\n+{\n+\tint retVal;\n+\tyaffs_Spare localSpare;\n+\n+\tdev->nPageReads++;\n+\n+\tif (!spare && data) {\n+\t\t/* If we don\'t have a real spare, then we use a local one. */\n+\t\t/* Need this for the calculation of the ecc */\n+\t\tspare = &localSpare;\n+\t}\n+\n+\tif (!dev->useNANDECC) {\n+\t\tretVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);\n+\t\tif (data && doErrorCorrection) {\n+\t\t\t/* Do ECC correction */\n+\t\t\t/* Todo handle any errors */\n+\t\t\tint eccResult1, eccResult2;\n+\t\t\t__u8 calcEcc[3];\n+\n+\t\t\tyaffs_ECCCalculate(data, calcEcc);\n+\t\t\teccResult1 =\n+\t\t\t    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);\n+\t\t\tyaffs_ECCCalculate(&data[256], calcEcc);\n+\t\t\teccResult2 =\n+\t\t\t    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);\n+\n+\t\t\tif (eccResult1 > 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>yaffs ecc error fix performed on chunk %d:0"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t\tdev->eccFixed++;\n+\t\t\t} else if (eccResult1 < 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>yaffs ecc error unfixed on chunk %d:0"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t\tdev->eccUnfixed++;\n+\t\t\t}\n+\n+\t\t\tif (eccResult2 > 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>yaffs ecc error fix performed on chunk %d:1"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t\tdev->eccFixed++;\n+\t\t\t} else if (eccResult2 < 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>yaffs ecc error unfixed on chunk %d:1"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t\tdev->eccUnfixed++;\n+\t\t\t}\n+\n+\t\t\tif (eccResult1 || eccResult2) {\n+\t\t\t\t/* We had a data problem on this page */\n+\t\t\t\tyaffs_HandleReadDataError(dev, chunkInNAND);\n+\t\t\t}\n+\n+\t\t\tif (eccResult1 < 0 || eccResult2 < 0)\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_UNFIXED;\n+\t\t\telse if (eccResult1 > 0 || eccResult2 > 0)\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_FIXED;\n+\t\t\telse\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_NO_ERROR;\n+\t\t}\n+\t} else {\n+\t\t/* Must allocate enough memory for spare+2*sizeof(int) */\n+\t\t/* for ecc results from device. */\n+\t\tstruct yaffs_NANDSpare nspare;\n+\n+\t\tmemset(&nspare,0,sizeof(nspare));\n+\n+\t\tretVal =\n+\t\t    dev->readChunkFromNAND(dev, chunkInNAND, data,\n+\t\t\t\t\t   (yaffs_Spare *) & nspare);\n+\t\tmemcpy(spare, &nspare, sizeof(yaffs_Spare));\n+\t\tif (data && doErrorCorrection) {\n+\t\t\tif (nspare.eccres1 > 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>mtd ecc error fix performed on chunk %d:0"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t} else if (nspare.eccres1 < 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>mtd ecc error unfixed on chunk %d:0"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t}\n+\n+\t\t\tif (nspare.eccres2 > 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>mtd ecc error fix performed on chunk %d:1"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t} else if (nspare.eccres2 < 0) {\n+\t\t\t\tT(YAFFS_TRACE_ERROR,\n+\t\t\t\t  (TSTR\n+\t\t\t\t   ("**>>mtd ecc error unfixed on chunk %d:1"\n+\t\t\t\t    TENDSTR), chunkInNAND));\n+\t\t\t}\n+\n+\t\t\tif (nspare.eccres1 || nspare.eccres2) {\n+\t\t\t\t/* We had a data problem on this page */\n+\t\t\t\tyaffs_HandleReadDataError(dev, chunkInNAND);\n+\t\t\t}\n+\n+\t\t\tif (nspare.eccres1 < 0 || nspare.eccres2 < 0)\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_UNFIXED;\n+\t\t\telse if (nspare.eccres1 > 0 || nspare.eccres2 > 0)\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_FIXED;\n+\t\t\telse\n+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_NO_ERROR;\n+\n+\t\t}\n+\t}\n+\treturn retVal;\n+}\n+\n+#ifdef NOTYET\n+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t  int chunkInNAND)\n+{\n+\n+\tstatic int init = 0;\n+\tstatic __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];\n+\tstatic __u8 data[YAFFS_BYTES_PER_CHUNK];\n+\t/* Might as well always allocate the larger size for */\n+\t/* dev->useNANDECC == true; */\n+\tstatic __u8 spare[sizeof(struct yaffs_NANDSpare)];\n+\n+\tdev->readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);\n+\n+\tif (!init) {\n+\t\tmemset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);\n+\t\tinit = 1;\n+\t}\n+\n+\tif (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))\n+\t\treturn YAFFS_FAIL;\n+\tif (memcmp(cmpbuf, spare, 16))\n+\t\treturn YAFFS_FAIL;\n+\n+\treturn YAFFS_OK;\n+\n+}\n+#endif\n+\n+/*\n+ * Functions for robustisizing\n+ */\n+\n+static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND)\n+{\n+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;\n+\n+\t/* Mark the block for retirement */\n+\tyaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;\n+\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,\n+\t  (TSTR("**>>Block %d marked for retirement" TENDSTR), blockInNAND));\n+\n+\t/* TODO:\n+\t * Just do a garbage collection on the affected block\n+\t * then retire the block\n+\t * NB recursion\n+\t */\n+}\n+\n+#ifdef NOTYET\n+static void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND)\n+{\n+}\n+\n+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t     const __u8 * data,\n+\t\t\t\t     const yaffs_Spare * spare)\n+{\n+}\n+\n+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,\n+\t\t\t\t    const yaffs_Spare * spare)\n+{\n+}\n+\n+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND)\n+{\n+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;\n+\n+\t/* Mark the block for retirement */\n+\tyaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;\n+\t/* Delete the chunk */\n+\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);\n+}\n+\n+static int yaffs_VerifyCompare(const __u8 * d0, const __u8 * d1,\n+\t\t\t       const yaffs_Spare * s0, const yaffs_Spare * s1)\n+{\n+\n+\tif (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||\n+\t    s0->tagByte0 != s1->tagByte0 ||\n+\t    s0->tagByte1 != s1->tagByte1 ||\n+\t    s0->tagByte2 != s1->tagByte2 ||\n+\t    s0->tagByte3 != s1->tagByte3 ||\n+\t    s0->tagByte4 != s1->tagByte4 ||\n+\t    s0->tagByte5 != s1->tagByte5 ||\n+\t    s0->tagByte6 != s1->tagByte6 ||\n+\t    s0->tagByte7 != s1->tagByte7 ||\n+\t    s0->ecc1[0] != s1->ecc1[0] ||\n+\t    s0->ecc1[1] != s1->ecc1[1] ||\n+\t    s0->ecc1[2] != s1->ecc1[2] ||\n+\t    s0->ecc2[0] != s1->ecc2[0] ||\n+\t    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {\n+\t\treturn 0;\n+\t}\n+\n+\treturn 1;\n+}\n+#endif\t\t\t\t/* NOTYET */\n+\n+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t    int chunkInNAND,\n+\t\t\t\t\t\t    const __u8 * data,\n+\t\t\t\t\t\t    const yaffs_ExtendedTags *\n+\t\t\t\t\t\t    eTags)\n+{\n+\tyaffs_Spare spare;\n+\tyaffs_Tags tags;\n+\n+\tyaffs_SpareInitialise(&spare);\n+\n+\tif (eTags->chunkDeleted) {\n+\t\tspare.pageStatus = 0;\n+\t} else {\n+\t\ttags.objectId = eTags->objectId;\n+\t\ttags.chunkId = eTags->chunkId;\n+\t\ttags.byteCount = eTags->byteCount;\n+\t\ttags.serialNumber = eTags->serialNumber;\n+\n+\t\tif (!dev->useNANDECC && data) {\n+\t\t\tyaffs_CalcECC(data, &spare);\n+\t\t}\n+\t\tyaffs_LoadTagsIntoSpare(&spare, &tags);\n+\n+\t}\n+\n+\treturn yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);\n+}\n+\n+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t     int chunkInNAND,\n+\t\t\t\t\t\t     __u8 * data,\n+\t\t\t\t\t\t     yaffs_ExtendedTags * eTags)\n+{\n+\n+\tyaffs_Spare spare;\n+\tyaffs_Tags tags;\n+\tyaffs_ECCResult eccResult;\n+\n+\tstatic yaffs_Spare spareFF;\n+\tstatic int init = 0;\n+\n+\tif (!init) {\n+\t\tmemset(&spareFF, 0xFF, sizeof(spareFF));\n+\t\tinit = 1;\n+\t}\n+\n+\tif (yaffs_ReadChunkFromNAND\n+\t    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {\n+\t\t/* eTags may be NULL */\n+\t\tif (eTags) {\n+\n+\t\t\tint deleted =\n+\t\t\t    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;\n+\n+\t\t\teTags->chunkDeleted = deleted;\n+\t\t\teTags->eccResult = eccResult;\n+\t\t\teTags->blockBad = 0;\t/* We\'re reading it */\n+\t\t\t/* therefore it is not a bad block */\n+\t\t\teTags->chunkUsed =\n+\t\t\t    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=\n+\t\t\t     0) ? 1 : 0;\n+\n+\t\t\tif (eTags->chunkUsed) {\n+\t\t\t\tyaffs_GetTagsFromSpare(dev, &spare, &tags);\n+\n+\t\t\t\teTags->objectId = tags.objectId;\n+\t\t\t\teTags->chunkId = tags.chunkId;\n+\t\t\t\teTags->byteCount = tags.byteCount;\n+\t\t\t\teTags->serialNumber = tags.serialNumber;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn YAFFS_OK;\n+\t} else {\n+\t\treturn YAFFS_FAIL;\n+\t}\n+}\n+\n+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t    int blockInNAND)\n+{\n+\n+\tyaffs_Spare spare;\n+\n+\tmemset(&spare, 0xff, sizeof(yaffs_Spare));\n+\n+\tspare.blockStatus = \'Y\';\n+\n+\tyaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,\n+\t\t\t       &spare);\n+\tyaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,\n+\t\t\t       NULL, &spare);\n+\n+\treturn YAFFS_OK;\n+\n+}\n+\n+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t  int blockNo,\n+\t\t\t\t\t  yaffs_BlockState *state,\n+\t\t\t\t\t  __u32 *sequenceNumber)\n+{\n+\n+\tyaffs_Spare spare0, spare1;\n+\tstatic yaffs_Spare spareFF;\n+\tstatic int init;\n+\tyaffs_ECCResult dummy;\n+\n+\tif (!init) {\n+\t\tmemset(&spareFF, 0xFF, sizeof(spareFF));\n+\t\tinit = 1;\n+\t}\n+\n+\t*sequenceNumber = 0;\n+\n+\tyaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,\n+\t\t\t\t&spare0, &dummy, 1);\n+\tyaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,\n+\t\t\t\t&spare1, &dummy, 1);\n+\n+\tif (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)\n+\t\t*state = YAFFS_BLOCK_STATE_DEAD;\n+\telse if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)\n+\t\t*state = YAFFS_BLOCK_STATE_EMPTY;\n+\telse\n+\t\t*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;\n+\n+\treturn YAFFS_OK;\n+}'),
 ('linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h\n--- linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h\n@@ -0,0 +1,41 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+#ifndef __YAFFS_TAGSCOMPAT_H__\n+#define __YAFFS_TAGSCOMPAT_H__\n+\n+#include "yaffs_guts.h"\n+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t    int chunkInNAND,\n+\t\t\t\t\t\t    const __u8 * data,\n+\t\t\t\t\t\t    const yaffs_ExtendedTags *\n+\t\t\t\t\t\t    tags);\n+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,\n+\t\t\t\t\t\t     int chunkInNAND,\n+\t\t\t\t\t\t     __u8 * data,\n+\t\t\t\t\t\t     yaffs_ExtendedTags *\n+\t\t\t\t\t\t     tags);\n+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t    int blockNo);\n+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,\n+\t\t\t\t\t  int blockNo,\n+\t\t\t\t\t  yaffs_BlockState *state,\n+\t\t\t\t\t  __u32 *sequenceNumber);\n+\n+void yaffs_CalcTagsECC(yaffs_Tags * tags);\n+int yaffs_CheckECCOnTags(yaffs_Tags * tags);\n+int yaffs_CountBits(__u8 byte);\n+\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c\n--- linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c\n@@ -0,0 +1,28 @@\n+/*\n+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "yaffs_tagsvalidity.h"\n+\n+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags)\n+{\n+\tmemset(tags, 0, sizeof(yaffs_ExtendedTags));\n+\ttags->validMarker0 = 0xAAAAAAAA;\n+\ttags->validMarker1 = 0x55555555;\n+}\n+\n+int yaffs_ValidateTags(yaffs_ExtendedTags * tags)\n+{\n+\treturn (tags->validMarker0 == 0xAAAAAAAA &&\n+\t\ttags->validMarker1 == 0x55555555);\n+\n+}'),
 ('linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h\n--- linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h\n@@ -0,0 +1,24 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+\n+#ifndef __YAFFS_TAGS_VALIDITY_H__\n+#define __YAFFS_TAGS_VALIDITY_H__\n+\n+#include "yaffs_guts.h"\n+\n+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags);\n+int yaffs_ValidateTags(yaffs_ExtendedTags * tags);\n+#endif'),
 ('linux-2.6.23/fs/yaffs2/yportenv.h',
  'linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h',
  'diff -Naur linux-2.6.23/fs/yaffs2/yportenv.h linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h\n--- linux-2.6.23/fs/yaffs2/yportenv.h\n+++ linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h\n@@ -0,0 +1,200 @@\n+/*\n+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.\n+ *\n+ * Copyright (C) 2002-2007 Aleph One Ltd.\n+ *   for Toby Churchill Ltd and Brightstar Engineering\n+ *\n+ * Created by Charles Manning <charles@aleph1.co.uk>\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License version 2.1 as\n+ * published by the Free Software Foundation.\n+ *\n+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.\n+ */\n+\n+\n+#ifndef __YPORTENV_H__\n+#define __YPORTENV_H__\n+\n+/*\n+ * Define the MTD version in terms of Linux Kernel versions\n+ * This allows yaffs to be used independantly of the kernel\n+ * as well as with it.\n+ */\n+\n+#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))\n+\n+#if defined CONFIG_YAFFS_WINCE\n+\n+#include "ywinceenv.h"\n+\n+#elif  defined __KERNEL__\n+\n+#include "moduleconfig.h"\n+\n+/* Linux kernel */\n+\n+#include <linux/version.h>\n+#define MTD_VERSION_CODE LINUX_VERSION_CODE\n+\n+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))\n+#include <linux/config.h>\n+#endif\n+#include <linux/kernel.h>\n+#include <linux/mm.h>\n+#include <linux/sched.h>\n+#include <linux/string.h>\n+#include <linux/slab.h>\n+#include <linux/vmalloc.h>\n+\n+#define YCHAR char\n+#define YUCHAR unsigned char\n+#define _Y(x)     x\n+#define yaffs_strcpy(a,b)    strcpy(a,b)\n+#define yaffs_strncpy(a,b,c) strncpy(a,b,c)\n+#define yaffs_strncmp(a,b,c) strncmp(a,b,c)\n+#define yaffs_strlen(s)\t     strlen(s)\n+#define yaffs_sprintf\t     sprintf\n+#define yaffs_toupper(a)     toupper(a)\n+\n+#define Y_INLINE inline\n+\n+#define YAFFS_LOSTNFOUND_NAME\t\t"lost+found"\n+#define YAFFS_LOSTNFOUND_PREFIX\t\t"obj"\n+\n+/* #define YPRINTF(x) printk x */\n+#define YMALLOC(x) kmalloc(x,GFP_KERNEL)\n+#define YFREE(x)   kfree(x)\n+#define YMALLOC_ALT(x) vmalloc(x)\n+#define YFREE_ALT(x)   vfree(x)\n+#define YMALLOC_DMA(x) YMALLOC(x)\n+\n+// KR - added for use in scan so processes aren\'t blocked indefinitely.\n+#define YYIELD() schedule()\n+\n+#define YAFFS_ROOT_MODE\t\t\t0666\n+#define YAFFS_LOSTNFOUND_MODE\t\t0666\n+\n+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))\n+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec\n+#define Y_TIME_CONVERT(x) (x).tv_sec\n+#else\n+#define Y_CURRENT_TIME CURRENT_TIME\n+#define Y_TIME_CONVERT(x) (x)\n+#endif\n+\n+#define yaffs_SumCompare(x,y) ((x) == (y))\n+#define yaffs_strcmp(a,b) strcmp(a,b)\n+\n+#define TENDSTR "\\n"\n+#define TSTR(x) KERN_WARNING x\n+#define TOUT(p) printk p\n+\n+#define yaffs_trace(mask, fmt, args...) \\\n+\tdo { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \\\n+\t\tprintk(KERN_WARNING "yaffs: " fmt, ## args); \\\n+\t} while (0)\n+\n+#define compile_time_assertion(assertion) \\\n+\t({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })\n+\n+#elif defined CONFIG_YAFFS_DIRECT\n+\n+#define MTD_VERSION_CODE MTD_VERSION(2,6,22)\n+\n+/* Direct interface */\n+#include "ydirectenv.h"\n+\n+#elif defined CONFIG_YAFFS_UTIL\n+\n+/* Stuff for YAFFS utilities */\n+\n+#include "stdlib.h"\n+#include "stdio.h"\n+#include "string.h"\n+\n+#include "devextras.h"\n+\n+#define YMALLOC(x) malloc(x)\n+#define YFREE(x)   free(x)\n+#define YMALLOC_ALT(x) malloc(x)\n+#define YFREE_ALT(x) free(x)\n+\n+#define YCHAR char\n+#define YUCHAR unsigned char\n+#define _Y(x)     x\n+#define yaffs_strcpy(a,b)    strcpy(a,b)\n+#define yaffs_strncpy(a,b,c) strncpy(a,b,c)\n+#define yaffs_strlen(s)\t     strlen(s)\n+#define yaffs_sprintf\t     sprintf\n+#define yaffs_toupper(a)     toupper(a)\n+\n+#define Y_INLINE inline\n+\n+/* #define YINFO(s) YPRINTF(( __FILE__ " %d %s\\n",__LINE__,s)) */\n+/* #define YALERT(s) YINFO(s) */\n+\n+#define TENDSTR "\\n"\n+#define TSTR(x) x\n+#define TOUT(p) printf p\n+\n+#define YAFFS_LOSTNFOUND_NAME\t\t"lost+found"\n+#define YAFFS_LOSTNFOUND_PREFIX\t\t"obj"\n+/* #define YPRINTF(x) printf x */\n+\n+#define YAFFS_ROOT_MODE\t\t\t\t0666\n+#define YAFFS_LOSTNFOUND_MODE\t\t0666\n+\n+#define yaffs_SumCompare(x,y) ((x) == (y))\n+#define yaffs_strcmp(a,b) strcmp(a,b)\n+\n+#else\n+/* Should have specified a configuration type */\n+#error Unknown configuration\n+\n+#endif\n+\n+/* see yaffs_fs.c */\n+extern unsigned int yaffs_traceMask;\n+extern unsigned int yaffs_wr_attempts;\n+\n+/*\n+ * Tracing flags.\n+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.\n+ */\n+\n+#define YAFFS_TRACE_OS\t\t\t0x00000002\n+#define YAFFS_TRACE_ALLOCATE\t\t0x00000004\n+#define YAFFS_TRACE_SCAN\t\t0x00000008\n+#define YAFFS_TRACE_BAD_BLOCKS\t\t0x00000010\n+#define YAFFS_TRACE_ERASE\t\t0x00000020\n+#define YAFFS_TRACE_GC\t\t\t0x00000040\n+#define YAFFS_TRACE_WRITE\t\t0x00000080\n+#define YAFFS_TRACE_TRACING\t\t0x00000100\n+#define YAFFS_TRACE_DELETION\t\t0x00000200\n+#define YAFFS_TRACE_BUFFERS\t\t0x00000400\n+#define YAFFS_TRACE_NANDACCESS\t\t0x00000800\n+#define YAFFS_TRACE_GC_DETAIL\t\t0x00001000\n+#define YAFFS_TRACE_SCAN_DEBUG\t\t0x00002000\n+#define YAFFS_TRACE_MTD\t\t\t0x00004000\n+#define YAFFS_TRACE_CHECKPOINT\t\t0x00008000\n+\n+#define YAFFS_TRACE_VERIFY\t\t0x00010000\n+#define YAFFS_TRACE_VERIFY_NAND\t\t0x00020000\n+#define YAFFS_TRACE_VERIFY_FULL\t\t0x00040000\n+#define YAFFS_TRACE_VERIFY_ALL\t\t0x000F0000\n+\n+\n+#define YAFFS_TRACE_ERROR\t\t0x40000000\n+#define YAFFS_TRACE_BUG\t\t\t0x80000000\n+#define YAFFS_TRACE_ALWAYS\t\t0xF0000000\n+\n+\n+#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)\n+\n+#ifndef YBUG\n+#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR("==>> yaffs bug: " __FILE__ " %d" TENDSTR),__LINE__));} while(0)\n+#endif\n+\n+#endif')]