[
  [
    "linux-2.6.23/fs/Kconfig", 
    "linux-2.6.23-yaffs2/fs/Kconfig", 
    [
      "diff -Naur linux-2.6.23/fs/Kconfig linux-2.6.23-yaffs2/fs/Kconfig", 
      "--- linux-2.6.23/fs/Kconfig", 
      "+++ linux-2.6.23-yaffs2/fs/Kconfig", 
      "@@ -1182,6 +1182,10 @@", 
      "To compile the EFS file system support as a module, choose M here: the", 
      "module will be called efs.", 
      "", 
      "+", 
      "+# Patched by YAFFS", 
      "+source \"fs/yaffs2/Kconfig\"", 
      "+", 
      "config JFFS2_FS", 
      "tristate \"Journalling Flash File System v2 (JFFS2) support\"", 
      "select CRC32"
    ]
  ], 
  [
    "linux-2.6.23/fs/Kconfig.pre.yaffs", 
    "linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs", 
    [
      "diff -Naur linux-2.6.23/fs/Kconfig.pre.yaffs linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs", 
      "--- linux-2.6.23/fs/Kconfig.pre.yaffs", 
      "+++ linux-2.6.23-yaffs2/fs/Kconfig.pre.yaffs", 
      "@@ -0,0 +1,2122 @@", 
      "+#", 
      "+# File system configuration", 
      "+#", 
      "+", 
      "+menu \"File systems\"", 
      "+", 
      "+if BLOCK", 
      "+", 
      "+config EXT2_FS", 
      "+\ttristate \"Second extended fs support\"", 
      "+\thelp", 
      "+\t  Ext2 is a standard Linux file system for hard disks.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called ext2.", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config EXT2_FS_XATTR", 
      "+\tbool \"Ext2 extended attributes\"", 
      "+\tdepends on EXT2_FS", 
      "+\thelp", 
      "+\t  Extended attributes are name:value pairs associated with inodes by", 
      "+\t  the kernel or by users (see the attr(5) manual page, or visit", 
      "+\t  <http://acl.bestbits.at/> for details).", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config EXT2_FS_POSIX_ACL", 
      "+\tbool \"Ext2 POSIX Access Control Lists\"", 
      "+\tdepends on EXT2_FS_XATTR", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  Posix Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the Posix ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config EXT2_FS_SECURITY", 
      "+\tbool \"Ext2 Security Labels\"", 
      "+\tdepends on EXT2_FS_XATTR", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the ext2 filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config EXT2_FS_XIP", 
      "+\tbool \"Ext2 execute in place support\"", 
      "+\tdepends on EXT2_FS && MMU", 
      "+\thelp", 
      "+\t  Execute in place can be used on memory-backed block devices. If you", 
      "+\t  enable this option, you can select to mount block devices which are", 
      "+\t  capable of this feature without using the page cache.", 
      "+", 
      "+\t  If you do not use a block device that is capable of using this,", 
      "+\t  or if unsure, say N.", 
      "+", 
      "+config FS_XIP", 
      "+# execute in place", 
      "+\tbool", 
      "+\tdepends on EXT2_FS_XIP", 
      "+\tdefault y", 
      "+", 
      "+config EXT3_FS", 
      "+\ttristate \"Ext3 journalling file system support\"", 
      "+\tselect JBD", 
      "+\thelp", 
      "+\t  This is the journalling version of the Second extended file system", 
      "+\t  (often called ext3), the de facto standard Linux file system", 
      "+\t  (method to organize files on a storage device) for hard disks.", 
      "+", 
      "+\t  The journalling code included in this driver means you do not have", 
      "+\t  to run e2fsck (file system checker) on your file systems after a", 
      "+\t  crash.  The journal keeps track of any changes that were being made", 
      "+\t  at the time the system crashed, and can ensure that your file system", 
      "+\t  is consistent without the need for a lengthy check.", 
      "+", 
      "+\t  Other than adding the journal to the file system, the on-disk format", 
      "+\t  of ext3 is identical to ext2.  It is possible to freely switch", 
      "+\t  between using the ext3 driver and the ext2 driver, as long as the", 
      "+\t  file system has been cleanly unmounted, or e2fsck is run on the file", 
      "+\t  system.", 
      "+", 
      "+\t  To add a journal on an existing ext2 file system or change the", 
      "+\t  behavior of ext3 file systems, you can use the tune2fs utility (\"man", 
      "+\t  tune2fs\").  To modify attributes of files and directories on ext3", 
      "+\t  file systems, use chattr (\"man chattr\").  You need to be using", 
      "+\t  e2fsprogs version 1.20 or later in order to create ext3 journals", 
      "+\t  (available at <http://sourceforge.net/projects/e2fsprogs/>).", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called ext3.", 
      "+", 
      "+config EXT3_FS_XATTR", 
      "+\tbool \"Ext3 extended attributes\"", 
      "+\tdepends on EXT3_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Extended attributes are name:value pairs associated with inodes by", 
      "+\t  the kernel or by users (see the attr(5) manual page, or visit", 
      "+\t  <http://acl.bestbits.at/> for details).", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+\t  You need this for POSIX ACL support on ext3.", 
      "+", 
      "+config EXT3_FS_POSIX_ACL", 
      "+\tbool \"Ext3 POSIX Access Control Lists\"", 
      "+\tdepends on EXT3_FS_XATTR", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  Posix Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the Posix ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config EXT3_FS_SECURITY", 
      "+\tbool \"Ext3 Security Labels\"", 
      "+\tdepends on EXT3_FS_XATTR", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the ext3 filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config EXT4DEV_FS", 
      "+\ttristate \"Ext4dev/ext4 extended fs support development (EXPERIMENTAL)\"", 
      "+\tdepends on EXPERIMENTAL", 
      "+\tselect JBD2", 
      "+\thelp", 
      "+\t  Ext4dev is a predecessor filesystem of the next generation", 
      "+\t  extended fs ext4, based on ext3 filesystem code. It will be", 
      "+\t  renamed ext4 fs later, once ext4dev is mature and stabilized.", 
      "+", 
      "+\t  Unlike the change from ext2 filesystem to ext3 filesystem,", 
      "+\t  the on-disk format of ext4dev is not the same as ext3 any more:", 
      "+\t  it is based on extent maps and it supports 48-bit physical block", 
      "+\t  numbers. These combined on-disk format changes will allow", 
      "+\t  ext4dev/ext4 to handle more than 16 TB filesystem volumes --", 
      "+\t  a hard limit that ext3 cannot overcome without changing the", 
      "+\t  on-disk format.", 
      "+", 
      "+\t  Other than extent maps and 48-bit block numbers, ext4dev also is", 
      "+\t  likely to have other new features such as persistent preallocation,", 
      "+\t  high resolution time stamps, and larger file support etc.  These", 
      "+\t  features will be added to ext4dev gradually.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here. The", 
      "+\t  module will be called ext4dev.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config EXT4DEV_FS_XATTR", 
      "+\tbool \"Ext4dev extended attributes\"", 
      "+\tdepends on EXT4DEV_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Extended attributes are name:value pairs associated with inodes by", 
      "+\t  the kernel or by users (see the attr(5) manual page, or visit", 
      "+\t  <http://acl.bestbits.at/> for details).", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+\t  You need this for POSIX ACL support on ext4dev/ext4.", 
      "+", 
      "+config EXT4DEV_FS_POSIX_ACL", 
      "+\tbool \"Ext4dev POSIX Access Control Lists\"", 
      "+\tdepends on EXT4DEV_FS_XATTR", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  POSIX Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the POSIX ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config EXT4DEV_FS_SECURITY", 
      "+\tbool \"Ext4dev Security Labels\"", 
      "+\tdepends on EXT4DEV_FS_XATTR", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the ext4dev/ext4 filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config JBD", 
      "+\ttristate", 
      "+\thelp", 
      "+\t  This is a generic journalling layer for block devices.  It is", 
      "+\t  currently used by the ext3 and OCFS2 file systems, but it could", 
      "+\t  also be used to add journal support to other file systems or block", 
      "+\t  devices such as RAID or LVM.", 
      "+", 
      "+\t  If you are using the ext3 or OCFS2 file systems, you need to", 
      "+\t  say Y here. If you are not using ext3 OCFS2 then you will probably", 
      "+\t  want to say N.", 
      "+", 
      "+\t  To compile this device as a module, choose M here: the module will be", 
      "+\t  called jbd.  If you are compiling ext3 or OCFS2 into the kernel,", 
      "+\t  you cannot compile this code as a module.", 
      "+", 
      "+config JBD_DEBUG", 
      "+\tbool \"JBD (ext3) debugging support\"", 
      "+\tdepends on JBD", 
      "+\thelp", 
      "+\t  If you are using the ext3 journaled file system (or potentially any", 
      "+\t  other file system/device using JBD), this option allows you to", 
      "+\t  enable debugging output while the system is running, in order to", 
      "+\t  help track down any problems you are having.  By default the", 
      "+\t  debugging output will be turned off.", 
      "+", 
      "+\t  If you select Y here, then you will be able to turn on debugging", 
      "+\t  with \"echo N > /proc/sys/fs/jbd-debug\", where N is a number between", 
      "+\t  1 and 5, the higher the number, the more debugging output is", 
      "+\t  generated.  To turn debugging off again, do", 
      "+\t  \"echo 0 > /proc/sys/fs/jbd-debug\".", 
      "+", 
      "+config JBD2", 
      "+\ttristate", 
      "+\thelp", 
      "+\t  This is a generic journaling layer for block devices that support", 
      "+\t  both 32-bit and 64-bit block numbers.  It is currently used by", 
      "+\t  the ext4dev/ext4 filesystem, but it could also be used to add", 
      "+\t  journal support to other file systems or block devices such", 
      "+\t  as RAID or LVM.", 
      "+", 
      "+\t  If you are using ext4dev/ext4, you need to say Y here. If you are not", 
      "+\t  using ext4dev/ext4 then you will probably want to say N.", 
      "+", 
      "+\t  To compile this device as a module, choose M here. The module will be", 
      "+\t  called jbd2.  If you are compiling ext4dev/ext4 into the kernel,", 
      "+\t  you cannot compile this code as a module.", 
      "+", 
      "+config JBD2_DEBUG", 
      "+\tbool \"JBD2 (ext4dev/ext4) debugging support\"", 
      "+\tdepends on JBD2 && DEBUG_FS", 
      "+\thelp", 
      "+\t  If you are using the ext4dev/ext4 journaled file system (or", 
      "+\t  potentially any other filesystem/device using JBD2), this option", 
      "+\t  allows you to enable debugging output while the system is running,", 
      "+\t  in order to help track down any problems you are having.", 
      "+\t  By default, the debugging output will be turned off.", 
      "+", 
      "+\t  If you select Y here, then you will be able to turn on debugging", 
      "+\t  with \"echo N > /sys/kernel/debug/jbd2/jbd2-debug\", where N is a", 
      "+\t  number between 1 and 5. The higher the number, the more debugging", 
      "+\t  output is generated.  To turn debugging off again, do", 
      "+\t  \"echo 0 > /sys/kernel/debug/jbd2/jbd2-debug\".", 
      "+", 
      "+config FS_MBCACHE", 
      "+# Meta block cache for Extended Attributes (ext2/ext3/ext4)", 
      "+\ttristate", 
      "+\tdepends on EXT2_FS_XATTR || EXT3_FS_XATTR || EXT4DEV_FS_XATTR", 
      "+\tdefault y if EXT2_FS=y || EXT3_FS=y || EXT4DEV_FS=y", 
      "+\tdefault m if EXT2_FS=m || EXT3_FS=m || EXT4DEV_FS=m", 
      "+", 
      "+config REISERFS_FS", 
      "+\ttristate \"Reiserfs support\"", 
      "+\thelp", 
      "+\t  Stores not just filenames but the files themselves in a balanced", 
      "+\t  tree.  Uses journalling.", 
      "+", 
      "+\t  Balanced trees are more efficient than traditional file system", 
      "+\t  architectural foundations.", 
      "+", 
      "+\t  In general, ReiserFS is as fast as ext2, but is very efficient with", 
      "+\t  large directories and small files.  Additional patches are needed", 
      "+\t  for NFS and quotas, please see <http://www.namesys.com/> for links.", 
      "+", 
      "+\t  It is more easily extended to have features currently found in", 
      "+\t  database and keyword search systems than block allocation based file", 
      "+\t  systems are.  The next version will be so extended, and will support", 
      "+\t  plugins consistent with our motto ``It takes more than a license to", 
      "+\t  make source code open.''", 
      "+", 
      "+\t  Read <http://www.namesys.com/> to learn more about reiserfs.", 
      "+", 
      "+\t  Sponsored by Threshold Networks, Emusic.com, and Bigstorage.com.", 
      "+", 
      "+\t  If you like it, you can pay us to add new features to it that you", 
      "+\t  need, buy a support contract, or pay us to port it to another OS.", 
      "+", 
      "+config REISERFS_CHECK", 
      "+\tbool \"Enable reiserfs debug mode\"", 
      "+\tdepends on REISERFS_FS", 
      "+\thelp", 
      "+\t  If you set this to Y, then ReiserFS will perform every check it can", 
      "+\t  possibly imagine of its internal consistency throughout its", 
      "+\t  operation.  It will also go substantially slower.  More than once we", 
      "+\t  have forgotten that this was on, and then gone despondent over the", 
      "+\t  latest benchmarks.:-) Use of this option allows our team to go all", 
      "+\t  out in checking for consistency when debugging without fear of its", 
      "+\t  effect on end users.  If you are on the verge of sending in a bug", 
      "+\t  report, say Y and you might get a useful error message.  Almost", 
      "+\t  everyone should say N.", 
      "+", 
      "+config REISERFS_PROC_INFO", 
      "+\tbool \"Stats in /proc/fs/reiserfs\"", 
      "+\tdepends on REISERFS_FS && PROC_FS", 
      "+\thelp", 
      "+\t  Create under /proc/fs/reiserfs a hierarchy of files, displaying", 
      "+\t  various ReiserFS statistics and internal data at the expense of", 
      "+\t  making your kernel or module slightly larger (+8 KB). This also", 
      "+\t  increases the amount of kernel memory required for each mount.", 
      "+\t  Almost everyone but ReiserFS developers and people fine-tuning", 
      "+\t  reiserfs or tracing problems should say N.", 
      "+", 
      "+config REISERFS_FS_XATTR", 
      "+\tbool \"ReiserFS extended attributes\"", 
      "+\tdepends on REISERFS_FS", 
      "+\thelp", 
      "+\t  Extended attributes are name:value pairs associated with inodes by", 
      "+\t  the kernel or by users (see the attr(5) manual page, or visit", 
      "+\t  <http://acl.bestbits.at/> for details).", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config REISERFS_FS_POSIX_ACL", 
      "+\tbool \"ReiserFS POSIX Access Control Lists\"", 
      "+\tdepends on REISERFS_FS_XATTR", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  Posix Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the Posix ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config REISERFS_FS_SECURITY", 
      "+\tbool \"ReiserFS Security Labels\"", 
      "+\tdepends on REISERFS_FS_XATTR", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the ReiserFS filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config JFS_FS", 
      "+\ttristate \"JFS filesystem support\"", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  This is a port of IBM's Journaled Filesystem .  More information is", 
      "+\t  available in the file <file:Documentation/filesystems/jfs.txt>.", 
      "+", 
      "+\t  If you do not intend to use the JFS filesystem, say N.", 
      "+", 
      "+config JFS_POSIX_ACL", 
      "+\tbool \"JFS POSIX Access Control Lists\"", 
      "+\tdepends on JFS_FS", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  Posix Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the Posix ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config JFS_SECURITY", 
      "+\tbool \"JFS Security Labels\"", 
      "+\tdepends on JFS_FS", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the jfs filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config JFS_DEBUG", 
      "+\tbool \"JFS debugging\"", 
      "+\tdepends on JFS_FS", 
      "+\thelp", 
      "+\t  If you are experiencing any problems with the JFS filesystem, say", 
      "+\t  Y here.  This will result in additional debugging messages to be", 
      "+\t  written to the system log.  Under normal circumstances, this", 
      "+\t  results in very little overhead.", 
      "+", 
      "+config JFS_STATISTICS", 
      "+\tbool \"JFS statistics\"", 
      "+\tdepends on JFS_FS", 
      "+\thelp", 
      "+\t  Enabling this option will cause statistics from the JFS file system", 
      "+\t  to be made available to the user in the /proc/fs/jfs/ directory.", 
      "+", 
      "+config FS_POSIX_ACL", 
      "+# Posix ACL utility routines (for now, only ext2/ext3/jfs/reiserfs)", 
      "+#", 
      "+# NOTE: you can implement Posix ACLs without these helpers (XFS does).", 
      "+# \tNever use this symbol for ifdefs.", 
      "+#", 
      "+\tbool", 
      "+\tdefault n", 
      "+", 
      "+source \"fs/xfs/Kconfig\"", 
      "+source \"fs/gfs2/Kconfig\"", 
      "+", 
      "+config OCFS2_FS", 
      "+\ttristate \"OCFS2 file system support\"", 
      "+\tdepends on NET && SYSFS", 
      "+\tselect CONFIGFS_FS", 
      "+\tselect JBD", 
      "+\tselect CRC32", 
      "+\thelp", 
      "+\t  OCFS2 is a general purpose extent based shared disk cluster file", 
      "+\t  system with many similarities to ext3. It supports 64 bit inode", 
      "+\t  numbers, and has automatically extending metadata groups which may", 
      "+\t  also make it attractive for non-clustered use.", 
      "+", 
      "+\t  You'll want to install the ocfs2-tools package in order to at least", 
      "+\t  get \"mount.ocfs2\".", 
      "+", 
      "+\t  Project web page:    http://oss.oracle.com/projects/ocfs2", 
      "+\t  Tools web page:      http://oss.oracle.com/projects/ocfs2-tools", 
      "+\t  OCFS2 mailing lists: http://oss.oracle.com/projects/ocfs2/mailman/", 
      "+", 
      "+\t  Note: Features which OCFS2 does not support yet:", 
      "+\t          - extended attributes", 
      "+\t          - quotas", 
      "+\t          - cluster aware flock", 
      "+\t          - Directory change notification (F_NOTIFY)", 
      "+\t          - Distributed Caching (F_SETLEASE/F_GETLEASE/break_lease)", 
      "+\t          - POSIX ACLs", 
      "+\t          - readpages / writepages (not user visible)", 
      "+", 
      "+config OCFS2_DEBUG_MASKLOG", 
      "+\tbool \"OCFS2 logging support\"", 
      "+\tdepends on OCFS2_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  The ocfs2 filesystem has an extensive logging system.  The system", 
      "+\t  allows selection of events to log via files in /sys/o2cb/logmask/.", 
      "+\t  This option will enlarge your kernel, but it allows debugging of", 
      "+\t  ocfs2 filesystem issues.", 
      "+", 
      "+config MINIX_FS", 
      "+\ttristate \"Minix fs support\"", 
      "+\thelp", 
      "+\t  Minix is a simple operating system used in many classes about OS's.", 
      "+\t  The minix file system (method to organize files on a hard disk", 
      "+\t  partition or a floppy disk) was the original file system for Linux,", 
      "+\t  but has been superseded by the second extended file system ext2fs.", 
      "+\t  You don't want to use the minix file system on your hard disk", 
      "+\t  because of certain built-in restrictions, but it is sometimes found", 
      "+\t  on older Linux floppy disks.  This option will enlarge your kernel", 
      "+\t  by about 28 KB. If unsure, say N.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called minix.  Note that the file system of your root", 
      "+\t  partition (the one containing the directory /) cannot be compiled as", 
      "+\t  a module.", 
      "+", 
      "+config ROMFS_FS", 
      "+\ttristate \"ROM file system support\"", 
      "+\t---help---", 
      "+\t  This is a very small read-only file system mainly intended for", 
      "+\t  initial ram disks of installation disks, but it could be used for", 
      "+\t  other read-only media as well.  Read", 
      "+\t  <file:Documentation/filesystems/romfs.txt> for details.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called romfs.  Note that the file system of your", 
      "+\t  root partition (the one containing the directory /) cannot be a", 
      "+\t  module.", 
      "+", 
      "+\t  If you don't know whether you need it, then you don't need it:", 
      "+\t  answer N.", 
      "+", 
      "+endif", 
      "+", 
      "+config INOTIFY", 
      "+\tbool \"Inotify file change notification support\"", 
      "+\tdefault y", 
      "+\t---help---", 
      "+\t  Say Y here to enable inotify support.  Inotify is a file change", 
      "+\t  notification system and a replacement for dnotify.  Inotify fixes", 
      "+\t  numerous shortcomings in dnotify and introduces several new features", 
      "+\t  including multiple file events, one-shot support, and unmount", 
      "+\t  notification.", 
      "+", 
      "+\t  For more information, see Documentation/filesystems/inotify.txt", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config INOTIFY_USER", 
      "+\tbool \"Inotify support for userspace\"", 
      "+\tdepends on INOTIFY", 
      "+\tdefault y", 
      "+\t---help---", 
      "+\t  Say Y here to enable inotify support for userspace, including the", 
      "+\t  associated system calls.  Inotify allows monitoring of both files and", 
      "+\t  directories via a single open fd.  Events are read from the file", 
      "+\t  descriptor, which is also select()- and poll()-able.", 
      "+", 
      "+\t  For more information, see Documentation/filesystems/inotify.txt", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config QUOTA", 
      "+\tbool \"Quota support\"", 
      "+\thelp", 
      "+\t  If you say Y here, you will be able to set per user limits for disk", 
      "+\t  usage (also called disk quotas). Currently, it works for the", 
      "+\t  ext2, ext3, and reiserfs file system. ext3 also supports journalled", 
      "+\t  quotas for which you don't need to run quotacheck(8) after an unclean", 
      "+\t  shutdown.", 
      "+\t  For further details, read the Quota mini-HOWTO, available from", 
      "+\t  <http://www.tldp.org/docs.html#howto>, or the documentation provided", 
      "+\t  with the quota tools. Probably the quota support is only useful for", 
      "+\t  multi user systems. If unsure, say N.", 
      "+", 
      "+config QFMT_V1", 
      "+\ttristate \"Old quota format support\"", 
      "+\tdepends on QUOTA", 
      "+\thelp", 
      "+\t  This quota format was (is) used by kernels earlier than 2.4.22. If", 
      "+\t  you have quota working and you don't want to convert to new quota", 
      "+\t  format say Y here.", 
      "+", 
      "+config QFMT_V2", 
      "+\ttristate \"Quota format v2 support\"", 
      "+\tdepends on QUOTA", 
      "+\thelp", 
      "+\t  This quota format allows using quotas with 32-bit UIDs/GIDs. If you", 
      "+\t  need this functionality say Y here.", 
      "+", 
      "+config QUOTACTL", 
      "+\tbool", 
      "+\tdepends on XFS_QUOTA || QUOTA", 
      "+\tdefault y", 
      "+", 
      "+config DNOTIFY", 
      "+\tbool \"Dnotify support\" if EMBEDDED", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Dnotify is a directory-based per-fd file change notification system", 
      "+\t  that uses signals to communicate events to user-space.  There exist", 
      "+\t  superior alternatives, but some applications may still rely on", 
      "+\t  dnotify.", 
      "+", 
      "+\t  Because of this, if unsure, say Y.", 
      "+", 
      "+config AUTOFS_FS", 
      "+\ttristate \"Kernel automounter support\"", 
      "+\thelp", 
      "+\t  The automounter is a tool to automatically mount remote file systems", 
      "+\t  on demand. This implementation is partially kernel-based to reduce", 
      "+\t  overhead in the already-mounted case; this is unlike the BSD", 
      "+\t  automounter (amd), which is a pure user space daemon.", 
      "+", 
      "+\t  To use the automounter you need the user-space tools from the autofs", 
      "+\t  package; you can find the location in <file:Documentation/Changes>.", 
      "+\t  You also want to answer Y to \"NFS file system support\", below.", 
      "+", 
      "+\t  If you want to use the newer version of the automounter with more", 
      "+\t  features, say N here and say Y to \"Kernel automounter v4 support\",", 
      "+\t  below.", 
      "+", 
      "+\t  To compile this support as a module, choose M here: the module will be", 
      "+\t  called autofs.", 
      "+", 
      "+\t  If you are not a part of a fairly large, distributed network, you", 
      "+\t  probably do not need an automounter, and can say N here.", 
      "+", 
      "+config AUTOFS4_FS", 
      "+\ttristate \"Kernel automounter version 4 support (also supports v3)\"", 
      "+\thelp", 
      "+\t  The automounter is a tool to automatically mount remote file systems", 
      "+\t  on demand. This implementation is partially kernel-based to reduce", 
      "+\t  overhead in the already-mounted case; this is unlike the BSD", 
      "+\t  automounter (amd), which is a pure user space daemon.", 
      "+", 
      "+\t  To use the automounter you need the user-space tools from", 
      "+\t  <ftp://ftp.kernel.org/pub/linux/daemons/autofs/v4/>; you also", 
      "+\t  want to answer Y to \"NFS file system support\", below.", 
      "+", 
      "+\t  To compile this support as a module, choose M here: the module will be", 
      "+\t  called autofs4.  You will need to add \"alias autofs autofs4\" to your", 
      "+\t  modules configuration file.", 
      "+", 
      "+\t  If you are not a part of a fairly large, distributed network or", 
      "+\t  don't have a laptop which needs to dynamically reconfigure to the", 
      "+\t  local network, you probably do not need an automounter, and can say", 
      "+\t  N here.", 
      "+", 
      "+config FUSE_FS", 
      "+\ttristate \"Filesystem in Userspace support\"", 
      "+\thelp", 
      "+\t  With FUSE it is possible to implement a fully functional filesystem", 
      "+\t  in a userspace program.", 
      "+", 
      "+\t  There's also companion library: libfuse.  This library along with", 
      "+\t  utilities is available from the FUSE homepage:", 
      "+\t  <http://fuse.sourceforge.net/>", 
      "+", 
      "+\t  See <file:Documentation/filesystems/fuse.txt> for more information.", 
      "+\t  See <file:Documentation/Changes> for needed library/utility version.", 
      "+", 
      "+\t  If you want to develop a userspace FS, or if you want to use", 
      "+\t  a filesystem based on FUSE, answer Y or M.", 
      "+", 
      "+config GENERIC_ACL", 
      "+\tbool", 
      "+\tselect FS_POSIX_ACL", 
      "+", 
      "+if BLOCK", 
      "+menu \"CD-ROM/DVD Filesystems\"", 
      "+", 
      "+config ISO9660_FS", 
      "+\ttristate \"ISO 9660 CDROM file system support\"", 
      "+\thelp", 
      "+\t  This is the standard file system used on CD-ROMs.  It was previously", 
      "+\t  known as \"High Sierra File System\" and is called \"hsfs\" on other", 
      "+\t  Unix systems.  The so-called Rock-Ridge extensions which allow for", 
      "+\t  long Unix filenames and symbolic links are also supported by this", 
      "+\t  driver.  If you have a CD-ROM drive and want to do more with it than", 
      "+\t  just listen to audio CDs and watch its LEDs, say Y (and read", 
      "+\t  <file:Documentation/filesystems/isofs.txt> and the CD-ROM-HOWTO,", 
      "+\t  available from <http://www.tldp.org/docs.html#howto>), thereby", 
      "+\t  enlarging your kernel by about 27 KB; otherwise say N.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called isofs.", 
      "+", 
      "+config JOLIET", 
      "+\tbool \"Microsoft Joliet CDROM extensions\"", 
      "+\tdepends on ISO9660_FS", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  Joliet is a Microsoft extension for the ISO 9660 CD-ROM file system", 
      "+\t  which allows for long filenames in unicode format (unicode is the", 
      "+\t  new 16 bit character code, successor to ASCII, which encodes the", 
      "+\t  characters of almost all languages of the world; see", 
      "+\t  <http://www.unicode.org/> for more information).  Say Y here if you", 
      "+\t  want to be able to read Joliet CD-ROMs under Linux.", 
      "+", 
      "+config ZISOFS", 
      "+\tbool \"Transparent decompression extension\"", 
      "+\tdepends on ISO9660_FS", 
      "+\tselect ZLIB_INFLATE", 
      "+\thelp", 
      "+\t  This is a Linux-specific extension to RockRidge which lets you store", 
      "+\t  data in compressed form on a CD-ROM and have it transparently", 
      "+\t  decompressed when the CD-ROM is accessed.  See", 
      "+\t  <http://www.kernel.org/pub/linux/utils/fs/zisofs/> for the tools", 
      "+\t  necessary to create such a filesystem.  Say Y here if you want to be", 
      "+\t  able to read such compressed CD-ROMs.", 
      "+", 
      "+config UDF_FS", 
      "+\ttristate \"UDF file system support\"", 
      "+\thelp", 
      "+\t  This is the new file system used on some CD-ROMs and DVDs. Say Y if", 
      "+\t  you intend to mount DVD discs or CDRW's written in packet mode, or", 
      "+\t  if written to by other UDF utilities, such as DirectCD.", 
      "+\t  Please read <file:Documentation/filesystems/udf.txt>.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called udf.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config UDF_NLS", 
      "+\tbool", 
      "+\tdefault y", 
      "+\tdepends on (UDF_FS=m && NLS) || (UDF_FS=y && NLS=y)", 
      "+", 
      "+endmenu", 
      "+endif", 
      "+", 
      "+if BLOCK", 
      "+menu \"DOS/FAT/NT Filesystems\"", 
      "+", 
      "+config FAT_FS", 
      "+\ttristate", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  If you want to use one of the FAT-based file systems (the MS-DOS and", 
      "+\t  VFAT (Windows 95) file systems), then you must say Y or M here", 
      "+\t  to include FAT support. You will then be able to mount partitions or", 
      "+\t  diskettes with FAT-based file systems and transparently access the", 
      "+\t  files on them, i.e. MSDOS files will look and behave just like all", 
      "+\t  other Unix files.", 
      "+", 
      "+\t  This FAT support is not a file system in itself, it only provides", 
      "+\t  the foundation for the other file systems. You will have to say Y or", 
      "+\t  M to at least one of \"MSDOS fs support\" or \"VFAT fs support\" in", 
      "+\t  order to make use of it.", 
      "+", 
      "+\t  Another way to read and write MSDOS floppies and hard drive", 
      "+\t  partitions from within Linux (but not transparently) is with the", 
      "+\t  mtools (\"man mtools\") program suite. You don't need to say Y here in", 
      "+\t  order to do that.", 
      "+", 
      "+\t  If you need to move large files on floppies between a DOS and a", 
      "+\t  Linux box, say Y here, mount the floppy under Linux with an MSDOS", 
      "+\t  file system and use GNU tar's M option. GNU tar is a program", 
      "+\t  available for Unix and DOS (\"man tar\" or \"info tar\").", 
      "+", 
      "+\t  The FAT support will enlarge your kernel by about 37 KB. If unsure,", 
      "+\t  say Y.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  fat.  Note that if you compile the FAT support as a module, you", 
      "+\t  cannot compile any of the FAT-based file systems into the kernel", 
      "+\t  -- they will have to be modules as well.", 
      "+", 
      "+config MSDOS_FS", 
      "+\ttristate \"MSDOS fs support\"", 
      "+\tselect FAT_FS", 
      "+\thelp", 
      "+\t  This allows you to mount MSDOS partitions of your hard drive (unless", 
      "+\t  they are compressed; to access compressed MSDOS partitions under", 
      "+\t  Linux, you can either use the DOS emulator DOSEMU, described in the", 
      "+\t  DOSEMU-HOWTO, available from", 
      "+\t  <http://www.tldp.org/docs.html#howto>, or try dmsdosfs in", 
      "+\t  <ftp://ibiblio.org/pub/Linux/system/filesystems/dosfs/>. If you", 
      "+\t  intend to use dosemu with a non-compressed MSDOS partition, say Y", 
      "+\t  here) and MSDOS floppies. This means that file access becomes", 
      "+\t  transparent, i.e. the MSDOS files look and behave just like all", 
      "+\t  other Unix files.", 
      "+", 
      "+\t  If you have Windows 95 or Windows NT installed on your MSDOS", 
      "+\t  partitions, you should use the VFAT file system (say Y to \"VFAT fs", 
      "+\t  support\" below), or you will not be able to see the long filenames", 
      "+\t  generated by Windows 95 / Windows NT.", 
      "+", 
      "+\t  This option will enlarge your kernel by about 7 KB. If unsure,", 
      "+\t  answer Y. This will only work if you said Y to \"DOS FAT fs support\"", 
      "+\t  as well. To compile this as a module, choose M here: the module will", 
      "+\t  be called msdos.", 
      "+", 
      "+config VFAT_FS", 
      "+\ttristate \"VFAT (Windows-95) fs support\"", 
      "+\tselect FAT_FS", 
      "+\thelp", 
      "+\t  This option provides support for normal Windows file systems with", 
      "+\t  long filenames.  That includes non-compressed FAT-based file systems", 
      "+\t  used by Windows 95, Windows 98, Windows NT 4.0, and the Unix", 
      "+\t  programs from the mtools package.", 
      "+", 
      "+\t  The VFAT support enlarges your kernel by about 10 KB and it only", 
      "+\t  works if you said Y to the \"DOS FAT fs support\" above.  Please read", 
      "+\t  the file <file:Documentation/filesystems/vfat.txt> for details.  If", 
      "+\t  unsure, say Y.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  vfat.", 
      "+", 
      "+config FAT_DEFAULT_CODEPAGE", 
      "+\tint \"Default codepage for FAT\"", 
      "+\tdepends on MSDOS_FS || VFAT_FS", 
      "+\tdefault 437", 
      "+\thelp", 
      "+\t  This option should be set to the codepage of your FAT filesystems.", 
      "+\t  It can be overridden with the \"codepage\" mount option.", 
      "+\t  See <file:Documentation/filesystems/vfat.txt> for more information.", 
      "+", 
      "+config FAT_DEFAULT_IOCHARSET", 
      "+\tstring \"Default iocharset for FAT\"", 
      "+\tdepends on VFAT_FS", 
      "+\tdefault \"iso8859-1\"", 
      "+\thelp", 
      "+\t  Set this to the default input/output character set you'd", 
      "+\t  like FAT to use. It should probably match the character set", 
      "+\t  that most of your FAT filesystems use, and can be overridden", 
      "+\t  with the \"iocharset\" mount option for FAT filesystems.", 
      "+\t  Note that \"utf8\" is not recommended for FAT filesystems.", 
      "+\t  If unsure, you shouldn't set \"utf8\" here.", 
      "+\t  See <file:Documentation/filesystems/vfat.txt> for more information.", 
      "+", 
      "+config NTFS_FS", 
      "+\ttristate \"NTFS file system support\"", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  NTFS is the file system of Microsoft Windows NT, 2000, XP and 2003.", 
      "+", 
      "+\t  Saying Y or M here enables read support.  There is partial, but", 
      "+\t  safe, write support available.  For write support you must also", 
      "+\t  say Y to \"NTFS write support\" below.", 
      "+", 
      "+\t  There are also a number of user-space tools available, called", 
      "+\t  ntfsprogs.  These include ntfsundelete and ntfsresize, that work", 
      "+\t  without NTFS support enabled in the kernel.", 
      "+", 
      "+\t  This is a rewrite from scratch of Linux NTFS support and replaced", 
      "+\t  the old NTFS code starting with Linux 2.5.11.  A backport to", 
      "+\t  the Linux 2.4 kernel series is separately available as a patch", 
      "+\t  from the project web site.", 
      "+", 
      "+\t  For more information see <file:Documentation/filesystems/ntfs.txt>", 
      "+\t  and <http://linux-ntfs.sourceforge.net/>.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called ntfs.", 
      "+", 
      "+\t  If you are not using Windows NT, 2000, XP or 2003 in addition to", 
      "+\t  Linux on your computer it is safe to say N.", 
      "+", 
      "+config NTFS_DEBUG", 
      "+\tbool \"NTFS debugging support\"", 
      "+\tdepends on NTFS_FS", 
      "+\thelp", 
      "+\t  If you are experiencing any problems with the NTFS file system, say", 
      "+\t  Y here.  This will result in additional consistency checks to be", 
      "+\t  performed by the driver as well as additional debugging messages to", 
      "+\t  be written to the system log.  Note that debugging messages are", 
      "+\t  disabled by default.  To enable them, supply the option debug_msgs=1", 
      "+\t  at the kernel command line when booting the kernel or as an option", 
      "+\t  to insmod when loading the ntfs module.  Once the driver is active,", 
      "+\t  you can enable debugging messages by doing (as root):", 
      "+\t  echo 1 > /proc/sys/fs/ntfs-debug", 
      "+\t  Replacing the \"1\" with \"0\" would disable debug messages.", 
      "+", 
      "+\t  If you leave debugging messages disabled, this results in little", 
      "+\t  overhead, but enabling debug messages results in very significant", 
      "+\t  slowdown of the system.", 
      "+", 
      "+\t  When reporting bugs, please try to have available a full dump of", 
      "+\t  debugging messages while the misbehaviour was occurring.", 
      "+", 
      "+config NTFS_RW", 
      "+\tbool \"NTFS write support\"", 
      "+\tdepends on NTFS_FS", 
      "+\thelp", 
      "+\t  This enables the partial, but safe, write support in the NTFS driver.", 
      "+", 
      "+\t  The only supported operation is overwriting existing files, without", 
      "+\t  changing the file length.  No file or directory creation, deletion or", 
      "+\t  renaming is possible.  Note only non-resident files can be written to", 
      "+\t  so you may find that some very small files (<500 bytes or so) cannot", 
      "+\t  be written to.", 
      "+", 
      "+\t  While we cannot guarantee that it will not damage any data, we have", 
      "+\t  so far not received a single report where the driver would have", 
      "+\t  damaged someones data so we assume it is perfectly safe to use.", 
      "+", 
      "+\t  Note:  While write support is safe in this version (a rewrite from", 
      "+\t  scratch of the NTFS support), it should be noted that the old NTFS", 
      "+\t  write support, included in Linux 2.5.10 and before (since 1997),", 
      "+\t  is not safe.", 
      "+", 
      "+\t  This is currently useful with TopologiLinux.  TopologiLinux is run", 
      "+\t  on top of any DOS/Microsoft Windows system without partitioning your", 
      "+\t  hard disk.  Unlike other Linux distributions TopologiLinux does not", 
      "+\t  need its own partition.  For more information see", 
      "+\t  <http://topologi-linux.sourceforge.net/>", 
      "+", 
      "+\t  It is perfectly safe to say N here.", 
      "+", 
      "+endmenu", 
      "+endif", 
      "+", 
      "+menu \"Pseudo filesystems\"", 
      "+", 
      "+config PROC_FS", 
      "+\tbool \"/proc file system support\" if EMBEDDED", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  This is a virtual file system providing information about the status", 
      "+\t  of the system. \"Virtual\" means that it doesn't take up any space on", 
      "+\t  your hard disk: the files are created on the fly by the kernel when", 
      "+\t  you try to access them. Also, you cannot read the files with older", 
      "+\t  version of the program less: you need to use more or cat.", 
      "+", 
      "+\t  It's totally cool; for example, \"cat /proc/interrupts\" gives", 
      "+\t  information about what the different IRQs are used for at the moment", 
      "+\t  (there is a small number of Interrupt ReQuest lines in your computer", 
      "+\t  that are used by the attached devices to gain the CPU's attention --", 
      "+\t  often a source of trouble if two devices are mistakenly configured", 
      "+\t  to use the same IRQ). The program procinfo to display some", 
      "+\t  information about your system gathered from the /proc file system.", 
      "+", 
      "+\t  Before you can use the /proc file system, it has to be mounted,", 
      "+\t  meaning it has to be given a location in the directory hierarchy.", 
      "+\t  That location should be /proc. A command such as \"mount -t proc proc", 
      "+\t  /proc\" or the equivalent line in /etc/fstab does the job.", 
      "+", 
      "+\t  The /proc file system is explained in the file", 
      "+\t  <file:Documentation/filesystems/proc.txt> and on the proc(5) manpage", 
      "+\t  (\"man 5 proc\").", 
      "+", 
      "+\t  This option will enlarge your kernel by about 67 KB. Several", 
      "+\t  programs depend on this, so everyone should say Y here.", 
      "+", 
      "+config PROC_KCORE", 
      "+\tbool \"/proc/kcore support\" if !ARM", 
      "+\tdepends on PROC_FS && MMU", 
      "+", 
      "+config PROC_VMCORE", 
      "+        bool \"/proc/vmcore support (EXPERIMENTAL)\"", 
      "+        depends on PROC_FS && EXPERIMENTAL && CRASH_DUMP", 
      "+\tdefault y", 
      "+        help", 
      "+        Exports the dump image of crashed kernel in ELF format.", 
      "+", 
      "+config PROC_SYSCTL", 
      "+\tbool \"Sysctl support (/proc/sys)\" if EMBEDDED", 
      "+\tdepends on PROC_FS", 
      "+\tselect SYSCTL", 
      "+\tdefault y", 
      "+\t---help---", 
      "+\t  The sysctl interface provides a means of dynamically changing", 
      "+\t  certain kernel parameters and variables on the fly without requiring", 
      "+\t  a recompile of the kernel or reboot of the system.  The primary", 
      "+\t  interface is through /proc/sys.  If you say Y here a tree of", 
      "+\t  modifiable sysctl entries will be generated beneath the", 
      "+          /proc/sys directory. They are explained in the files", 
      "+\t  in <file:Documentation/sysctl/>.  Note that enabling this", 
      "+\t  option will enlarge the kernel by at least 8 KB.", 
      "+", 
      "+\t  As it is generally a good thing, you should say Y here unless", 
      "+\t  building a kernel for install/rescue disks or your system is very", 
      "+\t  limited in memory.", 
      "+", 
      "+config SYSFS", 
      "+\tbool \"sysfs file system support\" if EMBEDDED", 
      "+\tdefault y", 
      "+\thelp", 
      "+\tThe sysfs filesystem is a virtual filesystem that the kernel uses to", 
      "+\texport internal kernel objects, their attributes, and their", 
      "+\trelationships to one another.", 
      "+", 
      "+\tUsers can use sysfs to ascertain useful information about the running", 
      "+\tkernel, such as the devices the kernel has discovered on each bus and", 
      "+\twhich driver each is bound to. sysfs can also be used to tune devices", 
      "+\tand other kernel subsystems.", 
      "+", 
      "+\tSome system agents rely on the information in sysfs to operate.", 
      "+\t/sbin/hotplug uses device and object attributes in sysfs to assist in", 
      "+\tdelegating policy decisions, like persistently naming devices.", 
      "+", 
      "+\tsysfs is currently used by the block subsystem to mount the root", 
      "+\tpartition.  If sysfs is disabled you must specify the boot device on", 
      "+\tthe kernel boot command line via its major and minor numbers.  For", 
      "+\texample, \"root=03:01\" for /dev/hda1.", 
      "+", 
      "+\tDesigners of embedded systems may wish to say N here to conserve space.", 
      "+", 
      "+config TMPFS", 
      "+\tbool \"Virtual memory file system support (former shm fs)\"", 
      "+\thelp", 
      "+\t  Tmpfs is a file system which keeps all files in virtual memory.", 
      "+", 
      "+\t  Everything in tmpfs is temporary in the sense that no files will be", 
      "+\t  created on your hard drive. The files live in memory and swap", 
      "+\t  space. If you unmount a tmpfs instance, everything stored therein is", 
      "+\t  lost.", 
      "+", 
      "+\t  See <file:Documentation/filesystems/tmpfs.txt> for details.", 
      "+", 
      "+config TMPFS_POSIX_ACL", 
      "+\tbool \"Tmpfs POSIX Access Control Lists\"", 
      "+\tdepends on TMPFS", 
      "+\tselect GENERIC_ACL", 
      "+\thelp", 
      "+\t  POSIX Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the POSIX ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N.", 
      "+", 
      "+config HUGETLBFS", 
      "+\tbool \"HugeTLB file system support\"", 
      "+\tdepends on X86 || IA64 || PPC64 || SPARC64 || (SUPERH && MMU) || BROKEN", 
      "+\thelp", 
      "+\t  hugetlbfs is a filesystem backing for HugeTLB pages, based on", 
      "+\t  ramfs. For architectures that support it, say Y here and read", 
      "+\t  <file:Documentation/vm/hugetlbpage.txt> for details.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config HUGETLB_PAGE", 
      "+\tdef_bool HUGETLBFS", 
      "+", 
      "+config RAMFS", 
      "+\tbool", 
      "+\tdefault y", 
      "+\t---help---", 
      "+\t  Ramfs is a file system which keeps all files in RAM. It allows", 
      "+\t  read and write access.", 
      "+", 
      "+\t  It is more of an programming example than a useable file system.  If", 
      "+\t  you need a file system which lives in RAM with limit checking use", 
      "+\t  tmpfs.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  ramfs.", 
      "+", 
      "+config CONFIGFS_FS", 
      "+\ttristate \"Userspace-driven configuration filesystem (EXPERIMENTAL)\"", 
      "+\tdepends on SYSFS && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  configfs is a ram-based filesystem that provides the converse", 
      "+\t  of sysfs's functionality. Where sysfs is a filesystem-based", 
      "+\t  view of kernel objects, configfs is a filesystem-based manager", 
      "+\t  of kernel objects, or config_items.", 
      "+", 
      "+\t  Both sysfs and configfs can and should exist together on the", 
      "+\t  same system. One is not a replacement for the other.", 
      "+", 
      "+endmenu", 
      "+", 
      "+menu \"Miscellaneous filesystems\"", 
      "+", 
      "+config ADFS_FS", 
      "+\ttristate \"ADFS file system support (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  The Acorn Disc Filing System is the standard file system of the", 
      "+\t  RiscOS operating system which runs on Acorn's ARM-based Risc PC", 
      "+\t  systems and the Acorn Archimedes range of machines. If you say Y", 
      "+\t  here, Linux will be able to read from ADFS partitions on hard drives", 
      "+\t  and from ADFS-formatted floppy discs. If you also want to be able to", 
      "+\t  write to those devices, say Y to \"ADFS write support\" below.", 
      "+", 
      "+\t  The ADFS partition should be the first partition (i.e.,", 
      "+\t  /dev/[hs]d?1) on each of your drives. Please read the file", 
      "+\t  <file:Documentation/filesystems/adfs.txt> for further details.", 
      "+", 
      "+\t  To compile this code as a module, choose M here: the module will be", 
      "+\t  called adfs.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config ADFS_FS_RW", 
      "+\tbool \"ADFS write support (DANGEROUS)\"", 
      "+\tdepends on ADFS_FS", 
      "+\thelp", 
      "+\t  If you say Y here, you will be able to write to ADFS partitions on", 
      "+\t  hard drives and ADFS-formatted floppy disks. This is experimental", 
      "+\t  codes, so if you're unsure, say N.", 
      "+", 
      "+config AFFS_FS", 
      "+\ttristate \"Amiga FFS file system support (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  The Fast File System (FFS) is the common file system used on hard", 
      "+\t  disks by Amiga(tm) systems since AmigaOS Version 1.3 (34.20).  Say Y", 
      "+\t  if you want to be able to read and write files from and to an Amiga", 
      "+\t  FFS partition on your hard drive.  Amiga floppies however cannot be", 
      "+\t  read with this driver due to an incompatibility of the floppy", 
      "+\t  controller used in an Amiga and the standard floppy controller in", 
      "+\t  PCs and workstations. Read <file:Documentation/filesystems/affs.txt>", 
      "+\t  and <file:fs/affs/Changes>.", 
      "+", 
      "+\t  With this driver you can also mount disk files used by Bernd", 
      "+\t  Schmidt's Un*X Amiga Emulator", 
      "+\t  (<http://www.freiburg.linux.de/~uae/>).", 
      "+\t  If you want to do this, you will also need to say Y or M to \"Loop", 
      "+\t  device support\", above.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called affs.  If unsure, say N.", 
      "+", 
      "+config ECRYPT_FS", 
      "+\ttristate \"eCrypt filesystem layer support (EXPERIMENTAL)\"", 
      "+\tdepends on EXPERIMENTAL && KEYS && CRYPTO && NET", 
      "+\thelp", 
      "+\t  Encrypted filesystem that operates on the VFS layer.  See", 
      "+\t  <file:Documentation/ecryptfs.txt> to learn more about", 
      "+\t  eCryptfs.  Userspace components are required and can be", 
      "+\t  obtained from <http://ecryptfs.sf.net>.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called ecryptfs.", 
      "+", 
      "+config HFS_FS", 
      "+\ttristate \"Apple Macintosh file system support (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  If you say Y here, you will be able to mount Macintosh-formatted", 
      "+\t  floppy disks and hard drive partitions with full read-write access.", 
      "+\t  Please read <file:fs/hfs/HFS.txt> to learn about the available mount", 
      "+\t  options.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called hfs.", 
      "+", 
      "+config HFSPLUS_FS", 
      "+\ttristate \"Apple Extended HFS file system support\"", 
      "+\tdepends on BLOCK", 
      "+\tselect NLS", 
      "+\tselect NLS_UTF8", 
      "+\thelp", 
      "+\t  If you say Y here, you will be able to mount extended format", 
      "+\t  Macintosh-formatted hard drive partitions with full read-write access.", 
      "+", 
      "+\t  This file system is often called HFS+ and was introduced with", 
      "+\t  MacOS 8. It includes all Mac specific filesystem data such as", 
      "+\t  data forks and creator codes, but it also has several UNIX", 
      "+\t  style features such as file ownership and permissions.", 
      "+", 
      "+config BEFS_FS", 
      "+\ttristate \"BeOS file system (BeFS) support (read only) (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  The BeOS File System (BeFS) is the native file system of Be, Inc's", 
      "+\t  BeOS. Notable features include support for arbitrary attributes", 
      "+\t  on files and directories, and database-like indices on selected", 
      "+\t  attributes. (Also note that this driver doesn't make those features", 
      "+\t  available at this time). It is a 64 bit filesystem, so it supports", 
      "+\t  extremely large volumes and files.", 
      "+", 
      "+\t  If you use this filesystem, you should also say Y to at least one", 
      "+\t  of the NLS (native language support) options below.", 
      "+", 
      "+\t  If you don't know what this is about, say N.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be", 
      "+\t  called befs.", 
      "+", 
      "+config BEFS_DEBUG", 
      "+\tbool \"Debug BeFS\"", 
      "+\tdepends on BEFS_FS", 
      "+\thelp", 
      "+\t  If you say Y here, you can use the 'debug' mount option to enable", 
      "+\t  debugging output from the driver.", 
      "+", 
      "+config BFS_FS", 
      "+\ttristate \"BFS file system support (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  Boot File System (BFS) is a file system used under SCO UnixWare to", 
      "+\t  allow the bootloader access to the kernel image and other important", 
      "+\t  files during the boot process.  It is usually mounted under /stand", 
      "+\t  and corresponds to the slice marked as \"STAND\" in the UnixWare", 
      "+\t  partition.  You should say Y if you want to read or write the files", 
      "+\t  on your /stand slice from within Linux.  You then also need to say Y", 
      "+\t  to \"UnixWare slices support\", below.  More information about the BFS", 
      "+\t  file system is contained in the file", 
      "+\t  <file:Documentation/filesystems/bfs.txt>.", 
      "+", 
      "+\t  If you don't know what this is about, say N.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  bfs.  Note that the file system of your root partition (the one", 
      "+\t  containing the directory /) cannot be compiled as a module.", 
      "+", 
      "+", 
      "+", 
      "+config EFS_FS", 
      "+\ttristate \"EFS file system support (read only) (EXPERIMENTAL)\"", 
      "+\tdepends on BLOCK && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  EFS is an older file system used for non-ISO9660 CD-ROMs and hard", 
      "+\t  disk partitions by SGI's IRIX operating system (IRIX 6.0 and newer", 
      "+\t  uses the XFS file system for hard disk partitions however).", 
      "+", 
      "+\t  This implementation only offers read-only access. If you don't know", 
      "+\t  what all this is about, it's safe to say N. For more information", 
      "+\t  about EFS see its home page at <http://aeschi.ch.eu.org/efs/>.", 
      "+", 
      "+\t  To compile the EFS file system support as a module, choose M here: the", 
      "+\t  module will be called efs.", 
      "+", 
      "+config JFFS2_FS", 
      "+\ttristate \"Journalling Flash File System v2 (JFFS2) support\"", 
      "+\tselect CRC32", 
      "+\tdepends on MTD", 
      "+\thelp", 
      "+\t  JFFS2 is the second generation of the Journalling Flash File System", 
      "+\t  for use on diskless embedded devices. It provides improved wear", 
      "+\t  levelling, compression and support for hard links. You cannot use", 
      "+\t  this on normal block devices, only on 'MTD' devices.", 
      "+", 
      "+\t  Further information on the design and implementation of JFFS2 is", 
      "+\t  available at <http://sources.redhat.com/jffs2/>.", 
      "+", 
      "+config JFFS2_FS_DEBUG", 
      "+\tint \"JFFS2 debugging verbosity (0 = quiet, 2 = noisy)\"", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault \"0\"", 
      "+\thelp", 
      "+\t  This controls the amount of debugging messages produced by the JFFS2", 
      "+\t  code. Set it to zero for use in production systems. For evaluation,", 
      "+\t  testing and debugging, it's advisable to set it to one. This will", 
      "+\t  enable a few assertions and will print debugging messages at the", 
      "+\t  KERN_DEBUG loglevel, where they won't normally be visible. Level 2", 
      "+\t  is unlikely to be useful - it enables extra debugging in certain", 
      "+\t  areas which at one point needed debugging, but when the bugs were", 
      "+\t  located and fixed, the detailed messages were relegated to level 2.", 
      "+", 
      "+\t  If reporting bugs, please try to have available a full dump of the", 
      "+\t  messages at debug level 1 while the misbehaviour was occurring.", 
      "+", 
      "+config JFFS2_FS_WRITEBUFFER", 
      "+\tbool \"JFFS2 write-buffering support\"", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  This enables the write-buffering support in JFFS2.", 
      "+", 
      "+\t  This functionality is required to support JFFS2 on the following", 
      "+\t  types of flash devices:", 
      "+\t    - NAND flash", 
      "+\t    - NOR flash with transparent ECC", 
      "+\t    - DataFlash", 
      "+", 
      "+config JFFS2_SUMMARY", 
      "+\tbool \"JFFS2 summary support (EXPERIMENTAL)\"", 
      "+\tdepends on JFFS2_FS && EXPERIMENTAL", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  This feature makes it possible to use summary information", 
      "+\t  for faster filesystem mount.", 
      "+", 
      "+\t  The summary information can be inserted into a filesystem image", 
      "+\t  by the utility 'sumtool'.", 
      "+", 
      "+\t  If unsure, say 'N'.", 
      "+", 
      "+config JFFS2_FS_XATTR", 
      "+\tbool \"JFFS2 XATTR support (EXPERIMENTAL)\"", 
      "+\tdepends on JFFS2_FS && EXPERIMENTAL", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  Extended attributes are name:value pairs associated with inodes by", 
      "+\t  the kernel or by users (see the attr(5) manual page, or visit", 
      "+\t  <http://acl.bestbits.at/> for details).", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config JFFS2_FS_POSIX_ACL", 
      "+\tbool \"JFFS2 POSIX Access Control Lists\"", 
      "+\tdepends on JFFS2_FS_XATTR", 
      "+\tdefault y", 
      "+\tselect FS_POSIX_ACL", 
      "+\thelp", 
      "+\t  Posix Access Control Lists (ACLs) support permissions for users and", 
      "+\t  groups beyond the owner/group/world scheme.", 
      "+", 
      "+\t  To learn more about Access Control Lists, visit the Posix ACLs for", 
      "+\t  Linux website <http://acl.bestbits.at/>.", 
      "+", 
      "+\t  If you don't know what Access Control Lists are, say N", 
      "+", 
      "+config JFFS2_FS_SECURITY", 
      "+\tbool \"JFFS2 Security Labels\"", 
      "+\tdepends on JFFS2_FS_XATTR", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Security labels support alternative access control models", 
      "+\t  implemented by security modules like SELinux.  This option", 
      "+\t  enables an extended attribute handler for file security", 
      "+\t  labels in the jffs2 filesystem.", 
      "+", 
      "+\t  If you are not using a security module that requires using", 
      "+\t  extended attributes for file security labels, say N.", 
      "+", 
      "+config JFFS2_COMPRESSION_OPTIONS", 
      "+\tbool \"Advanced compression options for JFFS2\"", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  Enabling this option allows you to explicitly choose which", 
      "+\t  compression modules, if any, are enabled in JFFS2. Removing", 
      "+\t  compressors and mean you cannot read existing file systems,", 
      "+\t  and enabling experimental compressors can mean that you", 
      "+\t  write a file system which cannot be read by a standard kernel.", 
      "+", 
      "+\t  If unsure, you should _definitely_ say 'N'.", 
      "+", 
      "+config JFFS2_ZLIB", 
      "+\tbool \"JFFS2 ZLIB compression support\" if JFFS2_COMPRESSION_OPTIONS", 
      "+\tselect ZLIB_INFLATE", 
      "+\tselect ZLIB_DEFLATE", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault y", 
      "+        help", 
      "+          Zlib is designed to be a free, general-purpose, legally unencumbered,", 
      "+          lossless data-compression library for use on virtually any computer", 
      "+          hardware and operating system. See <http://www.gzip.org/zlib/> for", 
      "+          further information.", 
      "+", 
      "+          Say 'Y' if unsure.", 
      "+", 
      "+config JFFS2_RTIME", 
      "+\tbool \"JFFS2 RTIME compression support\" if JFFS2_COMPRESSION_OPTIONS", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault y", 
      "+        help", 
      "+          Rtime does manage to recompress already-compressed data. Say 'Y' if unsure.", 
      "+", 
      "+config JFFS2_RUBIN", 
      "+\tbool \"JFFS2 RUBIN compression support\" if JFFS2_COMPRESSION_OPTIONS", 
      "+\tdepends on JFFS2_FS", 
      "+\tdefault n", 
      "+        help", 
      "+          RUBINMIPS and DYNRUBIN compressors. Say 'N' if unsure.", 
      "+", 
      "+choice", 
      "+        prompt \"JFFS2 default compression mode\" if JFFS2_COMPRESSION_OPTIONS", 
      "+        default JFFS2_CMODE_PRIORITY", 
      "+        depends on JFFS2_FS", 
      "+        help", 
      "+          You can set here the default compression mode of JFFS2 from", 
      "+          the available compression modes. Don't touch if unsure.", 
      "+", 
      "+config JFFS2_CMODE_NONE", 
      "+        bool \"no compression\"", 
      "+        help", 
      "+          Uses no compression.", 
      "+", 
      "+config JFFS2_CMODE_PRIORITY", 
      "+        bool \"priority\"", 
      "+        help", 
      "+          Tries the compressors in a predefined order and chooses the first", 
      "+          successful one.", 
      "+", 
      "+config JFFS2_CMODE_SIZE", 
      "+        bool \"size (EXPERIMENTAL)\"", 
      "+        help", 
      "+          Tries all compressors and chooses the one which has the smallest", 
      "+          result.", 
      "+", 
      "+endchoice", 
      "+", 
      "+config CRAMFS", 
      "+\ttristate \"Compressed ROM file system support (cramfs)\"", 
      "+\tdepends on BLOCK", 
      "+\tselect ZLIB_INFLATE", 
      "+\thelp", 
      "+\t  Saying Y here includes support for CramFs (Compressed ROM File", 
      "+\t  System).  CramFs is designed to be a simple, small, and compressed", 
      "+\t  file system for ROM based embedded systems.  CramFs is read-only,", 
      "+\t  limited to 256MB file systems (with 16MB files), and doesn't support", 
      "+\t  16/32 bits uid/gid, hard links and timestamps.", 
      "+", 
      "+\t  See <file:Documentation/filesystems/cramfs.txt> and", 
      "+\t  <file:fs/cramfs/README> for further information.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  cramfs.  Note that the root file system (the one containing the", 
      "+\t  directory /) cannot be compiled as a module.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config SQUASHFS", 
      "+\ttristate \"SquashFS 3.3 - Squashed file system support\"", 
      "+\tselect ZLIB_INFLATE", 
      "+\thelp", 
      "+\t  Saying Y here includes support for SquashFS 3.3 (a Compressed", 
      "+\t  Read-Only File System).  Squashfs is a highly compressed read-only", 
      "+\t  filesystem for Linux.  It uses zlib compression to compress both", 
      "+\t  files, inodes and directories.  Inodes in the system are very small", 
      "+\t  and all blocks are packed to minimise data overhead. Block sizes", 
      "+\t  greater than 4K are supported up to a maximum of 1 Mbytes (default", 
      "+\t  block size 128K).  SquashFS 3.3 supports 64 bit filesystems and files", 
      "+\t  (larger than 4GB), full uid/gid information, hard links and timestamps.", 
      "+", 
      "+\t  Squashfs is intended for general read-only filesystem use, for", 
      "+\t  archival use (i.e. in cases where a .tar.gz file may be used), and in", 
      "+\t  embedded systems where low overhead is needed.  Further information", 
      "+\t  and filesystem tools are available from http://squashfs.sourceforge.net.", 
      "+", 
      "+\t  If you want to compile this as a module ( = code which can be", 
      "+\t  inserted in and removed from the running kernel whenever you want),", 
      "+\t  say M here and read <file:Documentation/modules.txt>.  The module", 
      "+\t  will be called squashfs.  Note that the root file system (the one", 
      "+\t  containing the directory /) cannot be compiled as a module.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config SQUASHFS_EMBEDDED", 
      "+", 
      "+\tbool \"Additional option for memory-constrained systems\"", 
      "+\tdepends on SQUASHFS", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  Saying Y here allows you to specify cache size.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config SQUASHFS_FRAGMENT_CACHE_SIZE", 
      "+\tint \"Number of fragments cached\" if SQUASHFS_EMBEDDED", 
      "+\tdepends on SQUASHFS", 
      "+\tdefault \"3\"", 
      "+\thelp", 
      "+\t  By default SquashFS caches the last 3 fragments read from", 
      "+\t  the filesystem.  Increasing this amount may mean SquashFS", 
      "+\t  has to re-read fragments less often from disk, at the expense", 
      "+\t  of extra system memory.  Decreasing this amount will mean", 
      "+\t  SquashFS uses less memory at the expense of extra reads from disk.", 
      "+", 
      "+\t  Note there must be at least one cached fragment.  Anything", 
      "+\t  much more than three will probably not make much difference.", 
      "+", 
      "+config VXFS_FS", 
      "+\ttristate \"FreeVxFS file system support (VERITAS VxFS(TM) compatible)\"", 
      "+\tdepends on BLOCK", 
      "+\thelp", 
      "+\t  FreeVxFS is a file system driver that support the VERITAS VxFS(TM)", 
      "+\t  file system format.  VERITAS VxFS(TM) is the standard file system", 
      "+\t  of SCO UnixWare (and possibly others) and optionally available", 
      "+\t  for Sunsoft Solaris, HP-UX and many other operating systems.", 
      "+\t  Currently only readonly access is supported.", 
      "+", 
      "+\t  NOTE: the file system type as used by mount(1), mount(2) and", 
      "+\t  fstab(5) is 'vxfs' as it describes the file system format, not", 
      "+\t  the actual driver.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be", 
      "+\t  called freevxfs.  If unsure, say N.", 
      "+", 
      "+", 
      "+config HPFS_FS", 
      "+\ttristate \"OS/2 HPFS file system support\"", 
      "+\tdepends on BLOCK", 
      "+\thelp", 
      "+\t  OS/2 is IBM's operating system for PC's, the same as Warp, and HPFS", 
      "+\t  is the file system used for organizing files on OS/2 hard disk", 
      "+\t  partitions. Say Y if you want to be able to read files from and", 
      "+\t  write files to an OS/2 HPFS partition on your hard drive. OS/2", 
      "+\t  floppies however are in regular MSDOS format, so you don't need this", 
      "+\t  option in order to be able to read them. Read", 
      "+\t  <file:Documentation/filesystems/hpfs.txt>.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called hpfs.  If unsure, say N.", 
      "+", 
      "+", 
      "+", 
      "+config QNX4FS_FS", 
      "+\ttristate \"QNX4 file system support (read only)\"", 
      "+\tdepends on BLOCK", 
      "+\thelp", 
      "+\t  This is the file system used by the real-time operating systems", 
      "+\t  QNX 4 and QNX 6 (the latter is also called QNX RTP).", 
      "+\t  Further information is available at <http://www.qnx.com/>.", 
      "+\t  Say Y if you intend to mount QNX hard disks or floppies.", 
      "+\t  Unless you say Y to \"QNX4FS read-write support\" below, you will", 
      "+\t  only be able to read these file systems.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called qnx4.", 
      "+", 
      "+\t  If you don't know whether you need it, then you don't need it:", 
      "+\t  answer N.", 
      "+", 
      "+config QNX4FS_RW", 
      "+\tbool \"QNX4FS write support (DANGEROUS)\"", 
      "+\tdepends on QNX4FS_FS && EXPERIMENTAL && BROKEN", 
      "+\thelp", 
      "+\t  Say Y if you want to test write support for QNX4 file systems.", 
      "+", 
      "+\t  It's currently broken, so for now:", 
      "+\t  answer N.", 
      "+", 
      "+", 
      "+", 
      "+config SYSV_FS", 
      "+\ttristate \"System V/Xenix/V7/Coherent file system support\"", 
      "+\tdepends on BLOCK", 
      "+\thelp", 
      "+\t  SCO, Xenix and Coherent are commercial Unix systems for Intel", 
      "+\t  machines, and Version 7 was used on the DEC PDP-11. Saying Y", 
      "+\t  here would allow you to read from their floppies and hard disk", 
      "+\t  partitions.", 
      "+", 
      "+\t  If you have floppies or hard disk partitions like that, it is likely", 
      "+\t  that they contain binaries from those other Unix systems; in order", 
      "+\t  to run these binaries, you will want to install linux-abi which is", 
      "+\t  a set of kernel modules that lets you run SCO, Xenix, Wyse,", 
      "+\t  UnixWare, Dell Unix and System V programs under Linux.  It is", 
      "+\t  available via FTP (user: ftp) from", 
      "+\t  <ftp://ftp.openlinux.org/pub/people/hch/linux-abi/>).", 
      "+\t  NOTE: that will work only for binaries from Intel-based systems;", 
      "+\t  PDP ones will have to wait until somebody ports Linux to -11 ;-)", 
      "+", 
      "+\t  If you only intend to mount files from some other Unix over the", 
      "+\t  network using NFS, you don't need the System V file system support", 
      "+\t  (but you need NFS file system support obviously).", 
      "+", 
      "+\t  Note that this option is generally not needed for floppies, since a", 
      "+\t  good portable way to transport files and directories between unixes", 
      "+\t  (and even other operating systems) is given by the tar program (\"man", 
      "+\t  tar\" or preferably \"info tar\").  Note also that this option has", 
      "+\t  nothing whatsoever to do with the option \"System V IPC\". Read about", 
      "+\t  the System V file system in", 
      "+\t  <file:Documentation/filesystems/sysv-fs.txt>.", 
      "+\t  Saying Y here will enlarge your kernel by about 27 KB.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  sysv.", 
      "+", 
      "+\t  If you haven't heard about all of this before, it's safe to say N.", 
      "+", 
      "+", 
      "+", 
      "+config UFS_FS", 
      "+\ttristate \"UFS file system support (read only)\"", 
      "+\tdepends on BLOCK", 
      "+\thelp", 
      "+\t  BSD and derivate versions of Unix (such as SunOS, FreeBSD, NetBSD,", 
      "+\t  OpenBSD and NeXTstep) use a file system called UFS. Some System V", 
      "+\t  Unixes can create and mount hard disk partitions and diskettes using", 
      "+\t  this file system as well. Saying Y here will allow you to read from", 
      "+\t  these partitions; if you also want to write to them, say Y to the", 
      "+\t  experimental \"UFS file system write support\", below. Please read the", 
      "+\t  file <file:Documentation/filesystems/ufs.txt> for more information.", 
      "+", 
      "+          The recently released UFS2 variant (used in FreeBSD 5.x) is", 
      "+          READ-ONLY supported.", 
      "+", 
      "+\t  If you only intend to mount files from some other Unix over the", 
      "+\t  network using NFS, you don't need the UFS file system support (but", 
      "+\t  you need NFS file system support obviously).", 
      "+", 
      "+\t  Note that this option is generally not needed for floppies, since a", 
      "+\t  good portable way to transport files and directories between unixes", 
      "+\t  (and even other operating systems) is given by the tar program (\"man", 
      "+\t  tar\" or preferably \"info tar\").", 
      "+", 
      "+\t  When accessing NeXTstep files, you may need to convert them from the", 
      "+\t  NeXT character set to the Latin1 character set; use the program", 
      "+\t  recode (\"info recode\") for this purpose.", 
      "+", 
      "+\t  To compile the UFS file system support as a module, choose M here: the", 
      "+\t  module will be called ufs.", 
      "+", 
      "+\t  If you haven't heard about all of this before, it's safe to say N.", 
      "+", 
      "+config UFS_FS_WRITE", 
      "+\tbool \"UFS file system write support (DANGEROUS)\"", 
      "+\tdepends on UFS_FS && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  Say Y here if you want to try writing to UFS partitions. This is", 
      "+\t  experimental, so you should back up your UFS partitions beforehand.", 
      "+", 
      "+config UFS_DEBUG", 
      "+\tbool \"UFS debugging\"", 
      "+\tdepends on UFS_FS", 
      "+\thelp", 
      "+\t  If you are experiencing any problems with the UFS filesystem, say", 
      "+\t  Y here.  This will result in _many_ additional debugging messages to be", 
      "+\t  written to the system log.", 
      "+", 
      "+endmenu", 
      "+", 
      "+menu \"Network File Systems\"", 
      "+\tdepends on NET", 
      "+", 
      "+config NFS_FS", 
      "+\ttristate \"NFS file system support\"", 
      "+\tdepends on INET", 
      "+\tselect LOCKD", 
      "+\tselect SUNRPC", 
      "+\tselect NFS_ACL_SUPPORT if NFS_V3_ACL", 
      "+\thelp", 
      "+\t  If you are connected to some other (usually local) Unix computer", 
      "+\t  (using SLIP, PLIP, PPP or Ethernet) and want to mount files residing", 
      "+\t  on that computer (the NFS server) using the Network File Sharing", 
      "+\t  protocol, say Y. \"Mounting files\" means that the client can access", 
      "+\t  the files with usual UNIX commands as if they were sitting on the", 
      "+\t  client's hard disk. For this to work, the server must run the", 
      "+\t  programs nfsd and mountd (but does not need to have NFS file system", 
      "+\t  support enabled in its kernel). NFS is explained in the Network", 
      "+\t  Administrator's Guide, available from", 
      "+\t  <http://www.tldp.org/docs.html#guide>, on its man page: \"man", 
      "+\t  nfs\", and in the NFS-HOWTO.", 
      "+", 
      "+\t  A superior but less widely used alternative to NFS is provided by", 
      "+\t  the Coda file system; see \"Coda file system support\" below.", 
      "+", 
      "+\t  If you say Y here, you should have said Y to TCP/IP networking also.", 
      "+\t  This option would enlarge your kernel by about 27 KB.", 
      "+", 
      "+\t  To compile this file system support as a module, choose M here: the", 
      "+\t  module will be called nfs.", 
      "+", 
      "+\t  If you are configuring a diskless machine which will mount its root", 
      "+\t  file system over NFS at boot time, say Y here and to \"Kernel", 
      "+\t  level IP autoconfiguration\" above and to \"Root file system on NFS\"", 
      "+\t  below. You cannot compile this driver as a module in this case.", 
      "+\t  There are two packages designed for booting diskless machines over", 
      "+\t  the net: netboot, available from", 
      "+\t  <http://ftp1.sourceforge.net/netboot/>, and Etherboot,", 
      "+\t  available from <http://ftp1.sourceforge.net/etherboot/>.", 
      "+", 
      "+\t  If you don't know what all this is about, say N.", 
      "+", 
      "+config NFS_V3", 
      "+\tbool \"Provide NFSv3 client support\"", 
      "+\tdepends on NFS_FS", 
      "+\thelp", 
      "+\t  Say Y here if you want your NFS client to be able to speak version", 
      "+\t  3 of the NFS protocol.", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config NFS_V3_ACL", 
      "+\tbool \"Provide client support for the NFSv3 ACL protocol extension\"", 
      "+\tdepends on NFS_V3", 
      "+\thelp", 
      "+\t  Implement the NFSv3 ACL protocol extension for manipulating POSIX", 
      "+\t  Access Control Lists.  The server should also be compiled with", 
      "+\t  the NFSv3 ACL protocol extension; see the CONFIG_NFSD_V3_ACL option.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config NFS_V4", 
      "+\tbool \"Provide NFSv4 client support (EXPERIMENTAL)\"", 
      "+\tdepends on NFS_FS && EXPERIMENTAL", 
      "+\tselect RPCSEC_GSS_KRB5", 
      "+\thelp", 
      "+\t  Say Y here if you want your NFS client to be able to speak the newer", 
      "+\t  version 4 of the NFS protocol.", 
      "+", 
      "+\t  Note: Requires auxiliary userspace daemons which may be found on", 
      "+\t\thttp://www.citi.umich.edu/projects/nfsv4/", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config NFS_DIRECTIO", 
      "+\tbool \"Allow direct I/O on NFS files\"", 
      "+\tdepends on NFS_FS", 
      "+\thelp", 
      "+\t  This option enables applications to perform uncached I/O on files", 
      "+\t  in NFS file systems using the O_DIRECT open() flag.  When O_DIRECT", 
      "+\t  is set for a file, its data is not cached in the system's page", 
      "+\t  cache.  Data is moved to and from user-level application buffers", 
      "+\t  directly.  Unlike local disk-based file systems, NFS O_DIRECT has", 
      "+\t  no alignment restrictions.", 
      "+", 
      "+\t  Unless your program is designed to use O_DIRECT properly, you are", 
      "+\t  much better off allowing the NFS client to manage data caching for", 
      "+\t  you.  Misusing O_DIRECT can cause poor server performance or network", 
      "+\t  storms.  This kernel build option defaults OFF to avoid exposing", 
      "+\t  system administrators unwittingly to a potentially hazardous", 
      "+\t  feature.", 
      "+", 
      "+\t  For more details on NFS O_DIRECT, see fs/nfs/direct.c.", 
      "+", 
      "+\t  If unsure, say N.  This reduces the size of the NFS client, and", 
      "+\t  causes open() to return EINVAL if a file residing in NFS is", 
      "+\t  opened with the O_DIRECT flag.", 
      "+", 
      "+config NFSD", 
      "+\ttristate \"NFS server support\"", 
      "+\tdepends on INET", 
      "+\tselect LOCKD", 
      "+\tselect SUNRPC", 
      "+\tselect EXPORTFS", 
      "+\tselect NFSD_V2_ACL if NFSD_V3_ACL", 
      "+\tselect NFS_ACL_SUPPORT if NFSD_V2_ACL", 
      "+\tselect NFSD_TCP if NFSD_V4", 
      "+\tselect CRYPTO_MD5 if NFSD_V4", 
      "+\tselect CRYPTO if NFSD_V4", 
      "+\tselect FS_POSIX_ACL if NFSD_V4", 
      "+\thelp", 
      "+\t  If you want your Linux box to act as an NFS *server*, so that other", 
      "+\t  computers on your local network which support NFS can access certain", 
      "+\t  directories on your box transparently, you have two options: you can", 
      "+\t  use the self-contained user space program nfsd, in which case you", 
      "+\t  should say N here, or you can say Y and use the kernel based NFS", 
      "+\t  server. The advantage of the kernel based solution is that it is", 
      "+\t  faster.", 
      "+", 
      "+\t  In either case, you will need support software; the respective", 
      "+\t  locations are given in the file <file:Documentation/Changes> in the", 
      "+\t  NFS section.", 
      "+", 
      "+\t  If you say Y here, you will get support for version 2 of the NFS", 
      "+\t  protocol (NFSv2). If you also want NFSv3, say Y to the next question", 
      "+\t  as well.", 
      "+", 
      "+\t  Please read the NFS-HOWTO, available from", 
      "+\t  <http://www.tldp.org/docs.html#howto>.", 
      "+", 
      "+\t  To compile the NFS server support as a module, choose M here: the", 
      "+\t  module will be called nfsd.  If unsure, say N.", 
      "+", 
      "+config NFSD_V2_ACL", 
      "+\tbool", 
      "+\tdepends on NFSD", 
      "+", 
      "+config NFSD_V3", 
      "+\tbool \"Provide NFSv3 server support\"", 
      "+\tdepends on NFSD", 
      "+\thelp", 
      "+\t  If you would like to include the NFSv3 server as well as the NFSv2", 
      "+\t  server, say Y here.  If unsure, say Y.", 
      "+", 
      "+config NFSD_V3_ACL", 
      "+\tbool \"Provide server support for the NFSv3 ACL protocol extension\"", 
      "+\tdepends on NFSD_V3", 
      "+\thelp", 
      "+\t  Implement the NFSv3 ACL protocol extension for manipulating POSIX", 
      "+\t  Access Control Lists on exported file systems. NFS clients should", 
      "+\t  be compiled with the NFSv3 ACL protocol extension; see the", 
      "+\t  CONFIG_NFS_V3_ACL option.  If unsure, say N.", 
      "+", 
      "+config NFSD_V4", 
      "+\tbool \"Provide NFSv4 server support (EXPERIMENTAL)\"", 
      "+\tdepends on NFSD && NFSD_V3 && EXPERIMENTAL", 
      "+\tselect RPCSEC_GSS_KRB5", 
      "+\thelp", 
      "+\t  If you would like to include the NFSv4 server as well as the NFSv2", 
      "+\t  and NFSv3 servers, say Y here.  This feature is experimental, and", 
      "+\t  should only be used if you are interested in helping to test NFSv4.", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config NFSD_TCP", 
      "+\tbool \"Provide NFS server over TCP support\"", 
      "+\tdepends on NFSD", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  If you want your NFS server to support TCP connections, say Y here.", 
      "+\t  TCP connections usually perform better than the default UDP when", 
      "+\t  the network is lossy or congested.  If unsure, say Y.", 
      "+", 
      "+config ROOT_NFS", 
      "+\tbool \"Root file system on NFS\"", 
      "+\tdepends on NFS_FS=y && IP_PNP", 
      "+\thelp", 
      "+\t  If you want your Linux box to mount its whole root file system (the", 
      "+\t  one containing the directory /) from some other computer over the", 
      "+\t  net via NFS (presumably because your box doesn't have a hard disk),", 
      "+\t  say Y. Read <file:Documentation/nfsroot.txt> for details. It is", 
      "+\t  likely that in this case, you also want to say Y to \"Kernel level IP", 
      "+\t  autoconfiguration\" so that your box can discover its network address", 
      "+\t  at boot time.", 
      "+", 
      "+\t  Most people say N here.", 
      "+", 
      "+config LOCKD", 
      "+\ttristate", 
      "+", 
      "+config LOCKD_V4", 
      "+\tbool", 
      "+\tdepends on NFSD_V3 || NFS_V3", 
      "+\tdefault y", 
      "+", 
      "+config EXPORTFS", 
      "+\ttristate", 
      "+", 
      "+config NFS_ACL_SUPPORT", 
      "+\ttristate", 
      "+\tselect FS_POSIX_ACL", 
      "+", 
      "+config NFS_COMMON", 
      "+\tbool", 
      "+\tdepends on NFSD || NFS_FS", 
      "+\tdefault y", 
      "+", 
      "+config SUNRPC", 
      "+\ttristate", 
      "+", 
      "+config SUNRPC_GSS", 
      "+\ttristate", 
      "+", 
      "+config SUNRPC_BIND34", 
      "+\tbool \"Support for rpcbind versions 3 & 4 (EXPERIMENTAL)\"", 
      "+\tdepends on SUNRPC && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  Provides kernel support for querying rpcbind servers via versions 3", 
      "+\t  and 4 of the rpcbind protocol.  The kernel automatically falls back", 
      "+\t  to version 2 if a remote rpcbind service does not support versions", 
      "+\t  3 or 4.", 
      "+", 
      "+\t  If unsure, say N to get traditional behavior (version 2 rpcbind", 
      "+\t  requests only).", 
      "+", 
      "+config RPCSEC_GSS_KRB5", 
      "+\ttristate \"Secure RPC: Kerberos V mechanism (EXPERIMENTAL)\"", 
      "+\tdepends on SUNRPC && EXPERIMENTAL", 
      "+\tselect SUNRPC_GSS", 
      "+\tselect CRYPTO", 
      "+\tselect CRYPTO_MD5", 
      "+\tselect CRYPTO_DES", 
      "+\tselect CRYPTO_CBC", 
      "+\thelp", 
      "+\t  Provides for secure RPC calls by means of a gss-api", 
      "+\t  mechanism based on Kerberos V5. This is required for", 
      "+\t  NFSv4.", 
      "+", 
      "+\t  Note: Requires an auxiliary userspace daemon which may be found on", 
      "+\t\thttp://www.citi.umich.edu/projects/nfsv4/", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config RPCSEC_GSS_SPKM3", 
      "+\ttristate \"Secure RPC: SPKM3 mechanism (EXPERIMENTAL)\"", 
      "+\tdepends on SUNRPC && EXPERIMENTAL", 
      "+\tselect SUNRPC_GSS", 
      "+\tselect CRYPTO", 
      "+\tselect CRYPTO_MD5", 
      "+\tselect CRYPTO_DES", 
      "+\tselect CRYPTO_CAST5", 
      "+\tselect CRYPTO_CBC", 
      "+\thelp", 
      "+\t  Provides for secure RPC calls by means of a gss-api", 
      "+\t  mechanism based on the SPKM3 public-key mechanism.", 
      "+", 
      "+\t  Note: Requires an auxiliary userspace daemon which may be found on", 
      "+\t  \thttp://www.citi.umich.edu/projects/nfsv4/", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config SMB_FS", 
      "+\ttristate \"SMB file system support (to mount Windows shares etc.)\"", 
      "+\tdepends on INET", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  SMB (Server Message Block) is the protocol Windows for Workgroups", 
      "+\t  (WfW), Windows 95/98, Windows NT and OS/2 Lan Manager use to share", 
      "+\t  files and printers over local networks.  Saying Y here allows you to", 
      "+\t  mount their file systems (often called \"shares\" in this context) and", 
      "+\t  access them just like any other Unix directory.  Currently, this", 
      "+\t  works only if the Windows machines use TCP/IP as the underlying", 
      "+\t  transport protocol, and not NetBEUI.  For details, read", 
      "+\t  <file:Documentation/filesystems/smbfs.txt> and the SMB-HOWTO,", 
      "+\t  available from <http://www.tldp.org/docs.html#howto>.", 
      "+", 
      "+\t  Note: if you just want your box to act as an SMB *server* and make", 
      "+\t  files and printing services available to Windows clients (which need", 
      "+\t  to have a TCP/IP stack), you don't need to say Y here; you can use", 
      "+\t  the program SAMBA (available from <ftp://ftp.samba.org/pub/samba/>)", 
      "+\t  for that.", 
      "+", 
      "+\t  General information about how to connect Linux, Windows machines and", 
      "+\t  Macs is on the WWW at <http://www.eats.com/linux_mac_win.html>.", 
      "+", 
      "+\t  To compile the SMB support as a module, choose M here: the module will", 
      "+\t  be called smbfs.  Most people say N, however.", 
      "+", 
      "+config SMB_NLS_DEFAULT", 
      "+\tbool \"Use a default NLS\"", 
      "+\tdepends on SMB_FS", 
      "+\thelp", 
      "+\t  Enabling this will make smbfs use nls translations by default. You", 
      "+\t  need to specify the local charset (CONFIG_NLS_DEFAULT) in the nls", 
      "+\t  settings and you need to give the default nls for the SMB server as", 
      "+\t  CONFIG_SMB_NLS_REMOTE.", 
      "+", 
      "+\t  The nls settings can be changed at mount time, if your smbmount", 
      "+\t  supports that, using the codepage and iocharset parameters.", 
      "+", 
      "+\t  smbmount from samba 2.2.0 or later supports this.", 
      "+", 
      "+config SMB_NLS_REMOTE", 
      "+\tstring \"Default Remote NLS Option\"", 
      "+\tdepends on SMB_NLS_DEFAULT", 
      "+\tdefault \"cp437\"", 
      "+\thelp", 
      "+\t  This setting allows you to specify a default value for which", 
      "+\t  codepage the server uses. If this field is left blank no", 
      "+\t  translations will be done by default. The local codepage/charset", 
      "+\t  default to CONFIG_NLS_DEFAULT.", 
      "+", 
      "+\t  The nls settings can be changed at mount time, if your smbmount", 
      "+\t  supports that, using the codepage and iocharset parameters.", 
      "+", 
      "+\t  smbmount from samba 2.2.0 or later supports this.", 
      "+", 
      "+config CIFS", 
      "+\ttristate \"CIFS support (advanced network filesystem for Samba, Window and other CIFS compliant servers)\"", 
      "+\tdepends on INET", 
      "+\tselect NLS", 
      "+\thelp", 
      "+\t  This is the client VFS module for the Common Internet File System", 
      "+\t  (CIFS) protocol which is the successor to the Server Message Block", 
      "+\t  (SMB) protocol, the native file sharing mechanism for most early", 
      "+\t  PC operating systems.  The CIFS protocol is fully supported by", 
      "+\t  file servers such as Windows 2000 (including Windows 2003, NT 4", 
      "+\t  and Windows XP) as well by Samba (which provides excellent CIFS", 
      "+\t  server support for Linux and many other operating systems). Limited", 
      "+\t  support for OS/2 and Windows ME and similar servers is provided as well.", 
      "+", 
      "+\t  The intent of the cifs module is to provide an advanced", 
      "+\t  network file system client for mounting to CIFS compliant servers,", 
      "+\t  including support for dfs (hierarchical name space), secure per-user", 
      "+\t  session establishment, safe distributed caching (oplock), optional", 
      "+\t  packet signing, Unicode and other internationalization improvements.", 
      "+\t  If you need to mount to Samba or Windows from this machine, say Y.", 
      "+", 
      "+config CIFS_STATS", 
      "+        bool \"CIFS statistics\"", 
      "+        depends on CIFS", 
      "+        help", 
      "+          Enabling this option will cause statistics for each server share", 
      "+\t  mounted by the cifs client to be displayed in /proc/fs/cifs/Stats", 
      "+", 
      "+config CIFS_STATS2", 
      "+\tbool \"Extended statistics\"", 
      "+\tdepends on CIFS_STATS", 
      "+\thelp", 
      "+\t  Enabling this option will allow more detailed statistics on SMB", 
      "+\t  request timing to be displayed in /proc/fs/cifs/DebugData and also", 
      "+\t  allow optional logging of slow responses to dmesg (depending on the", 
      "+\t  value of /proc/fs/cifs/cifsFYI, see fs/cifs/README for more details).", 
      "+\t  These additional statistics may have a minor effect on performance", 
      "+\t  and memory utilization.", 
      "+", 
      "+\t  Unless you are a developer or are doing network performance analysis", 
      "+\t  or tuning, say N.", 
      "+", 
      "+config CIFS_WEAK_PW_HASH", 
      "+\tbool \"Support legacy servers which use weaker LANMAN security\"", 
      "+\tdepends on CIFS", 
      "+\thelp", 
      "+\t  Modern CIFS servers including Samba and most Windows versions", 
      "+\t  (since 1997) support stronger NTLM (and even NTLMv2 and Kerberos)", 
      "+\t  security mechanisms. These hash the password more securely", 
      "+\t  than the mechanisms used in the older LANMAN version of the", 
      "+          SMB protocol needed to establish sessions with old SMB servers.", 
      "+", 
      "+\t  Enabling this option allows the cifs module to mount to older", 
      "+\t  LANMAN based servers such as OS/2 and Windows 95, but such", 
      "+\t  mounts may be less secure than mounts using NTLM or more recent", 
      "+\t  security mechanisms if you are on a public network.  Unless you", 
      "+\t  have a need to access old SMB servers (and are on a private", 
      "+\t  network) you probably want to say N.  Even if this support", 
      "+\t  is enabled in the kernel build, they will not be used", 
      "+\t  automatically. At runtime LANMAN mounts are disabled but", 
      "+\t  can be set to required (or optional) either in", 
      "+\t  /proc/fs/cifs (see fs/cifs/README for more detail) or via an", 
      "+\t  option on the mount command. This support is disabled by", 
      "+\t  default in order to reduce the possibility of a downgrade", 
      "+\t  attack.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config CIFS_XATTR", 
      "+        bool \"CIFS extended attributes\"", 
      "+        depends on CIFS", 
      "+        help", 
      "+          Extended attributes are name:value pairs associated with inodes by", 
      "+          the kernel or by users (see the attr(5) manual page, or visit", 
      "+          <http://acl.bestbits.at/> for details).  CIFS maps the name of", 
      "+          extended attributes beginning with the user namespace prefix", 
      "+          to SMB/CIFS EAs. EAs are stored on Windows servers without the", 
      "+          user namespace prefix, but their names are seen by Linux cifs clients", 
      "+          prefaced by the user namespace prefix. The system namespace", 
      "+          (used by some filesystems to store ACLs) is not supported at", 
      "+          this time.", 
      "+", 
      "+          If unsure, say N.", 
      "+", 
      "+config CIFS_POSIX", 
      "+        bool \"CIFS POSIX Extensions\"", 
      "+        depends on CIFS_XATTR", 
      "+        help", 
      "+          Enabling this option will cause the cifs client to attempt to", 
      "+\t  negotiate a newer dialect with servers, such as Samba 3.0.5", 
      "+\t  or later, that optionally can handle more POSIX like (rather", 
      "+\t  than Windows like) file behavior.  It also enables", 
      "+\t  support for POSIX ACLs (getfacl and setfacl) to servers", 
      "+\t  (such as Samba 3.10 and later) which can negotiate", 
      "+\t  CIFS POSIX ACL support.  If unsure, say N.", 
      "+", 
      "+config CIFS_DEBUG2", 
      "+\tbool \"Enable additional CIFS debugging routines\"", 
      "+\tdepends on CIFS", 
      "+\thelp", 
      "+\t   Enabling this option adds a few more debugging routines", 
      "+\t   to the cifs code which slightly increases the size of", 
      "+\t   the cifs module and can cause additional logging of debug", 
      "+\t   messages in some error paths, slowing performance. This", 
      "+\t   option can be turned off unless you are debugging", 
      "+\t   cifs problems.  If unsure, say N.", 
      "+", 
      "+config CIFS_EXPERIMENTAL", 
      "+\t  bool \"CIFS Experimental Features (EXPERIMENTAL)\"", 
      "+\t  depends on CIFS && EXPERIMENTAL", 
      "+\t  help", 
      "+\t    Enables cifs features under testing. These features are", 
      "+\t    experimental and currently include DFS support and directory", 
      "+\t    change notification ie fcntl(F_DNOTIFY), as well as the upcall", 
      "+\t    mechanism which will be used for Kerberos session negotiation", 
      "+\t    and uid remapping.  Some of these features also may depend on", 
      "+\t    setting a value of 1 to the pseudo-file /proc/fs/cifs/Experimental", 
      "+\t    (which is disabled by default). See the file fs/cifs/README", 
      "+\t    for more details.  If unsure, say N.", 
      "+", 
      "+config CIFS_UPCALL", 
      "+\t  bool \"Kerberos/SPNEGO advanced session setup (EXPERIMENTAL)\"", 
      "+\t  depends on CIFS_EXPERIMENTAL", 
      "+\t  depends on CONNECTOR", 
      "+\t  help", 
      "+\t    Enables an upcall mechanism for CIFS which will be used to contact", 
      "+\t    userspace helper utilities to provide SPNEGO packaged Kerberos", 
      "+\t    tickets which are needed to mount to certain secure servers", 
      "+\t    (for which more secure Kerberos authentication is required). If", 
      "+\t    unsure, say N.", 
      "+", 
      "+config NCP_FS", 
      "+\ttristate \"NCP file system support (to mount NetWare volumes)\"", 
      "+\tdepends on IPX!=n || INET", 
      "+\thelp", 
      "+\t  NCP (NetWare Core Protocol) is a protocol that runs over IPX and is", 
      "+\t  used by Novell NetWare clients to talk to file servers.  It is to", 
      "+\t  IPX what NFS is to TCP/IP, if that helps.  Saying Y here allows you", 
      "+\t  to mount NetWare file server volumes and to access them just like", 
      "+\t  any other Unix directory.  For details, please read the file", 
      "+\t  <file:Documentation/filesystems/ncpfs.txt> in the kernel source and", 
      "+\t  the IPX-HOWTO from <http://www.tldp.org/docs.html#howto>.", 
      "+", 
      "+\t  You do not have to say Y here if you want your Linux box to act as a", 
      "+\t  file *server* for Novell NetWare clients.", 
      "+", 
      "+\t  General information about how to connect Linux, Windows machines and", 
      "+\t  Macs is on the WWW at <http://www.eats.com/linux_mac_win.html>.", 
      "+", 
      "+\t  To compile this as a module, choose M here: the module will be called", 
      "+\t  ncpfs.  Say N unless you are connected to a Novell network.", 
      "+", 
      "+source \"fs/ncpfs/Kconfig\"", 
      "+", 
      "+config CODA_FS", 
      "+\ttristate \"Coda file system support (advanced network fs)\"", 
      "+\tdepends on INET", 
      "+\thelp", 
      "+\t  Coda is an advanced network file system, similar to NFS in that it", 
      "+\t  enables you to mount file systems of a remote server and access them", 
      "+\t  with regular Unix commands as if they were sitting on your hard", 
      "+\t  disk.  Coda has several advantages over NFS: support for", 
      "+\t  disconnected operation (e.g. for laptops), read/write server", 
      "+\t  replication, security model for authentication and encryption,", 
      "+\t  persistent client caches and write back caching.", 
      "+", 
      "+\t  If you say Y here, your Linux box will be able to act as a Coda", 
      "+\t  *client*.  You will need user level code as well, both for the", 
      "+\t  client and server.  Servers are currently user level, i.e. they need", 
      "+\t  no kernel support.  Please read", 
      "+\t  <file:Documentation/filesystems/coda.txt> and check out the Coda", 
      "+\t  home page <http://www.coda.cs.cmu.edu/>.", 
      "+", 
      "+\t  To compile the coda client support as a module, choose M here: the", 
      "+\t  module will be called coda.", 
      "+", 
      "+config CODA_FS_OLD_API", 
      "+\tbool \"Use 96-bit Coda file identifiers\"", 
      "+\tdepends on CODA_FS", 
      "+\thelp", 
      "+\t  A new kernel-userspace API had to be introduced for Coda v6.0", 
      "+\t  to support larger 128-bit file identifiers as needed by the", 
      "+\t  new realms implementation.", 
      "+", 
      "+\t  However this new API is not backward compatible with older", 
      "+\t  clients. If you really need to run the old Coda userspace", 
      "+\t  cache manager then say Y.", 
      "+", 
      "+\t  For most cases you probably want to say N.", 
      "+", 
      "+config AFS_FS", 
      "+\ttristate \"Andrew File System support (AFS) (EXPERIMENTAL)\"", 
      "+\tdepends on INET && EXPERIMENTAL", 
      "+\tselect AF_RXRPC", 
      "+\thelp", 
      "+\t  If you say Y here, you will get an experimental Andrew File System", 
      "+\t  driver. It currently only supports unsecured read-only AFS access.", 
      "+", 
      "+\t  See <file:Documentation/filesystems/afs.txt> for more information.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config AFS_DEBUG", 
      "+\tbool \"AFS dynamic debugging\"", 
      "+\tdepends on AFS_FS", 
      "+\thelp", 
      "+\t  Say Y here to make runtime controllable debugging messages appear.", 
      "+", 
      "+\t  See <file:Documentation/filesystems/afs.txt> for more information.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config 9P_FS", 
      "+\ttristate \"Plan 9 Resource Sharing Support (9P2000) (Experimental)\"", 
      "+\tdepends on INET && NET_9P && EXPERIMENTAL", 
      "+\thelp", 
      "+\t  If you say Y here, you will get experimental support for", 
      "+\t  Plan 9 resource sharing via the 9P2000 protocol.", 
      "+", 
      "+\t  See <http://v9fs.sf.net> for more information.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+endmenu", 
      "+", 
      "+if BLOCK", 
      "+menu \"Partition Types\"", 
      "+", 
      "+source \"fs/partitions/Kconfig\"", 
      "+", 
      "+endmenu", 
      "+endif", 
      "+", 
      "+source \"fs/nls/Kconfig\"", 
      "+source \"fs/dlm/Kconfig\"", 
      "+", 
      "+endmenu", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/Makefile", 
    "linux-2.6.23-yaffs2/fs/Makefile", 
    [
      "diff -Naur linux-2.6.23/fs/Makefile linux-2.6.23-yaffs2/fs/Makefile", 
      "--- linux-2.6.23/fs/Makefile", 
      "+++ linux-2.6.23-yaffs2/fs/Makefile", 
      "@@ -119,3 +119,6 @@", 
      "obj-$(CONFIG_DEBUG_FS)\t\t+= debugfs/", 
      "obj-$(CONFIG_OCFS2_FS)\t\t+= ocfs2/", 
      "obj-$(CONFIG_GFS2_FS)           += gfs2/", 
      "+", 
      "+# Patched by YAFFS", 
      "+obj-$(CONFIG_YAFFS_FS)\t\t+= yaffs2/"
    ]
  ], 
  [
    "linux-2.6.23/fs/Makefile.pre.yaffs", 
    "linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs", 
    [
      "diff -Naur linux-2.6.23/fs/Makefile.pre.yaffs linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs", 
      "--- linux-2.6.23/fs/Makefile.pre.yaffs", 
      "+++ linux-2.6.23-yaffs2/fs/Makefile.pre.yaffs", 
      "@@ -0,0 +1,121 @@", 
      "+#", 
      "+# Makefile for the Linux filesystems.", 
      "+#", 
      "+# 14 Sep 2000, Christoph Hellwig <hch@infradead.org>", 
      "+# Rewritten to use lists instead of if-statements.", 
      "+#", 
      "+", 
      "+obj-y :=\topen.o read_write.o file_table.o super.o \\", 
      "+\t\tchar_dev.o stat.o exec.o pipe.o namei.o fcntl.o \\", 
      "+\t\tioctl.o readdir.o select.o fifo.o locks.o dcache.o inode.o \\", 
      "+\t\tattr.o bad_inode.o file.o filesystems.o namespace.o aio.o \\", 
      "+\t\tseq_file.o xattr.o libfs.o fs-writeback.o \\", 
      "+\t\tpnode.o drop_caches.o splice.o sync.o utimes.o \\", 
      "+\t\tstack.o", 
      "+", 
      "+ifeq ($(CONFIG_BLOCK),y)", 
      "+obj-y +=\tbuffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o", 
      "+else", 
      "+obj-y +=\tno-block.o", 
      "+endif", 
      "+", 
      "+obj-$(CONFIG_INOTIFY)\t\t+= inotify.o", 
      "+obj-$(CONFIG_INOTIFY_USER)\t+= inotify_user.o", 
      "+obj-$(CONFIG_EPOLL)\t\t+= eventpoll.o", 
      "+obj-$(CONFIG_ANON_INODES)\t+= anon_inodes.o", 
      "+obj-$(CONFIG_SIGNALFD)\t\t+= signalfd.o", 
      "+obj-$(CONFIG_TIMERFD)\t\t+= timerfd.o", 
      "+obj-$(CONFIG_EVENTFD)\t\t+= eventfd.o", 
      "+obj-$(CONFIG_COMPAT)\t\t+= compat.o compat_ioctl.o", 
      "+", 
      "+nfsd-$(CONFIG_NFSD)\t\t:= nfsctl.o", 
      "+obj-y\t\t\t\t+= $(nfsd-y) $(nfsd-m)", 
      "+", 
      "+obj-$(CONFIG_BINFMT_AOUT)\t+= binfmt_aout.o", 
      "+obj-$(CONFIG_BINFMT_EM86)\t+= binfmt_em86.o", 
      "+obj-$(CONFIG_BINFMT_MISC)\t+= binfmt_misc.o", 
      "+", 
      "+# binfmt_script is always there", 
      "+obj-y\t\t\t\t+= binfmt_script.o", 
      "+", 
      "+obj-$(CONFIG_BINFMT_ELF)\t+= binfmt_elf.o", 
      "+obj-$(CONFIG_BINFMT_ELF_FDPIC)\t+= binfmt_elf_fdpic.o", 
      "+obj-$(CONFIG_BINFMT_SOM)\t+= binfmt_som.o", 
      "+obj-$(CONFIG_BINFMT_FLAT)\t+= binfmt_flat.o", 
      "+", 
      "+obj-$(CONFIG_FS_MBCACHE)\t+= mbcache.o", 
      "+obj-$(CONFIG_FS_POSIX_ACL)\t+= posix_acl.o xattr_acl.o", 
      "+obj-$(CONFIG_NFS_COMMON)\t+= nfs_common/", 
      "+obj-$(CONFIG_GENERIC_ACL)\t+= generic_acl.o", 
      "+", 
      "+obj-$(CONFIG_QUOTA)\t\t+= dquot.o", 
      "+obj-$(CONFIG_QFMT_V1)\t\t+= quota_v1.o", 
      "+obj-$(CONFIG_QFMT_V2)\t\t+= quota_v2.o", 
      "+obj-$(CONFIG_QUOTACTL)\t\t+= quota.o", 
      "+", 
      "+obj-$(CONFIG_DNOTIFY)\t\t+= dnotify.o", 
      "+", 
      "+obj-$(CONFIG_PROC_FS)\t\t+= proc/", 
      "+obj-y\t\t\t\t+= partitions/", 
      "+obj-$(CONFIG_SYSFS)\t\t+= sysfs/", 
      "+obj-$(CONFIG_CONFIGFS_FS)\t+= configfs/", 
      "+obj-y\t\t\t\t+= devpts/", 
      "+", 
      "+obj-$(CONFIG_PROFILING)\t\t+= dcookies.o", 
      "+obj-$(CONFIG_DLM)\t\t+= dlm/", 
      "+", 
      "+# Do not add any filesystems before this line", 
      "+obj-$(CONFIG_REISERFS_FS)\t+= reiserfs/", 
      "+obj-$(CONFIG_EXT3_FS)\t\t+= ext3/ # Before ext2 so root fs can be ext3", 
      "+obj-$(CONFIG_EXT4DEV_FS)\t+= ext4/ # Before ext2 so root fs can be ext4dev", 
      "+obj-$(CONFIG_JBD)\t\t+= jbd/", 
      "+obj-$(CONFIG_JBD2)\t\t+= jbd2/", 
      "+obj-$(CONFIG_EXT2_FS)\t\t+= ext2/", 
      "+obj-$(CONFIG_CRAMFS)\t\t+= cramfs/", 
      "+obj-$(CONFIG_SQUASHFS)\t\t+= squashfs/", 
      "+obj-$(CONFIG_RAMFS)\t\t+= ramfs/", 
      "+obj-$(CONFIG_HUGETLBFS)\t\t+= hugetlbfs/", 
      "+obj-$(CONFIG_CODA_FS)\t\t+= coda/", 
      "+obj-$(CONFIG_MINIX_FS)\t\t+= minix/", 
      "+obj-$(CONFIG_FAT_FS)\t\t+= fat/", 
      "+obj-$(CONFIG_MSDOS_FS)\t\t+= msdos/", 
      "+obj-$(CONFIG_VFAT_FS)\t\t+= vfat/", 
      "+obj-$(CONFIG_BFS_FS)\t\t+= bfs/", 
      "+obj-$(CONFIG_ISO9660_FS)\t+= isofs/", 
      "+obj-$(CONFIG_HFSPLUS_FS)\t+= hfsplus/ # Before hfs to find wrapped HFS+", 
      "+obj-$(CONFIG_HFS_FS)\t\t+= hfs/", 
      "+obj-$(CONFIG_ECRYPT_FS)\t\t+= ecryptfs/", 
      "+obj-$(CONFIG_VXFS_FS)\t\t+= freevxfs/", 
      "+obj-$(CONFIG_NFS_FS)\t\t+= nfs/", 
      "+obj-$(CONFIG_EXPORTFS)\t\t+= exportfs/", 
      "+obj-$(CONFIG_NFSD)\t\t+= nfsd/", 
      "+obj-$(CONFIG_LOCKD)\t\t+= lockd/", 
      "+obj-$(CONFIG_NLS)\t\t+= nls/", 
      "+obj-$(CONFIG_SYSV_FS)\t\t+= sysv/", 
      "+obj-$(CONFIG_SMB_FS)\t\t+= smbfs/", 
      "+obj-$(CONFIG_CIFS)\t\t+= cifs/", 
      "+obj-$(CONFIG_NCP_FS)\t\t+= ncpfs/", 
      "+obj-$(CONFIG_HPFS_FS)\t\t+= hpfs/", 
      "+obj-$(CONFIG_NTFS_FS)\t\t+= ntfs/", 
      "+obj-$(CONFIG_UFS_FS)\t\t+= ufs/", 
      "+obj-$(CONFIG_EFS_FS)\t\t+= efs/", 
      "+obj-$(CONFIG_JFFS2_FS)\t\t+= jffs2/", 
      "+obj-$(CONFIG_AFFS_FS)\t\t+= affs/", 
      "+obj-$(CONFIG_ROMFS_FS)\t\t+= romfs/", 
      "+obj-$(CONFIG_QNX4FS_FS)\t\t+= qnx4/", 
      "+obj-$(CONFIG_AUTOFS_FS)\t\t+= autofs/", 
      "+obj-$(CONFIG_AUTOFS4_FS)\t+= autofs4/", 
      "+obj-$(CONFIG_ADFS_FS)\t\t+= adfs/", 
      "+obj-$(CONFIG_FUSE_FS)\t\t+= fuse/", 
      "+obj-$(CONFIG_UDF_FS)\t\t+= udf/", 
      "+obj-$(CONFIG_SUN_OPENPROMFS)\t+= openpromfs/", 
      "+obj-$(CONFIG_JFS_FS)\t\t+= jfs/", 
      "+obj-$(CONFIG_XFS_FS)\t\t+= xfs/", 
      "+obj-$(CONFIG_9P_FS)\t\t+= 9p/", 
      "+obj-$(CONFIG_AFS_FS)\t\t+= afs/", 
      "+obj-$(CONFIG_BEFS_FS)\t\t+= befs/", 
      "+obj-$(CONFIG_HOSTFS)\t\t+= hostfs/", 
      "+obj-$(CONFIG_HPPFS)\t\t+= hppfs/", 
      "+obj-$(CONFIG_DEBUG_FS)\t\t+= debugfs/", 
      "+obj-$(CONFIG_OCFS2_FS)\t\t+= ocfs2/", 
      "+obj-$(CONFIG_GFS2_FS)           += gfs2/"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/devextras.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/devextras.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/devextras.h linux-2.6.23-yaffs2/fs/yaffs2/devextras.h", 
      "--- linux-2.6.23/fs/yaffs2/devextras.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/devextras.h", 
      "@@ -0,0 +1,199 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+/*", 
      "+ * This file is just holds extra declarations of macros that would normally", 
      "+ * be providesd in the Linux kernel. These macros have been written from", 
      "+ * scratch but are functionally equivalent to the Linux ones.", 
      "+ *", 
      "+ */", 
      "+", 
      "+#ifndef __EXTRAS_H__", 
      "+#define __EXTRAS_H__", 
      "+", 
      "+", 
      "+#if !(defined __KERNEL__)", 
      "+", 
      "+/* Definition of types */", 
      "+typedef unsigned char __u8;", 
      "+typedef unsigned short __u16;", 
      "+typedef unsigned __u32;", 
      "+", 
      "+#endif", 
      "+", 
      "+/*", 
      "+ * This is a simple doubly linked list implementation that matches the", 
      "+ * way the Linux kernel doubly linked list implementation works.", 
      "+ */", 
      "+", 
      "+struct ylist_head {", 
      "+\tstruct ylist_head *next; /* next in chain */", 
      "+\tstruct ylist_head *prev; /* previous in chain */", 
      "+};", 
      "+", 
      "+", 
      "+/* Initialise a static list */", 
      "+#define YLIST_HEAD(name) \\", 
      "+struct ylist_head name = { &(name),&(name)}", 
      "+", 
      "+", 
      "+", 
      "+/* Initialise a list head to an empty list */", 
      "+#define YINIT_LIST_HEAD(p) \\", 
      "+do { \\", 
      "+ (p)->next = (p);\\", 
      "+ (p)->prev = (p); \\", 
      "+} while(0)", 
      "+", 
      "+", 
      "+/* Add an element to a list */", 
      "+static __inline__ void ylist_add(struct ylist_head *newEntry,", 
      "+                                 struct ylist_head *list)", 
      "+{", 
      "+        struct ylist_head *listNext = list->next;", 
      "+", 
      "+        list->next = newEntry;", 
      "+        newEntry->prev = list;", 
      "+\tnewEntry->next = listNext;", 
      "+\tlistNext->prev = newEntry;", 
      "+", 
      "+}", 
      "+", 
      "+static __inline__ void ylist_add_tail(struct ylist_head *newEntry,", 
      "+\t\t\t\t struct ylist_head *list)", 
      "+{", 
      "+\tstruct ylist_head *listPrev = list->prev;", 
      "+", 
      "+\tlist->prev = newEntry;", 
      "+\tnewEntry->next = list;", 
      "+\tnewEntry->prev = listPrev;", 
      "+\tlistPrev->next = newEntry;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+/* Take an element out of its current list, with or without", 
      "+ * reinitialising the links.of the entry*/", 
      "+static __inline__ void ylist_del(struct ylist_head *entry)", 
      "+{", 
      "+        struct ylist_head *listNext = entry->next;", 
      "+        struct ylist_head *listPrev = entry->prev;", 
      "+", 
      "+        listNext->prev = listPrev;", 
      "+        listPrev->next = listNext;", 
      "+", 
      "+}", 
      "+", 
      "+static __inline__ void ylist_del_init(struct ylist_head *entry)", 
      "+{", 
      "+        ylist_del(entry);", 
      "+        entry->next = entry->prev = entry;", 
      "+}", 
      "+", 
      "+", 
      "+/* Test if the list is empty */", 
      "+static __inline__ int ylist_empty(struct ylist_head *entry)", 
      "+{", 
      "+        return (entry->next == entry);", 
      "+}", 
      "+", 
      "+", 
      "+/* ylist_entry takes a pointer to a list entry and offsets it to that", 
      "+ * we can find a pointer to the object it is embedded in.", 
      "+ */", 
      "+", 
      "+", 
      "+#define ylist_entry(entry, type, member) \\", 
      "+        ((type *)((char *)(entry)-(unsigned long)(&((type *)NULL)->member)))", 
      "+", 
      "+", 
      "+/* ylist_for_each and list_for_each_safe  iterate over lists.", 
      "+ * ylist_for_each_safe uses temporary storage to make the list delete safe", 
      "+ */", 
      "+", 
      "+#define ylist_for_each(itervar, list) \\", 
      "+        for (itervar = (list)->next; itervar != (list); itervar = itervar->next )", 
      "+", 
      "+#define ylist_for_each_safe(itervar,saveVar, list) \\", 
      "+        for (itervar = (list)->next, saveVar = (list)->next->next; itervar != (list); \\", 
      "+         itervar = saveVar, saveVar = saveVar->next)", 
      "+", 
      "+", 
      "+#if !(defined __KERNEL__)", 
      "+", 
      "+", 
      "+#ifndef WIN32", 
      "+#include <sys/stat.h>", 
      "+#endif", 
      "+", 
      "+", 
      "+#ifdef CONFIG_YAFFS_PROVIDE_DEFS", 
      "+/* File types */", 
      "+", 
      "+", 
      "+#define DT_UNKNOWN      0", 
      "+#define DT_FIFO         1", 
      "+#define DT_CHR          2", 
      "+#define DT_DIR\t\t4", 
      "+#define DT_BLK\t\t6", 
      "+#define DT_REG          8", 
      "+#define DT_LNK          10", 
      "+#define DT_SOCK         12", 
      "+#define DT_WHT          14", 
      "+", 
      "+", 
      "+#ifndef WIN32", 
      "+#include <sys/stat.h>", 
      "+#endif", 
      "+", 
      "+/*", 
      "+ * Attribute flags.  These should be or-ed together to figure out what", 
      "+ * has been changed!", 
      "+ */", 
      "+#define ATTR_MODE       1", 
      "+#define ATTR_UID        2", 
      "+#define ATTR_GID\t4", 
      "+#define ATTR_SIZE\t8", 
      "+#define ATTR_ATIME\t16", 
      "+#define ATTR_MTIME\t32", 
      "+#define ATTR_CTIME\t64", 
      "+", 
      "+struct iattr {", 
      "+\tunsigned int ia_valid;", 
      "+\tunsigned ia_mode;", 
      "+\tunsigned ia_uid;", 
      "+\tunsigned ia_gid;", 
      "+\tunsigned ia_size;", 
      "+\tunsigned ia_atime;", 
      "+\tunsigned ia_mtime;", 
      "+\tunsigned ia_ctime;", 
      "+        unsigned int ia_attr_flags;", 
      "+};", 
      "+", 
      "+#endif", 
      "+", 
      "+", 
      "+#define KERN_DEBUG", 
      "+", 
      "+#else", 
      "+", 
      "+#include <linux/types.h>", 
      "+#include <linux/fs.h>", 
      "+#include <linux/stat.h>", 
      "+", 
      "+#endif", 
      "+", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/Kconfig", 
    "linux-2.6.23-yaffs2/fs/yaffs2/Kconfig", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/Kconfig linux-2.6.23-yaffs2/fs/yaffs2/Kconfig", 
      "--- linux-2.6.23/fs/yaffs2/Kconfig", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/Kconfig", 
      "@@ -0,0 +1,156 @@", 
      "+#", 
      "+# YAFFS file system configurations", 
      "+#", 
      "+", 
      "+config YAFFS_FS", 
      "+\ttristate \"YAFFS2 file system support\"", 
      "+\tdefault n", 
      "+\tdepends on MTD", 
      "+\tselect YAFFS_YAFFS1", 
      "+\tselect YAFFS_YAFFS2", 
      "+\thelp", 
      "+\t  YAFFS2, or Yet Another Flash Filing System, is a filing system", 
      "+\t  optimised for NAND Flash chips.", 
      "+", 
      "+\t  To compile the YAFFS2 file system support as a module, choose M", 
      "+\t  here: the module will be called yaffs2.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+\t  Further information on YAFFS2 is available at", 
      "+\t  <http://www.aleph1.co.uk/yaffs/>.", 
      "+", 
      "+config YAFFS_YAFFS1", 
      "+\tbool \"512 byte / page devices\"", 
      "+\tdepends on YAFFS_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Enable YAFFS1 support -- yaffs for 512 byte / page devices", 
      "+", 
      "+\t  Not needed for 2K-page devices.", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config YAFFS_9BYTE_TAGS", 
      "+\tbool \"Use older-style on-NAND data format with pageStatus byte\"", 
      "+\tdepends on YAFFS_YAFFS1", 
      "+\tdefault n", 
      "+\thelp", 
      "+", 
      "+\t  Older-style on-NAND data format has a \"pageStatus\" byte to record", 
      "+\t  chunk/page state.  This byte is zero when the page is discarded.", 
      "+\t  Choose this option if you have existing on-NAND data using this", 
      "+\t  format that you need to continue to support.  New data written", 
      "+\t  also uses the older-style format.  Note: Use of this option", 
      "+\t  generally requires that MTD's oob layout be adjusted to use the", 
      "+\t  older-style format.  See notes on tags formats and MTD versions", 
      "+\t  in yaffs_mtdif1.c.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config YAFFS_DOES_ECC", 
      "+\tbool \"Lets Yaffs do its own ECC\"", 
      "+\tdepends on YAFFS_FS && YAFFS_YAFFS1 && !YAFFS_9BYTE_TAGS", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  This enables Yaffs to use its own ECC functions instead of using", 
      "+\t  the ones from the generic MTD-NAND driver.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config YAFFS_ECC_WRONG_ORDER", 
      "+\tbool \"Use the same ecc byte order as Steven Hill's nand_ecc.c\"", 
      "+\tdepends on YAFFS_FS && YAFFS_DOES_ECC && !YAFFS_9BYTE_TAGS", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  This makes yaffs_ecc.c use the same ecc byte order as Steven", 
      "+\t  Hill's nand_ecc.c. If not set, then you get the same ecc byte", 
      "+\t  order as SmartMedia.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config YAFFS_YAFFS2", 
      "+\tbool \"2048 byte (or larger) / page devices\"", 
      "+\tdepends on YAFFS_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Enable YAFFS2 support -- yaffs for >= 2K bytes per page devices", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config YAFFS_AUTO_YAFFS2", 
      "+\tbool \"Autoselect yaffs2 format\"", 
      "+\tdepends on YAFFS_YAFFS2", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  Without this, you need to explicitely use yaffs2 as the file", 
      "+\t  system type. With this, you can say \"yaffs\" and yaffs or yaffs2", 
      "+\t  will be used depending on the device page size (yaffs on", 
      "+\t  512-byte page devices, yaffs2 on 2K page devices).", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config YAFFS_DISABLE_LAZY_LOAD", 
      "+\tbool \"Disable lazy loading\"", 
      "+\tdepends on YAFFS_YAFFS2", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  \"Lazy loading\" defers loading file details until they are", 
      "+\t  required. This saves mount time, but makes the first look-up", 
      "+\t  a bit longer.", 
      "+", 
      "+\t  Lazy loading will only happen if enabled by this option being 'n'", 
      "+\t  and if the appropriate tags are available, else yaffs2 will", 
      "+\t  automatically fall back to immediate loading and do the right", 
      "+\t  thing.", 
      "+", 
      "+\t  Lazy laoding will be required by checkpointing.", 
      "+", 
      "+\t  Setting this to 'y' will disable lazy loading.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+", 
      "+config YAFFS_DISABLE_WIDE_TNODES", 
      "+\tbool \"Turn off wide tnodes\"", 
      "+\tdepends on YAFFS_FS", 
      "+\tdefault n", 
      "+\thelp", 
      "+\t  Wide tnodes are only used for NAND arrays >=32MB for 512-byte", 
      "+\t  page devices and >=128MB for 2k page devices. They use slightly", 
      "+\t  more RAM but are faster since they eliminate chunk group", 
      "+\t  searching.", 
      "+", 
      "+\t  Setting this to 'y' will force tnode width to 16 bits and save", 
      "+\t  memory but make large arrays slower.", 
      "+", 
      "+\t  If unsure, say N.", 
      "+", 
      "+config YAFFS_ALWAYS_CHECK_CHUNK_ERASED", 
      "+\tbool \"Force chunk erase check\"", 
      "+\tdepends on YAFFS_FS", 
      "+\tdefault n", 
      "+\thelp", 
      "+          Normally YAFFS only checks chunks before writing until an erased", 
      "+\t  chunk is found. This helps to detect any partially written", 
      "+\t  chunks that might have happened due to power loss.", 
      "+", 
      "+\t  Enabling this forces on the test that chunks are erased in flash", 
      "+\t  before writing to them. This takes more time but is potentially", 
      "+\t  a bit more secure.", 
      "+", 
      "+\t  Suggest setting Y during development and ironing out driver", 
      "+\t  issues etc. Suggest setting to N if you want faster writing.", 
      "+", 
      "+\t  If unsure, say Y.", 
      "+", 
      "+config YAFFS_SHORT_NAMES_IN_RAM", 
      "+\tbool \"Cache short names in RAM\"", 
      "+\tdepends on YAFFS_FS", 
      "+\tdefault y", 
      "+\thelp", 
      "+\t  If this config is set, then short names are stored with the", 
      "+\t  yaffs_Object.  This costs an extra 16 bytes of RAM per object,", 
      "+\t  but makes look-ups faster.", 
      "+", 
      "+\t  If unsure, say Y."
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/Makefile", 
    "linux-2.6.23-yaffs2/fs/yaffs2/Makefile", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/Makefile linux-2.6.23-yaffs2/fs/yaffs2/Makefile", 
      "--- linux-2.6.23/fs/yaffs2/Makefile", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/Makefile", 
      "@@ -0,0 +1,10 @@", 
      "+#", 
      "+# Makefile for the linux YAFFS filesystem routines.", 
      "+#", 
      "+", 
      "+obj-$(CONFIG_YAFFS_FS) += yaffs.o", 
      "+", 
      "+yaffs-y := yaffs_ecc.o yaffs_fs.o yaffs_guts.o yaffs_checkptrw.o", 
      "+yaffs-y += yaffs_packedtags1.o yaffs_packedtags2.o yaffs_nand.o yaffs_qsort.o", 
      "+yaffs-y += yaffs_tagscompat.o yaffs_tagsvalidity.o", 
      "+yaffs-y += yaffs_mtdif.o yaffs_mtdif1.o yaffs_mtdif2.o"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/moduleconfig.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/moduleconfig.h linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h", 
      "--- linux-2.6.23/fs/yaffs2/moduleconfig.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/moduleconfig.h", 
      "@@ -0,0 +1,65 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Martin Fouts <Martin.Fouts@palmsource.com>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_CONFIG_H__", 
      "+#define __YAFFS_CONFIG_H__", 
      "+", 
      "+#ifdef YAFFS_OUT_OF_TREE", 
      "+", 
      "+/* DO NOT UNSET THESE THREE. YAFFS2 will not compile if you do. */", 
      "+#define CONFIG_YAFFS_FS", 
      "+#define CONFIG_YAFFS_YAFFS1", 
      "+#define CONFIG_YAFFS_YAFFS2", 
      "+", 
      "+/* These options are independent of each other.  Select those that matter. */", 
      "+", 
      "+/* Default: Not selected */", 
      "+/* Meaning: Yaffs does its own ECC, rather than using MTD ECC */", 
      "+//#define CONFIG_YAFFS_DOES_ECC", 
      "+", 
      "+/* Default: Not selected */", 
      "+/* Meaning: ECC byte order is 'wrong'.  Only meaningful if */", 
      "+/*          CONFIG_YAFFS_DOES_ECC is set */", 
      "+//#define CONFIG_YAFFS_ECC_WRONG_ORDER", 
      "+", 
      "+/* Default: Selected */", 
      "+/* Meaning: Disables testing whether chunks are erased before writing to them*/", 
      "+#define CONFIG_YAFFS_DISABLE_CHUNK_ERASED_CHECK", 
      "+", 
      "+/* Default: Selected */", 
      "+/* Meaning: Cache short names, taking more RAM, but faster look-ups */", 
      "+#define CONFIG_YAFFS_SHORT_NAMES_IN_RAM", 
      "+", 
      "+/* Default: 10 */", 
      "+/* Meaning: set the count of blocks to reserve for checkpointing */", 
      "+#define CONFIG_YAFFS_CHECKPOINT_RESERVED_BLOCKS 10", 
      "+", 
      "+/*", 
      "+Older-style on-NAND data format has a \"pageStatus\" byte to record", 
      "+chunk/page state.  This byte is zeroed when the page is discarded.", 
      "+Choose this option if you have existing on-NAND data in this format", 
      "+that you need to continue to support.  New data written also uses the", 
      "+older-style format.", 
      "+Note: Use of this option generally requires that MTD's oob layout be", 
      "+adjusted to use the older-style format.  See notes on tags formats and", 
      "+MTD versions in yaffs_mtdif1.c.", 
      "+*/", 
      "+/* Default: Not selected */", 
      "+/* Meaning: Use older-style on-NAND data format with pageStatus byte */", 
      "+//#define CONFIG_YAFFS_9BYTE_TAGS", 
      "+", 
      "+#endif /* YAFFS_OUT_OF_TREE */", 
      "+", 
      "+#endif /* __YAFFS_CONFIG_H__ */"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_checkptrw.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.c", 
      "@@ -0,0 +1,404 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+const char *yaffs_checkptrw_c_version =", 
      "+    \"$Id: yaffs_checkptrw.c,v 1.16 2008/05/05 07:58:58 charles Exp $\";", 
      "+", 
      "+", 
      "+#include \"yaffs_checkptrw.h\"", 
      "+#include \"yaffs_getblockinfo.h\"", 
      "+", 
      "+static int yaffs_CheckpointSpaceOk(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tint blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,", 
      "+\t\t(TSTR(\"checkpt blocks available = %d\" TENDSTR),", 
      "+\t\tblocksAvailable));", 
      "+", 
      "+", 
      "+\treturn (blocksAvailable <= 0) ? 0 : 1;", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_CheckpointErase(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tint i;", 
      "+", 
      "+", 
      "+\tif(!dev->eraseBlockInNAND)", 
      "+\t\treturn 0;", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"checking blocks %d to %d\"TENDSTR),", 
      "+\t\tdev->internalStartBlock,dev->internalEndBlock));", 
      "+", 
      "+\tfor(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {", 
      "+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);", 
      "+\t\tif(bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT){", 
      "+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"erasing checkpt block %d\"TENDSTR),i));", 
      "+\t\t\tif(dev->eraseBlockInNAND(dev,i- dev->blockOffset /* realign */)){", 
      "+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t\t\t\tdev->nErasedBlocks++;", 
      "+\t\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;", 
      "+\t\t\t}", 
      "+\t\t\telse {", 
      "+\t\t\t\tdev->markNANDBlockBad(dev,i);", 
      "+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_DEAD;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tdev->blocksInCheckpoint = 0;", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_CheckpointFindNextErasedBlock(yaffs_Device *dev)", 
      "+{", 
      "+\tint  i;", 
      "+\tint blocksAvailable = dev->nErasedBlocks - dev->nReservedBlocks;", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,", 
      "+\t\t(TSTR(\"allocating checkpt block: erased %d reserved %d avail %d next %d \"TENDSTR),", 
      "+\t\tdev->nErasedBlocks,dev->nReservedBlocks,blocksAvailable,dev->checkpointNextBlock));", 
      "+", 
      "+\tif(dev->checkpointNextBlock >= 0 &&", 
      "+\t   dev->checkpointNextBlock <= dev->internalEndBlock &&", 
      "+\t   blocksAvailable > 0){", 
      "+", 
      "+\t\tfor(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++){", 
      "+\t\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);", 
      "+\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_EMPTY){", 
      "+\t\t\t\tdev->checkpointNextBlock = i + 1;", 
      "+\t\t\t\tdev->checkpointCurrentBlock = i;", 
      "+\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"allocating checkpt block %d\"TENDSTR),i));", 
      "+\t\t\t\treturn;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"out of checkpt blocks\"TENDSTR)));", 
      "+", 
      "+\tdev->checkpointNextBlock = -1;", 
      "+\tdev->checkpointCurrentBlock = -1;", 
      "+}", 
      "+", 
      "+static void yaffs_CheckpointFindNextCheckpointBlock(yaffs_Device *dev)", 
      "+{", 
      "+\tint  i;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"find next checkpt block: start:  blocks %d next %d\" TENDSTR),", 
      "+\t\tdev->blocksInCheckpoint, dev->checkpointNextBlock));", 
      "+", 
      "+\tif(dev->blocksInCheckpoint < dev->checkpointMaxBlocks)", 
      "+\t\tfor(i = dev->checkpointNextBlock; i <= dev->internalEndBlock; i++){", 
      "+\t\t\tint chunk = i * dev->nChunksPerBlock;", 
      "+\t\t\tint realignedChunk = chunk - dev->chunkOffset;", 
      "+", 
      "+\t\t\tdev->readChunkWithTagsFromNAND(dev,realignedChunk,NULL,&tags);", 
      "+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"find next checkpt block: search: block %d oid %d seq %d eccr %d\" TENDSTR),", 
      "+\t\t\t\ti, tags.objectId,tags.sequenceNumber,tags.eccResult));", 
      "+", 
      "+\t\t\tif(tags.sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA){", 
      "+\t\t\t\t/* Right kind of block */", 
      "+\t\t\t\tdev->checkpointNextBlock = tags.objectId;", 
      "+\t\t\t\tdev->checkpointCurrentBlock = i;", 
      "+\t\t\t\tdev->checkpointBlockList[dev->blocksInCheckpoint] = i;", 
      "+\t\t\t\tdev->blocksInCheckpoint++;", 
      "+\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"found checkpt block %d\"TENDSTR),i));", 
      "+\t\t\t\treturn;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"found no more checkpt blocks\"TENDSTR)));", 
      "+", 
      "+\tdev->checkpointNextBlock = -1;", 
      "+\tdev->checkpointCurrentBlock = -1;", 
      "+}", 
      "+", 
      "+", 
      "+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting)", 
      "+{", 
      "+", 
      "+\t/* Got the functions we need? */", 
      "+\tif (!dev->writeChunkWithTagsToNAND ||", 
      "+\t    !dev->readChunkWithTagsFromNAND ||", 
      "+\t    !dev->eraseBlockInNAND ||", 
      "+\t    !dev->markNANDBlockBad)", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(forWriting && !yaffs_CheckpointSpaceOk(dev))", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(!dev->checkpointBuffer)", 
      "+\t\tdev->checkpointBuffer = YMALLOC_DMA(dev->totalBytesPerChunk);", 
      "+\tif(!dev->checkpointBuffer)", 
      "+\t\treturn 0;", 
      "+", 
      "+", 
      "+\tdev->checkpointPageSequence = 0;", 
      "+", 
      "+\tdev->checkpointOpenForWrite = forWriting;", 
      "+", 
      "+\tdev->checkpointByteCount = 0;", 
      "+\tdev->checkpointSum = 0;", 
      "+\tdev->checkpointXor = 0;", 
      "+\tdev->checkpointCurrentBlock = -1;", 
      "+\tdev->checkpointCurrentChunk = -1;", 
      "+\tdev->checkpointNextBlock = dev->internalStartBlock;", 
      "+", 
      "+\t/* Erase all the blocks in the checkpoint area */", 
      "+\tif(forWriting){", 
      "+\t\tmemset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);", 
      "+\t\tdev->checkpointByteOffset = 0;", 
      "+\t\treturn yaffs_CheckpointErase(dev);", 
      "+", 
      "+", 
      "+\t} else {", 
      "+\t\tint i;", 
      "+\t\t/* Set to a value that will kick off a read */", 
      "+\t\tdev->checkpointByteOffset = dev->nDataBytesPerChunk;", 
      "+\t\t/* A checkpoint block list of 1 checkpoint block per 16 block is (hopefully)", 
      "+\t\t * going to be way more than we need */", 
      "+\t\tdev->blocksInCheckpoint = 0;", 
      "+\t\tdev->checkpointMaxBlocks = (dev->internalEndBlock - dev->internalStartBlock)/16 + 2;", 
      "+\t\tdev->checkpointBlockList = YMALLOC(sizeof(int) * dev->checkpointMaxBlocks);", 
      "+\t\tfor(i = 0; i < dev->checkpointMaxBlocks; i++)", 
      "+\t\t\tdev->checkpointBlockList[i] = -1;", 
      "+\t}", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum)", 
      "+{", 
      "+\t__u32 compositeSum;", 
      "+\tcompositeSum =  (dev->checkpointSum << 8) | (dev->checkpointXor & 0xFF);", 
      "+\t*sum = compositeSum;", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+static int yaffs_CheckpointFlushBuffer(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tint chunk;", 
      "+\tint realignedChunk;", 
      "+", 
      "+\tyaffs_ExtendedTags tags;", 
      "+", 
      "+\tif(dev->checkpointCurrentBlock < 0){", 
      "+\t\tyaffs_CheckpointFindNextErasedBlock(dev);", 
      "+\t\tdev->checkpointCurrentChunk = 0;", 
      "+\t}", 
      "+", 
      "+\tif(dev->checkpointCurrentBlock < 0)", 
      "+\t\treturn 0;", 
      "+", 
      "+\ttags.chunkDeleted = 0;", 
      "+\ttags.objectId = dev->checkpointNextBlock; /* Hint to next place to look */", 
      "+\ttags.chunkId = dev->checkpointPageSequence + 1;", 
      "+\ttags.sequenceNumber =  YAFFS_SEQUENCE_CHECKPOINT_DATA;", 
      "+\ttags.byteCount = dev->nDataBytesPerChunk;", 
      "+\tif(dev->checkpointCurrentChunk == 0){", 
      "+\t\t/* First chunk we write for the block? Set block state to", 
      "+\t\t   checkpoint */", 
      "+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointCurrentBlock);", 
      "+\t\tbi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;", 
      "+\t\tdev->blocksInCheckpoint++;", 
      "+\t}", 
      "+", 
      "+\tchunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock + dev->checkpointCurrentChunk;", 
      "+", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"checkpoint wite buffer nand %d(%d:%d) objid %d chId %d\" TENDSTR),", 
      "+\t\tchunk, dev->checkpointCurrentBlock, dev->checkpointCurrentChunk,tags.objectId,tags.chunkId));", 
      "+", 
      "+\trealignedChunk = chunk - dev->chunkOffset;", 
      "+", 
      "+\tdev->writeChunkWithTagsToNAND(dev,realignedChunk,dev->checkpointBuffer,&tags);", 
      "+\tdev->checkpointByteOffset = 0;", 
      "+\tdev->checkpointPageSequence++;", 
      "+\tdev->checkpointCurrentChunk++;", 
      "+\tif(dev->checkpointCurrentChunk >= dev->nChunksPerBlock){", 
      "+\t\tdev->checkpointCurrentChunk = 0;", 
      "+\t\tdev->checkpointCurrentBlock = -1;", 
      "+\t}", 
      "+\tmemset(dev->checkpointBuffer,0,dev->nDataBytesPerChunk);", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+", 
      "+int yaffs_CheckpointWrite(yaffs_Device *dev,const void *data, int nBytes)", 
      "+{", 
      "+\tint i=0;", 
      "+\tint ok = 1;", 
      "+", 
      "+", 
      "+\t__u8 * dataBytes = (__u8 *)data;", 
      "+", 
      "+", 
      "+", 
      "+\tif(!dev->checkpointBuffer)", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(!dev->checkpointOpenForWrite)", 
      "+\t\treturn -1;", 
      "+", 
      "+\twhile(i < nBytes && ok) {", 
      "+", 
      "+", 
      "+", 
      "+\t\tdev->checkpointBuffer[dev->checkpointByteOffset] = *dataBytes ;", 
      "+\t\tdev->checkpointSum += *dataBytes;", 
      "+\t\tdev->checkpointXor ^= *dataBytes;", 
      "+", 
      "+\t\tdev->checkpointByteOffset++;", 
      "+\t\ti++;", 
      "+\t\tdataBytes++;", 
      "+\t\tdev->checkpointByteCount++;", 
      "+", 
      "+", 
      "+\t\tif(dev->checkpointByteOffset < 0 ||", 
      "+\t\t   dev->checkpointByteOffset >= dev->nDataBytesPerChunk)", 
      "+\t\t\tok = yaffs_CheckpointFlushBuffer(dev);", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn \ti;", 
      "+}", 
      "+", 
      "+int yaffs_CheckpointRead(yaffs_Device *dev, void *data, int nBytes)", 
      "+{", 
      "+\tint i=0;", 
      "+\tint ok = 1;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+", 
      "+", 
      "+\tint chunk;", 
      "+\tint realignedChunk;", 
      "+", 
      "+\t__u8 *dataBytes = (__u8 *)data;", 
      "+", 
      "+\tif(!dev->checkpointBuffer)", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(dev->checkpointOpenForWrite)", 
      "+\t\treturn -1;", 
      "+", 
      "+\twhile(i < nBytes && ok) {", 
      "+", 
      "+", 
      "+\t\tif(dev->checkpointByteOffset < 0 ||", 
      "+\t\t   dev->checkpointByteOffset >= dev->nDataBytesPerChunk) {", 
      "+", 
      "+\t\t   \tif(dev->checkpointCurrentBlock < 0){", 
      "+\t\t\t\tyaffs_CheckpointFindNextCheckpointBlock(dev);", 
      "+\t\t\t\tdev->checkpointCurrentChunk = 0;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif(dev->checkpointCurrentBlock < 0)", 
      "+\t\t\t\tok = 0;", 
      "+\t\t\telse {", 
      "+", 
      "+\t\t\t\tchunk = dev->checkpointCurrentBlock * dev->nChunksPerBlock +", 
      "+\t\t\t\t          dev->checkpointCurrentChunk;", 
      "+", 
      "+\t\t\t\trealignedChunk = chunk - dev->chunkOffset;", 
      "+", 
      "+\t   \t\t\t/* read in the next chunk */", 
      "+\t   \t\t\t/* printf(\"read checkpoint page %d\\n\",dev->checkpointPage); */", 
      "+\t\t\t\tdev->readChunkWithTagsFromNAND(dev, realignedChunk,", 
      "+\t\t\t\t\t\t\t       dev->checkpointBuffer,", 
      "+\t\t\t\t\t\t\t      &tags);", 
      "+", 
      "+\t\t\t\tif(tags.chunkId != (dev->checkpointPageSequence + 1) ||", 
      "+\t\t\t\t   tags.sequenceNumber != YAFFS_SEQUENCE_CHECKPOINT_DATA)", 
      "+\t\t\t\t   ok = 0;", 
      "+", 
      "+\t\t\t\tdev->checkpointByteOffset = 0;", 
      "+\t\t\t\tdev->checkpointPageSequence++;", 
      "+\t\t\t\tdev->checkpointCurrentChunk++;", 
      "+", 
      "+\t\t\t\tif(dev->checkpointCurrentChunk >= dev->nChunksPerBlock)", 
      "+\t\t\t\t\tdev->checkpointCurrentBlock = -1;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tif(ok){", 
      "+\t\t\t*dataBytes = dev->checkpointBuffer[dev->checkpointByteOffset];", 
      "+\t\t\tdev->checkpointSum += *dataBytes;", 
      "+\t\t\tdev->checkpointXor ^= *dataBytes;", 
      "+\t\t\tdev->checkpointByteOffset++;", 
      "+\t\t\ti++;", 
      "+\t\t\tdataBytes++;", 
      "+\t\t\tdev->checkpointByteCount++;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn \ti;", 
      "+}", 
      "+", 
      "+int yaffs_CheckpointClose(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tif(dev->checkpointOpenForWrite){", 
      "+\t\tif(dev->checkpointByteOffset != 0)", 
      "+\t\t\tyaffs_CheckpointFlushBuffer(dev);", 
      "+\t} else {", 
      "+\t\tint i;", 
      "+\t\tfor(i = 0; i < dev->blocksInCheckpoint && dev->checkpointBlockList[i] >= 0; i++){", 
      "+\t\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,dev->checkpointBlockList[i]);", 
      "+\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_EMPTY)", 
      "+\t\t\t\tbi->blockState = YAFFS_BLOCK_STATE_CHECKPOINT;", 
      "+\t\t\telse {", 
      "+\t\t\t\t// Todo this looks odd...", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t\tYFREE(dev->checkpointBlockList);", 
      "+\t\tdev->checkpointBlockList = NULL;", 
      "+\t}", 
      "+", 
      "+\tdev->nFreeChunks -= dev->blocksInCheckpoint * dev->nChunksPerBlock;", 
      "+\tdev->nErasedBlocks -= dev->blocksInCheckpoint;", 
      "+", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"checkpoint byte count %d\" TENDSTR),", 
      "+\t\t\tdev->checkpointByteCount));", 
      "+", 
      "+\tif(dev->checkpointBuffer){", 
      "+\t\t/* free the buffer */", 
      "+\t\tYFREE(dev->checkpointBuffer);", 
      "+\t\tdev->checkpointBuffer = NULL;", 
      "+\t\treturn 1;", 
      "+\t}", 
      "+\telse", 
      "+\t\treturn 0;", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev)", 
      "+{", 
      "+\t/* Erase the first checksum block */", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"checkpoint invalidate\"TENDSTR)));", 
      "+", 
      "+\tif(!yaffs_CheckpointSpaceOk(dev))", 
      "+\t\treturn 0;", 
      "+", 
      "+\treturn yaffs_CheckpointErase(dev);", 
      "+}", 
      "+", 
      "+", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_checkptrw.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_checkptrw.h", 
      "@@ -0,0 +1,35 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_CHECKPTRW_H__", 
      "+#define __YAFFS_CHECKPTRW_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+int yaffs_CheckpointOpen(yaffs_Device *dev, int forWriting);", 
      "+", 
      "+int yaffs_CheckpointWrite(yaffs_Device *dev,const void *data, int nBytes);", 
      "+", 
      "+int yaffs_CheckpointRead(yaffs_Device *dev,void *data, int nBytes);", 
      "+", 
      "+int yaffs_GetCheckpointSum(yaffs_Device *dev, __u32 *sum);", 
      "+", 
      "+int yaffs_CheckpointClose(yaffs_Device *dev);", 
      "+", 
      "+int yaffs_CheckpointInvalidateStream(yaffs_Device *dev);", 
      "+", 
      "+", 
      "+#endif", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_ecc.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_ecc.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_ecc.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.c", 
      "@@ -0,0 +1,331 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+/*", 
      "+ * This code implements the ECC algorithm used in SmartMedia.", 
      "+ *", 
      "+ * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.", 
      "+ * The two unused bit are set to 1.", 
      "+ * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC", 
      "+ * blocks are used on a 512-byte NAND page.", 
      "+ *", 
      "+ */", 
      "+", 
      "+/* Table generated by gen-ecc.c", 
      "+ * Using a table means we do not have to calculate p1..p4 and p1'..p4'", 
      "+ * for each byte of data. These are instead provided in a table in bits7..2.", 
      "+ * Bit 0 of each entry indicates whether the entry has an odd or even parity, and therefore", 
      "+ * this bytes influence on the line parity.", 
      "+ */", 
      "+", 
      "+const char *yaffs_ecc_c_version =", 
      "+    \"$Id: yaffs_ecc.c,v 1.10 2007/12/13 15:35:17 wookey Exp $\";", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+#include \"yaffs_ecc.h\"", 
      "+", 
      "+static const unsigned char column_parity_table[] = {", 
      "+\t0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,", 
      "+\t0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,", 
      "+\t0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,", 
      "+\t0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,", 
      "+\t0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,", 
      "+\t0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,", 
      "+\t0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,", 
      "+\t0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,", 
      "+\t0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,", 
      "+\t0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,", 
      "+\t0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,", 
      "+\t0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,", 
      "+\t0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,", 
      "+\t0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,", 
      "+\t0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,", 
      "+\t0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,", 
      "+\t0xa9, 0xfc, 0xf0, 0xa5, 0xcc, 0x99, 0x95, 0xc0,", 
      "+\t0xc0, 0x95, 0x99, 0xcc, 0xa5, 0xf0, 0xfc, 0xa9,", 
      "+\t0x3c, 0x69, 0x65, 0x30, 0x59, 0x0c, 0x00, 0x55,", 
      "+\t0x55, 0x00, 0x0c, 0x59, 0x30, 0x65, 0x69, 0x3c,", 
      "+\t0x30, 0x65, 0x69, 0x3c, 0x55, 0x00, 0x0c, 0x59,", 
      "+\t0x59, 0x0c, 0x00, 0x55, 0x3c, 0x69, 0x65, 0x30,", 
      "+\t0xa5, 0xf0, 0xfc, 0xa9, 0xc0, 0x95, 0x99, 0xcc,", 
      "+\t0xcc, 0x99, 0x95, 0xc0, 0xa9, 0xfc, 0xf0, 0xa5,", 
      "+\t0x0c, 0x59, 0x55, 0x00, 0x69, 0x3c, 0x30, 0x65,", 
      "+\t0x65, 0x30, 0x3c, 0x69, 0x00, 0x55, 0x59, 0x0c,", 
      "+\t0x99, 0xcc, 0xc0, 0x95, 0xfc, 0xa9, 0xa5, 0xf0,", 
      "+\t0xf0, 0xa5, 0xa9, 0xfc, 0x95, 0xc0, 0xcc, 0x99,", 
      "+\t0x95, 0xc0, 0xcc, 0x99, 0xf0, 0xa5, 0xa9, 0xfc,", 
      "+\t0xfc, 0xa9, 0xa5, 0xf0, 0x99, 0xcc, 0xc0, 0x95,", 
      "+\t0x00, 0x55, 0x59, 0x0c, 0x65, 0x30, 0x3c, 0x69,", 
      "+\t0x69, 0x3c, 0x30, 0x65, 0x0c, 0x59, 0x55, 0x00,", 
      "+};", 
      "+", 
      "+/* Count the bits in an unsigned char or a U32 */", 
      "+", 
      "+static int yaffs_CountBits(unsigned char x)", 
      "+{", 
      "+\tint r = 0;", 
      "+\twhile (x) {", 
      "+\t\tif (x & 1)", 
      "+\t\t\tr++;", 
      "+\t\tx >>= 1;", 
      "+\t}", 
      "+\treturn r;", 
      "+}", 
      "+", 
      "+static int yaffs_CountBits32(unsigned x)", 
      "+{", 
      "+\tint r = 0;", 
      "+\twhile (x) {", 
      "+\t\tif (x & 1)", 
      "+\t\t\tr++;", 
      "+\t\tx >>= 1;", 
      "+\t}", 
      "+\treturn r;", 
      "+}", 
      "+", 
      "+/* Calculate the ECC for a 256-byte block of data */", 
      "+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc)", 
      "+{", 
      "+\tunsigned int i;", 
      "+", 
      "+\tunsigned char col_parity = 0;", 
      "+\tunsigned char line_parity = 0;", 
      "+\tunsigned char line_parity_prime = 0;", 
      "+\tunsigned char t;", 
      "+\tunsigned char b;", 
      "+", 
      "+\tfor (i = 0; i < 256; i++) {", 
      "+\t\tb = column_parity_table[*data++];", 
      "+\t\tcol_parity ^= b;", 
      "+", 
      "+\t\tif (b & 0x01)\t// odd number of bits in the byte", 
      "+\t\t{", 
      "+\t\t\tline_parity ^= i;", 
      "+\t\t\tline_parity_prime ^= ~i;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\tecc[2] = (~col_parity) | 0x03;", 
      "+", 
      "+\tt = 0;", 
      "+\tif (line_parity & 0x80)", 
      "+\t\tt |= 0x80;", 
      "+\tif (line_parity_prime & 0x80)", 
      "+\t\tt |= 0x40;", 
      "+\tif (line_parity & 0x40)", 
      "+\t\tt |= 0x20;", 
      "+\tif (line_parity_prime & 0x40)", 
      "+\t\tt |= 0x10;", 
      "+\tif (line_parity & 0x20)", 
      "+\t\tt |= 0x08;", 
      "+\tif (line_parity_prime & 0x20)", 
      "+\t\tt |= 0x04;", 
      "+\tif (line_parity & 0x10)", 
      "+\t\tt |= 0x02;", 
      "+\tif (line_parity_prime & 0x10)", 
      "+\t\tt |= 0x01;", 
      "+\tecc[1] = ~t;", 
      "+", 
      "+\tt = 0;", 
      "+\tif (line_parity & 0x08)", 
      "+\t\tt |= 0x80;", 
      "+\tif (line_parity_prime & 0x08)", 
      "+\t\tt |= 0x40;", 
      "+\tif (line_parity & 0x04)", 
      "+\t\tt |= 0x20;", 
      "+\tif (line_parity_prime & 0x04)", 
      "+\t\tt |= 0x10;", 
      "+\tif (line_parity & 0x02)", 
      "+\t\tt |= 0x08;", 
      "+\tif (line_parity_prime & 0x02)", 
      "+\t\tt |= 0x04;", 
      "+\tif (line_parity & 0x01)", 
      "+\t\tt |= 0x02;", 
      "+\tif (line_parity_prime & 0x01)", 
      "+\t\tt |= 0x01;", 
      "+\tecc[0] = ~t;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER", 
      "+\t// Swap the bytes into the wrong order", 
      "+\tt = ecc[0];", 
      "+\tecc[0] = ecc[1];", 
      "+\tecc[1] = t;", 
      "+#endif", 
      "+}", 
      "+", 
      "+", 
      "+/* Correct the ECC on a 256 byte block of data */", 
      "+", 
      "+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,", 
      "+\t\t     const unsigned char *test_ecc)", 
      "+{", 
      "+\tunsigned char d0, d1, d2;\t/* deltas */", 
      "+", 
      "+\td0 = read_ecc[0] ^ test_ecc[0];", 
      "+\td1 = read_ecc[1] ^ test_ecc[1];", 
      "+\td2 = read_ecc[2] ^ test_ecc[2];", 
      "+", 
      "+\tif ((d0 | d1 | d2) == 0)", 
      "+\t\treturn 0; /* no error */", 
      "+", 
      "+\tif (((d0 ^ (d0 >> 1)) & 0x55) == 0x55 &&", 
      "+\t    ((d1 ^ (d1 >> 1)) & 0x55) == 0x55 &&", 
      "+\t    ((d2 ^ (d2 >> 1)) & 0x54) == 0x54) {", 
      "+\t\t/* Single bit (recoverable) error in data */", 
      "+", 
      "+\t\tunsigned byte;", 
      "+\t\tunsigned bit;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_ECC_WRONG_ORDER", 
      "+\t\t// swap the bytes to correct for the wrong order", 
      "+\t\tunsigned char t;", 
      "+", 
      "+\t\tt = d0;", 
      "+\t\td0 = d1;", 
      "+\t\td1 = t;", 
      "+#endif", 
      "+", 
      "+\t\tbit = byte = 0;", 
      "+", 
      "+\t\tif (d1 & 0x80)", 
      "+\t\t\tbyte |= 0x80;", 
      "+\t\tif (d1 & 0x20)", 
      "+\t\t\tbyte |= 0x40;", 
      "+\t\tif (d1 & 0x08)", 
      "+\t\t\tbyte |= 0x20;", 
      "+\t\tif (d1 & 0x02)", 
      "+\t\t\tbyte |= 0x10;", 
      "+\t\tif (d0 & 0x80)", 
      "+\t\t\tbyte |= 0x08;", 
      "+\t\tif (d0 & 0x20)", 
      "+\t\t\tbyte |= 0x04;", 
      "+\t\tif (d0 & 0x08)", 
      "+\t\t\tbyte |= 0x02;", 
      "+\t\tif (d0 & 0x02)", 
      "+\t\t\tbyte |= 0x01;", 
      "+", 
      "+\t\tif (d2 & 0x80)", 
      "+\t\t\tbit |= 0x04;", 
      "+\t\tif (d2 & 0x20)", 
      "+\t\t\tbit |= 0x02;", 
      "+\t\tif (d2 & 0x08)", 
      "+\t\t\tbit |= 0x01;", 
      "+", 
      "+\t\tdata[byte] ^= (1 << bit);", 
      "+", 
      "+\t\treturn 1; /* Corrected the error */", 
      "+\t}", 
      "+", 
      "+\tif ((yaffs_CountBits(d0) +", 
      "+\t     yaffs_CountBits(d1) +", 
      "+\t     yaffs_CountBits(d2)) ==  1) {", 
      "+\t\t/* Reccoverable error in ecc */", 
      "+", 
      "+\t\tread_ecc[0] = test_ecc[0];", 
      "+\t\tread_ecc[1] = test_ecc[1];", 
      "+\t\tread_ecc[2] = test_ecc[2];", 
      "+", 
      "+\t\treturn 1; /* Corrected the error */", 
      "+\t}", 
      "+", 
      "+\t/* Unrecoverable error */", 
      "+", 
      "+\treturn -1;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+/*", 
      "+ * ECCxxxOther does ECC calcs on arbitrary n bytes of data", 
      "+ */", 
      "+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,", 
      "+\t\t\t     yaffs_ECCOther * eccOther)", 
      "+{", 
      "+\tunsigned int i;", 
      "+", 
      "+\tunsigned char col_parity = 0;", 
      "+\tunsigned line_parity = 0;", 
      "+\tunsigned line_parity_prime = 0;", 
      "+\tunsigned char b;", 
      "+", 
      "+\tfor (i = 0; i < nBytes; i++) {", 
      "+\t\tb = column_parity_table[*data++];", 
      "+\t\tcol_parity ^= b;", 
      "+", 
      "+\t\tif (b & 0x01)\t {", 
      "+\t\t\t/* odd number of bits in the byte */", 
      "+\t\t\tline_parity ^= i;", 
      "+\t\t\tline_parity_prime ^= ~i;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\teccOther->colParity = (col_parity >> 2) & 0x3f;", 
      "+\teccOther->lineParity = line_parity;", 
      "+\teccOther->lineParityPrime = line_parity_prime;", 
      "+}", 
      "+", 
      "+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,", 
      "+\t\t\t  yaffs_ECCOther * read_ecc,", 
      "+\t\t\t  const yaffs_ECCOther * test_ecc)", 
      "+{", 
      "+\tunsigned char cDelta;\t/* column parity delta */", 
      "+\tunsigned lDelta;\t/* line parity delta */", 
      "+\tunsigned lDeltaPrime;\t/* line parity delta */", 
      "+\tunsigned bit;", 
      "+", 
      "+\tcDelta = read_ecc->colParity ^ test_ecc->colParity;", 
      "+\tlDelta = read_ecc->lineParity ^ test_ecc->lineParity;", 
      "+\tlDeltaPrime = read_ecc->lineParityPrime ^ test_ecc->lineParityPrime;", 
      "+", 
      "+\tif ((cDelta | lDelta | lDeltaPrime) == 0)", 
      "+\t\treturn 0; /* no error */", 
      "+", 
      "+\tif (lDelta == ~lDeltaPrime &&", 
      "+\t    (((cDelta ^ (cDelta >> 1)) & 0x15) == 0x15))", 
      "+\t{", 
      "+\t\t/* Single bit (recoverable) error in data */", 
      "+", 
      "+\t\tbit = 0;", 
      "+", 
      "+\t\tif (cDelta & 0x20)", 
      "+\t\t\tbit |= 0x04;", 
      "+\t\tif (cDelta & 0x08)", 
      "+\t\t\tbit |= 0x02;", 
      "+\t\tif (cDelta & 0x02)", 
      "+\t\t\tbit |= 0x01;", 
      "+", 
      "+\t\tif(lDelta >= nBytes)", 
      "+\t\t\treturn -1;", 
      "+", 
      "+\t\tdata[lDelta] ^= (1 << bit);", 
      "+", 
      "+\t\treturn 1; /* corrected */", 
      "+\t}", 
      "+", 
      "+\tif ((yaffs_CountBits32(lDelta) + yaffs_CountBits32(lDeltaPrime) +", 
      "+\t     yaffs_CountBits(cDelta)) == 1) {", 
      "+\t\t/* Reccoverable error in ecc */", 
      "+", 
      "+\t\t*read_ecc = *test_ecc;", 
      "+\t\treturn 1; /* corrected */", 
      "+\t}", 
      "+", 
      "+\t/* Unrecoverable error */", 
      "+", 
      "+\treturn -1;", 
      "+", 
      "+}", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_ecc.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_ecc.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_ecc.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_ecc.h", 
      "@@ -0,0 +1,44 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+ /*", 
      "+  * This code implements the ECC algorithm used in SmartMedia.", 
      "+  *", 
      "+  * The ECC comprises 22 bits of parity information and is stuffed into 3 bytes.", 
      "+  * The two unused bit are set to 1.", 
      "+  * The ECC can correct single bit errors in a 256-byte page of data. Thus, two such ECC", 
      "+  * blocks are used on a 512-byte NAND page.", 
      "+  *", 
      "+  */", 
      "+", 
      "+#ifndef __YAFFS_ECC_H__", 
      "+#define __YAFFS_ECC_H__", 
      "+", 
      "+typedef struct {", 
      "+\tunsigned char colParity;", 
      "+\tunsigned lineParity;", 
      "+\tunsigned lineParityPrime;", 
      "+} yaffs_ECCOther;", 
      "+", 
      "+void yaffs_ECCCalculate(const unsigned char *data, unsigned char *ecc);", 
      "+int yaffs_ECCCorrect(unsigned char *data, unsigned char *read_ecc,", 
      "+\t\t     const unsigned char *test_ecc);", 
      "+", 
      "+void yaffs_ECCCalculateOther(const unsigned char *data, unsigned nBytes,", 
      "+\t\t\t     yaffs_ECCOther * ecc);", 
      "+int yaffs_ECCCorrectOther(unsigned char *data, unsigned nBytes,", 
      "+\t\t\t  yaffs_ECCOther * read_ecc,", 
      "+\t\t\t  const yaffs_ECCOther * test_ecc);", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_fs.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_fs.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_fs.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_fs.c", 
      "@@ -0,0 +1,2372 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ * Acknowledgements:", 
      "+ * Luc van OostenRyck for numerous patches.", 
      "+ * Nick Bane for numerous patches.", 
      "+ * Nick Bane for 2.5/2.6 integration.", 
      "+ * Andras Toth for mknod rdev issue.", 
      "+ * Michael Fischer for finding the problem with inode inconsistency.", 
      "+ * Some code bodily lifted from JFFS", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+/*", 
      "+ *", 
      "+ * This is the file system front-end to YAFFS that hooks it up to", 
      "+ * the VFS.", 
      "+ *", 
      "+ * Special notes:", 
      "+ * >> 2.4: sb->u.generic_sbp points to the yaffs_Device associated with", 
      "+ *         this superblock", 
      "+ * >> 2.6: sb->s_fs_info  points to the yaffs_Device associated with this", 
      "+ *         superblock", 
      "+ * >> inode->u.generic_ip points to the associated yaffs_Object.", 
      "+ */", 
      "+", 
      "+const char *yaffs_fs_c_version =", 
      "+    \"$Id: yaffs_fs.c,v 1.67 2008/07/03 20:06:05 charles Exp $\";", 
      "+extern const char *yaffs_guts_c_version;", 
      "+", 
      "+#include <linux/version.h>", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))", 
      "+#include <linux/config.h>", 
      "+#endif", 
      "+#include <linux/kernel.h>", 
      "+#include <linux/module.h>", 
      "+#include <linux/slab.h>", 
      "+#include <linux/init.h>", 
      "+#include <linux/fs.h>", 
      "+#include <linux/proc_fs.h>", 
      "+#include <linux/smp_lock.h>", 
      "+#include <linux/pagemap.h>", 
      "+#include <linux/mtd/mtd.h>", 
      "+#include <linux/interrupt.h>", 
      "+#include <linux/string.h>", 
      "+#include <linux/ctype.h>", 
      "+", 
      "+#include \"asm/div64.h\"", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+", 
      "+#include <linux/statfs.h>\t/* Added NCB 15-8-2003 */", 
      "+#include <asm/statfs.h>", 
      "+#define UnlockPage(p) unlock_page(p)", 
      "+#define Page_Uptodate(page)\ttest_bit(PG_uptodate, &(page)->flags)", 
      "+", 
      "+/* FIXME: use sb->s_id instead ? */", 
      "+#define yaffs_devname(sb, buf)\tbdevname(sb->s_bdev, buf)", 
      "+", 
      "+#else", 
      "+", 
      "+#include <linux/locks.h>", 
      "+#define\tBDEVNAME_SIZE\t\t0", 
      "+#define\tyaffs_devname(sb, buf)\tkdevname(sb->s_dev)", 
      "+", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))", 
      "+/* added NCB 26/5/2006 for 2.4.25-vrs2-tcl1 kernel */", 
      "+#define __user", 
      "+#endif", 
      "+", 
      "+#endif", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+#define WRITE_SIZE_STR \"writesize\"", 
      "+#define WRITE_SIZE(mtd) (mtd)->writesize", 
      "+#else", 
      "+#define WRITE_SIZE_STR \"oobblock\"", 
      "+#define WRITE_SIZE(mtd) (mtd)->oobblock", 
      "+#endif", 
      "+", 
      "+#include <asm/uaccess.h>", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+#include <linux/mtd/mtd.h>", 
      "+#include \"yaffs_mtdif.h\"", 
      "+#include \"yaffs_mtdif1.h\"", 
      "+#include \"yaffs_mtdif2.h\"", 
      "+", 
      "+unsigned int yaffs_traceMask = YAFFS_TRACE_BAD_BLOCKS;", 
      "+unsigned int yaffs_wr_attempts = YAFFS_WR_ATTEMPTS;", 
      "+", 
      "+/* Module Parameters */", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+module_param(yaffs_traceMask,uint,0644);", 
      "+module_param(yaffs_wr_attempts,uint,0644);", 
      "+#else", 
      "+MODULE_PARM(yaffs_traceMask,\"i\");", 
      "+MODULE_PARM(yaffs_wr_attempts,\"i\");", 
      "+#endif", 
      "+", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))", 
      "+/* use iget and read_inode */", 
      "+#define Y_IGET(sb,inum) iget((sb),(inum))", 
      "+static void yaffs_read_inode(struct inode *inode);", 
      "+", 
      "+#else", 
      "+/* Call local equivalent */", 
      "+#define YAFFS_USE_OWN_IGET", 
      "+#define Y_IGET(sb,inum) yaffs_iget((sb),(inum))", 
      "+", 
      "+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino);", 
      "+#endif", 
      "+", 
      "+/*#define T(x) printk x */", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))", 
      "+#define yaffs_InodeToObjectLV(iptr) (iptr)->i_private", 
      "+#else", 
      "+#define yaffs_InodeToObjectLV(iptr) (iptr)->u.generic_ip", 
      "+#endif", 
      "+", 
      "+#define yaffs_InodeToObject(iptr) ((yaffs_Object *)(yaffs_InodeToObjectLV(iptr)))", 
      "+#define yaffs_DentryToObject(dptr) yaffs_InodeToObject((dptr)->d_inode)", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+#define yaffs_SuperToDevice(sb)\t((yaffs_Device *)sb->s_fs_info)", 
      "+#else", 
      "+#define yaffs_SuperToDevice(sb)\t((yaffs_Device *)sb->u.generic_sbp)", 
      "+#endif", 
      "+", 
      "+static void yaffs_put_super(struct super_block *sb);", 
      "+", 
      "+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,", 
      "+\t\t\t\tloff_t * pos);", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_file_flush(struct file *file, fl_owner_t id);", 
      "+#else", 
      "+static int yaffs_file_flush(struct file *file);", 
      "+#endif", 
      "+", 
      "+static int yaffs_sync_object(struct file *file, struct dentry *dentry,", 
      "+\t\t\t     int datasync);", 
      "+", 
      "+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir);", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t\tstruct nameidata *n);", 
      "+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,", 
      "+\t\t\t\t   struct nameidata *n);", 
      "+#else", 
      "+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode);", 
      "+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry);", 
      "+#endif", 
      "+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,", 
      "+\t\t      struct dentry *dentry);", 
      "+static int yaffs_unlink(struct inode *dir, struct dentry *dentry);", 
      "+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,", 
      "+\t\t\t const char *symname);", 
      "+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode);", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t       dev_t dev);", 
      "+#else", 
      "+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t       int dev);", 
      "+#endif", 
      "+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,", 
      "+\t\t\tstruct inode *new_dir, struct dentry *new_dentry);", 
      "+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr);", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_sync_fs(struct super_block *sb, int wait);", 
      "+static void yaffs_write_super(struct super_block *sb);", 
      "+#else", 
      "+static int yaffs_sync_fs(struct super_block *sb);", 
      "+static int yaffs_write_super(struct super_block *sb);", 
      "+#endif", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf);", 
      "+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf);", 
      "+#else", 
      "+static int yaffs_statfs(struct super_block *sb, struct statfs *buf);", 
      "+#endif", 
      "+", 
      "+static void yaffs_put_inode(struct inode *inode);", 
      "+static void yaffs_delete_inode(struct inode *);", 
      "+static void yaffs_clear_inode(struct inode *);", 
      "+", 
      "+static int yaffs_readpage(struct file *file, struct page *page);", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_writepage(struct page *page, struct writeback_control *wbc);", 
      "+#else", 
      "+static int yaffs_writepage(struct page *page);", 
      "+#endif", 
      "+static int yaffs_prepare_write(struct file *f, struct page *pg,", 
      "+\t\t\t       unsigned offset, unsigned to);", 
      "+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,", 
      "+\t\t\t      unsigned to);", 
      "+", 
      "+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,", 
      "+\t\t\t  int buflen);", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))", 
      "+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);", 
      "+#else", 
      "+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd);", 
      "+#endif", 
      "+", 
      "+static struct address_space_operations yaffs_file_address_operations = {", 
      "+\t.readpage = yaffs_readpage,", 
      "+\t.writepage = yaffs_writepage,", 
      "+\t.prepare_write = yaffs_prepare_write,", 
      "+\t.commit_write = yaffs_commit_write,", 
      "+};", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))", 
      "+static struct file_operations yaffs_file_operations = {", 
      "+\t.read = do_sync_read,", 
      "+\t.write = do_sync_write,", 
      "+\t.aio_read = generic_file_aio_read,", 
      "+\t.aio_write = generic_file_aio_write,", 
      "+\t.mmap = generic_file_mmap,", 
      "+\t.flush = yaffs_file_flush,", 
      "+\t.fsync = yaffs_sync_object,", 
      "+\t.splice_read = generic_file_splice_read,", 
      "+\t.splice_write = generic_file_splice_write,", 
      "+};", 
      "+", 
      "+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,18))", 
      "+", 
      "+static struct file_operations yaffs_file_operations = {", 
      "+\t.read = do_sync_read,", 
      "+\t.write = do_sync_write,", 
      "+\t.aio_read = generic_file_aio_read,", 
      "+\t.aio_write = generic_file_aio_write,", 
      "+\t.mmap = generic_file_mmap,", 
      "+\t.flush = yaffs_file_flush,", 
      "+\t.fsync = yaffs_sync_object,", 
      "+\t.sendfile = generic_file_sendfile,", 
      "+};", 
      "+", 
      "+#else", 
      "+", 
      "+static struct file_operations yaffs_file_operations = {", 
      "+\t.read = generic_file_read,", 
      "+\t.write = generic_file_write,", 
      "+\t.mmap = generic_file_mmap,", 
      "+\t.flush = yaffs_file_flush,", 
      "+\t.fsync = yaffs_sync_object,", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+\t.sendfile = generic_file_sendfile,", 
      "+#endif", 
      "+};", 
      "+#endif", 
      "+", 
      "+static struct inode_operations yaffs_file_inode_operations = {", 
      "+\t.setattr = yaffs_setattr,", 
      "+};", 
      "+", 
      "+static struct inode_operations yaffs_symlink_inode_operations = {", 
      "+\t.readlink = yaffs_readlink,", 
      "+\t.follow_link = yaffs_follow_link,", 
      "+\t.setattr = yaffs_setattr,", 
      "+};", 
      "+", 
      "+static struct inode_operations yaffs_dir_inode_operations = {", 
      "+\t.create = yaffs_create,", 
      "+\t.lookup = yaffs_lookup,", 
      "+\t.link = yaffs_link,", 
      "+\t.unlink = yaffs_unlink,", 
      "+\t.symlink = yaffs_symlink,", 
      "+\t.mkdir = yaffs_mkdir,", 
      "+\t.rmdir = yaffs_unlink,", 
      "+\t.mknod = yaffs_mknod,", 
      "+\t.rename = yaffs_rename,", 
      "+\t.setattr = yaffs_setattr,", 
      "+};", 
      "+", 
      "+static struct file_operations yaffs_dir_operations = {", 
      "+\t.read = generic_read_dir,", 
      "+\t.readdir = yaffs_readdir,", 
      "+\t.fsync = yaffs_sync_object,", 
      "+};", 
      "+", 
      "+static struct super_operations yaffs_super_ops = {", 
      "+\t.statfs = yaffs_statfs,", 
      "+", 
      "+#ifndef YAFFS_USE_OWN_IGET", 
      "+\t.read_inode = yaffs_read_inode,", 
      "+#endif", 
      "+\t.put_inode = yaffs_put_inode,", 
      "+\t.put_super = yaffs_put_super,", 
      "+\t.delete_inode = yaffs_delete_inode,", 
      "+\t.clear_inode = yaffs_clear_inode,", 
      "+\t.sync_fs = yaffs_sync_fs,", 
      "+\t.write_super = yaffs_write_super,", 
      "+};", 
      "+", 
      "+static void yaffs_GrossLock(yaffs_Device * dev)", 
      "+{", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs locking\\n\"));", 
      "+", 
      "+\tdown(&dev->grossLock);", 
      "+}", 
      "+", 
      "+static void yaffs_GrossUnlock(yaffs_Device * dev)", 
      "+{", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs unlocking\\n\"));", 
      "+\tup(&dev->grossLock);", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_readlink(struct dentry *dentry, char __user * buffer,", 
      "+\t\t\t  int buflen)", 
      "+{", 
      "+\tunsigned char *alias;", 
      "+\tint ret;", 
      "+", 
      "+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\talias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (!alias)", 
      "+\t\treturn -ENOMEM;", 
      "+", 
      "+\tret = vfs_readlink(dentry, buffer, buflen, alias);", 
      "+\tkfree(alias);", 
      "+\treturn ret;", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))", 
      "+static void *yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)", 
      "+#else", 
      "+static int yaffs_follow_link(struct dentry *dentry, struct nameidata *nd)", 
      "+#endif", 
      "+{", 
      "+\tunsigned char *alias;", 
      "+\tint ret;", 
      "+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\talias = yaffs_GetSymlinkAlias(yaffs_DentryToObject(dentry));", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (!alias)", 
      "+        {", 
      "+\t\tret = -ENOMEM;", 
      "+\t\tgoto out;", 
      "+        }", 
      "+", 
      "+\tret = vfs_follow_link(nd, alias);", 
      "+\tkfree(alias);", 
      "+out:", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))", 
      "+\treturn ERR_PTR (ret);", 
      "+#else", 
      "+\treturn ret;", 
      "+#endif", 
      "+}", 
      "+", 
      "+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,", 
      "+\t\t\t      yaffs_Object * obj);", 
      "+", 
      "+/*", 
      "+ * Lookup is used to find objects in the fs", 
      "+ */", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+", 
      "+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry,", 
      "+\t\t\t\t   struct nameidata *n)", 
      "+#else", 
      "+static struct dentry *yaffs_lookup(struct inode *dir, struct dentry *dentry)", 
      "+#endif", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tstruct inode *inode = NULL;\t/* NCB 2.5/2.6 needs NULL here */", 
      "+", 
      "+\tyaffs_Device *dev = yaffs_InodeToObject(dir)->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_lookup for %d:%s\\n\",", 
      "+\t   yaffs_InodeToObject(dir)->objectId, dentry->d_name.name));", 
      "+", 
      "+\tobj =", 
      "+\t    yaffs_FindObjectByName(yaffs_InodeToObject(dir),", 
      "+\t\t\t\t   dentry->d_name.name);", 
      "+", 
      "+\tobj = yaffs_GetEquivalentObject(obj);\t/* in case it was a hardlink */", 
      "+", 
      "+\t/* Can't hold gross lock when calling yaffs_get_inode() */", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (obj) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_lookup found %d\\n\", obj->objectId));", 
      "+", 
      "+\t\tinode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);", 
      "+", 
      "+\t\tif (inode) {", 
      "+\t\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t\t  (KERN_DEBUG \"yaffs_loookup dentry \\n\"));", 
      "+/* #if 0 asserted by NCB for 2.5/6 compatability - falls through to", 
      "+ * d_add even if NULL inode */", 
      "+#if 0", 
      "+\t\t\t/*dget(dentry); // try to solve directory bug */", 
      "+\t\t\td_add(dentry, inode);", 
      "+", 
      "+\t\t\t/* return dentry; */", 
      "+\t\t\treturn NULL;", 
      "+#endif", 
      "+\t\t}", 
      "+", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_lookup not found\\n\"));", 
      "+", 
      "+\t}", 
      "+", 
      "+/* added NCB for 2.5/6 compatability - forces add even if inode is", 
      "+ * NULL which creates dentry hash */", 
      "+\td_add(dentry, inode);", 
      "+", 
      "+\treturn NULL;", 
      "+\t/*      return (ERR_PTR(-EIO)); */", 
      "+", 
      "+}", 
      "+", 
      "+/* For now put inode is just for debugging", 
      "+ * Put inode is called when the inode **structure** is put.", 
      "+ */", 
      "+static void yaffs_put_inode(struct inode *inode)", 
      "+{", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs_put_inode: ino %d, count %d\\n\", (int)inode->i_ino,", 
      "+\t   atomic_read(&inode->i_count)));", 
      "+", 
      "+}", 
      "+", 
      "+/* clear is called to tell the fs to release any per-inode data it holds */", 
      "+static void yaffs_clear_inode(struct inode *inode)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tobj = yaffs_InodeToObject(inode);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs_clear_inode: ino %d, count %d %s\\n\", (int)inode->i_ino,", 
      "+\t   atomic_read(&inode->i_count),", 
      "+\t   obj ? \"object exists\" : \"null object\"));", 
      "+", 
      "+\tif (obj) {", 
      "+\t\tdev = obj->myDev;", 
      "+\t\tyaffs_GrossLock(dev);", 
      "+", 
      "+\t\t/* Clear the association between the inode and", 
      "+\t\t * the yaffs_Object.", 
      "+\t\t */", 
      "+\t\tobj->myInode = NULL;", 
      "+\t\tyaffs_InodeToObjectLV(inode) = NULL;", 
      "+", 
      "+\t\t/* If the object freeing was deferred, then the real", 
      "+\t\t * free happens now.", 
      "+\t\t * This should fix the inode inconsistency problem.", 
      "+\t\t */", 
      "+", 
      "+\t\tyaffs_HandleDeferedFree(obj);", 
      "+", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+/* delete is called when the link count is zero and the inode", 
      "+ * is put (ie. nobody wants to know about it anymore, time to", 
      "+ * delete the file).", 
      "+ * NB Must call clear_inode()", 
      "+ */", 
      "+static void yaffs_delete_inode(struct inode *inode)", 
      "+{", 
      "+\tyaffs_Object *obj = yaffs_InodeToObject(inode);", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs_delete_inode: ino %d, count %d %s\\n\", (int)inode->i_ino,", 
      "+\t   atomic_read(&inode->i_count),", 
      "+\t   obj ? \"object exists\" : \"null object\"));", 
      "+", 
      "+\tif (obj) {", 
      "+\t\tdev = obj->myDev;", 
      "+\t\tyaffs_GrossLock(dev);", 
      "+\t\tyaffs_DeleteFile(obj);", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+\t}", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))", 
      "+        truncate_inode_pages (&inode->i_data, 0);", 
      "+#endif", 
      "+\tclear_inode(inode);", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_file_flush(struct file *file, fl_owner_t id)", 
      "+#else", 
      "+static int yaffs_file_flush(struct file *file)", 
      "+#endif", 
      "+{", 
      "+\tyaffs_Object *obj = yaffs_DentryToObject(file->f_dentry);", 
      "+", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_file_flush object %d (%s)\\n\", obj->objectId,", 
      "+\t   obj->dirty ? \"dirty\" : \"clean\"));", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tyaffs_FlushFile(obj, 1);", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+static int yaffs_readpage_nolock(struct file *f, struct page *pg)", 
      "+{", 
      "+\t/* Lifted from jffs2 */", 
      "+", 
      "+\tyaffs_Object *obj;", 
      "+\tunsigned char *pg_buf;", 
      "+\tint ret;", 
      "+", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_readpage at %08x, size %08x\\n\",", 
      "+\t\t\t   (unsigned)(pg->index << PAGE_CACHE_SHIFT),", 
      "+\t\t\t   (unsigned)PAGE_CACHE_SIZE));", 
      "+", 
      "+\tobj = yaffs_DentryToObject(f->f_dentry);", 
      "+", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+\tBUG_ON(!PageLocked(pg));", 
      "+#else", 
      "+\tif (!PageLocked(pg))", 
      "+\t\tPAGE_BUG(pg);", 
      "+#endif", 
      "+", 
      "+\tpg_buf = kmap(pg);", 
      "+\t/* FIXME: Can kmap fail? */", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tret =", 
      "+\t    yaffs_ReadDataFromFile(obj, pg_buf, pg->index << PAGE_CACHE_SHIFT,", 
      "+\t\t\t\t   PAGE_CACHE_SIZE);", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (ret >= 0)", 
      "+\t\tret = 0;", 
      "+", 
      "+\tif (ret) {", 
      "+\t\tClearPageUptodate(pg);", 
      "+\t\tSetPageError(pg);", 
      "+\t} else {", 
      "+\t\tSetPageUptodate(pg);", 
      "+\t\tClearPageError(pg);", 
      "+\t}", 
      "+", 
      "+\tflush_dcache_page(pg);", 
      "+\tkunmap(pg);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_readpage done\\n\"));", 
      "+\treturn ret;", 
      "+}", 
      "+", 
      "+static int yaffs_readpage_unlock(struct file *f, struct page *pg)", 
      "+{", 
      "+\tint ret = yaffs_readpage_nolock(f, pg);", 
      "+\tUnlockPage(pg);", 
      "+\treturn ret;", 
      "+}", 
      "+", 
      "+static int yaffs_readpage(struct file *f, struct page *pg)", 
      "+{", 
      "+\treturn yaffs_readpage_unlock(f, pg);", 
      "+}", 
      "+", 
      "+/* writepage inspired by/stolen from smbfs */", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_writepage(struct page *page, struct writeback_control *wbc)", 
      "+#else", 
      "+static int yaffs_writepage(struct page *page)", 
      "+#endif", 
      "+{", 
      "+\tstruct address_space *mapping = page->mapping;", 
      "+\tloff_t offset = (loff_t) page->index << PAGE_CACHE_SHIFT;", 
      "+\tstruct inode *inode;", 
      "+\tunsigned long end_index;", 
      "+\tchar *buffer;", 
      "+\tyaffs_Object *obj;", 
      "+\tint nWritten = 0;", 
      "+\tunsigned nBytes;", 
      "+", 
      "+\tif (!mapping)", 
      "+\t\tBUG();", 
      "+\tinode = mapping->host;", 
      "+\tif (!inode)", 
      "+\t\tBUG();", 
      "+", 
      "+\tif (offset > inode->i_size) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG", 
      "+\t\t   \"yaffs_writepage at %08x, inode size = %08x!!!\\n\",", 
      "+\t\t   (unsigned)(page->index << PAGE_CACHE_SHIFT),", 
      "+\t\t   (unsigned)inode->i_size));", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"                -> don't care!!\\n\"));", 
      "+\t\tunlock_page(page);", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+", 
      "+\tend_index = inode->i_size >> PAGE_CACHE_SHIFT;", 
      "+", 
      "+\t/* easy case */", 
      "+\tif (page->index < end_index) {", 
      "+\t\tnBytes = PAGE_CACHE_SIZE;", 
      "+\t} else {", 
      "+\t\tnBytes = inode->i_size & (PAGE_CACHE_SIZE - 1);", 
      "+\t}", 
      "+", 
      "+\tget_page(page);", 
      "+", 
      "+\tbuffer = kmap(page);", 
      "+", 
      "+\tobj = yaffs_InodeToObject(inode);", 
      "+\tyaffs_GrossLock(obj->myDev);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_writepage at %08x, size %08x\\n\",", 
      "+\t   (unsigned)(page->index << PAGE_CACHE_SHIFT), nBytes));", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"writepag0: obj = %05x, ino = %05x\\n\",", 
      "+\t   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));", 
      "+", 
      "+\tnWritten =", 
      "+\t    yaffs_WriteDataToFile(obj, buffer, page->index << PAGE_CACHE_SHIFT,", 
      "+\t\t\t\t  nBytes, 0);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"writepag1: obj = %05x, ino = %05x\\n\",", 
      "+\t   (int)obj->variant.fileVariant.fileSize, (int)inode->i_size));", 
      "+", 
      "+\tyaffs_GrossUnlock(obj->myDev);", 
      "+", 
      "+\tkunmap(page);", 
      "+\tSetPageUptodate(page);", 
      "+\tUnlockPage(page);", 
      "+\tput_page(page);", 
      "+", 
      "+\treturn (nWritten == nBytes) ? 0 : -ENOSPC;", 
      "+}", 
      "+", 
      "+static int yaffs_prepare_write(struct file *f, struct page *pg,", 
      "+\t\t\t       unsigned offset, unsigned to)", 
      "+{", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_prepair_write\\n\"));", 
      "+\tif (!Page_Uptodate(pg) && (offset || to < PAGE_CACHE_SIZE))", 
      "+\t\treturn yaffs_readpage_nolock(f, pg);", 
      "+", 
      "+\treturn 0;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_commit_write(struct file *f, struct page *pg, unsigned offset,", 
      "+\t\t\t      unsigned to)", 
      "+{", 
      "+", 
      "+\tvoid *addr = page_address(pg) + offset;", 
      "+\tloff_t pos = (((loff_t) pg->index) << PAGE_CACHE_SHIFT) + offset;", 
      "+\tint nBytes = to - offset;", 
      "+\tint nWritten;", 
      "+", 
      "+\tunsigned spos = pos;", 
      "+\tunsigned saddr = (unsigned)addr;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_commit_write addr %x pos %x nBytes %d\\n\", saddr,", 
      "+\t   spos, nBytes));", 
      "+", 
      "+\tnWritten = yaffs_file_write(f, addr, nBytes, &pos);", 
      "+", 
      "+\tif (nWritten != nBytes) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG", 
      "+\t\t   \"yaffs_commit_write not same size nWritten %d  nBytes %d\\n\",", 
      "+\t\t   nWritten, nBytes));", 
      "+\t\tSetPageError(pg);", 
      "+\t\tClearPageUptodate(pg);", 
      "+\t} else {", 
      "+\t\tSetPageUptodate(pg);", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_commit_write returning %d\\n\",", 
      "+\t   nWritten == nBytes ? 0 : nWritten));", 
      "+", 
      "+\treturn nWritten == nBytes ? 0 : nWritten;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_FillInodeFromObject(struct inode *inode, yaffs_Object * obj)", 
      "+{", 
      "+\tif (inode && obj) {", 
      "+", 
      "+", 
      "+\t\t/* Check mode against the variant type and attempt to repair if broken. */", 
      "+ \t\t__u32 mode = obj->yst_mode;", 
      "+ \t\tswitch( obj->variantType ){", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_FILE :", 
      "+ \t\t        if( ! S_ISREG(mode) ){", 
      "+ \t\t\t        obj->yst_mode &= ~S_IFMT;", 
      "+ \t\t\t        obj->yst_mode |= S_IFREG;", 
      "+ \t\t\t}", 
      "+", 
      "+ \t\t\tbreak;", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_SYMLINK :", 
      "+ \t\t        if( ! S_ISLNK(mode) ){", 
      "+ \t\t\t        obj->yst_mode &= ~S_IFMT;", 
      "+ \t\t\t\tobj->yst_mode |= S_IFLNK;", 
      "+ \t\t\t}", 
      "+", 
      "+ \t\t\tbreak;", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_DIRECTORY :", 
      "+ \t\t        if( ! S_ISDIR(mode) ){", 
      "+ \t\t\t        obj->yst_mode &= ~S_IFMT;", 
      "+ \t\t\t        obj->yst_mode |= S_IFDIR;", 
      "+ \t\t\t}", 
      "+", 
      "+ \t\t\tbreak;", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_UNKNOWN :", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_HARDLINK :", 
      "+ \t\tcase YAFFS_OBJECT_TYPE_SPECIAL :", 
      "+ \t\tdefault:", 
      "+ \t\t        /* TODO? */", 
      "+ \t\t        break;", 
      "+ \t\t}", 
      "+", 
      "+ \t\tinode->i_flags |= S_NOATIME;", 
      "+", 
      "+\t\tinode->i_ino = obj->objectId;", 
      "+\t\tinode->i_mode = obj->yst_mode;", 
      "+\t\tinode->i_uid = obj->yst_uid;", 
      "+\t\tinode->i_gid = obj->yst_gid;", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))", 
      "+\t\tinode->i_blksize = inode->i_sb->s_blocksize;", 
      "+#endif", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+", 
      "+\t\tinode->i_rdev = old_decode_dev(obj->yst_rdev);", 
      "+\t\tinode->i_atime.tv_sec = (time_t) (obj->yst_atime);", 
      "+\t\tinode->i_atime.tv_nsec = 0;", 
      "+\t\tinode->i_mtime.tv_sec = (time_t) obj->yst_mtime;", 
      "+\t\tinode->i_mtime.tv_nsec = 0;", 
      "+\t\tinode->i_ctime.tv_sec = (time_t) obj->yst_ctime;", 
      "+\t\tinode->i_ctime.tv_nsec = 0;", 
      "+#else", 
      "+\t\tinode->i_rdev = obj->yst_rdev;", 
      "+\t\tinode->i_atime = obj->yst_atime;", 
      "+\t\tinode->i_mtime = obj->yst_mtime;", 
      "+\t\tinode->i_ctime = obj->yst_ctime;", 
      "+#endif", 
      "+\t\tinode->i_size = yaffs_GetObjectFileLength(obj);", 
      "+\t\tinode->i_blocks = (inode->i_size + 511) >> 9;", 
      "+", 
      "+\t\tinode->i_nlink = yaffs_GetObjectLinkCount(obj);", 
      "+", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG", 
      "+\t\t   \"yaffs_FillInode mode %x uid %d gid %d size %d count %d\\n\",", 
      "+\t\t   inode->i_mode, inode->i_uid, inode->i_gid,", 
      "+\t\t   (int)inode->i_size, atomic_read(&inode->i_count)));", 
      "+", 
      "+\t\tswitch (obj->yst_mode & S_IFMT) {", 
      "+\t\tdefault:\t/* fifo, device or socket */", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+\t\t\tinit_special_inode(inode, obj->yst_mode,", 
      "+\t\t\t\t\t   old_decode_dev(obj->yst_rdev));", 
      "+#else", 
      "+\t\t\tinit_special_inode(inode, obj->yst_mode,", 
      "+\t\t\t\t\t   (dev_t) (obj->yst_rdev));", 
      "+#endif", 
      "+\t\t\tbreak;", 
      "+\t\tcase S_IFREG:\t/* file */", 
      "+\t\t\tinode->i_op = &yaffs_file_inode_operations;", 
      "+\t\t\tinode->i_fop = &yaffs_file_operations;", 
      "+\t\t\tinode->i_mapping->a_ops =", 
      "+\t\t\t    &yaffs_file_address_operations;", 
      "+\t\t\tbreak;", 
      "+\t\tcase S_IFDIR:\t/* directory */", 
      "+\t\t\tinode->i_op = &yaffs_dir_inode_operations;", 
      "+\t\t\tinode->i_fop = &yaffs_dir_operations;", 
      "+\t\t\tbreak;", 
      "+\t\tcase S_IFLNK:\t/* symlink */", 
      "+\t\t\tinode->i_op = &yaffs_symlink_inode_operations;", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_InodeToObjectLV(inode) = obj;", 
      "+", 
      "+\t\tobj->myInode = inode;", 
      "+", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_FileInode invalid parameters\\n\"));", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+struct inode *yaffs_get_inode(struct super_block *sb, int mode, int dev,", 
      "+\t\t\t      yaffs_Object * obj)", 
      "+{", 
      "+\tstruct inode *inode;", 
      "+", 
      "+\tif (!sb) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_get_inode for NULL super_block!!\\n\"));", 
      "+\t\treturn NULL;", 
      "+", 
      "+\t}", 
      "+", 
      "+\tif (!obj) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_get_inode for NULL object!!\\n\"));", 
      "+\t\treturn NULL;", 
      "+", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_get_inode for object %d\\n\", obj->objectId));", 
      "+", 
      "+\tinode = Y_IGET(sb, obj->objectId);", 
      "+\tif(IS_ERR(inode))", 
      "+\t  return NULL;", 
      "+", 
      "+\t/* NB Side effect: iget calls back to yaffs_read_inode(). */", 
      "+\t/* iget also increments the inode's i_count */", 
      "+\t/* NB You can't be holding grossLock or deadlock will happen! */", 
      "+", 
      "+\treturn inode;", 
      "+}", 
      "+", 
      "+static ssize_t yaffs_file_write(struct file *f, const char *buf, size_t n,", 
      "+\t\t\t\tloff_t * pos)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tint nWritten, ipos;", 
      "+\tstruct inode *inode;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tobj = yaffs_DentryToObject(f->f_dentry);", 
      "+", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tinode = f->f_dentry->d_inode;", 
      "+", 
      "+\tif (!S_ISBLK(inode->i_mode) && f->f_flags & O_APPEND) {", 
      "+\t\tipos = inode->i_size;", 
      "+\t} else {", 
      "+\t\tipos = *pos;", 
      "+\t}", 
      "+", 
      "+\tif (!obj) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_file_write: hey obj is null!\\n\"));", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG", 
      "+\t\t   \"yaffs_file_write about to write writing %d bytes\"", 
      "+\t\t   \"to object %d at %d\\n\",", 
      "+\t\t   n, obj->objectId, ipos));", 
      "+\t}", 
      "+", 
      "+\tnWritten = yaffs_WriteDataToFile(obj, buf, ipos, n, 0);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_file_write writing %d bytes, %d written at %d\\n\",", 
      "+\t   n, nWritten, ipos));", 
      "+\tif (nWritten > 0) {", 
      "+\t\tipos += nWritten;", 
      "+\t\t*pos = ipos;", 
      "+\t\tif (ipos > inode->i_size) {", 
      "+\t\t\tinode->i_size = ipos;", 
      "+\t\t\tinode->i_blocks = (ipos + 511) >> 9;", 
      "+", 
      "+\t\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t\t  (KERN_DEBUG", 
      "+\t\t\t   \"yaffs_file_write size updated to %d bytes, \"", 
      "+\t\t\t   \"%d blocks\\n\",", 
      "+\t\t\t   ipos, (int)(inode->i_blocks)));", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+\treturn nWritten == 0 ? -ENOSPC : nWritten;", 
      "+}", 
      "+", 
      "+static int yaffs_readdir(struct file *f, void *dirent, filldir_t filldir)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev;", 
      "+\tstruct inode *inode = f->f_dentry->d_inode;", 
      "+\tunsigned long offset, curoffs;", 
      "+\tstruct ylist_head *i;", 
      "+\tyaffs_Object *l;", 
      "+", 
      "+\tchar name[YAFFS_MAX_NAME_LENGTH + 1];", 
      "+", 
      "+\tobj = yaffs_DentryToObject(f->f_dentry);", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\toffset = f->f_pos;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_readdir: starting at %d\\n\", (int)offset));", 
      "+", 
      "+\tif (offset == 0) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_readdir: entry . ino %d \\n\",", 
      "+\t\t   (int)inode->i_ino));", 
      "+\t\tif (filldir(dirent, \".\", 1, offset, inode->i_ino, DT_DIR)", 
      "+\t\t    < 0) {", 
      "+\t\t\tgoto out;", 
      "+\t\t}", 
      "+\t\toffset++;", 
      "+\t\tf->f_pos++;", 
      "+\t}", 
      "+\tif (offset == 1) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_readdir: entry .. ino %d \\n\",", 
      "+\t\t   (int)f->f_dentry->d_parent->d_inode->i_ino));", 
      "+\t\tif (filldir", 
      "+\t\t    (dirent, \"..\", 2, offset,", 
      "+\t\t     f->f_dentry->d_parent->d_inode->i_ino, DT_DIR) < 0) {", 
      "+\t\t\tgoto out;", 
      "+\t\t}", 
      "+\t\toffset++;", 
      "+\t\tf->f_pos++;", 
      "+\t}", 
      "+", 
      "+\tcuroffs = 1;", 
      "+", 
      "+\t/* If the directory has changed since the open or last call to", 
      "+\t   readdir, rewind to after the 2 canned entries. */", 
      "+", 
      "+\tif (f->f_version != inode->i_version) {", 
      "+\t\toffset = 2;", 
      "+\t\tf->f_pos = offset;", 
      "+\t\tf->f_version = inode->i_version;", 
      "+\t}", 
      "+", 
      "+\tylist_for_each(i, &obj->variant.directoryVariant.children) {", 
      "+\t\tcuroffs++;", 
      "+\t\tif (curoffs >= offset) {", 
      "+\t\t\tl = ylist_entry(i, yaffs_Object, siblings);", 
      "+", 
      "+\t\t\tyaffs_GetObjectName(l, name,", 
      "+\t\t\t\t\t    YAFFS_MAX_NAME_LENGTH + 1);", 
      "+\t\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t\t  (KERN_DEBUG \"yaffs_readdir: %s inode %d\\n\", name,", 
      "+\t\t\t   yaffs_GetObjectInode(l)));", 
      "+", 
      "+\t\t\tif (filldir(dirent,", 
      "+\t\t\t\t    name,", 
      "+\t\t\t\t    strlen(name),", 
      "+\t\t\t\t    offset,", 
      "+\t\t\t\t    yaffs_GetObjectInode(l),", 
      "+\t\t\t\t    yaffs_GetObjectType(l))", 
      "+\t\t\t    < 0) {", 
      "+\t\t\t\tgoto up_and_out;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\toffset++;", 
      "+\t\t\tf->f_pos++;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+      up_and_out:", 
      "+      out:", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * File creation. Allocate an inode, and we're done..", 
      "+ */", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t       dev_t rdev)", 
      "+#else", 
      "+static int yaffs_mknod(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t       int rdev)", 
      "+#endif", 
      "+{", 
      "+\tstruct inode *inode;", 
      "+", 
      "+\tyaffs_Object *obj = NULL;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tyaffs_Object *parent = yaffs_InodeToObject(dir);", 
      "+", 
      "+\tint error = -ENOSPC;", 
      "+\tuid_t uid = current->fsuid;", 
      "+\tgid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;", 
      "+", 
      "+\tif((dir->i_mode & S_ISGID) && S_ISDIR(mode))", 
      "+\t\tmode |= S_ISGID;", 
      "+", 
      "+\tif (parent) {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_mknod: parent object %d type %d\\n\",", 
      "+\t\t   parent->objectId, parent->variantType));", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_mknod: could not get parent object\\n\"));", 
      "+\t\treturn -EPERM;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_mknod: making oject for %s, \"", 
      "+\t\t\t   \"mode %x dev %x\\n\",", 
      "+\t\t\t   dentry->d_name.name, mode, rdev));", 
      "+", 
      "+\tdev = parent->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tswitch (mode & S_IFMT) {", 
      "+\tdefault:", 
      "+\t\t/* Special (socket, fifo, device...) */", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG", 
      "+\t\t\t\t   \"yaffs_mknod: making special\\n\"));", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+\t\tobj =", 
      "+\t\t    yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,", 
      "+\t\t\t\t       gid, old_encode_dev(rdev));", 
      "+#else", 
      "+\t\tobj =", 
      "+\t\t    yaffs_MknodSpecial(parent, dentry->d_name.name, mode, uid,", 
      "+\t\t\t\t       gid, rdev);", 
      "+#endif", 
      "+\t\tbreak;", 
      "+\tcase S_IFREG:\t\t/* file          */", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_mknod: making file\\n\"));", 
      "+\t\tobj =", 
      "+\t\t    yaffs_MknodFile(parent, dentry->d_name.name, mode, uid,", 
      "+\t\t\t\t    gid);", 
      "+\t\tbreak;", 
      "+\tcase S_IFDIR:\t\t/* directory */", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_mknod: making directory\\n\"));", 
      "+\t\tobj =", 
      "+\t\t    yaffs_MknodDirectory(parent, dentry->d_name.name, mode,", 
      "+\t\t\t\t\t uid, gid);", 
      "+\t\tbreak;", 
      "+\tcase S_IFLNK:\t\t/* symlink */", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_mknod: making file\\n\"));", 
      "+\t\tobj = NULL;\t/* Do we ever get here? */", 
      "+\t\tbreak;", 
      "+\t}", 
      "+", 
      "+\t/* Can not call yaffs_get_inode() with gross lock held */", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (obj) {", 
      "+\t\tinode = yaffs_get_inode(dir->i_sb, mode, rdev, obj);", 
      "+\t\td_instantiate(dentry, inode);", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_mknod created object %d count = %d\\n\",", 
      "+\t\t   obj->objectId, atomic_read(&inode->i_count)));", 
      "+\t\terror = 0;", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_mknod failed making object\\n\"));", 
      "+\t\terror = -ENOMEM;", 
      "+\t}", 
      "+", 
      "+\treturn error;", 
      "+}", 
      "+", 
      "+static int yaffs_mkdir(struct inode *dir, struct dentry *dentry, int mode)", 
      "+{", 
      "+\tint retVal;", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_mkdir\\n\"));", 
      "+\tretVal = yaffs_mknod(dir, dentry, mode | S_IFDIR, 0);", 
      "+#if 0", 
      "+\t/* attempt to fix dir bug - didn't work */", 
      "+\tif (!retVal) {", 
      "+\t\tdget(dentry);", 
      "+\t}", 
      "+#endif", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode,", 
      "+\t\t\tstruct nameidata *n)", 
      "+#else", 
      "+static int yaffs_create(struct inode *dir, struct dentry *dentry, int mode)", 
      "+#endif", 
      "+{", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_create\\n\"));", 
      "+\treturn yaffs_mknod(dir, dentry, mode | S_IFREG, 0);", 
      "+}", 
      "+", 
      "+static int yaffs_unlink(struct inode *dir, struct dentry *dentry)", 
      "+{", 
      "+\tint retVal;", 
      "+", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_unlink %d:%s\\n\", (int)(dir->i_ino),", 
      "+\t   dentry->d_name.name));", 
      "+", 
      "+\tdev = yaffs_InodeToObject(dir)->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tretVal = yaffs_Unlink(yaffs_InodeToObject(dir), dentry->d_name.name);", 
      "+", 
      "+\tif (retVal == YAFFS_OK) {", 
      "+\t\tdentry->d_inode->i_nlink--;", 
      "+\t\tdir->i_version++;", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+\t\tmark_inode_dirty(dentry->d_inode);", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+\treturn -ENOTEMPTY;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Create a link...", 
      "+ */", 
      "+static int yaffs_link(struct dentry *old_dentry, struct inode *dir,", 
      "+\t\t      struct dentry *dentry)", 
      "+{", 
      "+\tstruct inode *inode = old_dentry->d_inode;", 
      "+\tyaffs_Object *obj = NULL;", 
      "+\tyaffs_Object *link = NULL;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_link\\n\"));", 
      "+", 
      "+\tobj = yaffs_InodeToObject(inode);", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tif (!S_ISDIR(inode->i_mode))\t/* Don't link directories */", 
      "+\t{", 
      "+\t\tlink =", 
      "+\t\t    yaffs_Link(yaffs_InodeToObject(dir), dentry->d_name.name,", 
      "+\t\t\t       obj);", 
      "+\t}", 
      "+", 
      "+\tif (link) {", 
      "+\t\told_dentry->d_inode->i_nlink = yaffs_GetObjectLinkCount(obj);", 
      "+\t\td_instantiate(dentry, old_dentry->d_inode);", 
      "+\t\tatomic_inc(&old_dentry->d_inode->i_count);", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t  (KERN_DEBUG \"yaffs_link link count %d i_count %d\\n\",", 
      "+\t\t   old_dentry->d_inode->i_nlink,", 
      "+\t\t   atomic_read(&old_dentry->d_inode->i_count)));", 
      "+", 
      "+\t}", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (link) {", 
      "+", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+", 
      "+\treturn -EPERM;", 
      "+}", 
      "+", 
      "+static int yaffs_symlink(struct inode *dir, struct dentry *dentry,", 
      "+\t\t\t const char *symname)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev;", 
      "+\tuid_t uid = current->fsuid;", 
      "+\tgid_t gid = (dir->i_mode & S_ISGID) ? dir->i_gid : current->fsgid;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_symlink\\n\"));", 
      "+", 
      "+\tdev = yaffs_InodeToObject(dir)->myDev;", 
      "+\tyaffs_GrossLock(dev);", 
      "+\tobj = yaffs_MknodSymLink(yaffs_InodeToObject(dir), dentry->d_name.name,", 
      "+\t\t\t\t S_IFLNK | S_IRWXUGO, uid, gid, symname);", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (obj) {", 
      "+", 
      "+\t\tstruct inode *inode;", 
      "+", 
      "+\t\tinode = yaffs_get_inode(dir->i_sb, obj->yst_mode, 0, obj);", 
      "+\t\td_instantiate(dentry, inode);", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"symlink created OK\\n\"));", 
      "+\t\treturn 0;", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"symlink not created\\n\"));", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn -ENOMEM;", 
      "+}", 
      "+", 
      "+static int yaffs_sync_object(struct file *file, struct dentry *dentry,", 
      "+\t\t\t     int datasync)", 
      "+{", 
      "+", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tobj = yaffs_DentryToObject(dentry);", 
      "+", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_sync_object\\n\"));", 
      "+\tyaffs_GrossLock(dev);", 
      "+\tyaffs_FlushFile(obj, 1);", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * The VFS layer already does all the dentry stuff for rename.", 
      "+ *", 
      "+ * NB: POSIX says you can rename an object over an old object of the same name", 
      "+ */", 
      "+static int yaffs_rename(struct inode *old_dir, struct dentry *old_dentry,", 
      "+\t\t\tstruct inode *new_dir, struct dentry *new_dentry)", 
      "+{", 
      "+\tyaffs_Device *dev;", 
      "+\tint retVal = YAFFS_FAIL;", 
      "+\tyaffs_Object *target;", 
      "+", 
      "+        T(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_rename\\n\"));", 
      "+\tdev = yaffs_InodeToObject(old_dir)->myDev;", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\t/* Check if the target is an existing directory that is not empty. */", 
      "+\ttarget =", 
      "+\t    yaffs_FindObjectByName(yaffs_InodeToObject(new_dir),", 
      "+\t\t\t\t   new_dentry->d_name.name);", 
      "+", 
      "+", 
      "+", 
      "+\tif (target &&", 
      "+\t    target->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&", 
      "+\t    !ylist_empty(&target->variant.directoryVariant.children)) {", 
      "+", 
      "+\t        T(YAFFS_TRACE_OS, (KERN_DEBUG \"target is non-empty dir\\n\"));", 
      "+", 
      "+\t\tretVal = YAFFS_FAIL;", 
      "+\t} else {", 
      "+", 
      "+\t\t/* Now does unlinking internally using shadowing mechanism */", 
      "+\t        T(YAFFS_TRACE_OS, (KERN_DEBUG \"calling yaffs_RenameObject\\n\"));", 
      "+", 
      "+\t\tretVal =", 
      "+\t\t    yaffs_RenameObject(yaffs_InodeToObject(old_dir),", 
      "+\t\t\t\t       old_dentry->d_name.name,", 
      "+\t\t\t\t       yaffs_InodeToObject(new_dir),", 
      "+\t\t\t\t       new_dentry->d_name.name);", 
      "+", 
      "+\t}", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tif (retVal == YAFFS_OK) {", 
      "+\t\tif(target) {", 
      "+\t\t\tnew_dentry->d_inode->i_nlink--;", 
      "+\t\t\tmark_inode_dirty(new_dentry->d_inode);", 
      "+\t\t}", 
      "+", 
      "+\t\treturn 0;", 
      "+\t} else {", 
      "+\t\treturn -ENOTEMPTY;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_setattr(struct dentry *dentry, struct iattr *attr)", 
      "+{", 
      "+\tstruct inode *inode = dentry->d_inode;", 
      "+\tint error;", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_setattr of object %d\\n\",", 
      "+\t   yaffs_InodeToObject(inode)->objectId));", 
      "+", 
      "+\tif ((error = inode_change_ok(inode, attr)) == 0) {", 
      "+", 
      "+\t\tdev = yaffs_InodeToObject(inode)->myDev;", 
      "+\t\tyaffs_GrossLock(dev);", 
      "+\t\tif (yaffs_SetAttributes(yaffs_InodeToObject(inode), attr) ==", 
      "+\t\t    YAFFS_OK) {", 
      "+\t\t\terror = 0;", 
      "+\t\t} else {", 
      "+\t\t\terror = -EPERM;", 
      "+\t\t}", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+\t\tif (!error)", 
      "+\t\t\terror = inode_setattr(inode, attr);", 
      "+\t}", 
      "+\treturn error;", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_statfs(struct dentry *dentry, struct kstatfs *buf)", 
      "+{", 
      "+\tyaffs_Device *dev = yaffs_DentryToObject(dentry)->myDev;", 
      "+\tstruct super_block *sb = dentry->d_sb;", 
      "+#elif (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_statfs(struct super_block *sb, struct kstatfs *buf)", 
      "+{", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);", 
      "+#else", 
      "+static int yaffs_statfs(struct super_block *sb, struct statfs *buf)", 
      "+{", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);", 
      "+#endif", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_statfs\\n\"));", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tbuf->f_type = YAFFS_MAGIC;", 
      "+\tbuf->f_bsize = sb->s_blocksize;", 
      "+\tbuf->f_namelen = 255;", 
      "+", 
      "+\tif(dev->nDataBytesPerChunk & (dev->nDataBytesPerChunk - 1)){", 
      "+\t\t/* Do this if chunk size is not a power of 2 */", 
      "+", 
      "+\t\tuint64_t bytesInDev;", 
      "+\t\tuint64_t bytesFree;", 
      "+", 
      "+\t\tbytesInDev = ((uint64_t)((dev->endBlock - dev->startBlock +1))) *", 
      "+\t\t\t     ((uint64_t)(dev->nChunksPerBlock * dev->nDataBytesPerChunk));", 
      "+", 
      "+\t\tdo_div(bytesInDev,sb->s_blocksize); /* bytesInDev becomes the number of blocks */", 
      "+\t\tbuf->f_blocks = bytesInDev;", 
      "+", 
      "+\t\tbytesFree  = ((uint64_t)(yaffs_GetNumberOfFreeChunks(dev))) *", 
      "+\t\t\t     ((uint64_t)(dev->nDataBytesPerChunk));", 
      "+", 
      "+\t\tdo_div(bytesFree,sb->s_blocksize);", 
      "+", 
      "+\t\tbuf->f_bfree = bytesFree;", 
      "+", 
      "+\t} else if (sb->s_blocksize > dev->nDataBytesPerChunk) {", 
      "+", 
      "+\t\tbuf->f_blocks =", 
      "+\t                   (dev->endBlock - dev->startBlock + 1) *", 
      "+\t                    dev->nChunksPerBlock /", 
      "+\t                    (sb->s_blocksize / dev->nDataBytesPerChunk);", 
      "+\t        buf->f_bfree =", 
      "+\t                   yaffs_GetNumberOfFreeChunks(dev) /", 
      "+\t                   (sb->s_blocksize / dev->nDataBytesPerChunk);", 
      "+\t} else {", 
      "+\t       buf->f_blocks =", 
      "+\t                   (dev->endBlock - dev->startBlock + 1) *", 
      "+\t                   dev->nChunksPerBlock *", 
      "+\t                   (dev->nDataBytesPerChunk / sb->s_blocksize);", 
      "+", 
      "+\t               buf->f_bfree =", 
      "+\t                   yaffs_GetNumberOfFreeChunks(dev) *", 
      "+\t                   (dev->nDataBytesPerChunk / sb->s_blocksize);", 
      "+\t}", 
      "+", 
      "+", 
      "+\tbuf->f_files = 0;", 
      "+\tbuf->f_ffree = 0;", 
      "+\tbuf->f_bavail = buf->f_bfree;", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_do_sync_fs(struct super_block *sb)", 
      "+{", 
      "+", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_do_sync_fs\\n\"));", 
      "+", 
      "+\tif(sb->s_dirt) {", 
      "+\t\tyaffs_GrossLock(dev);", 
      "+", 
      "+\t\tif(dev){", 
      "+\t\t\tyaffs_FlushEntireDeviceCache(dev);", 
      "+\t\t\tyaffs_CheckpointSave(dev);", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\t\tsb->s_dirt = 0;", 
      "+\t}", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static void yaffs_write_super(struct super_block *sb)", 
      "+#else", 
      "+static int yaffs_write_super(struct super_block *sb)", 
      "+#endif", 
      "+{", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_write_super\\n\"));", 
      "+\tyaffs_do_sync_fs(sb);", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18))", 
      "+\treturn 0;", 
      "+#endif", 
      "+}", 
      "+", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_sync_fs(struct super_block *sb, int wait)", 
      "+#else", 
      "+static int yaffs_sync_fs(struct super_block *sb)", 
      "+#endif", 
      "+{", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_sync_fs\\n\"));", 
      "+", 
      "+\tyaffs_do_sync_fs(sb);", 
      "+", 
      "+\treturn 0;", 
      "+", 
      "+}", 
      "+", 
      "+#ifdef YAFFS_USE_OWN_IGET", 
      "+", 
      "+static struct inode * yaffs_iget(struct super_block *sb, unsigned long ino)", 
      "+{", 
      "+\tstruct inode *inode;", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_iget for %lu\\n\", ino));", 
      "+", 
      "+\tinode = iget_locked(sb, ino);", 
      "+\tif (!inode)", 
      "+\t\treturn ERR_PTR(-ENOMEM);", 
      "+\tif (!(inode->i_state & I_NEW))", 
      "+\t\treturn inode;", 
      "+", 
      "+       /* NB This is called as a side effect of other functions, but", 
      "+\t* we had to release the lock to prevent deadlocks, so", 
      "+\t* need to lock again.", 
      "+\t*/", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tobj = yaffs_FindObjectByNumber(dev, inode->i_ino);", 
      "+", 
      "+\tyaffs_FillInodeFromObject(inode, obj);", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\tunlock_new_inode(inode);", 
      "+\treturn inode;", 
      "+}", 
      "+", 
      "+#else", 
      "+", 
      "+static void yaffs_read_inode(struct inode *inode)", 
      "+{", 
      "+\t/* NB This is called as a side effect of other functions, but", 
      "+\t * we had to release the lock to prevent deadlocks, so", 
      "+\t * need to lock again.", 
      "+\t */", 
      "+", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(inode->i_sb);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (KERN_DEBUG \"yaffs_read_inode for %d\\n\", (int)inode->i_ino));", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tobj = yaffs_FindObjectByNumber(dev, inode->i_ino);", 
      "+", 
      "+\tyaffs_FillInodeFromObject(inode, obj);", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+}", 
      "+", 
      "+#endif", 
      "+", 
      "+static YLIST_HEAD(yaffs_dev_list);", 
      "+", 
      "+#if 0 // not used", 
      "+static int yaffs_remount_fs(struct super_block *sb, int *flags, char *data)", 
      "+{", 
      "+\tyaffs_Device    *dev = yaffs_SuperToDevice(sb);", 
      "+", 
      "+\tif( *flags & MS_RDONLY ) {", 
      "+\t\tstruct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;", 
      "+", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t\t(KERN_DEBUG \"yaffs_remount_fs: %s: RO\\n\", dev->name ));", 
      "+", 
      "+\t\tyaffs_GrossLock(dev);", 
      "+", 
      "+\t\tyaffs_FlushEntireDeviceCache(dev);", 
      "+", 
      "+\t\tyaffs_CheckpointSave(dev);", 
      "+", 
      "+\t\tif (mtd->sync)", 
      "+\t\t\tmtd->sync(mtd);", 
      "+", 
      "+\t\tyaffs_GrossUnlock(dev);", 
      "+\t}", 
      "+\telse {", 
      "+\t\tT(YAFFS_TRACE_OS,", 
      "+\t\t\t(KERN_DEBUG \"yaffs_remount_fs: %s: RW\\n\", dev->name ));", 
      "+\t}", 
      "+", 
      "+\treturn 0;", 
      "+}", 
      "+#endif", 
      "+", 
      "+static void yaffs_put_super(struct super_block *sb)", 
      "+{", 
      "+\tyaffs_Device *dev = yaffs_SuperToDevice(sb);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_put_super\\n\"));", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\tyaffs_FlushEntireDeviceCache(dev);", 
      "+", 
      "+\tyaffs_CheckpointSave(dev);", 
      "+", 
      "+\tif (dev->putSuperFunc) {", 
      "+\t\tdev->putSuperFunc(sb);", 
      "+\t}", 
      "+", 
      "+\tyaffs_Deinitialise(dev);", 
      "+", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\t/* we assume this is protected by lock_kernel() in mount/umount */", 
      "+\tylist_del(&dev->devList);", 
      "+", 
      "+\tif(dev->spareBuffer){", 
      "+\t\tYFREE(dev->spareBuffer);", 
      "+\t\tdev->spareBuffer = NULL;", 
      "+\t}", 
      "+", 
      "+\tkfree(dev);", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_MTDPutSuper(struct super_block *sb)", 
      "+{", 
      "+", 
      "+\tstruct mtd_info *mtd = yaffs_SuperToDevice(sb)->genericDevice;", 
      "+", 
      "+\tif (mtd->sync) {", 
      "+\t\tmtd->sync(mtd);", 
      "+\t}", 
      "+", 
      "+\tput_mtd_device(mtd);", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_MarkSuperBlockDirty(void *vsb)", 
      "+{", 
      "+\tstruct super_block *sb = (struct super_block *)vsb;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (KERN_DEBUG \"yaffs_MarkSuperBlockDirty() sb = %p\\n\",sb));", 
      "+//\tif(sb)", 
      "+//\t\tsb->s_dirt = 1;", 
      "+}", 
      "+", 
      "+typedef struct {", 
      "+\tint inband_tags;", 
      "+\tint skip_checkpoint_read;", 
      "+\tint skip_checkpoint_write;", 
      "+\tint no_cache;", 
      "+} yaffs_options;", 
      "+", 
      "+#define MAX_OPT_LEN 20", 
      "+static int yaffs_parse_options(yaffs_options *options, const char *options_str)", 
      "+{", 
      "+\tchar cur_opt[MAX_OPT_LEN+1];", 
      "+\tint p;", 
      "+\tint error = 0;", 
      "+", 
      "+\t/* Parse through the options which is a comma seperated list */", 
      "+", 
      "+\twhile(options_str && *options_str && !error){", 
      "+\t\tmemset(cur_opt,0,MAX_OPT_LEN+1);", 
      "+\t\tp = 0;", 
      "+", 
      "+\t\twhile(*options_str && *options_str != ','){", 
      "+\t\t\tif(p < MAX_OPT_LEN){", 
      "+\t\t\t\tcur_opt[p] = *options_str;", 
      "+\t\t\t\tp++;", 
      "+\t\t\t}", 
      "+\t\t\toptions_str++;", 
      "+\t\t}", 
      "+", 
      "+\t\tif(!strcmp(cur_opt,\"inband-tags\"))", 
      "+\t\t\toptions->inband_tags = 1;", 
      "+\t\telse if(!strcmp(cur_opt,\"no-cache\"))", 
      "+\t\t\toptions->no_cache = 1;", 
      "+\t\telse if(!strcmp(cur_opt,\"no-checkpoint-read\"))", 
      "+\t\t\toptions->skip_checkpoint_read = 1;", 
      "+\t\telse if(!strcmp(cur_opt,\"no-checkpoint-write\"))", 
      "+\t\t\toptions->skip_checkpoint_write = 1;", 
      "+\t\telse if(!strcmp(cur_opt,\"no-checkpoint\")){", 
      "+\t\t\toptions->skip_checkpoint_read = 1;", 
      "+\t\t\toptions->skip_checkpoint_write = 1;", 
      "+\t\t} else {", 
      "+\t\t\tprintk(KERN_INFO \"yaffs: Bad mount option \\\"%s\\\"\\n\",cur_opt);", 
      "+\t\t\terror = 1;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn error;", 
      "+}", 
      "+", 
      "+static struct super_block *yaffs_internal_read_super(int yaffsVersion,", 
      "+\t\t\t\t\t\t     struct super_block *sb,", 
      "+\t\t\t\t\t\t     void *data, int silent)", 
      "+{", 
      "+\tint nBlocks;", 
      "+\tstruct inode *inode = NULL;", 
      "+\tstruct dentry *root;", 
      "+\tyaffs_Device *dev = 0;", 
      "+\tchar devname_buf[BDEVNAME_SIZE + 1];", 
      "+\tstruct mtd_info *mtd;", 
      "+\tint err;", 
      "+\tchar *data_str = (char *)data;", 
      "+", 
      "+\tyaffs_options options;", 
      "+", 
      "+\tsb->s_magic = YAFFS_MAGIC;", 
      "+\tsb->s_op = &yaffs_super_ops;", 
      "+\tsb->s_flags |= MS_NOATIME;", 
      "+", 
      "+\tif (!sb)", 
      "+\t\tprintk(KERN_INFO \"yaffs: sb is NULL\\n\");", 
      "+\telse if (!sb->s_dev)", 
      "+\t\tprintk(KERN_INFO \"yaffs: sb->s_dev is NULL\\n\");", 
      "+\telse if (!yaffs_devname(sb, devname_buf))", 
      "+\t\tprintk(KERN_INFO \"yaffs: devname is NULL\\n\");", 
      "+\telse", 
      "+\t\tprintk(KERN_INFO \"yaffs: dev is %d name is \\\"%s\\\"\\n\",", 
      "+\t\t       sb->s_dev,", 
      "+\t\t       yaffs_devname(sb, devname_buf));", 
      "+", 
      "+\tif(!data_str)", 
      "+\t\tdata_str = \"\";", 
      "+", 
      "+\tprintk(KERN_INFO \"yaffs: passed flags \\\"%s\\\"\\n\",data_str);", 
      "+", 
      "+\tmemset(&options,0,sizeof(options));", 
      "+", 
      "+\tif(yaffs_parse_options(&options,data_str)){", 
      "+\t\t/* Option parsing failed */", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+", 
      "+\tsb->s_blocksize = PAGE_CACHE_SIZE;", 
      "+\tsb->s_blocksize_bits = PAGE_CACHE_SHIFT;", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_read_super: Using yaffs%d\\n\", yaffsVersion));", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs_read_super: block size %d\\n\", (int)(sb->s_blocksize)));", 
      "+", 
      "+#ifdef CONFIG_YAFFS_DISABLE_WRITE_VERIFY", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs: Write verification disabled. All guarantees \"", 
      "+\t   \"null and void\\n\"));", 
      "+#endif", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS, (KERN_INFO \"yaffs: Attempting MTD mount on %u.%u, \"", 
      "+\t\t\t       \"\\\"%s\\\"\\n\",", 
      "+\t\t\t       MAJOR(sb->s_dev), MINOR(sb->s_dev),", 
      "+\t\t\t       yaffs_devname(sb, devname_buf)));", 
      "+", 
      "+\t/* Check it's an mtd device..... */", 
      "+\tif (MAJOR(sb->s_dev) != MTD_BLOCK_MAJOR) {", 
      "+\t\treturn NULL;\t/* This isn't an mtd device */", 
      "+\t}", 
      "+\t/* Get the device */", 
      "+\tmtd = get_mtd_device(NULL, MINOR(sb->s_dev));", 
      "+\tif (!mtd) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (KERN_WARNING \"yaffs: MTD device #%u doesn't appear to exist\\n\",", 
      "+\t\t   MINOR(sb->s_dev)));", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+\t/* Check it's NAND */", 
      "+\tif (mtd->type != MTD_NANDFLASH) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (KERN_WARNING \"yaffs: MTD device is not NAND it's type %d\\n\", mtd->type));", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\" erase %p\\n\", mtd->erase));", 
      "+\tT(YAFFS_TRACE_OS, (\" read %p\\n\", mtd->read));", 
      "+\tT(YAFFS_TRACE_OS, (\" write %p\\n\", mtd->write));", 
      "+\tT(YAFFS_TRACE_OS, (\" readoob %p\\n\", mtd->read_oob));", 
      "+\tT(YAFFS_TRACE_OS, (\" writeoob %p\\n\", mtd->write_oob));", 
      "+\tT(YAFFS_TRACE_OS, (\" block_isbad %p\\n\", mtd->block_isbad));", 
      "+\tT(YAFFS_TRACE_OS, (\" block_markbad %p\\n\", mtd->block_markbad));", 
      "+\tT(YAFFS_TRACE_OS, (\" %s %d\\n\", WRITE_SIZE_STR, WRITE_SIZE(mtd)));", 
      "+\tT(YAFFS_TRACE_OS, (\" oobsize %d\\n\", mtd->oobsize));", 
      "+\tT(YAFFS_TRACE_OS, (\" erasesize %d\\n\", mtd->erasesize));", 
      "+\tT(YAFFS_TRACE_OS, (\" size %d\\n\", mtd->size));", 
      "+", 
      "+#ifdef CONFIG_YAFFS_AUTO_YAFFS2", 
      "+", 
      "+\tif (yaffsVersion == 1 &&", 
      "+\t    WRITE_SIZE(mtd) >= 2048) {", 
      "+\t    T(YAFFS_TRACE_ALWAYS,(\"yaffs: auto selecting yaffs2\\n\"));", 
      "+\t    yaffsVersion = 2;", 
      "+\t}", 
      "+", 
      "+\t/* Added NCB 26/5/2006 for completeness */", 
      "+\tif (yaffsVersion == 2 &&", 
      "+\t    !options.inband_tags &&", 
      "+\t    WRITE_SIZE(mtd) == 512){", 
      "+\t    T(YAFFS_TRACE_ALWAYS,(\"yaffs: auto selecting yaffs1\\n\"));", 
      "+\t    yaffsVersion = 1;", 
      "+\t}", 
      "+", 
      "+#endif", 
      "+", 
      "+\tif (yaffsVersion == 2) {", 
      "+\t\t/* Check for version 2 style functions */", 
      "+\t\tif (!mtd->erase ||", 
      "+\t\t    !mtd->block_isbad ||", 
      "+\t\t    !mtd->block_markbad ||", 
      "+\t\t    !mtd->read ||", 
      "+\t\t    !mtd->write ||", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\t\t    !mtd->read_oob || !mtd->write_oob) {", 
      "+#else", 
      "+\t\t    !mtd->write_ecc ||", 
      "+\t\t    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {", 
      "+#endif", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (\"yaffs: MTD device does not support required \"", 
      "+\t\t\t   \"functions\\n\"));;", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+", 
      "+\t\tif ((WRITE_SIZE(mtd) < YAFFS_MIN_YAFFS2_CHUNK_SIZE ||", 
      "+\t\t    mtd->oobsize < YAFFS_MIN_YAFFS2_SPARE_SIZE) &&", 
      "+\t\t    !options.inband_tags) {", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (\"yaffs: MTD device does not have the \"", 
      "+\t\t\t   \"right page sizes\\n\"));", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+\t} else {", 
      "+\t\t/* Check for V1 style functions */", 
      "+\t\tif (!mtd->erase ||", 
      "+\t\t    !mtd->read ||", 
      "+\t\t    !mtd->write ||", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\t\t    !mtd->read_oob || !mtd->write_oob) {", 
      "+#else", 
      "+\t\t    !mtd->write_ecc ||", 
      "+\t\t    !mtd->read_ecc || !mtd->read_oob || !mtd->write_oob) {", 
      "+#endif", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (\"yaffs: MTD device does not support required \"", 
      "+\t\t\t   \"functions\\n\"));;", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+", 
      "+\t\tif (WRITE_SIZE(mtd) < YAFFS_BYTES_PER_CHUNK ||", 
      "+\t\t    mtd->oobsize != YAFFS_BYTES_PER_SPARE) {", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (\"yaffs: MTD device does not support have the \"", 
      "+\t\t\t   \"right page sizes\\n\"));", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\t/* OK, so if we got here, we have an MTD that's NAND and looks", 
      "+\t * like it has the right capabilities", 
      "+\t * Set the yaffs_Device up for mtd", 
      "+\t */", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+\tsb->s_fs_info = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);", 
      "+#else", 
      "+\tsb->u.generic_sbp = dev = kmalloc(sizeof(yaffs_Device), GFP_KERNEL);", 
      "+#endif", 
      "+\tif (!dev) {", 
      "+\t\t/* Deep shit could not allocate device structure */", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (\"yaffs_read_super: Failed trying to allocate \"", 
      "+\t\t   \"yaffs_Device. \\n\"));", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tmemset(dev, 0, sizeof(yaffs_Device));", 
      "+\tdev->genericDevice = mtd;", 
      "+\tdev->name = mtd->name;", 
      "+", 
      "+\t/* Set up the memory size parameters.... */", 
      "+", 
      "+\tnBlocks = mtd->size / (YAFFS_CHUNKS_PER_BLOCK * YAFFS_BYTES_PER_CHUNK);", 
      "+\tdev->startBlock = 0;", 
      "+\tdev->endBlock = nBlocks - 1;", 
      "+\tdev->nChunksPerBlock = YAFFS_CHUNKS_PER_BLOCK;", 
      "+\tdev->totalBytesPerChunk = YAFFS_BYTES_PER_CHUNK;", 
      "+\tdev->nReservedBlocks = 5;", 
      "+\tdev->nShortOpCaches = (options.no_cache) ? 0 : 10;", 
      "+\tdev->inbandTags = options.inband_tags;", 
      "+", 
      "+\t/* ... and the functions. */", 
      "+\tif (yaffsVersion == 2) {", 
      "+\t\tdev->writeChunkWithTagsToNAND =", 
      "+\t\t    nandmtd2_WriteChunkWithTagsToNAND;", 
      "+\t\tdev->readChunkWithTagsFromNAND =", 
      "+\t\t    nandmtd2_ReadChunkWithTagsFromNAND;", 
      "+\t\tdev->markNANDBlockBad = nandmtd2_MarkNANDBlockBad;", 
      "+\t\tdev->queryNANDBlock = nandmtd2_QueryNANDBlock;", 
      "+\t\tdev->spareBuffer = YMALLOC(mtd->oobsize);", 
      "+\t\tdev->isYaffs2 = 1;", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\t\tdev->totalBytesPerChunk = mtd->writesize;", 
      "+\t\tdev->nChunksPerBlock = mtd->erasesize / mtd->writesize;", 
      "+#else", 
      "+\t\tdev->totalBytesPerChunk = mtd->oobblock;", 
      "+\t\tdev->nChunksPerBlock = mtd->erasesize / mtd->oobblock;", 
      "+#endif", 
      "+\t\tnBlocks = mtd->size / mtd->erasesize;", 
      "+", 
      "+\t\tdev->startBlock = 0;", 
      "+\t\tdev->endBlock = nBlocks - 1;", 
      "+\t} else {", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\t\t/* use the MTD interface in yaffs_mtdif1.c */", 
      "+\t\tdev->writeChunkWithTagsToNAND =", 
      "+\t\t\tnandmtd1_WriteChunkWithTagsToNAND;", 
      "+\t\tdev->readChunkWithTagsFromNAND =", 
      "+\t\t\tnandmtd1_ReadChunkWithTagsFromNAND;", 
      "+\t\tdev->markNANDBlockBad = nandmtd1_MarkNANDBlockBad;", 
      "+\t\tdev->queryNANDBlock = nandmtd1_QueryNANDBlock;", 
      "+#else", 
      "+\t\tdev->writeChunkToNAND = nandmtd_WriteChunkToNAND;", 
      "+\t\tdev->readChunkFromNAND = nandmtd_ReadChunkFromNAND;", 
      "+#endif", 
      "+\t\tdev->isYaffs2 = 0;", 
      "+\t}", 
      "+\t/* ... and common functions */", 
      "+\tdev->eraseBlockInNAND = nandmtd_EraseBlockInNAND;", 
      "+\tdev->initialiseNAND = nandmtd_InitialiseNAND;", 
      "+", 
      "+\tdev->putSuperFunc = yaffs_MTDPutSuper;", 
      "+", 
      "+\tdev->superBlock = (void *)sb;", 
      "+\tdev->markSuperBlockDirty = yaffs_MarkSuperBlockDirty;", 
      "+", 
      "+", 
      "+#ifndef CONFIG_YAFFS_DOES_ECC", 
      "+\tdev->useNANDECC = 1;", 
      "+#endif", 
      "+", 
      "+#ifdef CONFIG_YAFFS_DISABLE_WIDE_TNODES", 
      "+\tdev->wideTnodesDisabled = 1;", 
      "+#endif", 
      "+", 
      "+\tdev->skipCheckpointRead = options.skip_checkpoint_read;", 
      "+\tdev->skipCheckpointWrite = options.skip_checkpoint_write;", 
      "+", 
      "+\t/* we assume this is protected by lock_kernel() in mount/umount */", 
      "+\tylist_add_tail(&dev->devList, &yaffs_dev_list);", 
      "+", 
      "+\tinit_MUTEX(&dev->grossLock);", 
      "+", 
      "+\tyaffs_GrossLock(dev);", 
      "+", 
      "+\terr = yaffs_GutsInitialise(dev);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS,", 
      "+\t  (\"yaffs_read_super: guts initialised %s\\n\",", 
      "+\t   (err == YAFFS_OK) ? \"OK\" : \"FAILED\"));", 
      "+", 
      "+\t/* Release lock before yaffs_get_inode() */", 
      "+\tyaffs_GrossUnlock(dev);", 
      "+", 
      "+\t/* Create root inode */", 
      "+\tif (err == YAFFS_OK)", 
      "+\t\tinode = yaffs_get_inode(sb, S_IFDIR | 0755, 0,", 
      "+\t\t\t\t\tyaffs_Root(dev));", 
      "+", 
      "+\tif (!inode)", 
      "+\t\treturn NULL;", 
      "+", 
      "+\tinode->i_op = &yaffs_dir_inode_operations;", 
      "+\tinode->i_fop = &yaffs_dir_operations;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_read_super: got root inode\\n\"));", 
      "+", 
      "+\troot = d_alloc_root(inode);", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_read_super: d_alloc_root done\\n\"));", 
      "+", 
      "+\tif (!root) {", 
      "+\t\tiput(inode);", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+\tsb->s_root = root;", 
      "+", 
      "+\tT(YAFFS_TRACE_OS, (\"yaffs_read_super: done\\n\"));", 
      "+\treturn sb;", 
      "+}", 
      "+", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs_internal_read_super_mtd(struct super_block *sb, void *data,", 
      "+\t\t\t\t\t int silent)", 
      "+{", 
      "+\treturn yaffs_internal_read_super(1, sb, data, silent) ? 0 : -EINVAL;", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs_read_super(struct file_system_type *fs,", 
      "+\t\t\t    int flags, const char *dev_name,", 
      "+\t\t\t    void *data, struct vfsmount *mnt)", 
      "+{", 
      "+", 
      "+\treturn get_sb_bdev(fs, flags, dev_name, data,", 
      "+\t\t\t   yaffs_internal_read_super_mtd, mnt);", 
      "+}", 
      "+#else", 
      "+static struct super_block *yaffs_read_super(struct file_system_type *fs,", 
      "+\t\t\t\t\t    int flags, const char *dev_name,", 
      "+\t\t\t\t\t    void *data)", 
      "+{", 
      "+", 
      "+\treturn get_sb_bdev(fs, flags, dev_name, data,", 
      "+\t\t\t   yaffs_internal_read_super_mtd);", 
      "+}", 
      "+#endif", 
      "+", 
      "+static struct file_system_type yaffs_fs_type = {", 
      "+\t.owner = THIS_MODULE,", 
      "+\t.name = \"yaffs\",", 
      "+\t.get_sb = yaffs_read_super,", 
      "+\t.kill_sb = kill_block_super,", 
      "+\t.fs_flags = FS_REQUIRES_DEV,", 
      "+};", 
      "+#else", 
      "+static struct super_block *yaffs_read_super(struct super_block *sb, void *data,", 
      "+\t\t\t\t\t    int silent)", 
      "+{", 
      "+\treturn yaffs_internal_read_super(1, sb, data, silent);", 
      "+}", 
      "+", 
      "+static DECLARE_FSTYPE(yaffs_fs_type, \"yaffs\", yaffs_read_super,", 
      "+\t\t      FS_REQUIRES_DEV);", 
      "+#endif", 
      "+", 
      "+", 
      "+#ifdef CONFIG_YAFFS_YAFFS2", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+static int yaffs2_internal_read_super_mtd(struct super_block *sb, void *data,", 
      "+\t\t\t\t\t  int silent)", 
      "+{", 
      "+\treturn yaffs_internal_read_super(2, sb, data, silent) ? 0 : -EINVAL;", 
      "+}", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+static int yaffs2_read_super(struct file_system_type *fs,", 
      "+\t\t\tint flags, const char *dev_name, void *data,", 
      "+\t\t\tstruct vfsmount *mnt)", 
      "+{", 
      "+\treturn get_sb_bdev(fs, flags, dev_name, data,", 
      "+\t\t\tyaffs2_internal_read_super_mtd, mnt);", 
      "+}", 
      "+#else", 
      "+static struct super_block *yaffs2_read_super(struct file_system_type *fs,", 
      "+\t\t\t\t\t     int flags, const char *dev_name,", 
      "+\t\t\t\t\t     void *data)", 
      "+{", 
      "+", 
      "+\treturn get_sb_bdev(fs, flags, dev_name, data,", 
      "+\t\t\t   yaffs2_internal_read_super_mtd);", 
      "+}", 
      "+#endif", 
      "+", 
      "+static struct file_system_type yaffs2_fs_type = {", 
      "+\t.owner = THIS_MODULE,", 
      "+\t.name = \"yaffs2\",", 
      "+\t.get_sb = yaffs2_read_super,", 
      "+\t.kill_sb = kill_block_super,", 
      "+\t.fs_flags = FS_REQUIRES_DEV,", 
      "+};", 
      "+#else", 
      "+static struct super_block *yaffs2_read_super(struct super_block *sb,", 
      "+\t\t\t\t\t     void *data, int silent)", 
      "+{", 
      "+\treturn yaffs_internal_read_super(2, sb, data, silent);", 
      "+}", 
      "+", 
      "+static DECLARE_FSTYPE(yaffs2_fs_type, \"yaffs2\", yaffs2_read_super,", 
      "+\t\t      FS_REQUIRES_DEV);", 
      "+#endif", 
      "+", 
      "+#endif\t\t\t\t/* CONFIG_YAFFS_YAFFS2 */", 
      "+", 
      "+static struct proc_dir_entry *my_proc_entry;", 
      "+", 
      "+static char *yaffs_dump_dev(char *buf, yaffs_Device * dev)", 
      "+{", 
      "+\tbuf += sprintf(buf, \"startBlock......... %d\\n\", dev->startBlock);", 
      "+\tbuf += sprintf(buf, \"endBlock........... %d\\n\", dev->endBlock);", 
      "+\tbuf += sprintf(buf, \"totalBytesPerChunk. %d\\n\", dev->totalBytesPerChunk);", 
      "+\tbuf += sprintf(buf, \"nDataBytesPerChunk. %d\\n\", dev->nDataBytesPerChunk);", 
      "+\tbuf += sprintf(buf, \"chunkGroupBits..... %d\\n\", dev->chunkGroupBits);", 
      "+\tbuf += sprintf(buf, \"chunkGroupSize..... %d\\n\", dev->chunkGroupSize);", 
      "+\tbuf += sprintf(buf, \"nErasedBlocks...... %d\\n\", dev->nErasedBlocks);", 
      "+\tbuf += sprintf(buf, \"nReservedBlocks.... %d\\n\", dev->nReservedBlocks);", 
      "+\tbuf += sprintf(buf, \"blocksInCheckpoint. %d\\n\", dev->blocksInCheckpoint);", 
      "+\tbuf += sprintf(buf, \"nTnodesCreated..... %d\\n\", dev->nTnodesCreated);", 
      "+\tbuf += sprintf(buf, \"nFreeTnodes........ %d\\n\", dev->nFreeTnodes);", 
      "+\tbuf += sprintf(buf, \"nObjectsCreated.... %d\\n\", dev->nObjectsCreated);", 
      "+\tbuf += sprintf(buf, \"nFreeObjects....... %d\\n\", dev->nFreeObjects);", 
      "+\tbuf += sprintf(buf, \"nFreeChunks........ %d\\n\", dev->nFreeChunks);", 
      "+\tbuf += sprintf(buf, \"nPageWrites........ %d\\n\", dev->nPageWrites);", 
      "+\tbuf += sprintf(buf, \"nPageReads......... %d\\n\", dev->nPageReads);", 
      "+\tbuf += sprintf(buf, \"nBlockErasures..... %d\\n\", dev->nBlockErasures);", 
      "+\tbuf += sprintf(buf, \"nGCCopies.......... %d\\n\", dev->nGCCopies);", 
      "+\tbuf += sprintf(buf, \"garbageCollections. %d\\n\", dev->garbageCollections);", 
      "+\tbuf += sprintf(buf, \"passiveGCs......... %d\\n\",", 
      "+\t\t    dev->passiveGarbageCollections);", 
      "+\tbuf += sprintf(buf, \"nRetriedWrites..... %d\\n\", dev->nRetriedWrites);", 
      "+\tbuf += sprintf(buf, \"nShortOpCaches..... %d\\n\", dev->nShortOpCaches);", 
      "+\tbuf += sprintf(buf, \"nRetireBlocks...... %d\\n\", dev->nRetiredBlocks);", 
      "+\tbuf += sprintf(buf, \"eccFixed........... %d\\n\", dev->eccFixed);", 
      "+\tbuf += sprintf(buf, \"eccUnfixed......... %d\\n\", dev->eccUnfixed);", 
      "+\tbuf += sprintf(buf, \"tagsEccFixed....... %d\\n\", dev->tagsEccFixed);", 
      "+\tbuf += sprintf(buf, \"tagsEccUnfixed..... %d\\n\", dev->tagsEccUnfixed);", 
      "+\tbuf += sprintf(buf, \"cacheHits.......... %d\\n\", dev->cacheHits);", 
      "+\tbuf += sprintf(buf, \"nDeletedFiles...... %d\\n\", dev->nDeletedFiles);", 
      "+\tbuf += sprintf(buf, \"nUnlinkedFiles..... %d\\n\", dev->nUnlinkedFiles);", 
      "+\tbuf +=", 
      "+\t    sprintf(buf, \"nBackgroudDeletions %d\\n\", dev->nBackgroundDeletions);", 
      "+\tbuf += sprintf(buf, \"useNANDECC......... %d\\n\", dev->useNANDECC);", 
      "+\tbuf += sprintf(buf, \"isYaffs2........... %d\\n\", dev->isYaffs2);", 
      "+\tbuf += sprintf(buf, \"inbandTags......... %d\\n\", dev->inbandTags);", 
      "+", 
      "+\treturn buf;", 
      "+}", 
      "+", 
      "+static int yaffs_proc_read(char *page,", 
      "+\t\t\t   char **start,", 
      "+\t\t\t   off_t offset, int count, int *eof, void *data)", 
      "+{", 
      "+\tstruct ylist_head *item;", 
      "+\tchar *buf = page;", 
      "+\tint step = offset;", 
      "+\tint n = 0;", 
      "+", 
      "+\t/* Get proc_file_read() to step 'offset' by one on each sucessive call.", 
      "+\t * We use 'offset' (*ppos) to indicate where we are in devList.", 
      "+\t * This also assumes the user has posted a read buffer large", 
      "+\t * enough to hold the complete output; but that's life in /proc.", 
      "+\t */", 
      "+", 
      "+\t*(int *)start = 1;", 
      "+", 
      "+\t/* Print header first */", 
      "+\tif (step == 0) {", 
      "+\t\tbuf += sprintf(buf, \"YAFFS built:\" __DATE__ \" \" __TIME__", 
      "+\t\t\t       \"\\n%s\\n%s\\n\", yaffs_fs_c_version,", 
      "+\t\t\t       yaffs_guts_c_version);", 
      "+\t}", 
      "+", 
      "+\t/* hold lock_kernel while traversing yaffs_dev_list */", 
      "+\tlock_kernel();", 
      "+", 
      "+\t/* Locate and print the Nth entry.  Order N-squared but N is small. */", 
      "+\tylist_for_each(item, &yaffs_dev_list) {", 
      "+\t\tyaffs_Device *dev = ylist_entry(item, yaffs_Device, devList);", 
      "+\t\tif (n < step) {", 
      "+\t\t\tn++;", 
      "+\t\t\tcontinue;", 
      "+\t\t}", 
      "+\t\tbuf += sprintf(buf, \"\\nDevice %d \\\"%s\\\"\\n\", n, dev->name);", 
      "+\t\tbuf = yaffs_dump_dev(buf, dev);", 
      "+\t\tbreak;", 
      "+\t}", 
      "+\tunlock_kernel();", 
      "+", 
      "+\treturn buf - page < count ? buf - page : count;", 
      "+}", 
      "+", 
      "+/**", 
      "+ * Set the verbosity of the warnings and error messages.", 
      "+ *", 
      "+ * Note that the names can only be a..z or _ with the current code.", 
      "+ */", 
      "+", 
      "+static struct {", 
      "+\tchar *mask_name;", 
      "+\tunsigned mask_bitfield;", 
      "+} mask_flags[] = {", 
      "+\t{\"allocate\", YAFFS_TRACE_ALLOCATE},", 
      "+\t{\"always\", YAFFS_TRACE_ALWAYS},", 
      "+\t{\"bad_blocks\", YAFFS_TRACE_BAD_BLOCKS},", 
      "+\t{\"buffers\", YAFFS_TRACE_BUFFERS},", 
      "+\t{\"bug\", YAFFS_TRACE_BUG},", 
      "+\t{\"checkpt\", YAFFS_TRACE_CHECKPOINT},", 
      "+\t{\"deletion\", YAFFS_TRACE_DELETION},", 
      "+\t{\"erase\", YAFFS_TRACE_ERASE},", 
      "+\t{\"error\", YAFFS_TRACE_ERROR},", 
      "+\t{\"gc_detail\", YAFFS_TRACE_GC_DETAIL},", 
      "+\t{\"gc\", YAFFS_TRACE_GC},", 
      "+\t{\"mtd\", YAFFS_TRACE_MTD},", 
      "+\t{\"nandaccess\", YAFFS_TRACE_NANDACCESS},", 
      "+\t{\"os\", YAFFS_TRACE_OS},", 
      "+\t{\"scan_debug\", YAFFS_TRACE_SCAN_DEBUG},", 
      "+\t{\"scan\", YAFFS_TRACE_SCAN},", 
      "+\t{\"tracing\", YAFFS_TRACE_TRACING},", 
      "+", 
      "+\t{\"verify\", YAFFS_TRACE_VERIFY},", 
      "+\t{\"verify_nand\", YAFFS_TRACE_VERIFY_NAND},", 
      "+\t{\"verify_full\", YAFFS_TRACE_VERIFY_FULL},", 
      "+\t{\"verify_all\", YAFFS_TRACE_VERIFY_ALL},", 
      "+", 
      "+\t{\"write\", YAFFS_TRACE_WRITE},", 
      "+\t{\"all\", 0xffffffff},", 
      "+\t{\"none\", 0},", 
      "+\t{NULL, 0},", 
      "+};", 
      "+", 
      "+#define MAX_MASK_NAME_LENGTH 40", 
      "+static int yaffs_proc_write(struct file *file, const char *buf,", 
      "+\t\t\t\t\t unsigned long count, void *data)", 
      "+{", 
      "+\tunsigned rg = 0, mask_bitfield;", 
      "+\tchar *end;", 
      "+\tchar *mask_name;", 
      "+\tconst char *x;", 
      "+\tchar substring[MAX_MASK_NAME_LENGTH+1];", 
      "+\tint i;", 
      "+\tint done = 0;", 
      "+\tint add, len = 0;", 
      "+\tint pos = 0;", 
      "+", 
      "+\trg = yaffs_traceMask;", 
      "+", 
      "+\twhile (!done && (pos < count)) {", 
      "+\t\tdone = 1;", 
      "+\t\twhile ((pos < count) && isspace(buf[pos])) {", 
      "+\t\t\tpos++;", 
      "+\t\t}", 
      "+", 
      "+\t\tswitch (buf[pos]) {", 
      "+\t\tcase '+':", 
      "+\t\tcase '-':", 
      "+\t\tcase '=':", 
      "+\t\t\tadd = buf[pos];", 
      "+\t\t\tpos++;", 
      "+\t\t\tbreak;", 
      "+", 
      "+\t\tdefault:", 
      "+\t\t\tadd = ' ';", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+\t\tmask_name = NULL;", 
      "+", 
      "+\t\tmask_bitfield = simple_strtoul(buf + pos, &end, 0);", 
      "+\t\tif (end > buf + pos) {", 
      "+\t\t\tmask_name = \"numeral\";", 
      "+\t\t\tlen = end - (buf + pos);", 
      "+\t\t\tpos += len;", 
      "+\t\t\tdone = 0;", 
      "+\t\t} else {", 
      "+\t\t\tfor(x = buf + pos, i = 0;", 
      "+\t\t\t    (*x == '_' || (*x >='a' && *x <= 'z')) &&", 
      "+\t\t\t    i <MAX_MASK_NAME_LENGTH; x++, i++, pos++)", 
      "+\t\t\t    substring[i] = *x;", 
      "+\t\t\tsubstring[i] = '\\0';", 
      "+", 
      "+\t\t\tfor (i = 0; mask_flags[i].mask_name != NULL; i++) {", 
      "+\t\t\t\tif(strcmp(substring,mask_flags[i].mask_name) == 0){", 
      "+\t\t\t\t\tmask_name = mask_flags[i].mask_name;", 
      "+\t\t\t\t\tmask_bitfield = mask_flags[i].mask_bitfield;", 
      "+\t\t\t\t\tdone = 0;", 
      "+\t\t\t\t\tbreak;", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tif (mask_name != NULL) {", 
      "+\t\t\tdone = 0;", 
      "+\t\t\tswitch(add) {", 
      "+\t\t\tcase '-':", 
      "+\t\t\t\trg &= ~mask_bitfield;", 
      "+\t\t\t\tbreak;", 
      "+\t\t\tcase '+':", 
      "+\t\t\t\trg |= mask_bitfield;", 
      "+\t\t\t\tbreak;", 
      "+\t\t\tcase '=':", 
      "+\t\t\t\trg = mask_bitfield;", 
      "+\t\t\t\tbreak;", 
      "+\t\t\tdefault:", 
      "+\t\t\t\trg |= mask_bitfield;", 
      "+\t\t\t\tbreak;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tyaffs_traceMask = rg | YAFFS_TRACE_ALWAYS;", 
      "+", 
      "+\tprintk(\"new trace = 0x%08X\\n\",yaffs_traceMask);", 
      "+", 
      "+\tif (rg & YAFFS_TRACE_ALWAYS) {", 
      "+\t\tfor (i = 0; mask_flags[i].mask_name != NULL; i++) {", 
      "+\t\t\tchar flag;", 
      "+\t\t\tflag = ((rg & mask_flags[i].mask_bitfield) == mask_flags[i].mask_bitfield) ? '+' : '-';", 
      "+\t\t\tprintk(\"%c%s\\n\", flag, mask_flags[i].mask_name);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn count;", 
      "+}", 
      "+", 
      "+/* Stuff to handle installation of file systems */", 
      "+struct file_system_to_install {", 
      "+\tstruct file_system_type *fst;", 
      "+\tint installed;", 
      "+};", 
      "+", 
      "+static struct file_system_to_install fs_to_install[] = {", 
      "+//#ifdef CONFIG_YAFFS_YAFFS1", 
      "+\t{&yaffs_fs_type, 0},", 
      "+//#endif", 
      "+//#ifdef CONFIG_YAFFS_YAFFS2", 
      "+\t{&yaffs2_fs_type, 0},", 
      "+//#endif", 
      "+\t{NULL, 0}", 
      "+};", 
      "+", 
      "+static int __init init_yaffs_fs(void)", 
      "+{", 
      "+\tint error = 0;", 
      "+\tstruct file_system_to_install *fsinst;", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t  (KERN_INFO \"yaffs \" __DATE__ \" \" __TIME__ \" Installing. \\n\"));", 
      "+", 
      "+\t/* Install the proc_fs entry */", 
      "+\tmy_proc_entry = create_proc_entry(\"yaffs\",", 
      "+\t\t\t\t\t       S_IRUGO | S_IFREG,", 
      "+\t\t\t\t\t       &proc_root);", 
      "+", 
      "+\tif (my_proc_entry) {", 
      "+\t\tmy_proc_entry->write_proc = yaffs_proc_write;", 
      "+\t\tmy_proc_entry->read_proc = yaffs_proc_read;", 
      "+\t\tmy_proc_entry->data = NULL;", 
      "+\t} else {", 
      "+\t\treturn -ENOMEM;", 
      "+\t}", 
      "+", 
      "+\t/* Now add the file system entries */", 
      "+", 
      "+\tfsinst = fs_to_install;", 
      "+", 
      "+\twhile (fsinst->fst && !error) {", 
      "+\t\terror = register_filesystem(fsinst->fst);", 
      "+\t\tif (!error) {", 
      "+\t\t\tfsinst->installed = 1;", 
      "+\t\t}", 
      "+\t\tfsinst++;", 
      "+\t}", 
      "+", 
      "+\t/* Any errors? uninstall  */", 
      "+\tif (error) {", 
      "+\t\tfsinst = fs_to_install;", 
      "+", 
      "+\t\twhile (fsinst->fst) {", 
      "+\t\t\tif (fsinst->installed) {", 
      "+\t\t\t\tunregister_filesystem(fsinst->fst);", 
      "+\t\t\t\tfsinst->installed = 0;", 
      "+\t\t\t}", 
      "+\t\t\tfsinst++;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn error;", 
      "+}", 
      "+", 
      "+static void __exit exit_yaffs_fs(void)", 
      "+{", 
      "+", 
      "+\tstruct file_system_to_install *fsinst;", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS, (\"yaffs \" __DATE__ \" \" __TIME__", 
      "+\t\t\t       \" removing. \\n\"));", 
      "+", 
      "+\tremove_proc_entry(\"yaffs\", &proc_root);", 
      "+", 
      "+\tfsinst = fs_to_install;", 
      "+", 
      "+\twhile (fsinst->fst) {", 
      "+\t\tif (fsinst->installed) {", 
      "+\t\t\tunregister_filesystem(fsinst->fst);", 
      "+\t\t\tfsinst->installed = 0;", 
      "+\t\t}", 
      "+\t\tfsinst++;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+module_init(init_yaffs_fs)", 
      "+module_exit(exit_yaffs_fs)", 
      "+", 
      "+MODULE_DESCRIPTION(\"YAFFS2 - a NAND specific flash file system\");", 
      "+MODULE_AUTHOR(\"Charles Manning, Aleph One Ltd., 2002-2006\");", 
      "+MODULE_LICENSE(\"GPL\");"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_getblockinfo.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_getblockinfo.h", 
      "@@ -0,0 +1,34 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_GETBLOCKINFO_H__", 
      "+#define __YAFFS_GETBLOCKINFO_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+/* Function to manipulate block info */", 
      "+static Y_INLINE yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blk)", 
      "+{", 
      "+\tif (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"**>> yaffs: getBlockInfo block %d is not valid\" TENDSTR),", 
      "+\t\t   blk));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+\treturn &dev->blockInfo[blk - dev->internalStartBlock];", 
      "+}", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_guts.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_guts.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_guts.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.c", 
      "@@ -0,0 +1,7531 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+const char *yaffs_guts_c_version =", 
      "+    \"$Id: yaffs_guts.c,v 1.58 2008/07/03 20:06:05 charles Exp $\";", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+#include \"yaffsinterface.h\"", 
      "+#include \"yaffs_guts.h\"", 
      "+#include \"yaffs_tagsvalidity.h\"", 
      "+#include \"yaffs_getblockinfo.h\"", 
      "+", 
      "+#include \"yaffs_tagscompat.h\"", 
      "+#ifndef  CONFIG_YAFFS_USE_OWN_SORT", 
      "+#include \"yaffs_qsort.h\"", 
      "+#endif", 
      "+#include \"yaffs_nand.h\"", 
      "+", 
      "+#include \"yaffs_checkptrw.h\"", 
      "+", 
      "+#include \"yaffs_nand.h\"", 
      "+#include \"yaffs_packedtags2.h\"", 
      "+", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+void yfsd_LockYAFFS(BOOL fsLockOnly);", 
      "+void yfsd_UnlockYAFFS(BOOL fsLockOnly);", 
      "+#endif", 
      "+", 
      "+#define YAFFS_PASSIVE_GC_CHUNKS 2", 
      "+", 
      "+#include \"yaffs_ecc.h\"", 
      "+", 
      "+", 
      "+/* Robustification (if it ever comes about...) */", 
      "+static void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND);", 
      "+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk);", 
      "+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t     const __u8 * data,", 
      "+\t\t\t\t     const yaffs_ExtendedTags * tags);", 
      "+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t    const yaffs_ExtendedTags * tags);", 
      "+", 
      "+/* Other local prototypes */", 
      "+static int yaffs_UnlinkObject( yaffs_Object *obj);", 
      "+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj);", 
      "+", 
      "+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList);", 
      "+", 
      "+static int yaffs_WriteNewChunkWithTagsToNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t     const __u8 * buffer,", 
      "+\t\t\t\t\t     yaffs_ExtendedTags * tags,", 
      "+\t\t\t\t\t     int useReserve);", 
      "+static int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t  int chunkInNAND, int inScan);", 
      "+", 
      "+static yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,", 
      "+\t\t\t\t\t   yaffs_ObjectType type);", 
      "+static void yaffs_AddObjectToDirectory(yaffs_Object * directory,", 
      "+\t\t\t\t       yaffs_Object * obj);", 
      "+static int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name,", 
      "+\t\t\t\t    int force, int isShrink, int shadows);", 
      "+static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj);", 
      "+static int yaffs_CheckStructures(void);", 
      "+static int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,", 
      "+\t\t\t      int chunkOffset, int *limit);", 
      "+static int yaffs_DoGenericObjectDeletion(yaffs_Object * in);", 
      "+", 
      "+static yaffs_BlockInfo *yaffs_GetBlockInfo(yaffs_Device * dev, int blockNo);", 
      "+", 
      "+", 
      "+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int chunkInNAND);", 
      "+", 
      "+static int yaffs_UnlinkWorker(yaffs_Object * obj);", 
      "+static void yaffs_DestroyObject(yaffs_Object * obj);", 
      "+", 
      "+static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,", 
      "+\t\t\t   int chunkInObject);", 
      "+", 
      "+loff_t yaffs_GetFileSize(yaffs_Object * obj);", 
      "+", 
      "+static int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr);", 
      "+", 
      "+static void yaffs_VerifyFreeChunks(yaffs_Device * dev);", 
      "+", 
      "+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in);", 
      "+", 
      "+#ifdef YAFFS_PARANOID", 
      "+static int yaffs_CheckFileSanity(yaffs_Object * in);", 
      "+#else", 
      "+#define yaffs_CheckFileSanity(in)", 
      "+#endif", 
      "+", 
      "+static void yaffs_InvalidateWholeChunkCache(yaffs_Object * in);", 
      "+static void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId);", 
      "+", 
      "+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev);", 
      "+", 
      "+static int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t yaffs_ExtendedTags * tags);", 
      "+", 
      "+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos);", 
      "+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,", 
      "+\t\t\t\t\t  yaffs_FileStructure * fStruct,", 
      "+\t\t\t\t\t  __u32 chunkId);", 
      "+", 
      "+", 
      "+/* Function to calculate chunk and offset */", 
      "+", 
      "+static void yaffs_AddrToChunk(yaffs_Device *dev, loff_t addr, int *chunkOut, __u32 *offsetOut)", 
      "+{", 
      "+\tint chunk;", 
      "+\t__u32 offset;", 
      "+", 
      "+\tchunk  = (__u32)(addr >> dev->chunkShift);", 
      "+", 
      "+\tif(dev->chunkDiv == 1)", 
      "+\t{", 
      "+\t\t/* easy power of 2 case */", 
      "+\t\toffset = (__u32)(addr & dev->chunkMask);", 
      "+\t}", 
      "+\telse", 
      "+\t{", 
      "+\t\t/* Non power-of-2 case */", 
      "+", 
      "+\t\tloff_t chunkBase;", 
      "+", 
      "+\t\tchunk /= dev->chunkDiv;", 
      "+", 
      "+\t\tchunkBase = ((loff_t)chunk) * dev->nDataBytesPerChunk;", 
      "+\t\toffset = (__u32)(addr - chunkBase);", 
      "+\t}", 
      "+", 
      "+\t*chunkOut = chunk;", 
      "+\t*offsetOut = offset;", 
      "+}", 
      "+", 
      "+/* Function to return the number of shifts for a power of 2 greater than or equal", 
      "+ * to the given number", 
      "+ * Note we don't try to cater for all possible numbers and this does not have to", 
      "+ * be hellishly efficient.", 
      "+ */", 
      "+", 
      "+static __u32 ShiftsGE(__u32 x)", 
      "+{", 
      "+\tint extraBits;", 
      "+\tint nShifts;", 
      "+", 
      "+\tnShifts = extraBits = 0;", 
      "+", 
      "+\twhile(x>1){", 
      "+\t\tif(x & 1) extraBits++;", 
      "+\t\tx>>=1;", 
      "+\t\tnShifts++;", 
      "+\t}", 
      "+", 
      "+\tif(extraBits)", 
      "+\t\tnShifts++;", 
      "+", 
      "+\treturn nShifts;", 
      "+}", 
      "+", 
      "+/* Function to return the number of shifts to get a 1 in bit 0", 
      "+ */", 
      "+", 
      "+static __u32 Shifts(__u32 x)", 
      "+{", 
      "+\tint nShifts;", 
      "+", 
      "+\tnShifts =  0;", 
      "+", 
      "+\tif(!x) return 0;", 
      "+", 
      "+\twhile( !(x&1)){", 
      "+\t\tx>>=1;", 
      "+\t\tnShifts++;", 
      "+\t}", 
      "+", 
      "+\treturn nShifts;", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+/*", 
      "+ * Temporary buffer manipulations.", 
      "+ */", 
      "+", 
      "+static int yaffs_InitialiseTempBuffers(yaffs_Device *dev)", 
      "+{", 
      "+\tint i;", 
      "+\t__u8 *buf = (__u8 *)1;", 
      "+", 
      "+\tmemset(dev->tempBuffer,0,sizeof(dev->tempBuffer));", 
      "+", 
      "+\tfor (i = 0; buf && i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\tdev->tempBuffer[i].line = 0;\t/* not in use */", 
      "+\t\tdev->tempBuffer[i].buffer = buf =", 
      "+\t\t    YMALLOC_DMA(dev->totalBytesPerChunk);", 
      "+\t}", 
      "+", 
      "+\treturn buf ? YAFFS_OK : YAFFS_FAIL;", 
      "+", 
      "+}", 
      "+", 
      "+__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo)", 
      "+{", 
      "+\tint i, j;", 
      "+", 
      "+\tdev->tempInUse++;", 
      "+\tif(dev->tempInUse > dev->maxTemp)", 
      "+\t\tdev->maxTemp = dev->tempInUse;", 
      "+", 
      "+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\tif (dev->tempBuffer[i].line == 0) {", 
      "+\t\t\tdev->tempBuffer[i].line = lineNo;", 
      "+\t\t\tif ((i + 1) > dev->maxTemp) {", 
      "+\t\t\t\tdev->maxTemp = i + 1;", 
      "+\t\t\t\tfor (j = 0; j <= i; j++)", 
      "+\t\t\t\t\tdev->tempBuffer[j].maxLine =", 
      "+\t\t\t\t\t    dev->tempBuffer[j].line;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\treturn dev->tempBuffer[i].buffer;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_BUFFERS,", 
      "+\t  (TSTR(\"Out of temp buffers at line %d, other held by lines:\"),", 
      "+\t   lineNo));", 
      "+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\tT(YAFFS_TRACE_BUFFERS, (TSTR(\" %d \"), dev->tempBuffer[i].line));", 
      "+\t}", 
      "+\tT(YAFFS_TRACE_BUFFERS, (TSTR(\" \" TENDSTR)));", 
      "+", 
      "+\t/*", 
      "+\t * If we got here then we have to allocate an unmanaged one", 
      "+\t * This is not good.", 
      "+\t */", 
      "+", 
      "+\tdev->unmanagedTempAllocations++;", 
      "+\treturn YMALLOC(dev->nDataBytesPerChunk);", 
      "+", 
      "+}", 
      "+", 
      "+void yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer,", 
      "+\t\t\t\t    int lineNo)", 
      "+{", 
      "+\tint i;", 
      "+", 
      "+\tdev->tempInUse--;", 
      "+", 
      "+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\tif (dev->tempBuffer[i].buffer == buffer) {", 
      "+\t\t\tdev->tempBuffer[i].line = 0;", 
      "+\t\t\treturn;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tif (buffer) {", 
      "+\t\t/* assume it is an unmanaged one. */", 
      "+\t\tT(YAFFS_TRACE_BUFFERS,", 
      "+\t\t  (TSTR(\"Releasing unmanaged temp buffer in line %d\" TENDSTR),", 
      "+\t\t   lineNo));", 
      "+\t\tYFREE(buffer);", 
      "+\t\tdev->unmanagedTempDeallocations++;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Determine if we have a managed buffer.", 
      "+ */", 
      "+int yaffs_IsManagedTempBuffer(yaffs_Device * dev, const __u8 * buffer)", 
      "+{", 
      "+\tint i;", 
      "+\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\tif (dev->tempBuffer[i].buffer == buffer)", 
      "+\t\t\treturn 1;", 
      "+", 
      "+\t}", 
      "+", 
      "+    for (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+        if( dev->srCache[i].data == buffer )", 
      "+            return 1;", 
      "+", 
      "+    }", 
      "+", 
      "+    if (buffer == dev->checkpointBuffer)", 
      "+      return 1;", 
      "+", 
      "+    T(YAFFS_TRACE_ALWAYS,", 
      "+\t  (TSTR(\"yaffs: unmaged buffer detected.\\n\" TENDSTR)));", 
      "+    return 0;", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+/*", 
      "+ * Chunk bitmap manipulations", 
      "+ */", 
      "+", 
      "+static Y_INLINE __u8 *yaffs_BlockBits(yaffs_Device * dev, int blk)", 
      "+{", 
      "+\tif (blk < dev->internalStartBlock || blk > dev->internalEndBlock) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR(\"**>> yaffs: BlockBits block %d is not valid\" TENDSTR),", 
      "+\t\t   blk));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+\treturn dev->chunkBits +", 
      "+\t    (dev->chunkBitmapStride * (blk - dev->internalStartBlock));", 
      "+}", 
      "+", 
      "+static Y_INLINE void yaffs_VerifyChunkBitId(yaffs_Device *dev, int blk, int chunk)", 
      "+{", 
      "+\tif(blk < dev->internalStartBlock || blk > dev->internalEndBlock ||", 
      "+\t   chunk < 0 || chunk >= dev->nChunksPerBlock) {", 
      "+\t   T(YAFFS_TRACE_ERROR,", 
      "+\t    (TSTR(\"**>> yaffs: Chunk Id (%d:%d) invalid\"TENDSTR),blk,chunk));", 
      "+\t    YBUG();", 
      "+\t}", 
      "+}", 
      "+", 
      "+static Y_INLINE void yaffs_ClearChunkBits(yaffs_Device * dev, int blk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+", 
      "+\tmemset(blkBits, 0, dev->chunkBitmapStride);", 
      "+}", 
      "+", 
      "+static Y_INLINE void yaffs_ClearChunkBit(yaffs_Device * dev, int blk, int chunk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+", 
      "+\tyaffs_VerifyChunkBitId(dev,blk,chunk);", 
      "+", 
      "+\tblkBits[chunk / 8] &= ~(1 << (chunk & 7));", 
      "+}", 
      "+", 
      "+static Y_INLINE void yaffs_SetChunkBit(yaffs_Device * dev, int blk, int chunk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+", 
      "+\tyaffs_VerifyChunkBitId(dev,blk,chunk);", 
      "+", 
      "+\tblkBits[chunk / 8] |= (1 << (chunk & 7));", 
      "+}", 
      "+", 
      "+static Y_INLINE int yaffs_CheckChunkBit(yaffs_Device * dev, int blk, int chunk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+\tyaffs_VerifyChunkBitId(dev,blk,chunk);", 
      "+", 
      "+\treturn (blkBits[chunk / 8] & (1 << (chunk & 7))) ? 1 : 0;", 
      "+}", 
      "+", 
      "+static Y_INLINE int yaffs_StillSomeChunkBits(yaffs_Device * dev, int blk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+\tint i;", 
      "+\tfor (i = 0; i < dev->chunkBitmapStride; i++) {", 
      "+\t\tif (*blkBits)", 
      "+\t\t\treturn 1;", 
      "+\t\tblkBits++;", 
      "+\t}", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+static int yaffs_CountChunkBits(yaffs_Device * dev, int blk)", 
      "+{", 
      "+\t__u8 *blkBits = yaffs_BlockBits(dev, blk);", 
      "+\tint i;", 
      "+\tint n = 0;", 
      "+\tfor (i = 0; i < dev->chunkBitmapStride; i++) {", 
      "+\t\t__u8 x = *blkBits;", 
      "+\t\twhile(x){", 
      "+\t\t\tif(x & 1)", 
      "+\t\t\t\tn++;", 
      "+\t\t\tx >>=1;", 
      "+\t\t}", 
      "+", 
      "+\t\tblkBits++;", 
      "+\t}", 
      "+\treturn n;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Verification code", 
      "+ */", 
      "+", 
      "+static int yaffs_SkipVerification(yaffs_Device *dev)", 
      "+{", 
      "+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY | YAFFS_TRACE_VERIFY_FULL));", 
      "+}", 
      "+", 
      "+#if 0", 
      "+static int yaffs_SkipFullVerification(yaffs_Device *dev)", 
      "+{", 
      "+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_FULL));", 
      "+}", 
      "+", 
      "+#endif", 
      "+", 
      "+static int yaffs_SkipNANDVerification(yaffs_Device *dev)", 
      "+{", 
      "+\treturn !(yaffs_traceMask & (YAFFS_TRACE_VERIFY_NAND));", 
      "+}", 
      "+", 
      "+static const char * blockStateName[] = {", 
      "+\"Unknown\",", 
      "+\"Needs scanning\",", 
      "+\"Scanning\",", 
      "+\"Empty\",", 
      "+\"Allocating\",", 
      "+\"Full\",", 
      "+\"Dirty\",", 
      "+\"Checkpoint\",", 
      "+\"Collecting\",", 
      "+\"Dead\"", 
      "+};", 
      "+", 
      "+static void yaffs_VerifyBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)", 
      "+{", 
      "+\tint actuallyUsed;", 
      "+\tint inUse;", 
      "+", 
      "+\tif(yaffs_SkipVerification(dev))", 
      "+\t\treturn;", 
      "+", 
      "+\t/* Report illegal runtime states */", 
      "+\tif(bi->blockState <0 || bi->blockState >= YAFFS_NUMBER_OF_BLOCK_STATES)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block %d has undefined state %d\"TENDSTR),n,bi->blockState));", 
      "+", 
      "+\tswitch(bi->blockState){", 
      "+\t case YAFFS_BLOCK_STATE_UNKNOWN:", 
      "+\t case YAFFS_BLOCK_STATE_SCANNING:", 
      "+\t case YAFFS_BLOCK_STATE_NEEDS_SCANNING:", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block %d has bad run-state %s\"TENDSTR),", 
      "+\t\tn,blockStateName[bi->blockState]));", 
      "+\t}", 
      "+", 
      "+\t/* Check pages in use and soft deletions are legal */", 
      "+", 
      "+\tactuallyUsed = bi->pagesInUse - bi->softDeletions;", 
      "+", 
      "+\tif(bi->pagesInUse < 0 || bi->pagesInUse > dev->nChunksPerBlock ||", 
      "+\t   bi->softDeletions < 0 || bi->softDeletions > dev->nChunksPerBlock ||", 
      "+\t   actuallyUsed < 0 || actuallyUsed > dev->nChunksPerBlock)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block %d has illegal values pagesInUsed %d softDeletions %d\"TENDSTR),", 
      "+\t\tn,bi->pagesInUse,bi->softDeletions));", 
      "+", 
      "+", 
      "+\t/* Check chunk bitmap legal */", 
      "+\tinUse = yaffs_CountChunkBits(dev,n);", 
      "+\tif(inUse != bi->pagesInUse)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block %d has inconsistent values pagesInUse %d counted chunk bits %d\"TENDSTR),", 
      "+\t\t\tn,bi->pagesInUse,inUse));", 
      "+", 
      "+\t/* Check that the sequence number is valid.", 
      "+\t * Ten million is legal, but is very unlikely", 
      "+\t */", 
      "+\tif(dev->isYaffs2 &&", 
      "+\t   (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING || bi->blockState == YAFFS_BLOCK_STATE_FULL) &&", 
      "+\t   (bi->sequenceNumber < YAFFS_LOWEST_SEQUENCE_NUMBER || bi->sequenceNumber > 10000000 ))", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block %d has suspect sequence number of %d\"TENDSTR),", 
      "+\t\tn,bi->sequenceNumber));", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyCollectedBlock(yaffs_Device *dev,yaffs_BlockInfo *bi,int n)", 
      "+{", 
      "+\tyaffs_VerifyBlock(dev,bi,n);", 
      "+", 
      "+\t/* After collection the block should be in the erased state */", 
      "+\t/* TODO: This will need to change if we do partial gc */", 
      "+", 
      "+\tif(bi->blockState != YAFFS_BLOCK_STATE_EMPTY){", 
      "+\t\tT(YAFFS_TRACE_ERROR,(TSTR(\"Block %d is in state %d after gc, should be erased\"TENDSTR),", 
      "+\t\t\tn,bi->blockState));", 
      "+\t}", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyBlocks(yaffs_Device *dev)", 
      "+{", 
      "+\tint i;", 
      "+\tint nBlocksPerState[YAFFS_NUMBER_OF_BLOCK_STATES];", 
      "+\tint nIllegalBlockStates = 0;", 
      "+", 
      "+", 
      "+\tif(yaffs_SkipVerification(dev))", 
      "+\t\treturn;", 
      "+", 
      "+\tmemset(nBlocksPerState,0,sizeof(nBlocksPerState));", 
      "+", 
      "+", 
      "+\tfor(i = dev->internalStartBlock; i <= dev->internalEndBlock; i++){", 
      "+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev,i);", 
      "+\t\tyaffs_VerifyBlock(dev,bi,i);", 
      "+", 
      "+\t\tif(bi->blockState >=0 && bi->blockState < YAFFS_NUMBER_OF_BLOCK_STATES)", 
      "+\t\t\tnBlocksPerState[bi->blockState]++;", 
      "+\t\telse", 
      "+\t\t\tnIllegalBlockStates++;", 
      "+", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_VERIFY,(TSTR(\"\"TENDSTR)));", 
      "+\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Block summary\"TENDSTR)));", 
      "+", 
      "+\tT(YAFFS_TRACE_VERIFY,(TSTR(\"%d blocks have illegal states\"TENDSTR),nIllegalBlockStates));", 
      "+\tif(nBlocksPerState[YAFFS_BLOCK_STATE_ALLOCATING] > 1)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,(TSTR(\"Too many allocating blocks\"TENDSTR)));", 
      "+", 
      "+\tfor(i = 0; i < YAFFS_NUMBER_OF_BLOCK_STATES; i++)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t  (TSTR(\"%s %d blocks\"TENDSTR),", 
      "+\t\t  blockStateName[i],nBlocksPerState[i]));", 
      "+", 
      "+\tif(dev->blocksInCheckpoint != nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT])", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Checkpoint block count wrong dev %d count %d\"TENDSTR),", 
      "+\t\t dev->blocksInCheckpoint, nBlocksPerState[YAFFS_BLOCK_STATE_CHECKPOINT]));", 
      "+", 
      "+\tif(dev->nErasedBlocks != nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY])", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Erased block count wrong dev %d count %d\"TENDSTR),", 
      "+\t\t dev->nErasedBlocks, nBlocksPerState[YAFFS_BLOCK_STATE_EMPTY]));", 
      "+", 
      "+\tif(nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING] > 1)", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Too many collecting blocks %d (max is 1)\"TENDSTR),", 
      "+\t\t nBlocksPerState[YAFFS_BLOCK_STATE_COLLECTING]));", 
      "+", 
      "+\tT(YAFFS_TRACE_VERIFY,(TSTR(\"\"TENDSTR)));", 
      "+", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Verify the object header. oh must be valid, but obj and tags may be NULL in which", 
      "+ * case those tests will not be performed.", 
      "+ */", 
      "+static void yaffs_VerifyObjectHeader(yaffs_Object *obj, yaffs_ObjectHeader *oh, yaffs_ExtendedTags *tags, int parentCheck)", 
      "+{", 
      "+\tif(yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+", 
      "+\tif(!(tags && obj && oh)){", 
      "+\t \tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t \t\t(TSTR(\"Verifying object header tags %x obj %x oh %x\"TENDSTR),", 
      "+\t\t \t\t(__u32)tags,(__u32)obj,(__u32)oh));", 
      "+\t\treturn;", 
      "+\t}", 
      "+", 
      "+\tif(oh->type <= YAFFS_OBJECT_TYPE_UNKNOWN ||", 
      "+\t   oh->type > YAFFS_OBJECT_TYPE_MAX)", 
      "+\t \tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Obj %d header type is illegal value 0x%x\"TENDSTR),", 
      "+\t\t tags->objectId, oh->type));", 
      "+", 
      "+\tif(tags->objectId != obj->objectId)", 
      "+\t \tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Obj %d header mismatch objectId %d\"TENDSTR),", 
      "+\t\t tags->objectId, obj->objectId));", 
      "+", 
      "+", 
      "+\t/*", 
      "+\t * Check that the object's parent ids match if parentCheck requested.", 
      "+\t *", 
      "+\t * Tests do not apply to the root object.", 
      "+\t */", 
      "+", 
      "+\tif(parentCheck && tags->objectId > 1 && !obj->parent)", 
      "+\t \tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Obj %d header mismatch parentId %d obj->parent is NULL\"TENDSTR),", 
      "+\t \t tags->objectId, oh->parentObjectId));", 
      "+", 
      "+", 
      "+\tif(parentCheck && obj->parent &&", 
      "+\t   oh->parentObjectId != obj->parent->objectId &&", 
      "+\t   (oh->parentObjectId != YAFFS_OBJECTID_UNLINKED ||", 
      "+\t    obj->parent->objectId != YAFFS_OBJECTID_DELETED))", 
      "+\t \tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t (TSTR(\"Obj %d header mismatch parentId %d parentObjectId %d\"TENDSTR),", 
      "+\t \t tags->objectId, oh->parentObjectId, obj->parent->objectId));", 
      "+", 
      "+", 
      "+\tif(tags->objectId > 1 && oh->name[0] == 0) /* Null name */", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t(TSTR(\"Obj %d header name is NULL\"TENDSTR),", 
      "+\t\t obj->objectId));", 
      "+", 
      "+\tif(tags->objectId > 1 && ((__u8)(oh->name[0])) == 0xff) /* Trashed name */", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t(TSTR(\"Obj %d header name is 0xFF\"TENDSTR),", 
      "+\t\t obj->objectId));", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+static int yaffs_VerifyTnodeWorker(yaffs_Object * obj, yaffs_Tnode * tn,", 
      "+\t\t\t\t  \t__u32 level, int chunkOffset)", 
      "+{", 
      "+\tint i;", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+\tint ok = 1;", 
      "+", 
      "+\tif (tn) {", 
      "+\t\tif (level > 0) {", 
      "+", 
      "+\t\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){", 
      "+\t\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\t\tok = yaffs_VerifyTnodeWorker(obj,", 
      "+\t\t\t\t\t\t\ttn->internal[i],", 
      "+\t\t\t\t\t\t\tlevel - 1,", 
      "+\t\t\t\t\t\t\t(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t} else if (level == 0) {", 
      "+\t\t\tint i;", 
      "+\t\t\tyaffs_ExtendedTags tags;", 
      "+\t\t\t__u32 objectId = obj->objectId;", 
      "+", 
      "+\t\t\tchunkOffset <<=  YAFFS_TNODES_LEVEL0_BITS;", 
      "+", 
      "+\t\t\tfor(i = 0; i < YAFFS_NTNODES_LEVEL0; i++){", 
      "+\t\t\t\t__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);", 
      "+", 
      "+\t\t\t\tif(theChunk > 0){", 
      "+\t\t\t\t\t/* T(~0,(TSTR(\"verifying (%d:%d) %d\"TENDSTR),tags.objectId,tags.chunkId,theChunk)); */", 
      "+\t\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);", 
      "+\t\t\t\t\tif(tags.objectId != objectId || tags.chunkId != chunkOffset){", 
      "+\t\t\t\t\t\tT(~0,(TSTR(\"Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)\"TENDSTR),", 
      "+\t\t\t\t\t\t\tobjectId, chunkOffset, theChunk,", 
      "+\t\t\t\t\t\t\ttags.objectId, tags.chunkId));", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+\t\t\t\tchunkOffset++;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn ok;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_VerifyFile(yaffs_Object *obj)", 
      "+{", 
      "+\tint requiredTallness;", 
      "+\tint actualTallness;", 
      "+\t__u32 lastChunk;", 
      "+\t__u32 x;", 
      "+\t__u32 i;", 
      "+\tyaffs_Device *dev;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tyaffs_Tnode *tn;", 
      "+\t__u32 objectId;", 
      "+", 
      "+\tif(obj && yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+", 
      "+\tdev = obj->myDev;", 
      "+\tobjectId = obj->objectId;", 
      "+", 
      "+\t/* Check file size is consistent with tnode depth */", 
      "+\tlastChunk =  obj->variant.fileVariant.fileSize / dev->nDataBytesPerChunk + 1;", 
      "+\tx = lastChunk >> YAFFS_TNODES_LEVEL0_BITS;", 
      "+\trequiredTallness = 0;", 
      "+\twhile (x> 0) {", 
      "+\t\tx >>= YAFFS_TNODES_INTERNAL_BITS;", 
      "+\t\trequiredTallness++;", 
      "+\t}", 
      "+", 
      "+\tactualTallness = obj->variant.fileVariant.topLevel;", 
      "+", 
      "+\tif(requiredTallness > actualTallness )", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t(TSTR(\"Obj %d had tnode tallness %d, needs to be %d\"TENDSTR),", 
      "+\t\t obj->objectId,actualTallness, requiredTallness));", 
      "+", 
      "+", 
      "+\t/* Check that the chunks in the tnode tree are all correct.", 
      "+\t * We do this by scanning through the tnode tree and", 
      "+\t * checking the tags for every chunk match.", 
      "+\t */", 
      "+", 
      "+\tif(yaffs_SkipNANDVerification(dev))", 
      "+\t\treturn;", 
      "+", 
      "+\tfor(i = 1; i <= lastChunk; i++){", 
      "+\t\ttn = yaffs_FindLevel0Tnode(dev, &obj->variant.fileVariant,i);", 
      "+", 
      "+\t\tif (tn) {", 
      "+\t\t\t__u32 theChunk = yaffs_GetChunkGroupBase(dev,tn,i);", 
      "+\t\t\tif(theChunk > 0){", 
      "+\t\t\t\t/* T(~0,(TSTR(\"verifying (%d:%d) %d\"TENDSTR),objectId,i,theChunk)); */", 
      "+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,theChunk,NULL, &tags);", 
      "+\t\t\t\tif(tags.objectId != objectId || tags.chunkId != i){", 
      "+\t\t\t\t\tT(~0,(TSTR(\"Object %d chunkId %d NAND mismatch chunk %d tags (%d:%d)\"TENDSTR),", 
      "+\t\t\t\t\t\tobjectId, i, theChunk,", 
      "+\t\t\t\t\t\ttags.objectId, tags.chunkId));", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyDirectory(yaffs_Object *obj)", 
      "+{", 
      "+\tif(obj && yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyHardLink(yaffs_Object *obj)", 
      "+{", 
      "+\tif(obj && yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+", 
      "+\t/* Verify sane equivalent object */", 
      "+}", 
      "+", 
      "+static void yaffs_VerifySymlink(yaffs_Object *obj)", 
      "+{", 
      "+\tif(obj && yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+", 
      "+\t/* Verify symlink string */", 
      "+}", 
      "+", 
      "+static void yaffs_VerifySpecial(yaffs_Object *obj)", 
      "+{", 
      "+\tif(obj && yaffs_SkipVerification(obj->myDev))", 
      "+\t\treturn;", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyObject(yaffs_Object *obj)", 
      "+{", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\t__u32 chunkMin;", 
      "+\t__u32 chunkMax;", 
      "+", 
      "+\t__u32 chunkIdOk;", 
      "+\t__u32 chunkIsLive;", 
      "+", 
      "+\tif(!obj)", 
      "+\t\treturn;", 
      "+", 
      "+\tdev = obj->myDev;", 
      "+", 
      "+\tif(yaffs_SkipVerification(dev))", 
      "+\t\treturn;", 
      "+", 
      "+\t/* Check sane object header chunk */", 
      "+", 
      "+\tchunkMin = dev->internalStartBlock * dev->nChunksPerBlock;", 
      "+\tchunkMax = (dev->internalEndBlock+1) * dev->nChunksPerBlock - 1;", 
      "+", 
      "+\tchunkIdOk = (((unsigned)(obj->hdrChunk)) >= chunkMin && ((unsigned)(obj->hdrChunk)) <= chunkMax);", 
      "+\tchunkIsLive = chunkIdOk &&", 
      "+\t\t\tyaffs_CheckChunkBit(dev,", 
      "+\t\t\t\t\t    obj->hdrChunk / dev->nChunksPerBlock,", 
      "+\t\t\t\t\t    obj->hdrChunk % dev->nChunksPerBlock);", 
      "+\tif(!obj->fake &&", 
      "+\t    (!chunkIdOk || !chunkIsLive)) {", 
      "+\t   T(YAFFS_TRACE_VERIFY,", 
      "+\t   (TSTR(\"Obj %d has chunkId %d %s %s\"TENDSTR),", 
      "+\t   obj->objectId,obj->hdrChunk,", 
      "+\t   chunkIdOk ? \"\" : \",out of range\",", 
      "+\t   chunkIsLive || !chunkIdOk ? \"\" : \",marked as deleted\"));", 
      "+\t}", 
      "+", 
      "+\tif(chunkIdOk && chunkIsLive &&!yaffs_SkipNANDVerification(dev)) {", 
      "+\t\tyaffs_ExtendedTags tags;", 
      "+\t\tyaffs_ObjectHeader *oh;", 
      "+\t\t__u8 *buffer = yaffs_GetTempBuffer(dev,__LINE__);", 
      "+", 
      "+\t\toh = (yaffs_ObjectHeader *)buffer;", 
      "+", 
      "+\t\tyaffs_ReadChunkWithTagsFromNAND(dev, obj->hdrChunk,buffer, &tags);", 
      "+", 
      "+\t\tyaffs_VerifyObjectHeader(obj,oh,&tags,1);", 
      "+", 
      "+\t\tyaffs_ReleaseTempBuffer(dev,buffer,__LINE__);", 
      "+\t}", 
      "+", 
      "+\t/* Verify it has a parent */", 
      "+\tif(obj && !obj->fake &&", 
      "+\t   (!obj->parent || obj->parent->myDev != dev)){", 
      "+\t   T(YAFFS_TRACE_VERIFY,", 
      "+\t   (TSTR(\"Obj %d has parent pointer %p which does not look like an object\"TENDSTR),", 
      "+\t   obj->objectId,obj->parent));", 
      "+\t}", 
      "+", 
      "+\t/* Verify parent is a directory */", 
      "+\tif(obj->parent && obj->parent->variantType != YAFFS_OBJECT_TYPE_DIRECTORY){", 
      "+\t   T(YAFFS_TRACE_VERIFY,", 
      "+\t   (TSTR(\"Obj %d's parent is not a directory (type %d)\"TENDSTR),", 
      "+\t   obj->objectId,obj->parent->variantType));", 
      "+\t}", 
      "+", 
      "+\tswitch(obj->variantType){", 
      "+\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\tyaffs_VerifyFile(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\tyaffs_VerifySymlink(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\tyaffs_VerifyDirectory(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\tyaffs_VerifyHardLink(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\tyaffs_VerifySpecial(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\tdefault:", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t(TSTR(\"Obj %d has illegaltype %d\"TENDSTR),", 
      "+\t\tobj->objectId,obj->variantType));", 
      "+\t\tbreak;", 
      "+\t}", 
      "+", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_VerifyObjects(yaffs_Device *dev)", 
      "+{", 
      "+        yaffs_Object *obj;", 
      "+        int i;", 
      "+        struct ylist_head *lh;", 
      "+", 
      "+        if(yaffs_SkipVerification(dev))", 
      "+                return;", 
      "+", 
      "+        /* Iterate through the objects in each hash entry */", 
      "+", 
      "+         for(i = 0; i <  YAFFS_NOBJECT_BUCKETS; i++){", 
      "+                ylist_for_each(lh, &dev->objectBucket[i].list) {", 
      "+                        if (lh) {", 
      "+                                obj = ylist_entry(lh, yaffs_Object, hashLink);", 
      "+                                yaffs_VerifyObject(obj);", 
      "+                        }", 
      "+                }", 
      "+\t }", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+/*", 
      "+ *  Simple hash function. Needs to have a reasonable spread", 
      "+ */", 
      "+", 
      "+static Y_INLINE int yaffs_HashFunction(int n)", 
      "+{", 
      "+\tn = abs(n);", 
      "+\treturn (n % YAFFS_NOBJECT_BUCKETS);", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Access functions to useful fake objects.", 
      "+ * Note that root might have a presence in NAND if permissions are set.", 
      "+ */", 
      "+", 
      "+yaffs_Object *yaffs_Root(yaffs_Device * dev)", 
      "+{", 
      "+\treturn dev->rootDir;", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_LostNFound(yaffs_Device * dev)", 
      "+{", 
      "+\treturn dev->lostNFoundDir;", 
      "+}", 
      "+", 
      "+", 
      "+/*", 
      "+ *  Erased NAND checking functions", 
      "+ */", 
      "+", 
      "+int yaffs_CheckFF(__u8 * buffer, int nBytes)", 
      "+{", 
      "+\t/* Horrible, slow implementation */", 
      "+\twhile (nBytes--) {", 
      "+\t\tif (*buffer != 0xFF)", 
      "+\t\t\treturn 0;", 
      "+\t\tbuffer++;", 
      "+\t}", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int chunkInNAND)", 
      "+{", 
      "+", 
      "+\tint retval = YAFFS_OK;", 
      "+\t__u8 *data = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tint result;", 
      "+", 
      "+\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunkInNAND, data, &tags);", 
      "+", 
      "+\tif(tags.eccResult > YAFFS_ECC_RESULT_NO_ERROR)", 
      "+\t\tretval = YAFFS_FAIL;", 
      "+", 
      "+", 
      "+\tif (!yaffs_CheckFF(data, dev->nDataBytesPerChunk) || tags.chunkUsed) {", 
      "+\t\tT(YAFFS_TRACE_NANDACCESS,", 
      "+\t\t  (TSTR(\"Chunk %d not erased\" TENDSTR), chunkInNAND));", 
      "+\t\tretval = YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tyaffs_ReleaseTempBuffer(dev, data, __LINE__);", 
      "+", 
      "+\treturn retval;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_WriteNewChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t     const __u8 * data,", 
      "+\t\t\t\t\t     yaffs_ExtendedTags * tags,", 
      "+\t\t\t\t\t     int useReserve)", 
      "+{", 
      "+\tint attempts = 0;", 
      "+\tint writeOk = 0;", 
      "+\tint chunk;", 
      "+", 
      "+\tyaffs_InvalidateCheckpoint(dev);", 
      "+", 
      "+\tdo {", 
      "+\t\tyaffs_BlockInfo *bi = 0;", 
      "+\t\tint erasedOk = 0;", 
      "+", 
      "+\t\tchunk = yaffs_AllocateChunk(dev, useReserve, &bi);", 
      "+\t\tif (chunk < 0) {", 
      "+\t\t\t/* no space */", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t\t/* First check this chunk is erased, if it needs", 
      "+\t\t * checking.  The checking policy (unless forced", 
      "+\t\t * always on) is as follows:", 
      "+\t\t *", 
      "+\t\t * Check the first page we try to write in a block.", 
      "+\t\t * If the check passes then we don't need to check any", 
      "+\t\t * more.\tIf the check fails, we check again...", 
      "+\t\t * If the block has been erased, we don't need to check.", 
      "+\t\t *", 
      "+\t\t * However, if the block has been prioritised for gc,", 
      "+\t\t * then we think there might be something odd about", 
      "+\t\t * this block and stop using it.", 
      "+\t\t *", 
      "+\t\t * Rationale: We should only ever see chunks that have", 
      "+\t\t * not been erased if there was a partially written", 
      "+\t\t * chunk due to power loss.  This checking policy should", 
      "+\t\t * catch that case with very few checks and thus save a", 
      "+\t\t * lot of checks that are most likely not needed.", 
      "+\t\t */", 
      "+\t\tif (bi->gcPrioritise) {", 
      "+\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);", 
      "+\t\t\t/* try another chunk */", 
      "+\t\t\tcontinue;", 
      "+\t\t}", 
      "+", 
      "+\t\t/* let's give it a try */", 
      "+\t\tattempts++;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED", 
      "+\t\tbi->skipErasedCheck = 0;", 
      "+#endif", 
      "+\t\tif (!bi->skipErasedCheck) {", 
      "+\t\t\terasedOk = yaffs_CheckChunkErased(dev, chunk);", 
      "+\t\t\tif (erasedOk != YAFFS_OK) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t(TSTR (\"**>> yaffs chunk %d was not erased\"", 
      "+\t\t\t\tTENDSTR), chunk));", 
      "+", 
      "+\t\t\t\t/* try another chunk */", 
      "+\t\t\t\tcontinue;", 
      "+\t\t\t}", 
      "+\t\t\tbi->skipErasedCheck = 1;", 
      "+\t\t}", 
      "+", 
      "+\t\twriteOk = yaffs_WriteChunkWithTagsToNAND(dev, chunk,", 
      "+\t\t\t\tdata, tags);", 
      "+\t\tif (writeOk != YAFFS_OK) {", 
      "+\t\t\tyaffs_HandleWriteChunkError(dev, chunk, erasedOk);", 
      "+\t\t\t/* try another chunk */", 
      "+\t\t\tcontinue;", 
      "+\t\t}", 
      "+", 
      "+\t\t/* Copy the data into the robustification buffer */", 
      "+\t\tyaffs_HandleWriteChunkOk(dev, chunk, data, tags);", 
      "+", 
      "+\t} while (writeOk != YAFFS_OK &&", 
      "+\t        (yaffs_wr_attempts <= 0 || attempts <= yaffs_wr_attempts));", 
      "+", 
      "+\tif(!writeOk)", 
      "+\t\tchunk = -1;", 
      "+", 
      "+\tif (attempts > 1) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t(TSTR(\"**>> yaffs write required %d attempts\" TENDSTR),", 
      "+\t\t\tattempts));", 
      "+", 
      "+\t\tdev->nRetriedWrites += (attempts - 1);", 
      "+\t}", 
      "+", 
      "+\treturn chunk;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Block retiring for handling a broken block.", 
      "+ */", 
      "+", 
      "+static void yaffs_RetireBlock(yaffs_Device * dev, int blockInNAND)", 
      "+{", 
      "+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);", 
      "+", 
      "+\tyaffs_InvalidateCheckpoint(dev);", 
      "+", 
      "+\tyaffs_MarkBlockBad(dev, blockInNAND);", 
      "+", 
      "+\tbi->blockState = YAFFS_BLOCK_STATE_DEAD;", 
      "+\tbi->gcPrioritise = 0;", 
      "+\tbi->needsRetiring = 0;", 
      "+", 
      "+\tdev->nRetiredBlocks++;", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Functions for robustisizing TODO", 
      "+ *", 
      "+ */", 
      "+", 
      "+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t     const __u8 * data,", 
      "+\t\t\t\t     const yaffs_ExtendedTags * tags)", 
      "+{", 
      "+}", 
      "+", 
      "+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t    const yaffs_ExtendedTags * tags)", 
      "+{", 
      "+}", 
      "+", 
      "+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi)", 
      "+{", 
      "+\tif(!bi->gcPrioritise){", 
      "+\t\tbi->gcPrioritise = 1;", 
      "+\t\tdev->hasPendingPrioritisedGCs = 1;", 
      "+\t\tbi->chunkErrorStrikes ++;", 
      "+", 
      "+\t\tif(bi->chunkErrorStrikes > 3){", 
      "+\t\t\tbi->needsRetiring = 1; /* Too many stikes, so retire this */", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS, (TSTR(\"yaffs: Block struck out\" TENDSTR)));", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+}", 
      "+", 
      "+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND, int erasedOk)", 
      "+{", 
      "+", 
      "+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;", 
      "+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockInNAND);", 
      "+", 
      "+\tyaffs_HandleChunkError(dev,bi);", 
      "+", 
      "+", 
      "+\tif(erasedOk ) {", 
      "+\t\t/* Was an actual write failure, so mark the block for retirement  */", 
      "+\t\tbi->needsRetiring = 1;", 
      "+\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t  (TSTR(\"**>> Block %d needs retiring\" TENDSTR), blockInNAND));", 
      "+", 
      "+", 
      "+\t}", 
      "+", 
      "+\t/* Delete the chunk */", 
      "+\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);", 
      "+}", 
      "+", 
      "+", 
      "+/*---------------- Name handling functions ------------*/", 
      "+", 
      "+static __u16 yaffs_CalcNameSum(const YCHAR * name)", 
      "+{", 
      "+\t__u16 sum = 0;", 
      "+\t__u16 i = 1;", 
      "+", 
      "+\tYUCHAR *bname = (YUCHAR *) name;", 
      "+\tif (bname) {", 
      "+\t\twhile ((*bname) && (i < (YAFFS_MAX_NAME_LENGTH/2))) {", 
      "+", 
      "+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE", 
      "+\t\t\tsum += yaffs_toupper(*bname) * i;", 
      "+#else", 
      "+\t\t\tsum += (*bname) * i;", 
      "+#endif", 
      "+\t\t\ti++;", 
      "+\t\t\tbname++;", 
      "+\t\t}", 
      "+\t}", 
      "+\treturn sum;", 
      "+}", 
      "+", 
      "+static void yaffs_SetObjectName(yaffs_Object * obj, const YCHAR * name)", 
      "+{", 
      "+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM", 
      "+\tif (name && yaffs_strlen(name) <= YAFFS_SHORT_NAME_LENGTH) {", 
      "+\t\tyaffs_strcpy(obj->shortName, name);", 
      "+\t} else {", 
      "+\t\tobj->shortName[0] = _Y('\\0');", 
      "+\t}", 
      "+#endif", 
      "+\tobj->sum = yaffs_CalcNameSum(name);", 
      "+}", 
      "+", 
      "+/*-------------------- TNODES -------------------", 
      "+", 
      "+ * List of spare tnodes", 
      "+ * The list is hooked together using the first pointer", 
      "+ * in the tnode.", 
      "+ */", 
      "+", 
      "+/* yaffs_CreateTnodes creates a bunch more tnodes and", 
      "+ * adds them to the tnode free list.", 
      "+ * Don't use this function directly", 
      "+ */", 
      "+", 
      "+static int yaffs_CreateTnodes(yaffs_Device * dev, int nTnodes)", 
      "+{", 
      "+\tint i;", 
      "+\tint tnodeSize;", 
      "+\tyaffs_Tnode *newTnodes;", 
      "+\t__u8 *mem;", 
      "+\tyaffs_Tnode *curr;", 
      "+\tyaffs_Tnode *next;", 
      "+\tyaffs_TnodeList *tnl;", 
      "+", 
      "+\tif (nTnodes < 1)", 
      "+\t\treturn YAFFS_OK;", 
      "+", 
      "+\t/* Calculate the tnode size in bytes for variable width tnode support.", 
      "+\t * Must be a multiple of 32-bits  */", 
      "+\ttnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;", 
      "+", 
      "+\tif(tnodeSize < sizeof(yaffs_Tnode))", 
      "+\t\ttnodeSize = sizeof(yaffs_Tnode);", 
      "+", 
      "+", 
      "+\t/* make these things */", 
      "+", 
      "+\tnewTnodes = YMALLOC(nTnodes * tnodeSize);", 
      "+\tmem = (__u8 *)newTnodes;", 
      "+", 
      "+\tif (!newTnodes) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR(\"yaffs: Could not allocate Tnodes\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* Hook them into the free list */", 
      "+#if 0", 
      "+\tfor (i = 0; i < nTnodes - 1; i++) {", 
      "+\t\tnewTnodes[i].internal[0] = &newTnodes[i + 1];", 
      "+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+\t\tnewTnodes[i].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;", 
      "+#endif", 
      "+\t}", 
      "+", 
      "+\tnewTnodes[nTnodes - 1].internal[0] = dev->freeTnodes;", 
      "+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+\tnewTnodes[nTnodes - 1].internal[YAFFS_NTNODES_INTERNAL] = (void *)1;", 
      "+#endif", 
      "+\tdev->freeTnodes = newTnodes;", 
      "+#else", 
      "+\t/* New hookup for wide tnodes */", 
      "+\tfor(i = 0; i < nTnodes -1; i++) {", 
      "+\t\tcurr = (yaffs_Tnode *) &mem[i * tnodeSize];", 
      "+\t\tnext = (yaffs_Tnode *) &mem[(i+1) * tnodeSize];", 
      "+\t\tcurr->internal[0] = next;", 
      "+\t}", 
      "+", 
      "+\tcurr = (yaffs_Tnode *) &mem[(nTnodes - 1) * tnodeSize];", 
      "+\tcurr->internal[0] = dev->freeTnodes;", 
      "+\tdev->freeTnodes = (yaffs_Tnode *)mem;", 
      "+", 
      "+#endif", 
      "+", 
      "+", 
      "+\tdev->nFreeTnodes += nTnodes;", 
      "+\tdev->nTnodesCreated += nTnodes;", 
      "+", 
      "+\t/* Now add this bunch of tnodes to a list for freeing up.", 
      "+\t * NB If we can't add this to the management list it isn't fatal", 
      "+\t * but it just means we can't free this bunch of tnodes later.", 
      "+\t */", 
      "+", 
      "+\ttnl = YMALLOC(sizeof(yaffs_TnodeList));", 
      "+\tif (!tnl) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"yaffs: Could not add tnodes to management list\" TENDSTR)));", 
      "+\t\t   return YAFFS_FAIL;", 
      "+", 
      "+\t} else {", 
      "+\t\ttnl->tnodes = newTnodes;", 
      "+\t\ttnl->next = dev->allocatedTnodeList;", 
      "+\t\tdev->allocatedTnodeList = tnl;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_ALLOCATE, (TSTR(\"yaffs: Tnodes added\" TENDSTR)));", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* GetTnode gets us a clean tnode. Tries to make allocate more if we run out */", 
      "+", 
      "+static yaffs_Tnode *yaffs_GetTnodeRaw(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_Tnode *tn = NULL;", 
      "+", 
      "+\t/* If there are none left make more */", 
      "+\tif (!dev->freeTnodes) {", 
      "+\t\tyaffs_CreateTnodes(dev, YAFFS_ALLOCATION_NTNODES);", 
      "+\t}", 
      "+", 
      "+\tif (dev->freeTnodes) {", 
      "+\t\ttn = dev->freeTnodes;", 
      "+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+\t\tif (tn->internal[YAFFS_NTNODES_INTERNAL] != (void *)1) {", 
      "+\t\t\t/* Hoosterman, this thing looks like it isn't in the list */", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (TSTR(\"yaffs: Tnode list bug 1\" TENDSTR)));", 
      "+\t\t}", 
      "+#endif", 
      "+\t\tdev->freeTnodes = dev->freeTnodes->internal[0];", 
      "+\t\tdev->nFreeTnodes--;", 
      "+\t}", 
      "+", 
      "+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/", 
      "+", 
      "+\treturn tn;", 
      "+}", 
      "+", 
      "+static yaffs_Tnode *yaffs_GetTnode(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_Tnode *tn = yaffs_GetTnodeRaw(dev);", 
      "+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;", 
      "+", 
      "+\tif(tnodeSize < sizeof(yaffs_Tnode))", 
      "+\t\ttnodeSize = sizeof(yaffs_Tnode);", 
      "+", 
      "+\tif(tn)", 
      "+\t\tmemset(tn, 0, tnodeSize);", 
      "+", 
      "+\treturn tn;", 
      "+}", 
      "+", 
      "+/* FreeTnode frees up a tnode and puts it back on the free list */", 
      "+static void yaffs_FreeTnode(yaffs_Device * dev, yaffs_Tnode * tn)", 
      "+{", 
      "+\tif (tn) {", 
      "+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+\t\tif (tn->internal[YAFFS_NTNODES_INTERNAL] != 0) {", 
      "+\t\t\t/* Hoosterman, this thing looks like it is already in the list */", 
      "+\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t  (TSTR(\"yaffs: Tnode list bug 2\" TENDSTR)));", 
      "+\t\t}", 
      "+\t\ttn->internal[YAFFS_NTNODES_INTERNAL] = (void *)1;", 
      "+#endif", 
      "+\t\ttn->internal[0] = dev->freeTnodes;", 
      "+\t\tdev->freeTnodes = tn;", 
      "+\t\tdev->nFreeTnodes++;", 
      "+\t}", 
      "+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_DeinitialiseTnodes(yaffs_Device * dev)", 
      "+{", 
      "+\t/* Free the list of allocated tnodes */", 
      "+\tyaffs_TnodeList *tmp;", 
      "+", 
      "+\twhile (dev->allocatedTnodeList) {", 
      "+\t\ttmp = dev->allocatedTnodeList->next;", 
      "+", 
      "+\t\tYFREE(dev->allocatedTnodeList->tnodes);", 
      "+\t\tYFREE(dev->allocatedTnodeList);", 
      "+\t\tdev->allocatedTnodeList = tmp;", 
      "+", 
      "+\t}", 
      "+", 
      "+\tdev->freeTnodes = NULL;", 
      "+\tdev->nFreeTnodes = 0;", 
      "+}", 
      "+", 
      "+static void yaffs_InitialiseTnodes(yaffs_Device * dev)", 
      "+{", 
      "+\tdev->allocatedTnodeList = NULL;", 
      "+\tdev->freeTnodes = NULL;", 
      "+\tdev->nFreeTnodes = 0;", 
      "+\tdev->nTnodesCreated = 0;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+void yaffs_PutLevel0Tnode(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos, unsigned val)", 
      "+{", 
      "+  __u32 *map = (__u32 *)tn;", 
      "+  __u32 bitInMap;", 
      "+  __u32 bitInWord;", 
      "+  __u32 wordInMap;", 
      "+  __u32 mask;", 
      "+", 
      "+  pos &= YAFFS_TNODES_LEVEL0_MASK;", 
      "+  val >>= dev->chunkGroupBits;", 
      "+", 
      "+  bitInMap = pos * dev->tnodeWidth;", 
      "+  wordInMap = bitInMap /32;", 
      "+  bitInWord = bitInMap & (32 -1);", 
      "+", 
      "+  mask = dev->tnodeMask << bitInWord;", 
      "+", 
      "+  map[wordInMap] &= ~mask;", 
      "+  map[wordInMap] |= (mask & (val << bitInWord));", 
      "+", 
      "+  if(dev->tnodeWidth > (32-bitInWord)) {", 
      "+    bitInWord = (32 - bitInWord);", 
      "+    wordInMap++;;", 
      "+    mask = dev->tnodeMask >> (/*dev->tnodeWidth -*/ bitInWord);", 
      "+    map[wordInMap] &= ~mask;", 
      "+    map[wordInMap] |= (mask & (val >> bitInWord));", 
      "+  }", 
      "+}", 
      "+", 
      "+static __u32 yaffs_GetChunkGroupBase(yaffs_Device *dev, yaffs_Tnode *tn, unsigned pos)", 
      "+{", 
      "+  __u32 *map = (__u32 *)tn;", 
      "+  __u32 bitInMap;", 
      "+  __u32 bitInWord;", 
      "+  __u32 wordInMap;", 
      "+  __u32 val;", 
      "+", 
      "+  pos &= YAFFS_TNODES_LEVEL0_MASK;", 
      "+", 
      "+  bitInMap = pos * dev->tnodeWidth;", 
      "+  wordInMap = bitInMap /32;", 
      "+  bitInWord = bitInMap & (32 -1);", 
      "+", 
      "+  val = map[wordInMap] >> bitInWord;", 
      "+", 
      "+  if(dev->tnodeWidth > (32-bitInWord)) {", 
      "+    bitInWord = (32 - bitInWord);", 
      "+    wordInMap++;;", 
      "+    val |= (map[wordInMap] << bitInWord);", 
      "+  }", 
      "+", 
      "+  val &= dev->tnodeMask;", 
      "+  val <<= dev->chunkGroupBits;", 
      "+", 
      "+  return val;", 
      "+}", 
      "+", 
      "+/* ------------------- End of individual tnode manipulation -----------------*/", 
      "+", 
      "+/* ---------Functions to manipulate the look-up tree (made up of tnodes) ------", 
      "+ * The look up tree is represented by the top tnode and the number of topLevel", 
      "+ * in the tree. 0 means only the level 0 tnode is in the tree.", 
      "+ */", 
      "+", 
      "+/* FindLevel0Tnode finds the level 0 tnode, if one exists. */", 
      "+static yaffs_Tnode *yaffs_FindLevel0Tnode(yaffs_Device * dev,", 
      "+\t\t\t\t\t  yaffs_FileStructure * fStruct,", 
      "+\t\t\t\t\t  __u32 chunkId)", 
      "+{", 
      "+", 
      "+\tyaffs_Tnode *tn = fStruct->top;", 
      "+\t__u32 i;", 
      "+\tint requiredTallness;", 
      "+\tint level = fStruct->topLevel;", 
      "+", 
      "+\t/* Check sane level and chunk Id */", 
      "+\tif (level < 0 || level > YAFFS_TNODES_MAX_LEVEL) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tif (chunkId > YAFFS_MAX_CHUNK_ID) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\t/* First check we're tall enough (ie enough topLevel) */", 
      "+", 
      "+\ti = chunkId >> YAFFS_TNODES_LEVEL0_BITS;", 
      "+\trequiredTallness = 0;", 
      "+\twhile (i) {", 
      "+\t\ti >>= YAFFS_TNODES_INTERNAL_BITS;", 
      "+\t\trequiredTallness++;", 
      "+\t}", 
      "+", 
      "+\tif (requiredTallness > fStruct->topLevel) {", 
      "+\t\t/* Not tall enough, so we can't find it, return NULL. */", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\t/* Traverse down to level 0 */", 
      "+\twhile (level > 0 && tn) {", 
      "+\t\ttn = tn->", 
      "+\t\t    internal[(chunkId >>", 
      "+\t\t\t       ( YAFFS_TNODES_LEVEL0_BITS +", 
      "+\t\t\t         (level - 1) *", 
      "+\t\t\t         YAFFS_TNODES_INTERNAL_BITS)", 
      "+\t\t\t      ) &", 
      "+\t\t\t     YAFFS_TNODES_INTERNAL_MASK];", 
      "+\t\tlevel--;", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn tn;", 
      "+}", 
      "+", 
      "+/* AddOrFindLevel0Tnode finds the level 0 tnode if it exists, otherwise first expands the tree.", 
      "+ * This happens in two steps:", 
      "+ *  1. If the tree isn't tall enough, then make it taller.", 
      "+ *  2. Scan down the tree towards the level 0 tnode adding tnodes if required.", 
      "+ *", 
      "+ * Used when modifying the tree.", 
      "+ *", 
      "+ *  If the tn argument is NULL, then a fresh tnode will be added otherwise the specified tn will", 
      "+ *  be plugged into the ttree.", 
      "+ */", 
      "+", 
      "+static yaffs_Tnode *yaffs_AddOrFindLevel0Tnode(yaffs_Device * dev,", 
      "+\t\t\t\t\t       yaffs_FileStructure * fStruct,", 
      "+\t\t\t\t\t       __u32 chunkId,", 
      "+\t\t\t\t\t       yaffs_Tnode *passedTn)", 
      "+{", 
      "+", 
      "+\tint requiredTallness;", 
      "+\tint i;", 
      "+\tint l;", 
      "+\tyaffs_Tnode *tn;", 
      "+", 
      "+\t__u32 x;", 
      "+", 
      "+", 
      "+\t/* Check sane level and page Id */", 
      "+\tif (fStruct->topLevel < 0 || fStruct->topLevel > YAFFS_TNODES_MAX_LEVEL) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tif (chunkId > YAFFS_MAX_CHUNK_ID) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\t/* First check we're tall enough (ie enough topLevel) */", 
      "+", 
      "+\tx = chunkId >> YAFFS_TNODES_LEVEL0_BITS;", 
      "+\trequiredTallness = 0;", 
      "+\twhile (x) {", 
      "+\t\tx >>= YAFFS_TNODES_INTERNAL_BITS;", 
      "+\t\trequiredTallness++;", 
      "+\t}", 
      "+", 
      "+", 
      "+\tif (requiredTallness > fStruct->topLevel) {", 
      "+\t\t/* Not tall enough,gotta make the tree taller */", 
      "+\t\tfor (i = fStruct->topLevel; i < requiredTallness; i++) {", 
      "+", 
      "+\t\t\ttn = yaffs_GetTnode(dev);", 
      "+", 
      "+\t\t\tif (tn) {", 
      "+\t\t\t\ttn->internal[0] = fStruct->top;", 
      "+\t\t\t\tfStruct->top = tn;", 
      "+\t\t\t} else {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR(\"yaffs: no more tnodes\" TENDSTR)));", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tfStruct->topLevel = requiredTallness;", 
      "+\t}", 
      "+", 
      "+\t/* Traverse down to level 0, adding anything we need */", 
      "+", 
      "+\tl = fStruct->topLevel;", 
      "+\ttn = fStruct->top;", 
      "+", 
      "+\tif(l > 0) {", 
      "+\t\twhile (l > 0 && tn) {", 
      "+\t\t\tx = (chunkId >>", 
      "+\t\t\t     ( YAFFS_TNODES_LEVEL0_BITS +", 
      "+\t\t\t      (l - 1) * YAFFS_TNODES_INTERNAL_BITS)) &", 
      "+\t\t\t    YAFFS_TNODES_INTERNAL_MASK;", 
      "+", 
      "+", 
      "+\t\t\tif((l>1) && !tn->internal[x]){", 
      "+\t\t\t\t/* Add missing non-level-zero tnode */", 
      "+\t\t\t\ttn->internal[x] = yaffs_GetTnode(dev);", 
      "+", 
      "+\t\t\t} else if(l == 1) {", 
      "+\t\t\t\t/* Looking from level 1 at level 0 */", 
      "+\t\t\t \tif (passedTn) {", 
      "+\t\t\t\t\t/* If we already have one, then release it.*/", 
      "+\t\t\t\t\tif(tn->internal[x])", 
      "+\t\t\t\t\t\tyaffs_FreeTnode(dev,tn->internal[x]);", 
      "+\t\t\t\t\ttn->internal[x] = passedTn;", 
      "+", 
      "+\t\t\t\t} else if(!tn->internal[x]) {", 
      "+\t\t\t\t\t/* Don't have one, none passed in */", 
      "+\t\t\t\t\ttn->internal[x] = yaffs_GetTnode(dev);", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\ttn = tn->internal[x];", 
      "+\t\t\tl--;", 
      "+\t\t}", 
      "+\t} else {", 
      "+\t\t/* top is level 0 */", 
      "+\t\tif(passedTn) {", 
      "+\t\t\tmemcpy(tn,passedTn,(dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8);", 
      "+\t\t\tyaffs_FreeTnode(dev,passedTn);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn tn;", 
      "+}", 
      "+", 
      "+static int yaffs_FindChunkInGroup(yaffs_Device * dev, int theChunk,", 
      "+\t\t\t\t  yaffs_ExtendedTags * tags, int objectId,", 
      "+\t\t\t\t  int chunkInInode)", 
      "+{", 
      "+\tint j;", 
      "+", 
      "+\tfor (j = 0; theChunk && j < dev->chunkGroupSize; j++) {", 
      "+\t\tif (yaffs_CheckChunkBit", 
      "+\t\t    (dev, theChunk / dev->nChunksPerBlock,", 
      "+\t\t     theChunk % dev->nChunksPerBlock)) {", 
      "+\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev, theChunk, NULL,", 
      "+\t\t\t\t\t\t\ttags);", 
      "+\t\t\tif (yaffs_TagsMatch(tags, objectId, chunkInInode)) {", 
      "+\t\t\t\t/* found it; */", 
      "+\t\t\t\treturn theChunk;", 
      "+", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t\ttheChunk++;", 
      "+\t}", 
      "+\treturn -1;", 
      "+}", 
      "+", 
      "+", 
      "+/* DeleteWorker scans backwards through the tnode tree and deletes all the", 
      "+ * chunks and tnodes in the file", 
      "+ * Returns 1 if the tree was deleted.", 
      "+ * Returns 0 if it stopped early due to hitting the limit and the delete is incomplete.", 
      "+ */", 
      "+", 
      "+static int yaffs_DeleteWorker(yaffs_Object * in, yaffs_Tnode * tn, __u32 level,", 
      "+\t\t\t      int chunkOffset, int *limit)", 
      "+{", 
      "+\tint i;", 
      "+\tint chunkInInode;", 
      "+\tint theChunk;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tint foundChunk;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tint allDone = 1;", 
      "+", 
      "+\tif (tn) {", 
      "+\t\tif (level > 0) {", 
      "+", 
      "+\t\t\tfor (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;", 
      "+\t\t\t     i--) {", 
      "+\t\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\t\tif (limit && (*limit) < 0) {", 
      "+\t\t\t\t\t\tallDone = 0;", 
      "+\t\t\t\t\t} else {", 
      "+\t\t\t\t\t\tallDone =", 
      "+\t\t\t\t\t\t    yaffs_DeleteWorker(in,", 
      "+\t\t\t\t\t\t\t\t       tn->", 
      "+\t\t\t\t\t\t\t\t       internal", 
      "+\t\t\t\t\t\t\t\t       [i],", 
      "+\t\t\t\t\t\t\t\t       level -", 
      "+\t\t\t\t\t\t\t\t       1,", 
      "+\t\t\t\t\t\t\t\t       (chunkOffset", 
      "+\t\t\t\t\t\t\t\t\t<<", 
      "+\t\t\t\t\t\t\t\t\tYAFFS_TNODES_INTERNAL_BITS)", 
      "+\t\t\t\t\t\t\t\t       + i,", 
      "+\t\t\t\t\t\t\t\t       limit);", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\tif (allDone) {", 
      "+\t\t\t\t\t\tyaffs_FreeTnode(dev,", 
      "+\t\t\t\t\t\t\t\ttn->", 
      "+\t\t\t\t\t\t\t\tinternal[i]);", 
      "+\t\t\t\t\t\ttn->internal[i] = NULL;", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t}", 
      "+\t\t\treturn (allDone) ? 1 : 0;", 
      "+\t\t} else if (level == 0) {", 
      "+\t\t\tint hitLimit = 0;", 
      "+", 
      "+\t\t\tfor (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0 && !hitLimit;", 
      "+\t\t\t     i--) {", 
      "+\t\t\t        theChunk = yaffs_GetChunkGroupBase(dev,tn,i);", 
      "+\t\t\t\tif (theChunk) {", 
      "+", 
      "+\t\t\t\t\tchunkInInode =", 
      "+\t\t\t\t\t    (chunkOffset <<", 
      "+\t\t\t\t\t     YAFFS_TNODES_LEVEL0_BITS) + i;", 
      "+", 
      "+\t\t\t\t\tfoundChunk =", 
      "+\t\t\t\t\t    yaffs_FindChunkInGroup(dev,", 
      "+\t\t\t\t\t\t\t\t   theChunk,", 
      "+\t\t\t\t\t\t\t\t   &tags,", 
      "+\t\t\t\t\t\t\t\t   in->objectId,", 
      "+\t\t\t\t\t\t\t\t   chunkInInode);", 
      "+", 
      "+\t\t\t\t\tif (foundChunk > 0) {", 
      "+\t\t\t\t\t\tyaffs_DeleteChunk(dev,", 
      "+\t\t\t\t\t\t\t\t  foundChunk, 1,", 
      "+\t\t\t\t\t\t\t\t  __LINE__);", 
      "+\t\t\t\t\t\tin->nDataChunks--;", 
      "+\t\t\t\t\t\tif (limit) {", 
      "+\t\t\t\t\t\t\t*limit = *limit - 1;", 
      "+\t\t\t\t\t\t\tif (*limit <= 0) {", 
      "+\t\t\t\t\t\t\t\thitLimit = 1;", 
      "+\t\t\t\t\t\t\t}", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tyaffs_PutLevel0Tnode(dev,tn,i,0);", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t}", 
      "+\t\t\treturn (i < 0) ? 1 : 0;", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn 1;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_SoftDeleteChunk(yaffs_Device * dev, int chunk)", 
      "+{", 
      "+", 
      "+\tyaffs_BlockInfo *theBlock;", 
      "+", 
      "+\tT(YAFFS_TRACE_DELETION, (TSTR(\"soft delete chunk %d\" TENDSTR), chunk));", 
      "+", 
      "+\ttheBlock = yaffs_GetBlockInfo(dev, chunk / dev->nChunksPerBlock);", 
      "+\tif (theBlock) {", 
      "+\t\ttheBlock->softDeletions++;", 
      "+\t\tdev->nFreeChunks++;", 
      "+\t}", 
      "+}", 
      "+", 
      "+/* SoftDeleteWorker scans backwards through the tnode tree and soft deletes all the chunks in the file.", 
      "+ * All soft deleting does is increment the block's softdelete count and pulls the chunk out", 
      "+ * of the tnode.", 
      "+ * Thus, essentially this is the same as DeleteWorker except that the chunks are soft deleted.", 
      "+ */", 
      "+", 
      "+static int yaffs_SoftDeleteWorker(yaffs_Object * in, yaffs_Tnode * tn,", 
      "+\t\t\t\t  __u32 level, int chunkOffset)", 
      "+{", 
      "+\tint i;", 
      "+\tint theChunk;", 
      "+\tint allDone = 1;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tif (tn) {", 
      "+\t\tif (level > 0) {", 
      "+", 
      "+\t\t\tfor (i = YAFFS_NTNODES_INTERNAL - 1; allDone && i >= 0;", 
      "+\t\t\t     i--) {", 
      "+\t\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\t\tallDone =", 
      "+\t\t\t\t\t    yaffs_SoftDeleteWorker(in,", 
      "+\t\t\t\t\t\t\t\t   tn->", 
      "+\t\t\t\t\t\t\t\t   internal[i],", 
      "+\t\t\t\t\t\t\t\t   level - 1,", 
      "+\t\t\t\t\t\t\t\t   (chunkOffset", 
      "+\t\t\t\t\t\t\t\t    <<", 
      "+\t\t\t\t\t\t\t\t    YAFFS_TNODES_INTERNAL_BITS)", 
      "+\t\t\t\t\t\t\t\t   + i);", 
      "+\t\t\t\t\tif (allDone) {", 
      "+\t\t\t\t\t\tyaffs_FreeTnode(dev,", 
      "+\t\t\t\t\t\t\t\ttn->", 
      "+\t\t\t\t\t\t\t\tinternal[i]);", 
      "+\t\t\t\t\t\ttn->internal[i] = NULL;", 
      "+\t\t\t\t\t} else {", 
      "+\t\t\t\t\t\t/* Hoosterman... how could this happen? */", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t\treturn (allDone) ? 1 : 0;", 
      "+\t\t} else if (level == 0) {", 
      "+", 
      "+\t\t\tfor (i = YAFFS_NTNODES_LEVEL0 - 1; i >= 0; i--) {", 
      "+\t\t\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,i);", 
      "+\t\t\t\tif (theChunk) {", 
      "+\t\t\t\t\t/* Note this does not find the real chunk, only the chunk group.", 
      "+\t\t\t\t\t * We make an assumption that a chunk group is not larger than", 
      "+\t\t\t\t\t * a block.", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\tyaffs_SoftDeleteChunk(dev, theChunk);", 
      "+\t\t\t\t\tyaffs_PutLevel0Tnode(dev,tn,i,0);", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t}", 
      "+\t\t\treturn 1;", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn 1;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_SoftDeleteFile(yaffs_Object * obj)", 
      "+{", 
      "+\tif (obj->deleted &&", 
      "+\t    obj->variantType == YAFFS_OBJECT_TYPE_FILE && !obj->softDeleted) {", 
      "+\t\tif (obj->nDataChunks <= 0) {", 
      "+\t\t\t/* Empty file with no duplicate object headers, just delete it immediately */", 
      "+\t\t\tyaffs_FreeTnode(obj->myDev,", 
      "+\t\t\t\t\tobj->variant.fileVariant.top);", 
      "+\t\t\tobj->variant.fileVariant.top = NULL;", 
      "+\t\t\tT(YAFFS_TRACE_TRACING,", 
      "+\t\t\t  (TSTR(\"yaffs: Deleting empty file %d\" TENDSTR),", 
      "+\t\t\t   obj->objectId));", 
      "+\t\t\tyaffs_DoGenericObjectDeletion(obj);", 
      "+\t\t} else {", 
      "+\t\t\tyaffs_SoftDeleteWorker(obj,", 
      "+\t\t\t\t\t       obj->variant.fileVariant.top,", 
      "+\t\t\t\t\t       obj->variant.fileVariant.", 
      "+\t\t\t\t\t       topLevel, 0);", 
      "+\t\t\tobj->softDeleted = 1;", 
      "+\t\t}", 
      "+\t}", 
      "+}", 
      "+", 
      "+/* Pruning removes any part of the file structure tree that is beyond the", 
      "+ * bounds of the file (ie that does not point to chunks).", 
      "+ *", 
      "+ * A file should only get pruned when its size is reduced.", 
      "+ *", 
      "+ * Before pruning, the chunks must be pulled from the tree and the", 
      "+ * level 0 tnode entries must be zeroed out.", 
      "+ * Could also use this for file deletion, but that's probably better handled", 
      "+ * by a special case.", 
      "+ */", 
      "+", 
      "+static yaffs_Tnode *yaffs_PruneWorker(yaffs_Device * dev, yaffs_Tnode * tn,", 
      "+\t\t\t\t      __u32 level, int del0)", 
      "+{", 
      "+\tint i;", 
      "+\tint hasData;", 
      "+", 
      "+\tif (tn) {", 
      "+\t\thasData = 0;", 
      "+", 
      "+\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL; i++) {", 
      "+\t\t\tif (tn->internal[i] && level > 0) {", 
      "+\t\t\t\ttn->internal[i] =", 
      "+\t\t\t\t    yaffs_PruneWorker(dev, tn->internal[i],", 
      "+\t\t\t\t\t\t      level - 1,", 
      "+\t\t\t\t\t\t      (i == 0) ? del0 : 1);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\thasData++;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tif (hasData == 0 && del0) {", 
      "+\t\t\t/* Free and return NULL */", 
      "+", 
      "+\t\t\tyaffs_FreeTnode(dev, tn);", 
      "+\t\t\ttn = NULL;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn tn;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_PruneFileStructure(yaffs_Device * dev,", 
      "+\t\t\t\t    yaffs_FileStructure * fStruct)", 
      "+{", 
      "+\tint i;", 
      "+\tint hasData;", 
      "+\tint done = 0;", 
      "+\tyaffs_Tnode *tn;", 
      "+", 
      "+\tif (fStruct->topLevel > 0) {", 
      "+\t\tfStruct->top =", 
      "+\t\t    yaffs_PruneWorker(dev, fStruct->top, fStruct->topLevel, 0);", 
      "+", 
      "+\t\t/* Now we have a tree with all the non-zero branches NULL but the height", 
      "+\t\t * is the same as it was.", 
      "+\t\t * Let's see if we can trim internal tnodes to shorten the tree.", 
      "+\t\t * We can do this if only the 0th element in the tnode is in use", 
      "+\t\t * (ie all the non-zero are NULL)", 
      "+\t\t */", 
      "+", 
      "+\t\twhile (fStruct->topLevel && !done) {", 
      "+\t\t\ttn = fStruct->top;", 
      "+", 
      "+\t\t\thasData = 0;", 
      "+\t\t\tfor (i = 1; i < YAFFS_NTNODES_INTERNAL; i++) {", 
      "+\t\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\t\thasData++;", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (!hasData) {", 
      "+\t\t\t\tfStruct->top = tn->internal[0];", 
      "+\t\t\t\tfStruct->topLevel--;", 
      "+\t\t\t\tyaffs_FreeTnode(dev, tn);", 
      "+\t\t\t} else {", 
      "+\t\t\t\tdone = 1;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/*-------------------- End of File Structure functions.-------------------*/", 
      "+", 
      "+/* yaffs_CreateFreeObjects creates a bunch more objects and", 
      "+ * adds them to the object free list.", 
      "+ */", 
      "+static int yaffs_CreateFreeObjects(yaffs_Device * dev, int nObjects)", 
      "+{", 
      "+\tint i;", 
      "+\tyaffs_Object *newObjects;", 
      "+\tyaffs_ObjectList *list;", 
      "+", 
      "+\tif (nObjects < 1)", 
      "+\t\treturn YAFFS_OK;", 
      "+", 
      "+\t/* make these things */", 
      "+\tnewObjects = YMALLOC(nObjects * sizeof(yaffs_Object));", 
      "+\tlist = YMALLOC(sizeof(yaffs_ObjectList));", 
      "+", 
      "+\tif (!newObjects || !list) {", 
      "+\t\tif(newObjects)", 
      "+\t\t\tYFREE(newObjects);", 
      "+\t\tif(list)", 
      "+\t\t\tYFREE(list);", 
      "+\t\tT(YAFFS_TRACE_ALLOCATE,", 
      "+\t\t  (TSTR(\"yaffs: Could not allocate more objects\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+        /* Hook them into the free list */", 
      "+        for (i = 0; i < nObjects - 1; i++) {", 
      "+                newObjects[i].siblings.next =", 
      "+                    (struct ylist_head *)(&newObjects[i + 1]);", 
      "+        }", 
      "+", 
      "+        newObjects[nObjects - 1].siblings.next = (void *)dev->freeObjects;", 
      "+\tdev->freeObjects = newObjects;", 
      "+\tdev->nFreeObjects += nObjects;", 
      "+\tdev->nObjectsCreated += nObjects;", 
      "+", 
      "+\t/* Now add this bunch of Objects to a list for freeing up. */", 
      "+", 
      "+\tlist->objects = newObjects;", 
      "+\tlist->next = dev->allocatedObjectList;", 
      "+\tdev->allocatedObjectList = list;", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+", 
      "+/* AllocateEmptyObject gets us a clean Object. Tries to make allocate more if we run out */", 
      "+static yaffs_Object *yaffs_AllocateEmptyObject(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_Object *tn = NULL;", 
      "+", 
      "+\t/* If there are none left make more */", 
      "+\tif (!dev->freeObjects) {", 
      "+\t\tyaffs_CreateFreeObjects(dev, YAFFS_ALLOCATION_NOBJECTS);", 
      "+\t}", 
      "+", 
      "+\tif (dev->freeObjects) {", 
      "+\t\ttn = dev->freeObjects;", 
      "+\t\tdev->freeObjects =", 
      "+\t\t    (yaffs_Object *) (dev->freeObjects->siblings.next);", 
      "+\t\tdev->nFreeObjects--;", 
      "+", 
      "+\t\t/* Now sweeten it up... */", 
      "+", 
      "+\t\tmemset(tn, 0, sizeof(yaffs_Object));", 
      "+\t\ttn->myDev = dev;", 
      "+\t\ttn->hdrChunk = 0;", 
      "+\t\ttn->variantType = YAFFS_OBJECT_TYPE_UNKNOWN;", 
      "+\t\tYINIT_LIST_HEAD(&(tn->hardLinks));", 
      "+\t\tYINIT_LIST_HEAD(&(tn->hashLink));", 
      "+\t\tYINIT_LIST_HEAD(&tn->siblings);", 
      "+", 
      "+                /* Add it to the lost and found directory.", 
      "+                 * NB Can't put root or lostNFound in lostNFound so", 
      "+\t\t * check if lostNFound exists first", 
      "+\t\t */", 
      "+\t\tif (dev->lostNFoundDir) {", 
      "+\t\t\tyaffs_AddObjectToDirectory(dev->lostNFoundDir, tn);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/", 
      "+", 
      "+\treturn tn;", 
      "+}", 
      "+", 
      "+static yaffs_Object *yaffs_CreateFakeDirectory(yaffs_Device * dev, int number,", 
      "+\t\t\t\t\t       __u32 mode)", 
      "+{", 
      "+", 
      "+\tyaffs_Object *obj =", 
      "+\t    yaffs_CreateNewObject(dev, number, YAFFS_OBJECT_TYPE_DIRECTORY);", 
      "+\tif (obj) {", 
      "+\t\tobj->fake = 1;\t\t/* it is fake so it might have no NAND presence... */", 
      "+\t\tobj->renameAllowed = 0;\t/* ... and we're not allowed to rename it... */", 
      "+\t\tobj->unlinkAllowed = 0;\t/* ... or unlink it */", 
      "+\t\tobj->deleted = 0;", 
      "+\t\tobj->unlinked = 0;", 
      "+\t\tobj->yst_mode = mode;", 
      "+\t\tobj->myDev = dev;", 
      "+\t\tobj->hdrChunk = 0;\t/* Not a valid chunk. */", 
      "+\t}", 
      "+", 
      "+\treturn obj;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_UnhashObject(yaffs_Object * tn)", 
      "+{", 
      "+\tint bucket;", 
      "+        yaffs_Device *dev = tn->myDev;", 
      "+", 
      "+        /* If it is still linked into the bucket list, free from the list */", 
      "+        if (!ylist_empty(&tn->hashLink)) {", 
      "+                ylist_del_init(&tn->hashLink);", 
      "+                bucket = yaffs_HashFunction(tn->objectId);", 
      "+                dev->objectBucket[bucket].count--;", 
      "+        }", 
      "+", 
      "+}", 
      "+", 
      "+/*  FreeObject frees up a Object and puts it back on the free list */", 
      "+static void yaffs_FreeObject(yaffs_Object * tn)", 
      "+{", 
      "+", 
      "+\tyaffs_Device *dev = tn->myDev;", 
      "+", 
      "+#ifdef  __KERNEL__", 
      "+\tif (tn->myInode) {", 
      "+\t\t/* We're still hooked up to a cached inode.", 
      "+\t\t * Don't delete now, but mark for later deletion", 
      "+\t\t */", 
      "+\t\ttn->deferedFree = 1;", 
      "+\t\treturn;", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+        yaffs_UnhashObject(tn);", 
      "+", 
      "+        /* Link into the free list. */", 
      "+        tn->siblings.next = (struct ylist_head *)(dev->freeObjects);", 
      "+        dev->freeObjects = tn;", 
      "+        dev->nFreeObjects++;", 
      "+", 
      "+\tdev->nCheckpointBlocksRequired = 0; /* force recalculation*/", 
      "+", 
      "+}", 
      "+", 
      "+#ifdef __KERNEL__", 
      "+", 
      "+void yaffs_HandleDeferedFree(yaffs_Object * obj)", 
      "+{", 
      "+\tif (obj->deferedFree) {", 
      "+\t\tyaffs_FreeObject(obj);", 
      "+\t}", 
      "+}", 
      "+", 
      "+#endif", 
      "+", 
      "+static void yaffs_DeinitialiseObjects(yaffs_Device * dev)", 
      "+{", 
      "+\t/* Free the list of allocated Objects */", 
      "+", 
      "+\tyaffs_ObjectList *tmp;", 
      "+", 
      "+\twhile (dev->allocatedObjectList) {", 
      "+\t\ttmp = dev->allocatedObjectList->next;", 
      "+\t\tYFREE(dev->allocatedObjectList->objects);", 
      "+\t\tYFREE(dev->allocatedObjectList);", 
      "+", 
      "+\t\tdev->allocatedObjectList = tmp;", 
      "+\t}", 
      "+", 
      "+\tdev->freeObjects = NULL;", 
      "+\tdev->nFreeObjects = 0;", 
      "+}", 
      "+", 
      "+static void yaffs_InitialiseObjects(yaffs_Device * dev)", 
      "+{", 
      "+\tint i;", 
      "+", 
      "+\tdev->allocatedObjectList = NULL;", 
      "+\tdev->freeObjects = NULL;", 
      "+        dev->nFreeObjects = 0;", 
      "+", 
      "+        for (i = 0; i < YAFFS_NOBJECT_BUCKETS; i++) {", 
      "+                YINIT_LIST_HEAD(&dev->objectBucket[i].list);", 
      "+                dev->objectBucket[i].count = 0;", 
      "+        }", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_FindNiceObjectBucket(yaffs_Device * dev)", 
      "+{", 
      "+\tstatic int x = 0;", 
      "+\tint i;", 
      "+\tint l = 999;", 
      "+\tint lowest = 999999;", 
      "+", 
      "+\t/* First let's see if we can find one that's empty. */", 
      "+", 
      "+\tfor (i = 0; i < 10 && lowest > 0; i++) {", 
      "+\t\tx++;", 
      "+\t\tx %= YAFFS_NOBJECT_BUCKETS;", 
      "+\t\tif (dev->objectBucket[x].count < lowest) {", 
      "+\t\t\tlowest = dev->objectBucket[x].count;", 
      "+\t\t\tl = x;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\t/* If we didn't find an empty list, then try", 
      "+\t * looking a bit further for a short one", 
      "+\t */", 
      "+", 
      "+\tfor (i = 0; i < 10 && lowest > 3; i++) {", 
      "+\t\tx++;", 
      "+\t\tx %= YAFFS_NOBJECT_BUCKETS;", 
      "+\t\tif (dev->objectBucket[x].count < lowest) {", 
      "+\t\t\tlowest = dev->objectBucket[x].count;", 
      "+\t\t\tl = x;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn l;", 
      "+}", 
      "+", 
      "+static int yaffs_CreateNewObjectNumber(yaffs_Device * dev)", 
      "+{", 
      "+\tint bucket = yaffs_FindNiceObjectBucket(dev);", 
      "+", 
      "+\t/* Now find an object value that has not already been taken", 
      "+\t * by scanning the list.", 
      "+         */", 
      "+", 
      "+        int found = 0;", 
      "+        struct ylist_head *i;", 
      "+", 
      "+        __u32 n = (__u32) bucket;", 
      "+", 
      "+\t/* yaffs_CheckObjectHashSanity();  */", 
      "+", 
      "+\twhile (!found) {", 
      "+                found = 1;", 
      "+                n += YAFFS_NOBJECT_BUCKETS;", 
      "+                if (1 || dev->objectBucket[bucket].count > 0) {", 
      "+                        ylist_for_each(i, &dev->objectBucket[bucket].list) {", 
      "+                                /* If there is already one in the list */", 
      "+                                if (i", 
      "+                                    && ylist_entry(i, yaffs_Object,", 
      "+                                                  hashLink)->objectId == n) {", 
      "+                                        found = 0;", 
      "+                                }", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+", 
      "+\treturn n;", 
      "+}", 
      "+", 
      "+static void yaffs_HashObject(yaffs_Object * in)", 
      "+{", 
      "+        int bucket = yaffs_HashFunction(in->objectId);", 
      "+        yaffs_Device *dev = in->myDev;", 
      "+", 
      "+        ylist_add(&in->hashLink, &dev->objectBucket[bucket].list);", 
      "+        dev->objectBucket[bucket].count++;", 
      "+", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number)", 
      "+{", 
      "+        int bucket = yaffs_HashFunction(number);", 
      "+        struct ylist_head *i;", 
      "+        yaffs_Object *in;", 
      "+", 
      "+        ylist_for_each(i, &dev->objectBucket[bucket].list) {", 
      "+                /* Look if it is in the list */", 
      "+                if (i) {", 
      "+                        in = ylist_entry(i, yaffs_Object, hashLink);", 
      "+                        if (in->objectId == number) {", 
      "+#ifdef __KERNEL__", 
      "+                                /* Don't tell the VFS about this one if it is defered free */", 
      "+\t\t\t\tif (in->deferedFree)", 
      "+\t\t\t\t\treturn NULL;", 
      "+#endif", 
      "+", 
      "+\t\t\t\treturn in;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn NULL;", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_CreateNewObject(yaffs_Device * dev, int number,", 
      "+\t\t\t\t    yaffs_ObjectType type)", 
      "+{", 
      "+", 
      "+\tyaffs_Object *theObject;", 
      "+\tyaffs_Tnode *tn = NULL;", 
      "+", 
      "+\tif (number < 0) {", 
      "+\t\tnumber = yaffs_CreateNewObjectNumber(dev);", 
      "+\t}", 
      "+", 
      "+\ttheObject = yaffs_AllocateEmptyObject(dev);", 
      "+\tif(!theObject)", 
      "+\t\treturn NULL;", 
      "+", 
      "+\tif(type == YAFFS_OBJECT_TYPE_FILE){", 
      "+\t\ttn = yaffs_GetTnode(dev);", 
      "+\t\tif(!tn){", 
      "+\t\t\tyaffs_FreeObject(theObject);", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+", 
      "+", 
      "+\tif (theObject) {", 
      "+\t\ttheObject->fake = 0;", 
      "+\t\ttheObject->renameAllowed = 1;", 
      "+\t\ttheObject->unlinkAllowed = 1;", 
      "+\t\ttheObject->objectId = number;", 
      "+\t\tyaffs_HashObject(theObject);", 
      "+\t\ttheObject->variantType = type;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\tyfsd_WinFileTimeNow(theObject->win_atime);", 
      "+\t\ttheObject->win_ctime[0] = theObject->win_mtime[0] =", 
      "+\t\t    theObject->win_atime[0];", 
      "+\t\ttheObject->win_ctime[1] = theObject->win_mtime[1] =", 
      "+\t\t    theObject->win_atime[1];", 
      "+", 
      "+#else", 
      "+", 
      "+\t\ttheObject->yst_atime = theObject->yst_mtime =", 
      "+\t\t    theObject->yst_ctime = Y_CURRENT_TIME;", 
      "+#endif", 
      "+\t\tswitch (type) {", 
      "+\t\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\t\ttheObject->variant.fileVariant.fileSize = 0;", 
      "+\t\t\ttheObject->variant.fileVariant.scannedFileSize = 0;", 
      "+\t\t\ttheObject->variant.fileVariant.shrinkSize = 0xFFFFFFFF;\t/* max __u32 */", 
      "+\t\t\ttheObject->variant.fileVariant.topLevel = 0;", 
      "+                        theObject->variant.fileVariant.top = tn;", 
      "+                        break;", 
      "+                case YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+                        YINIT_LIST_HEAD(&theObject->variant.directoryVariant.", 
      "+                                       children);", 
      "+                        break;", 
      "+                case YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\t\t/* No action required */", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\t\t/* todo this should not happen */", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn theObject;", 
      "+}", 
      "+", 
      "+static yaffs_Object *yaffs_FindOrCreateObjectByNumber(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t      int number,", 
      "+\t\t\t\t\t\t      yaffs_ObjectType type)", 
      "+{", 
      "+\tyaffs_Object *theObject = NULL;", 
      "+", 
      "+\tif (number > 0) {", 
      "+\t\ttheObject = yaffs_FindObjectByNumber(dev, number);", 
      "+\t}", 
      "+", 
      "+\tif (!theObject) {", 
      "+\t\ttheObject = yaffs_CreateNewObject(dev, number, type);", 
      "+\t}", 
      "+", 
      "+\treturn theObject;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+static YCHAR *yaffs_CloneString(const YCHAR * str)", 
      "+{", 
      "+\tYCHAR *newStr = NULL;", 
      "+", 
      "+\tif (str && *str) {", 
      "+\t\tnewStr = YMALLOC((yaffs_strlen(str) + 1) * sizeof(YCHAR));", 
      "+\t\tif(newStr)", 
      "+\t\t\tyaffs_strcpy(newStr, str);", 
      "+\t}", 
      "+", 
      "+\treturn newStr;", 
      "+", 
      "+}", 
      "+", 
      "+/*", 
      "+ * Mknod (create) a new object.", 
      "+ * equivalentObject only has meaning for a hard link;", 
      "+ * aliasString only has meaning for a sumlink.", 
      "+ * rdev only has meaning for devices (a subset of special objects)", 
      "+ */", 
      "+", 
      "+static yaffs_Object *yaffs_MknodObject(yaffs_ObjectType type,", 
      "+\t\t\t\t       yaffs_Object * parent,", 
      "+\t\t\t\t       const YCHAR * name,", 
      "+\t\t\t\t       __u32 mode,", 
      "+\t\t\t\t       __u32 uid,", 
      "+\t\t\t\t       __u32 gid,", 
      "+\t\t\t\t       yaffs_Object * equivalentObject,", 
      "+\t\t\t\t       const YCHAR * aliasString, __u32 rdev)", 
      "+{", 
      "+\tyaffs_Object *in;", 
      "+\tYCHAR *str = NULL;", 
      "+", 
      "+\tyaffs_Device *dev = parent->myDev;", 
      "+", 
      "+\t/* Check if the entry exists. If it does then fail the call since we don't want a dup.*/", 
      "+\tif (yaffs_FindObjectByName(parent, name)) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tin = yaffs_CreateNewObject(dev, -1, type);", 
      "+", 
      "+\tif(type == YAFFS_OBJECT_TYPE_SYMLINK){", 
      "+\t\tstr = yaffs_CloneString(aliasString);", 
      "+\t\tif(!str){", 
      "+\t\t\tyaffs_FreeObject(in);", 
      "+\t\t\treturn NULL;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+", 
      "+", 
      "+\tif (in) {", 
      "+\t\tin->hdrChunk = 0;", 
      "+\t\tin->valid = 1;", 
      "+\t\tin->variantType = type;", 
      "+", 
      "+\t\tin->yst_mode = mode;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\tyfsd_WinFileTimeNow(in->win_atime);", 
      "+\t\tin->win_ctime[0] = in->win_mtime[0] = in->win_atime[0];", 
      "+\t\tin->win_ctime[1] = in->win_mtime[1] = in->win_atime[1];", 
      "+", 
      "+#else", 
      "+\t\tin->yst_atime = in->yst_mtime = in->yst_ctime = Y_CURRENT_TIME;", 
      "+", 
      "+\t\tin->yst_rdev = rdev;", 
      "+\t\tin->yst_uid = uid;", 
      "+\t\tin->yst_gid = gid;", 
      "+#endif", 
      "+\t\tin->nDataChunks = 0;", 
      "+", 
      "+\t\tyaffs_SetObjectName(in, name);", 
      "+\t\tin->dirty = 1;", 
      "+", 
      "+\t\tyaffs_AddObjectToDirectory(parent, in);", 
      "+", 
      "+\t\tin->myDev = parent->myDev;", 
      "+", 
      "+\t\tswitch (type) {", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\t\tin->variant.symLinkVariant.alias = str;", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\t\tin->variant.hardLinkVariant.equivalentObject =", 
      "+                            equivalentObject;", 
      "+                        in->variant.hardLinkVariant.equivalentObjectId =", 
      "+                            equivalentObject->objectId;", 
      "+                        ylist_add(&in->hardLinks, &equivalentObject->hardLinks);", 
      "+                        break;", 
      "+                case YAFFS_OBJECT_TYPE_FILE:", 
      "+                case YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\t\t/* do nothing */", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t\tif (yaffs_UpdateObjectHeader(in, name, 0, 0, 0) < 0) {", 
      "+\t\t\t/* Could not create the object header, fail the creation */", 
      "+\t\t\tyaffs_DestroyObject(in);", 
      "+\t\t\tin = NULL;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn in;", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t      __u32 mode, __u32 uid, __u32 gid)", 
      "+{", 
      "+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_FILE, parent, name, mode,", 
      "+\t\t\t\t uid, gid, NULL, NULL, 0);", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t   __u32 mode, __u32 uid, __u32 gid)", 
      "+{", 
      "+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_DIRECTORY, parent, name,", 
      "+\t\t\t\t mode, uid, gid, NULL, NULL, 0);", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t __u32 mode, __u32 uid, __u32 gid, __u32 rdev)", 
      "+{", 
      "+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_SPECIAL, parent, name, mode,", 
      "+\t\t\t\t uid, gid, NULL, NULL, rdev);", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t __u32 mode, __u32 uid, __u32 gid,", 
      "+\t\t\t\t const YCHAR * alias)", 
      "+{", 
      "+\treturn yaffs_MknodObject(YAFFS_OBJECT_TYPE_SYMLINK, parent, name, mode,", 
      "+\t\t\t\t uid, gid, NULL, alias, 0);", 
      "+}", 
      "+", 
      "+/* yaffs_Link returns the object id of the equivalent object.*/", 
      "+yaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t yaffs_Object * equivalentObject)", 
      "+{", 
      "+\t/* Get the real object in case we were fed a hard link as an equivalent object */", 
      "+\tequivalentObject = yaffs_GetEquivalentObject(equivalentObject);", 
      "+", 
      "+\tif (yaffs_MknodObject", 
      "+\t    (YAFFS_OBJECT_TYPE_HARDLINK, parent, name, 0, 0, 0,", 
      "+\t     equivalentObject, NULL, 0)) {", 
      "+\t\treturn equivalentObject;", 
      "+\t} else {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_ChangeObjectName(yaffs_Object * obj, yaffs_Object * newDir,", 
      "+\t\t\t\t  const YCHAR * newName, int force, int shadows)", 
      "+{", 
      "+\tint unlinkOp;", 
      "+\tint deleteOp;", 
      "+", 
      "+\tyaffs_Object *existingTarget;", 
      "+", 
      "+\tif (newDir == NULL) {", 
      "+\t\tnewDir = obj->parent;\t/* use the old directory */", 
      "+\t}", 
      "+", 
      "+\tif (newDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragendy: yaffs_ChangeObjectName: newDir is not a directory\"", 
      "+\t\t    TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+", 
      "+\t/* TODO: Do we need this different handling for YAFFS2 and YAFFS1?? */", 
      "+\tif (obj->myDev->isYaffs2) {", 
      "+\t\tunlinkOp = (newDir == obj->myDev->unlinkedDir);", 
      "+\t} else {", 
      "+\t\tunlinkOp = (newDir == obj->myDev->unlinkedDir", 
      "+\t\t\t    && obj->variantType == YAFFS_OBJECT_TYPE_FILE);", 
      "+\t}", 
      "+", 
      "+\tdeleteOp = (newDir == obj->myDev->deletedDir);", 
      "+", 
      "+\texistingTarget = yaffs_FindObjectByName(newDir, newName);", 
      "+", 
      "+\t/* If the object is a file going into the unlinked directory,", 
      "+\t *   then it is OK to just stuff it in since duplicate names are allowed.", 
      "+\t *   else only proceed if the new name does not exist and if we're putting", 
      "+\t *   it into a directory.", 
      "+\t */", 
      "+\tif ((unlinkOp ||", 
      "+\t     deleteOp ||", 
      "+\t     force ||", 
      "+\t     (shadows > 0) ||", 
      "+\t     !existingTarget) &&", 
      "+\t    newDir->variantType == YAFFS_OBJECT_TYPE_DIRECTORY) {", 
      "+\t\tyaffs_SetObjectName(obj, newName);", 
      "+\t\tobj->dirty = 1;", 
      "+", 
      "+\t\tyaffs_AddObjectToDirectory(newDir, obj);", 
      "+", 
      "+\t\tif (unlinkOp)", 
      "+\t\t\tobj->unlinked = 1;", 
      "+", 
      "+\t\t/* If it is a deletion then we mark it as a shrink for gc purposes. */", 
      "+\t\tif (yaffs_UpdateObjectHeader(obj, newName, 0, deleteOp, shadows)>= 0)", 
      "+\t\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,", 
      "+\t\t       yaffs_Object * newDir, const YCHAR * newName)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_Object *existingTarget;", 
      "+\tint force = 0;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_CASE_INSENSITIVE", 
      "+\t/* Special case for case insemsitive systems (eg. WinCE).", 
      "+\t * While look-up is case insensitive, the name isn't.", 
      "+\t * Therefore we might want to change x.txt to X.txt", 
      "+\t*/", 
      "+\tif (oldDir == newDir && yaffs_strcmp(oldName, newName) == 0) {", 
      "+\t\tforce = 1;", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tobj = yaffs_FindObjectByName(oldDir, oldName);", 
      "+\t/* Check new name to long. */", 
      "+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK &&", 
      "+\t    yaffs_strlen(newName) > YAFFS_MAX_ALIAS_LENGTH)", 
      "+\t  /* ENAMETOOLONG */", 
      "+\t  return YAFFS_FAIL;", 
      "+\telse if (obj->variantType != YAFFS_OBJECT_TYPE_SYMLINK &&", 
      "+\t\t yaffs_strlen(newName) > YAFFS_MAX_NAME_LENGTH)", 
      "+\t  /* ENAMETOOLONG */", 
      "+\t  return YAFFS_FAIL;", 
      "+", 
      "+\tif (obj && obj->renameAllowed) {", 
      "+", 
      "+\t\t/* Now do the handling for an existing target, if there is one */", 
      "+", 
      "+                existingTarget = yaffs_FindObjectByName(newDir, newName);", 
      "+                if (existingTarget &&", 
      "+                    existingTarget->variantType == YAFFS_OBJECT_TYPE_DIRECTORY &&", 
      "+                    !ylist_empty(&existingTarget->variant.directoryVariant.children)) {", 
      "+                        /* There is a target that is a non-empty directory, so we fail */", 
      "+                        return YAFFS_FAIL;      /* EEXIST or ENOTEMPTY */", 
      "+                } else if (existingTarget && existingTarget != obj) {", 
      "+\t\t\t/* Nuke the target first, using shadowing,", 
      "+\t\t\t * but only if it isn't the same object", 
      "+\t\t\t */", 
      "+\t\t\tyaffs_ChangeObjectName(obj, newDir, newName, force,", 
      "+\t\t\t\t\t       existingTarget->objectId);", 
      "+\t\t\tyaffs_UnlinkObject(existingTarget);", 
      "+\t\t}", 
      "+", 
      "+\t\treturn yaffs_ChangeObjectName(obj, newDir, newName, 1, 0);", 
      "+\t}", 
      "+\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+/*------------------------- Block Management and Page Allocation ----------------*/", 
      "+", 
      "+static int yaffs_InitialiseBlocks(yaffs_Device * dev)", 
      "+{", 
      "+\tint nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;", 
      "+", 
      "+\tdev->blockInfo = NULL;", 
      "+\tdev->chunkBits = NULL;", 
      "+", 
      "+\tdev->allocationBlock = -1;\t/* force it to get a new one */", 
      "+", 
      "+\t/* If the first allocation strategy fails, thry the alternate one */", 
      "+\tdev->blockInfo = YMALLOC(nBlocks * sizeof(yaffs_BlockInfo));", 
      "+\tif(!dev->blockInfo){", 
      "+\t\tdev->blockInfo = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockInfo));", 
      "+\t\tdev->blockInfoAlt = 1;", 
      "+\t}", 
      "+\telse", 
      "+\t\tdev->blockInfoAlt = 0;", 
      "+", 
      "+\tif(dev->blockInfo){", 
      "+", 
      "+\t\t/* Set up dynamic blockinfo stuff. */", 
      "+\t\tdev->chunkBitmapStride = (dev->nChunksPerBlock + 7) / 8; /* round up bytes */", 
      "+\t\tdev->chunkBits = YMALLOC(dev->chunkBitmapStride * nBlocks);", 
      "+\t\tif(!dev->chunkBits){", 
      "+\t\t\tdev->chunkBits = YMALLOC_ALT(dev->chunkBitmapStride * nBlocks);", 
      "+\t\t\tdev->chunkBitsAlt = 1;", 
      "+\t\t}", 
      "+\t\telse", 
      "+\t\t\tdev->chunkBitsAlt = 0;", 
      "+\t}", 
      "+", 
      "+\tif (dev->blockInfo && dev->chunkBits) {", 
      "+\t\tmemset(dev->blockInfo, 0, nBlocks * sizeof(yaffs_BlockInfo));", 
      "+\t\tmemset(dev->chunkBits, 0, dev->chunkBitmapStride * nBlocks);", 
      "+\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_FAIL;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_DeinitialiseBlocks(yaffs_Device * dev)", 
      "+{", 
      "+\tif(dev->blockInfoAlt && dev->blockInfo)", 
      "+\t\tYFREE_ALT(dev->blockInfo);", 
      "+\telse if(dev->blockInfo)", 
      "+\t\tYFREE(dev->blockInfo);", 
      "+", 
      "+\tdev->blockInfoAlt = 0;", 
      "+", 
      "+\tdev->blockInfo = NULL;", 
      "+", 
      "+\tif(dev->chunkBitsAlt && dev->chunkBits)", 
      "+\t\tYFREE_ALT(dev->chunkBits);", 
      "+\telse if(dev->chunkBits)", 
      "+\t\tYFREE(dev->chunkBits);", 
      "+\tdev->chunkBitsAlt = 0;", 
      "+\tdev->chunkBits = NULL;", 
      "+}", 
      "+", 
      "+static int yaffs_BlockNotDisqualifiedFromGC(yaffs_Device * dev,", 
      "+\t\t\t\t\t    yaffs_BlockInfo * bi)", 
      "+{", 
      "+\tint i;", 
      "+\t__u32 seq;", 
      "+\tyaffs_BlockInfo *b;", 
      "+", 
      "+\tif (!dev->isYaffs2)", 
      "+\t\treturn 1;\t/* disqualification only applies to yaffs2. */", 
      "+", 
      "+\tif (!bi->hasShrinkHeader)", 
      "+\t\treturn 1;\t/* can gc */", 
      "+", 
      "+\t/* Find the oldest dirty sequence number if we don't know it and save it", 
      "+\t * so we don't have to keep recomputing it.", 
      "+\t */", 
      "+\tif (!dev->oldestDirtySequence) {", 
      "+\t\tseq = dev->sequenceNumber;", 
      "+", 
      "+\t\tfor (i = dev->internalStartBlock; i <= dev->internalEndBlock;", 
      "+\t\t     i++) {", 
      "+\t\t\tb = yaffs_GetBlockInfo(dev, i);", 
      "+\t\t\tif (b->blockState == YAFFS_BLOCK_STATE_FULL &&", 
      "+\t\t\t    (b->pagesInUse - b->softDeletions) <", 
      "+\t\t\t    dev->nChunksPerBlock && b->sequenceNumber < seq) {", 
      "+\t\t\t\tseq = b->sequenceNumber;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t\tdev->oldestDirtySequence = seq;", 
      "+\t}", 
      "+", 
      "+\t/* Can't do gc of this block if there are any blocks older than this one that have", 
      "+\t * discarded pages.", 
      "+\t */", 
      "+\treturn (bi->sequenceNumber <= dev->oldestDirtySequence);", 
      "+", 
      "+}", 
      "+", 
      "+/* FindDiretiestBlock is used to select the dirtiest block (or close enough)", 
      "+ * for garbage collection.", 
      "+ */", 
      "+", 
      "+static int yaffs_FindBlockForGarbageCollection(yaffs_Device * dev,", 
      "+\t\t\t\t\t       int aggressive)", 
      "+{", 
      "+", 
      "+\tint b = dev->currentDirtyChecker;", 
      "+", 
      "+\tint i;", 
      "+\tint iterations;", 
      "+\tint dirtiest = -1;", 
      "+\tint pagesInUse = 0;", 
      "+\tint prioritised=0;", 
      "+\tyaffs_BlockInfo *bi;", 
      "+\tint pendingPrioritisedExist = 0;", 
      "+", 
      "+\t/* First let's see if we need to grab a prioritised block */", 
      "+\tif(dev->hasPendingPrioritisedGCs){", 
      "+\t\tfor(i = dev->internalStartBlock; i < dev->internalEndBlock && !prioritised; i++){", 
      "+", 
      "+\t\t\tbi = yaffs_GetBlockInfo(dev, i);", 
      "+\t\t\t//yaffs_VerifyBlock(dev,bi,i);", 
      "+", 
      "+\t\t\tif(bi->gcPrioritise) {", 
      "+\t\t\t\tpendingPrioritisedExist = 1;", 
      "+\t\t\t\tif(bi->blockState == YAFFS_BLOCK_STATE_FULL &&", 
      "+\t\t\t\t   yaffs_BlockNotDisqualifiedFromGC(dev, bi)){", 
      "+\t\t\t\t\tpagesInUse = (bi->pagesInUse - bi->softDeletions);", 
      "+\t\t\t\t\tdirtiest = i;", 
      "+\t\t\t\t\tprioritised = 1;", 
      "+\t\t\t\t\taggressive = 1; /* Fool the non-aggressive skip logiv below */", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tif(!pendingPrioritisedExist) /* None found, so we can clear this */", 
      "+\t\t\tdev->hasPendingPrioritisedGCs = 0;", 
      "+\t}", 
      "+", 
      "+\t/* If we're doing aggressive GC then we are happy to take a less-dirty block, and", 
      "+\t * search harder.", 
      "+\t * else (we're doing a leasurely gc), then we only bother to do this if the", 
      "+\t * block has only a few pages in use.", 
      "+\t */", 
      "+", 
      "+\tdev->nonAggressiveSkip--;", 
      "+", 
      "+\tif (!aggressive && (dev->nonAggressiveSkip > 0)) {", 
      "+\t\treturn -1;", 
      "+\t}", 
      "+", 
      "+\tif(!prioritised)", 
      "+\t\tpagesInUse =", 
      "+\t    \t\t(aggressive) ? dev->nChunksPerBlock : YAFFS_PASSIVE_GC_CHUNKS + 1;", 
      "+", 
      "+\tif (aggressive) {", 
      "+\t\titerations =", 
      "+\t\t    dev->internalEndBlock - dev->internalStartBlock + 1;", 
      "+\t} else {", 
      "+\t\titerations =", 
      "+\t\t    dev->internalEndBlock - dev->internalStartBlock + 1;", 
      "+\t\titerations = iterations / 16;", 
      "+\t\tif (iterations > 200) {", 
      "+\t\t\titerations = 200;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tfor (i = 0; i <= iterations && pagesInUse > 0 && !prioritised; i++) {", 
      "+\t\tb++;", 
      "+\t\tif (b < dev->internalStartBlock || b > dev->internalEndBlock) {", 
      "+\t\t\tb = dev->internalStartBlock;", 
      "+\t\t}", 
      "+", 
      "+\t\tif (b < dev->internalStartBlock || b > dev->internalEndBlock) {", 
      "+\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t  (TSTR(\"**>> Block %d is not valid\" TENDSTR), b));", 
      "+\t\t\tYBUG();", 
      "+\t\t}", 
      "+", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, b);", 
      "+", 
      "+#if 0", 
      "+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT) {", 
      "+\t\t\tdirtiest = b;", 
      "+\t\t\tpagesInUse = 0;", 
      "+\t\t}", 
      "+\t\telse", 
      "+#endif", 
      "+", 
      "+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_FULL &&", 
      "+\t\t       (bi->pagesInUse - bi->softDeletions) < pagesInUse &&", 
      "+\t\t        yaffs_BlockNotDisqualifiedFromGC(dev, bi)) {", 
      "+\t\t\tdirtiest = b;", 
      "+\t\t\tpagesInUse = (bi->pagesInUse - bi->softDeletions);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tdev->currentDirtyChecker = b;", 
      "+", 
      "+\tif (dirtiest > 0) {", 
      "+\t\tT(YAFFS_TRACE_GC,", 
      "+\t\t  (TSTR(\"GC Selected block %d with %d free, prioritised:%d\" TENDSTR), dirtiest,", 
      "+\t\t   dev->nChunksPerBlock - pagesInUse,prioritised));", 
      "+\t}", 
      "+", 
      "+\tdev->oldestDirtySequence = 0;", 
      "+", 
      "+\tif (dirtiest > 0) {", 
      "+\t\tdev->nonAggressiveSkip = 4;", 
      "+\t}", 
      "+", 
      "+\treturn dirtiest;", 
      "+}", 
      "+", 
      "+static void yaffs_BlockBecameDirty(yaffs_Device * dev, int blockNo)", 
      "+{", 
      "+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, blockNo);", 
      "+", 
      "+\tint erasedOk = 0;", 
      "+", 
      "+\t/* If the block is still healthy erase it and mark as clean.", 
      "+\t * If the block has had a data failure, then retire it.", 
      "+\t */", 
      "+", 
      "+\tT(YAFFS_TRACE_GC | YAFFS_TRACE_ERASE,", 
      "+\t\t(TSTR(\"yaffs_BlockBecameDirty block %d state %d %s\"TENDSTR),", 
      "+\t\tblockNo, bi->blockState, (bi->needsRetiring) ? \"needs retiring\" : \"\"));", 
      "+", 
      "+\tbi->blockState = YAFFS_BLOCK_STATE_DIRTY;", 
      "+", 
      "+\tif (!bi->needsRetiring) {", 
      "+\t\tyaffs_InvalidateCheckpoint(dev);", 
      "+\t\terasedOk = yaffs_EraseBlockInNAND(dev, blockNo);", 
      "+\t\tif (!erasedOk) {", 
      "+\t\t\tdev->nErasureFailures++;", 
      "+\t\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t\t  (TSTR(\"**>> Erasure failed %d\" TENDSTR), blockNo));", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tif (erasedOk &&", 
      "+\t    ((yaffs_traceMask & YAFFS_TRACE_ERASE) || !yaffs_SkipVerification(dev))) {", 
      "+\t\tint i;", 
      "+\t\tfor (i = 0; i < dev->nChunksPerBlock; i++) {", 
      "+\t\t\tif (!yaffs_CheckChunkErased", 
      "+\t\t\t    (dev, blockNo * dev->nChunksPerBlock + i)) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\">>Block %d erasure supposedly OK, but chunk %d not erased\"", 
      "+\t\t\t\t    TENDSTR), blockNo, i));", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tif (erasedOk) {", 
      "+\t\t/* Clean it up... */", 
      "+\t\tbi->blockState = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t\tdev->nErasedBlocks++;", 
      "+\t\tbi->pagesInUse = 0;", 
      "+\t\tbi->softDeletions = 0;", 
      "+\t\tbi->hasShrinkHeader = 0;", 
      "+\t\tbi->skipErasedCheck = 1;  /* This is clean, so no need to check */", 
      "+\t\tbi->gcPrioritise = 0;", 
      "+\t\tyaffs_ClearChunkBits(dev, blockNo);", 
      "+", 
      "+\t\tT(YAFFS_TRACE_ERASE,", 
      "+\t\t  (TSTR(\"Erased block %d\" TENDSTR), blockNo));", 
      "+\t} else {", 
      "+\t\tdev->nFreeChunks -= dev->nChunksPerBlock;\t/* We lost a block of free space */", 
      "+", 
      "+\t\tyaffs_RetireBlock(dev, blockNo);", 
      "+\t\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t  (TSTR(\"**>> Block %d retired\" TENDSTR), blockNo));", 
      "+\t}", 
      "+}", 
      "+", 
      "+static int yaffs_FindBlockForAllocation(yaffs_Device * dev)", 
      "+{", 
      "+\tint i;", 
      "+", 
      "+\tyaffs_BlockInfo *bi;", 
      "+", 
      "+\tif (dev->nErasedBlocks < 1) {", 
      "+\t\t/* Hoosterman we've got a problem.", 
      "+\t\t * Can't get space to gc", 
      "+\t\t */", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR(\"yaffs tragedy: no more eraased blocks\" TENDSTR)));", 
      "+", 
      "+\t\treturn -1;", 
      "+\t}", 
      "+", 
      "+\t/* Find an empty block. */", 
      "+", 
      "+\tfor (i = dev->internalStartBlock; i <= dev->internalEndBlock; i++) {", 
      "+\t\tdev->allocationBlockFinder++;", 
      "+\t\tif (dev->allocationBlockFinder < dev->internalStartBlock", 
      "+\t\t    || dev->allocationBlockFinder > dev->internalEndBlock) {", 
      "+\t\t\tdev->allocationBlockFinder = dev->internalStartBlock;", 
      "+\t\t}", 
      "+", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, dev->allocationBlockFinder);", 
      "+", 
      "+\t\tif (bi->blockState == YAFFS_BLOCK_STATE_EMPTY) {", 
      "+\t\t\tbi->blockState = YAFFS_BLOCK_STATE_ALLOCATING;", 
      "+\t\t\tdev->sequenceNumber++;", 
      "+\t\t\tbi->sequenceNumber = dev->sequenceNumber;", 
      "+\t\t\tdev->nErasedBlocks--;", 
      "+\t\t\tT(YAFFS_TRACE_ALLOCATE,", 
      "+\t\t\t  (TSTR(\"Allocated block %d, seq  %d, %d left\" TENDSTR),", 
      "+\t\t\t   dev->allocationBlockFinder, dev->sequenceNumber,", 
      "+\t\t\t   dev->nErasedBlocks));", 
      "+\t\t\treturn dev->allocationBlockFinder;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t  (TSTR", 
      "+\t   (\"yaffs tragedy: no more eraased blocks, but there should have been %d\"", 
      "+\t    TENDSTR), dev->nErasedBlocks));", 
      "+", 
      "+\treturn -1;", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+static int yaffs_CalcCheckpointBlocksRequired(yaffs_Device *dev)", 
      "+{", 
      "+\tif(!dev->nCheckpointBlocksRequired){", 
      "+\t\t/* Not a valid value so recalculate */", 
      "+\t\tint nBytes = 0;", 
      "+\t\tint nBlocks;", 
      "+\t\tint devBlocks = (dev->endBlock - dev->startBlock + 1);", 
      "+\t\tint tnodeSize;", 
      "+", 
      "+\t\ttnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;", 
      "+", 
      "+\t\tif(tnodeSize < sizeof(yaffs_Tnode))", 
      "+\t\t\ttnodeSize = sizeof(yaffs_Tnode);", 
      "+", 
      "+\t\tnBytes += sizeof(yaffs_CheckpointValidity);", 
      "+\t\tnBytes += sizeof(yaffs_CheckpointDevice);", 
      "+\t\tnBytes += devBlocks * sizeof(yaffs_BlockInfo);", 
      "+\t\tnBytes += devBlocks * dev->chunkBitmapStride;", 
      "+\t\tnBytes += (sizeof(yaffs_CheckpointObject) + sizeof(__u32)) * (dev->nObjectsCreated - dev->nFreeObjects);", 
      "+\t\tnBytes += (tnodeSize + sizeof(__u32)) * (dev->nTnodesCreated - dev->nFreeTnodes);", 
      "+\t\tnBytes += sizeof(yaffs_CheckpointValidity);", 
      "+\t\tnBytes += sizeof(__u32); /* checksum*/", 
      "+", 
      "+\t\t/* Round up and add 2 blocks to allow for some bad blocks, so add 3 */", 
      "+", 
      "+\t\tnBlocks = (nBytes/(dev->nDataBytesPerChunk * dev->nChunksPerBlock)) + 3;", 
      "+", 
      "+\t\tdev->nCheckpointBlocksRequired = nBlocks;", 
      "+\t}", 
      "+", 
      "+\treturn dev->nCheckpointBlocksRequired;", 
      "+}", 
      "+", 
      "+// Check if there's space to allocate...", 
      "+// Thinks.... do we need top make this ths same as yaffs_GetFreeChunks()?", 
      "+static int yaffs_CheckSpaceForAllocation(yaffs_Device * dev)", 
      "+{", 
      "+\tint reservedChunks;", 
      "+\tint reservedBlocks = dev->nReservedBlocks;", 
      "+\tint checkpointBlocks;", 
      "+", 
      "+\tcheckpointBlocks =  yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;", 
      "+\tif(checkpointBlocks < 0)", 
      "+\t\tcheckpointBlocks = 0;", 
      "+", 
      "+\treservedChunks = ((reservedBlocks + checkpointBlocks) * dev->nChunksPerBlock);", 
      "+", 
      "+\treturn (dev->nFreeChunks > reservedChunks);", 
      "+}", 
      "+", 
      "+static int yaffs_AllocateChunk(yaffs_Device * dev, int useReserve, yaffs_BlockInfo **blockUsedPtr)", 
      "+{", 
      "+\tint retVal;", 
      "+\tyaffs_BlockInfo *bi;", 
      "+", 
      "+\tif (dev->allocationBlock < 0) {", 
      "+\t\t/* Get next block to allocate off */", 
      "+\t\tdev->allocationBlock = yaffs_FindBlockForAllocation(dev);", 
      "+\t\tdev->allocationPage = 0;", 
      "+\t}", 
      "+", 
      "+\tif (!useReserve && !yaffs_CheckSpaceForAllocation(dev)) {", 
      "+\t\t/* Not enough space to allocate unless we're allowed to use the reserve. */", 
      "+\t\treturn -1;", 
      "+\t}", 
      "+", 
      "+\tif (dev->nErasedBlocks < dev->nReservedBlocks", 
      "+\t    && dev->allocationPage == 0) {", 
      "+\t\tT(YAFFS_TRACE_ALLOCATE, (TSTR(\"Allocating reserve\" TENDSTR)));", 
      "+\t}", 
      "+", 
      "+\t/* Next page please.... */", 
      "+\tif (dev->allocationBlock >= 0) {", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, dev->allocationBlock);", 
      "+", 
      "+\t\tretVal = (dev->allocationBlock * dev->nChunksPerBlock) +", 
      "+\t\t    dev->allocationPage;", 
      "+\t\tbi->pagesInUse++;", 
      "+\t\tyaffs_SetChunkBit(dev, dev->allocationBlock,", 
      "+\t\t\t\t  dev->allocationPage);", 
      "+", 
      "+\t\tdev->allocationPage++;", 
      "+", 
      "+\t\tdev->nFreeChunks--;", 
      "+", 
      "+\t\t/* If the block is full set the state to full */", 
      "+\t\tif (dev->allocationPage >= dev->nChunksPerBlock) {", 
      "+\t\t\tbi->blockState = YAFFS_BLOCK_STATE_FULL;", 
      "+\t\t\tdev->allocationBlock = -1;", 
      "+\t\t}", 
      "+", 
      "+\t\tif(blockUsedPtr)", 
      "+\t\t\t*blockUsedPtr = bi;", 
      "+", 
      "+\t\treturn retVal;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_ERROR,", 
      "+\t  (TSTR(\"!!!!!!!!! Allocator out !!!!!!!!!!!!!!!!!\" TENDSTR)));", 
      "+", 
      "+\treturn -1;", 
      "+}", 
      "+", 
      "+static int yaffs_GetErasedChunks(yaffs_Device * dev)", 
      "+{", 
      "+\tint n;", 
      "+", 
      "+\tn = dev->nErasedBlocks * dev->nChunksPerBlock;", 
      "+", 
      "+\tif (dev->allocationBlock > 0) {", 
      "+\t\tn += (dev->nChunksPerBlock - dev->allocationPage);", 
      "+\t}", 
      "+", 
      "+\treturn n;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_GarbageCollectBlock(yaffs_Device * dev, int block)", 
      "+{", 
      "+\tint oldChunk;", 
      "+\tint newChunk;", 
      "+\tint chunkInBlock;", 
      "+\tint markNAND;", 
      "+\tint retVal = YAFFS_OK;", 
      "+\tint cleanups = 0;", 
      "+\tint i;", 
      "+\tint isCheckpointBlock;", 
      "+\tint matchingChunk;", 
      "+", 
      "+\tint chunksBefore = yaffs_GetErasedChunks(dev);", 
      "+\tint chunksAfter;", 
      "+", 
      "+\tyaffs_ExtendedTags tags;", 
      "+", 
      "+\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, block);", 
      "+", 
      "+\tyaffs_Object *object;", 
      "+", 
      "+\tisCheckpointBlock = (bi->blockState == YAFFS_BLOCK_STATE_CHECKPOINT);", 
      "+", 
      "+\tbi->blockState = YAFFS_BLOCK_STATE_COLLECTING;", 
      "+", 
      "+\tT(YAFFS_TRACE_TRACING,", 
      "+\t  (TSTR(\"Collecting block %d, in use %d, shrink %d, \" TENDSTR), block,", 
      "+\t   bi->pagesInUse, bi->hasShrinkHeader));", 
      "+", 
      "+\t/*yaffs_VerifyFreeChunks(dev); */", 
      "+", 
      "+\tbi->hasShrinkHeader = 0;\t/* clear the flag so that the block can erase */", 
      "+", 
      "+\t/* Take off the number of soft deleted entries because", 
      "+\t * they're going to get really deleted during GC.", 
      "+\t */", 
      "+\tdev->nFreeChunks -= bi->softDeletions;", 
      "+", 
      "+\tdev->isDoingGC = 1;", 
      "+", 
      "+\tif (isCheckpointBlock ||", 
      "+\t    !yaffs_StillSomeChunkBits(dev, block)) {", 
      "+\t\tT(YAFFS_TRACE_TRACING,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"Collecting block %d that has no chunks in use\" TENDSTR),", 
      "+\t\t   block));", 
      "+\t\tyaffs_BlockBecameDirty(dev, block);", 
      "+\t} else {", 
      "+", 
      "+\t\t__u8 *buffer = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t\tyaffs_VerifyBlock(dev,bi,block);", 
      "+", 
      "+\t\tfor (chunkInBlock = 0, oldChunk = block * dev->nChunksPerBlock;", 
      "+\t\t     chunkInBlock < dev->nChunksPerBlock", 
      "+\t\t     && yaffs_StillSomeChunkBits(dev, block);", 
      "+\t\t     chunkInBlock++, oldChunk++) {", 
      "+\t\t\tif (yaffs_CheckChunkBit(dev, block, chunkInBlock)) {", 
      "+", 
      "+\t\t\t\t/* This page is in use and might need to be copied off */", 
      "+", 
      "+\t\t\t\tmarkNAND = 1;", 
      "+", 
      "+\t\t\t\tyaffs_InitialiseTags(&tags);", 
      "+", 
      "+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev, oldChunk,", 
      "+\t\t\t\t\t\t\t\tbuffer, &tags);", 
      "+", 
      "+\t\t\t\tobject =", 
      "+\t\t\t\t    yaffs_FindObjectByNumber(dev,", 
      "+\t\t\t\t\t\t\t     tags.objectId);", 
      "+", 
      "+\t\t\t\tT(YAFFS_TRACE_GC_DETAIL,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"Collecting page %d, %d %d %d \" TENDSTR),", 
      "+\t\t\t\t   chunkInBlock, tags.objectId, tags.chunkId,", 
      "+\t\t\t\t   tags.byteCount));", 
      "+", 
      "+\t\t\t\tif(object && !yaffs_SkipVerification(dev)){", 
      "+\t\t\t\t\tif(tags.chunkId == 0)", 
      "+\t\t\t\t\t\tmatchingChunk = object->hdrChunk;", 
      "+\t\t\t\t\telse if(object->softDeleted)", 
      "+\t\t\t\t\t\tmatchingChunk = oldChunk; /* Defeat the test */", 
      "+\t\t\t\t\telse", 
      "+\t\t\t\t\t\tmatchingChunk = yaffs_FindChunkInFile(object,tags.chunkId,NULL);", 
      "+", 
      "+\t\t\t\t\tif(oldChunk != matchingChunk)", 
      "+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t\t\t  (TSTR(\"gc: page in gc mismatch: %d %d %d %d\"TENDSTR),", 
      "+\t\t\t\t\t\t  oldChunk,matchingChunk,tags.objectId, tags.chunkId));", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (!object) {", 
      "+\t\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t   (\"page %d in gc has no object: %d %d %d \"", 
      "+\t\t\t\t\t    TENDSTR), oldChunk,", 
      "+\t\t\t\t\t    tags.objectId, tags.chunkId, tags.byteCount));", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (object && object->deleted", 
      "+\t\t\t\t    && tags.chunkId != 0) {", 
      "+\t\t\t\t\t/* Data chunk in a deleted file, throw it away", 
      "+\t\t\t\t\t * It's a soft deleted data chunk,", 
      "+\t\t\t\t\t * No need to copy this, just forget about it and", 
      "+\t\t\t\t\t * fix up the object.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tobject->nDataChunks--;", 
      "+", 
      "+\t\t\t\t\tif (object->nDataChunks <= 0) {", 
      "+\t\t\t\t\t\t/* remeber to clean up the object */", 
      "+\t\t\t\t\t\tdev->gcCleanupList[cleanups] =", 
      "+\t\t\t\t\t\t    tags.objectId;", 
      "+\t\t\t\t\t\tcleanups++;", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\tmarkNAND = 0;", 
      "+\t\t\t\t} else if (0", 
      "+\t\t\t\t\t   /* Todo object && object->deleted && object->nDataChunks == 0 */", 
      "+\t\t\t\t\t   ) {", 
      "+\t\t\t\t\t/* Deleted object header with no data chunks.", 
      "+\t\t\t\t\t * Can be discarded and the file deleted.", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\tobject->hdrChunk = 0;", 
      "+\t\t\t\t\tyaffs_FreeTnode(object->myDev,", 
      "+\t\t\t\t\t\t\tobject->variant.", 
      "+\t\t\t\t\t\t\tfileVariant.top);", 
      "+\t\t\t\t\tobject->variant.fileVariant.top = NULL;", 
      "+\t\t\t\t\tyaffs_DoGenericObjectDeletion(object);", 
      "+", 
      "+\t\t\t\t} else if (object) {", 
      "+\t\t\t\t\t/* It's either a data chunk in a live file or", 
      "+\t\t\t\t\t * an ObjectHeader, so we're interested in it.", 
      "+\t\t\t\t\t * NB Need to keep the ObjectHeaders of deleted files", 
      "+\t\t\t\t\t * until the whole file has been deleted off", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\ttags.serialNumber++;", 
      "+", 
      "+\t\t\t\t\tdev->nGCCopies++;", 
      "+", 
      "+\t\t\t\t\tif (tags.chunkId == 0) {", 
      "+\t\t\t\t\t\t/* It is an object Id,", 
      "+\t\t\t\t\t\t * We need to nuke the shrinkheader flags first", 
      "+\t\t\t\t\t\t * We no longer want the shrinkHeader flag since its work is done", 
      "+\t\t\t\t\t\t * and if it is left in place it will mess up scanning.", 
      "+\t\t\t\t\t\t * Also, clear out any shadowing stuff", 
      "+\t\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\t\tyaffs_ObjectHeader *oh;", 
      "+\t\t\t\t\t\toh = (yaffs_ObjectHeader *)buffer;", 
      "+\t\t\t\t\t\toh->isShrink = 0;", 
      "+\t\t\t\t\t\toh->shadowsObject = oh->inbandShadowsObject = -1;", 
      "+\t\t\t\t\t\ttags.extraShadows = 0;", 
      "+\t\t\t\t\t\ttags.extraIsShrinkHeader = 0;", 
      "+", 
      "+\t\t\t\t\t\tyaffs_VerifyObjectHeader(object,oh,&tags,1);", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tnewChunk =", 
      "+\t\t\t\t\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &tags, 1);", 
      "+", 
      "+\t\t\t\t\tif (newChunk < 0) {", 
      "+\t\t\t\t\t\tretVal = YAFFS_FAIL;", 
      "+\t\t\t\t\t} else {", 
      "+", 
      "+\t\t\t\t\t\t/* Ok, now fix up the Tnodes etc. */", 
      "+", 
      "+\t\t\t\t\t\tif (tags.chunkId == 0) {", 
      "+\t\t\t\t\t\t\t/* It's a header */", 
      "+\t\t\t\t\t\t\tobject->hdrChunk =  newChunk;", 
      "+\t\t\t\t\t\t\tobject->serial =   tags.serialNumber;", 
      "+\t\t\t\t\t\t} else {", 
      "+\t\t\t\t\t\t\t/* It's a data chunk */", 
      "+\t\t\t\t\t\t\tyaffs_PutChunkIntoFile", 
      "+\t\t\t\t\t\t\t    (object,", 
      "+\t\t\t\t\t\t\t     tags.chunkId,", 
      "+\t\t\t\t\t\t\t     newChunk, 0);", 
      "+\t\t\t\t\t\t}", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tyaffs_DeleteChunk(dev, oldChunk, markNAND, __LINE__);", 
      "+", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_ReleaseTempBuffer(dev, buffer, __LINE__);", 
      "+", 
      "+", 
      "+\t\t/* Do any required cleanups */", 
      "+\t\tfor (i = 0; i < cleanups; i++) {", 
      "+\t\t\t/* Time to delete the file too */", 
      "+\t\t\tobject =", 
      "+\t\t\t    yaffs_FindObjectByNumber(dev,", 
      "+\t\t\t\t\t\t     dev->gcCleanupList[i]);", 
      "+\t\t\tif (object) {", 
      "+\t\t\t\tyaffs_FreeTnode(dev,", 
      "+\t\t\t\t\t\tobject->variant.fileVariant.", 
      "+\t\t\t\t\t\ttop);", 
      "+\t\t\t\tobject->variant.fileVariant.top = NULL;", 
      "+\t\t\t\tT(YAFFS_TRACE_GC,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"yaffs: About to finally delete object %d\"", 
      "+\t\t\t\t    TENDSTR), object->objectId));", 
      "+\t\t\t\tyaffs_DoGenericObjectDeletion(object);", 
      "+\t\t\t\tobject->myDev->nDeletedFiles--;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\tyaffs_VerifyCollectedBlock(dev,bi,block);", 
      "+", 
      "+\tif (chunksBefore >= (chunksAfter = yaffs_GetErasedChunks(dev))) {", 
      "+\t\tT(YAFFS_TRACE_GC,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"gc did not increase free chunks before %d after %d\"", 
      "+\t\t    TENDSTR), chunksBefore, chunksAfter));", 
      "+\t}", 
      "+", 
      "+\tdev->isDoingGC = 0;", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* New garbage collector", 
      "+ * If we're very low on erased blocks then we do aggressive garbage collection", 
      "+ * otherwise we do \"leasurely\" garbage collection.", 
      "+ * Aggressive gc looks further (whole array) and will accept less dirty blocks.", 
      "+ * Passive gc only inspects smaller areas and will only accept more dirty blocks.", 
      "+ *", 
      "+ * The idea is to help clear out space in a more spread-out manner.", 
      "+ * Dunno if it really does anything useful.", 
      "+ */", 
      "+static int yaffs_CheckGarbageCollection(yaffs_Device * dev)", 
      "+{", 
      "+\tint block;", 
      "+\tint aggressive;", 
      "+\tint gcOk = YAFFS_OK;", 
      "+\tint maxTries = 0;", 
      "+", 
      "+\tint checkpointBlockAdjust;", 
      "+", 
      "+\tif (dev->isDoingGC) {", 
      "+\t\t/* Bail out so we don't get recursive gc */", 
      "+\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\t/* This loop should pass the first time.", 
      "+\t * We'll only see looping here if the erase of the collected block fails.", 
      "+\t */", 
      "+", 
      "+\tdo {", 
      "+\t\tmaxTries++;", 
      "+", 
      "+\t\tcheckpointBlockAdjust = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;", 
      "+\t\tif(checkpointBlockAdjust < 0)", 
      "+\t\t\tcheckpointBlockAdjust = 0;", 
      "+", 
      "+\t\tif (dev->nErasedBlocks < (dev->nReservedBlocks + checkpointBlockAdjust + 2)) {", 
      "+\t\t\t/* We need a block soon...*/", 
      "+\t\t\taggressive = 1;", 
      "+\t\t} else {", 
      "+\t\t\t/* We're in no hurry */", 
      "+\t\t\taggressive = 0;", 
      "+\t\t}", 
      "+", 
      "+\t\tblock = yaffs_FindBlockForGarbageCollection(dev, aggressive);", 
      "+", 
      "+\t\tif (block > 0) {", 
      "+\t\t\tdev->garbageCollections++;", 
      "+\t\t\tif (!aggressive) {", 
      "+\t\t\t\tdev->passiveGarbageCollections++;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tT(YAFFS_TRACE_GC,", 
      "+\t\t\t  (TSTR", 
      "+\t\t\t   (\"yaffs: GC erasedBlocks %d aggressive %d\" TENDSTR),", 
      "+\t\t\t   dev->nErasedBlocks, aggressive));", 
      "+", 
      "+\t\t\tgcOk = yaffs_GarbageCollectBlock(dev, block);", 
      "+\t\t}", 
      "+", 
      "+\t\tif (dev->nErasedBlocks < (dev->nReservedBlocks) && block > 0) {", 
      "+\t\t\tT(YAFFS_TRACE_GC,", 
      "+\t\t\t  (TSTR", 
      "+\t\t\t   (\"yaffs: GC !!!no reclaim!!! erasedBlocks %d after try %d block %d\"", 
      "+\t\t\t    TENDSTR), dev->nErasedBlocks, maxTries, block));", 
      "+\t\t}", 
      "+\t} while ((dev->nErasedBlocks < dev->nReservedBlocks) && (block > 0)", 
      "+\t\t && (maxTries < 2));", 
      "+", 
      "+\treturn aggressive ? gcOk : YAFFS_OK;", 
      "+}", 
      "+", 
      "+/*-------------------------  TAGS --------------------------------*/", 
      "+", 
      "+static int yaffs_TagsMatch(const yaffs_ExtendedTags * tags, int objectId,", 
      "+\t\t\t   int chunkInObject)", 
      "+{", 
      "+\treturn (tags->chunkId == chunkInObject &&", 
      "+\t\ttags->objectId == objectId && !tags->chunkDeleted) ? 1 : 0;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+/*-------------------- Data file manipulation -----------------*/", 
      "+", 
      "+static int yaffs_FindChunkInFile(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\t/*Get the Tnode, then get the level 0 offset chunk offset */", 
      "+\tyaffs_Tnode *tn;", 
      "+\tint theChunk = -1;", 
      "+\tyaffs_ExtendedTags localTags;", 
      "+\tint retVal = -1;", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tif (!tags) {", 
      "+\t\t/* Passed a NULL, so use our own tags space */", 
      "+\t\ttags = &localTags;", 
      "+\t}", 
      "+", 
      "+\ttn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);", 
      "+", 
      "+\tif (tn) {", 
      "+\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);", 
      "+", 
      "+\t\tretVal =", 
      "+\t\t    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,", 
      "+\t\t\t\t\t   chunkInInode);", 
      "+\t}", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+static int yaffs_FindAndDeleteChunkInFile(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t\t  yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\t/* Get the Tnode, then get the level 0 offset chunk offset */", 
      "+\tyaffs_Tnode *tn;", 
      "+\tint theChunk = -1;", 
      "+\tyaffs_ExtendedTags localTags;", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+\tint retVal = -1;", 
      "+", 
      "+\tif (!tags) {", 
      "+\t\t/* Passed a NULL, so use our own tags space */", 
      "+\t\ttags = &localTags;", 
      "+\t}", 
      "+", 
      "+\ttn = yaffs_FindLevel0Tnode(dev, &in->variant.fileVariant, chunkInInode);", 
      "+", 
      "+\tif (tn) {", 
      "+", 
      "+\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);", 
      "+", 
      "+\t\tretVal =", 
      "+\t\t    yaffs_FindChunkInGroup(dev, theChunk, tags, in->objectId,", 
      "+\t\t\t\t\t   chunkInInode);", 
      "+", 
      "+\t\t/* Delete the entry in the filestructure (if found) */", 
      "+\t\tif (retVal != -1) {", 
      "+\t\t\tyaffs_PutLevel0Tnode(dev,tn,chunkInInode,0);", 
      "+\t\t}", 
      "+\t} else {", 
      "+\t\t/*T((\"No level 0 found for %d\\n\", chunkInInode)); */", 
      "+\t}", 
      "+", 
      "+\tif (retVal == -1) {", 
      "+\t\t/* T((\"Could not find %d to delete\\n\",chunkInInode)); */", 
      "+\t}", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+#ifdef YAFFS_PARANOID", 
      "+", 
      "+static int yaffs_CheckFileSanity(yaffs_Object * in)", 
      "+{", 
      "+\tint chunk;", 
      "+\tint nChunks;", 
      "+\tint fSize;", 
      "+\tint failed = 0;", 
      "+\tint objId;", 
      "+\tyaffs_Tnode *tn;", 
      "+\tyaffs_Tags localTags;", 
      "+\tyaffs_Tags *tags = &localTags;", 
      "+\tint theChunk;", 
      "+\tint chunkDeleted;", 
      "+", 
      "+\tif (in->variantType != YAFFS_OBJECT_TYPE_FILE) {", 
      "+\t\t/* T((\"Object not a file\\n\")); */", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tobjId = in->objectId;", 
      "+\tfSize = in->variant.fileVariant.fileSize;", 
      "+\tnChunks =", 
      "+\t    (fSize + in->myDev->nDataBytesPerChunk - 1) / in->myDev->nDataBytesPerChunk;", 
      "+", 
      "+\tfor (chunk = 1; chunk <= nChunks; chunk++) {", 
      "+\t\ttn = yaffs_FindLevel0Tnode(in->myDev, &in->variant.fileVariant,", 
      "+\t\t\t\t\t   chunk);", 
      "+", 
      "+\t\tif (tn) {", 
      "+", 
      "+\t\t\ttheChunk = yaffs_GetChunkGroupBase(dev,tn,chunk);", 
      "+", 
      "+\t\t\tif (yaffs_CheckChunkBits", 
      "+\t\t\t    (dev, theChunk / dev->nChunksPerBlock,", 
      "+\t\t\t     theChunk % dev->nChunksPerBlock)) {", 
      "+", 
      "+\t\t\t\tyaffs_ReadChunkTagsFromNAND(in->myDev, theChunk,", 
      "+\t\t\t\t\t\t\t    tags,", 
      "+\t\t\t\t\t\t\t    &chunkDeleted);", 
      "+\t\t\t\tif (yaffs_TagsMatch", 
      "+\t\t\t\t    (tags, in->objectId, chunk, chunkDeleted)) {", 
      "+\t\t\t\t\t/* found it; */", 
      "+", 
      "+\t\t\t\t}", 
      "+\t\t\t} else {", 
      "+", 
      "+\t\t\t\tfailed = 1;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t} else {", 
      "+\t\t\t/* T((\"No level 0 found for %d\\n\", chunk)); */", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn failed ? YAFFS_FAIL : YAFFS_OK;", 
      "+}", 
      "+", 
      "+#endif", 
      "+", 
      "+static int yaffs_PutChunkIntoFile(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t  int chunkInNAND, int inScan)", 
      "+{", 
      "+\t/* NB inScan is zero unless scanning.", 
      "+\t * For forward scanning, inScan is > 0;", 
      "+\t * for backward scanning inScan is < 0", 
      "+\t */", 
      "+", 
      "+\tyaffs_Tnode *tn;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+\tint existingChunk;", 
      "+\tyaffs_ExtendedTags existingTags;", 
      "+\tyaffs_ExtendedTags newTags;", 
      "+\tunsigned existingSerial, newSerial;", 
      "+", 
      "+\tif (in->variantType != YAFFS_OBJECT_TYPE_FILE) {", 
      "+\t\t/* Just ignore an attempt at putting a chunk into a non-file during scanning", 
      "+\t\t * If it is not during Scanning then something went wrong!", 
      "+\t\t */", 
      "+\t\tif (!inScan) {", 
      "+\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t  (TSTR", 
      "+\t\t\t   (\"yaffs tragedy:attempt to put data chunk into a non-file\"", 
      "+\t\t\t    TENDSTR)));", 
      "+\t\t\tYBUG();", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);", 
      "+\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\ttn = yaffs_AddOrFindLevel0Tnode(dev,", 
      "+\t\t\t\t\t&in->variant.fileVariant,", 
      "+\t\t\t\t\tchunkInInode,", 
      "+\t\t\t\t\tNULL);", 
      "+\tif (!tn) {", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\texistingChunk = yaffs_GetChunkGroupBase(dev,tn,chunkInInode);", 
      "+", 
      "+\tif (inScan != 0) {", 
      "+\t\t/* If we're scanning then we need to test for duplicates", 
      "+\t\t * NB This does not need to be efficient since it should only ever", 
      "+\t\t * happen when the power fails during a write, then only one", 
      "+\t\t * chunk should ever be affected.", 
      "+\t\t *", 
      "+\t\t * Correction for YAFFS2: This could happen quite a lot and we need to think about efficiency! TODO", 
      "+\t\t * Update: For backward scanning we don't need to re-read tags so this is quite cheap.", 
      "+\t\t */", 
      "+", 
      "+\t\tif (existingChunk > 0) {", 
      "+\t\t\t/* NB Right now existing chunk will not be real chunkId if the device >= 32MB", 
      "+\t\t\t *    thus we have to do a FindChunkInFile to get the real chunk id.", 
      "+\t\t\t *", 
      "+\t\t\t * We have a duplicate now we need to decide which one to use:", 
      "+\t\t\t *", 
      "+\t\t\t * Backwards scanning YAFFS2: The old one is what we use, dump the new one.", 
      "+\t\t\t * Forward scanning YAFFS2: The new one is what we use, dump the old one.", 
      "+\t\t\t * YAFFS1: Get both sets of tags and compare serial numbers.", 
      "+\t\t\t */", 
      "+", 
      "+\t\t\tif (inScan > 0) {", 
      "+\t\t\t\t/* Only do this for forward scanning */", 
      "+\t\t\t\tyaffs_ReadChunkWithTagsFromNAND(dev,", 
      "+\t\t\t\t\t\t\t\tchunkInNAND,", 
      "+\t\t\t\t\t\t\t\tNULL, &newTags);", 
      "+", 
      "+\t\t\t\t/* Do a proper find */", 
      "+\t\t\t\texistingChunk =", 
      "+\t\t\t\t    yaffs_FindChunkInFile(in, chunkInInode,", 
      "+\t\t\t\t\t\t\t  &existingTags);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (existingChunk <= 0) {", 
      "+\t\t\t\t/*Hoosterman - how did this happen? */", 
      "+", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"yaffs tragedy: existing chunk < 0 in scan\"", 
      "+\t\t\t\t    TENDSTR)));", 
      "+", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\t/* NB The deleted flags should be false, otherwise the chunks will", 
      "+\t\t\t * not be loaded during a scan", 
      "+\t\t\t */", 
      "+", 
      "+\t\t\tnewSerial = newTags.serialNumber;", 
      "+\t\t\texistingSerial = existingTags.serialNumber;", 
      "+", 
      "+\t\t\tif ((inScan > 0) &&", 
      "+\t\t\t    (in->myDev->isYaffs2 ||", 
      "+\t\t\t     existingChunk <= 0 ||", 
      "+\t\t\t     ((existingSerial + 1) & 3) == newSerial)) {", 
      "+\t\t\t\t/* Forward scanning.", 
      "+\t\t\t\t * Use new", 
      "+\t\t\t\t * Delete the old one and drop through to update the tnode", 
      "+\t\t\t\t */", 
      "+\t\t\t\tyaffs_DeleteChunk(dev, existingChunk, 1,", 
      "+\t\t\t\t\t\t  __LINE__);", 
      "+\t\t\t} else {", 
      "+\t\t\t\t/* Backward scanning or we want to use the existing one", 
      "+\t\t\t\t * Use existing.", 
      "+\t\t\t\t * Delete the new one and return early so that the tnode isn't changed", 
      "+\t\t\t\t */", 
      "+\t\t\t\tyaffs_DeleteChunk(dev, chunkInNAND, 1,", 
      "+\t\t\t\t\t\t  __LINE__);", 
      "+\t\t\t\treturn YAFFS_OK;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\tif (existingChunk == 0) {", 
      "+\t\tin->nDataChunks++;", 
      "+\t}", 
      "+", 
      "+\tyaffs_PutLevel0Tnode(dev,tn,chunkInInode,chunkInNAND);", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadChunkDataFromObject(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t\t __u8 * buffer)", 
      "+{", 
      "+\tint chunkInNAND = yaffs_FindChunkInFile(in, chunkInInode, NULL);", 
      "+", 
      "+\tif (chunkInNAND >= 0) {", 
      "+\t\treturn yaffs_ReadChunkWithTagsFromNAND(in->myDev, chunkInNAND,", 
      "+\t\t\t\t\t\t       buffer,NULL);", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_NANDACCESS,", 
      "+\t\t  (TSTR(\"Chunk %d not found zero instead\" TENDSTR),", 
      "+\t\t   chunkInNAND));", 
      "+\t\t/* get sane (zero) data if you read a hole */", 
      "+\t\tmemset(buffer, 0, in->myDev->nDataBytesPerChunk);", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+void yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn)", 
      "+{", 
      "+\tint block;", 
      "+\tint page;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tyaffs_BlockInfo *bi;", 
      "+", 
      "+\tif (chunkId <= 0)", 
      "+\t\treturn;", 
      "+", 
      "+", 
      "+\tdev->nDeletions++;", 
      "+\tblock = chunkId / dev->nChunksPerBlock;", 
      "+\tpage = chunkId % dev->nChunksPerBlock;", 
      "+", 
      "+", 
      "+\tif(!yaffs_CheckChunkBit(dev,block,page))", 
      "+\t\tT(YAFFS_TRACE_VERIFY,", 
      "+\t\t \t(TSTR(\"Deleting invalid chunk %d\"TENDSTR),", 
      "+\t\t \t chunkId));", 
      "+", 
      "+\tbi = yaffs_GetBlockInfo(dev, block);", 
      "+", 
      "+\tT(YAFFS_TRACE_DELETION,", 
      "+\t  (TSTR(\"line %d delete of chunk %d\" TENDSTR), lyn, chunkId));", 
      "+", 
      "+\tif (markNAND &&", 
      "+\t    bi->blockState != YAFFS_BLOCK_STATE_COLLECTING && !dev->isYaffs2) {", 
      "+", 
      "+\t\tyaffs_InitialiseTags(&tags);", 
      "+", 
      "+\t\ttags.chunkDeleted = 1;", 
      "+", 
      "+\t\tyaffs_WriteChunkWithTagsToNAND(dev, chunkId, NULL, &tags);", 
      "+\t\tyaffs_HandleUpdateChunk(dev, chunkId, &tags);", 
      "+\t} else {", 
      "+\t\tdev->nUnmarkedDeletions++;", 
      "+\t}", 
      "+", 
      "+\t/* Pull out of the management area.", 
      "+\t * If the whole block became dirty, this will kick off an erasure.", 
      "+\t */", 
      "+\tif (bi->blockState == YAFFS_BLOCK_STATE_ALLOCATING ||", 
      "+\t    bi->blockState == YAFFS_BLOCK_STATE_FULL ||", 
      "+\t    bi->blockState == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||", 
      "+\t    bi->blockState == YAFFS_BLOCK_STATE_COLLECTING) {", 
      "+\t\tdev->nFreeChunks++;", 
      "+", 
      "+\t\tyaffs_ClearChunkBit(dev, block, page);", 
      "+", 
      "+\t\tbi->pagesInUse--;", 
      "+", 
      "+\t\tif (bi->pagesInUse == 0 &&", 
      "+\t\t    !bi->hasShrinkHeader &&", 
      "+\t\t    bi->blockState != YAFFS_BLOCK_STATE_ALLOCATING &&", 
      "+\t\t    bi->blockState != YAFFS_BLOCK_STATE_NEEDS_SCANNING) {", 
      "+\t\t\tyaffs_BlockBecameDirty(dev, block);", 
      "+\t\t}", 
      "+", 
      "+\t} else {", 
      "+\t\t/* T((\"Bad news deleting chunk %d\\n\",chunkId)); */", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_WriteChunkDataToObject(yaffs_Object * in, int chunkInInode,", 
      "+\t\t\t\t\tconst __u8 * buffer, int nBytes,", 
      "+\t\t\t\t\tint useReserve)", 
      "+{", 
      "+\t/* Find old chunk Need to do this to get serial number", 
      "+\t * Write new one and patch into tree.", 
      "+\t * Invalidate old tags.", 
      "+\t */", 
      "+", 
      "+\tint prevChunkId;", 
      "+\tyaffs_ExtendedTags prevTags;", 
      "+", 
      "+\tint newChunkId;", 
      "+\tyaffs_ExtendedTags newTags;", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tyaffs_CheckGarbageCollection(dev);", 
      "+", 
      "+\t/* Get the previous chunk at this location in the file if it exists */", 
      "+\tprevChunkId = yaffs_FindChunkInFile(in, chunkInInode, &prevTags);", 
      "+", 
      "+\t/* Set up new tags */", 
      "+\tyaffs_InitialiseTags(&newTags);", 
      "+", 
      "+\tnewTags.chunkId = chunkInInode;", 
      "+\tnewTags.objectId = in->objectId;", 
      "+\tnewTags.serialNumber =", 
      "+\t    (prevChunkId >= 0) ? prevTags.serialNumber + 1 : 1;", 
      "+\tnewTags.byteCount = nBytes;", 
      "+", 
      "+\tnewChunkId =", 
      "+\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,", 
      "+\t\t\t\t\t      useReserve);", 
      "+", 
      "+\tif (newChunkId >= 0) {", 
      "+\t\tyaffs_PutChunkIntoFile(in, chunkInInode, newChunkId, 0);", 
      "+", 
      "+\t\tif (prevChunkId >= 0) {", 
      "+\t\t\tyaffs_DeleteChunk(dev, prevChunkId, 1, __LINE__);", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_CheckFileSanity(in);", 
      "+\t}", 
      "+\treturn newChunkId;", 
      "+", 
      "+}", 
      "+", 
      "+/* UpdateObjectHeader updates the header on NAND for an object.", 
      "+ * If name is not NULL, then that new name is used.", 
      "+ */", 
      "+int yaffs_UpdateObjectHeader(yaffs_Object * in, const YCHAR * name, int force,", 
      "+\t\t\t     int isShrink, int shadows)", 
      "+{", 
      "+", 
      "+\tyaffs_BlockInfo *bi;", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tint prevChunkId;", 
      "+\tint retVal = 0;", 
      "+\tint result = 0;", 
      "+", 
      "+\tint newChunkId;", 
      "+\tyaffs_ExtendedTags newTags;", 
      "+\tyaffs_ExtendedTags oldTags;", 
      "+", 
      "+\t__u8 *buffer = NULL;", 
      "+\tYCHAR oldName[YAFFS_MAX_NAME_LENGTH + 1];", 
      "+", 
      "+        yaffs_ObjectHeader *oh = NULL;", 
      "+", 
      "+        yaffs_strcpy(oldName,_Y(\"silly old name\"));", 
      "+", 
      "+", 
      "+\tif (!in->fake ||", 
      "+\t    in == dev->rootDir || /* The rootDir should also be saved */", 
      "+\t    force) {", 
      "+", 
      "+\t\tyaffs_CheckGarbageCollection(dev);", 
      "+\t\tyaffs_CheckObjectDetailsLoaded(in);", 
      "+", 
      "+\t\tbuffer = yaffs_GetTempBuffer(in->myDev, __LINE__);", 
      "+\t\toh = (yaffs_ObjectHeader *) buffer;", 
      "+", 
      "+\t\tprevChunkId = in->hdrChunk;", 
      "+", 
      "+\t\tif (prevChunkId > 0) {", 
      "+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, prevChunkId,", 
      "+\t\t\t\t\t\t\tbuffer, &oldTags);", 
      "+", 
      "+\t\t\tyaffs_VerifyObjectHeader(in,oh,&oldTags,0);", 
      "+", 
      "+\t\t\tmemcpy(oldName, oh->name, sizeof(oh->name));", 
      "+\t\t}", 
      "+", 
      "+\t\tmemset(buffer, 0xFF, dev->nDataBytesPerChunk);", 
      "+", 
      "+\t\toh->type = in->variantType;", 
      "+\t\toh->yst_mode = in->yst_mode;", 
      "+\t\toh->shadowsObject = oh->inbandShadowsObject = shadows;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\toh->win_atime[0] = in->win_atime[0];", 
      "+\t\toh->win_ctime[0] = in->win_ctime[0];", 
      "+\t\toh->win_mtime[0] = in->win_mtime[0];", 
      "+\t\toh->win_atime[1] = in->win_atime[1];", 
      "+\t\toh->win_ctime[1] = in->win_ctime[1];", 
      "+\t\toh->win_mtime[1] = in->win_mtime[1];", 
      "+#else", 
      "+\t\toh->yst_uid = in->yst_uid;", 
      "+\t\toh->yst_gid = in->yst_gid;", 
      "+\t\toh->yst_atime = in->yst_atime;", 
      "+\t\toh->yst_mtime = in->yst_mtime;", 
      "+\t\toh->yst_ctime = in->yst_ctime;", 
      "+\t\toh->yst_rdev = in->yst_rdev;", 
      "+#endif", 
      "+\t\tif (in->parent) {", 
      "+\t\t\toh->parentObjectId = in->parent->objectId;", 
      "+\t\t} else {", 
      "+\t\t\toh->parentObjectId = 0;", 
      "+\t\t}", 
      "+", 
      "+\t\tif (name && *name) {", 
      "+\t\t\tmemset(oh->name, 0, sizeof(oh->name));", 
      "+\t\t\tyaffs_strncpy(oh->name, name, YAFFS_MAX_NAME_LENGTH);", 
      "+\t\t} else if (prevChunkId>=0) {", 
      "+\t\t\tmemcpy(oh->name, oldName, sizeof(oh->name));", 
      "+\t\t} else {", 
      "+\t\t\tmemset(oh->name, 0, sizeof(oh->name));", 
      "+\t\t}", 
      "+", 
      "+\t\toh->isShrink = isShrink;", 
      "+", 
      "+\t\tswitch (in->variantType) {", 
      "+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\t\t/* Should not happen */", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\t\toh->fileSize =", 
      "+\t\t\t    (oh->parentObjectId == YAFFS_OBJECTID_DELETED", 
      "+\t\t\t     || oh->parentObjectId ==", 
      "+\t\t\t     YAFFS_OBJECTID_UNLINKED) ? 0 : in->variant.", 
      "+\t\t\t    fileVariant.fileSize;", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\t\toh->equivalentObjectId =", 
      "+\t\t\t    in->variant.hardLinkVariant.equivalentObjectId;", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\t\t/* Do nothing */", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\t\t/* Do nothing */", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\t\tyaffs_strncpy(oh->alias,", 
      "+\t\t\t\t      in->variant.symLinkVariant.alias,", 
      "+\t\t\t\t      YAFFS_MAX_ALIAS_LENGTH);", 
      "+\t\t\toh->alias[YAFFS_MAX_ALIAS_LENGTH] = 0;", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t\t/* Tags */", 
      "+\t\tyaffs_InitialiseTags(&newTags);", 
      "+\t\tin->serial++;", 
      "+\t\tnewTags.chunkId = 0;", 
      "+\t\tnewTags.objectId = in->objectId;", 
      "+\t\tnewTags.serialNumber = in->serial;", 
      "+", 
      "+\t\t/* Add extra info for file header */", 
      "+", 
      "+\t\tnewTags.extraHeaderInfoAvailable = 1;", 
      "+\t\tnewTags.extraParentObjectId = oh->parentObjectId;", 
      "+\t\tnewTags.extraFileLength = oh->fileSize;", 
      "+\t\tnewTags.extraIsShrinkHeader = oh->isShrink;", 
      "+\t\tnewTags.extraEquivalentObjectId = oh->equivalentObjectId;", 
      "+\t\tnewTags.extraShadows = (oh->shadowsObject > 0) ? 1 : 0;", 
      "+\t\tnewTags.extraObjectType = in->variantType;", 
      "+", 
      "+\t\tyaffs_VerifyObjectHeader(in,oh,&newTags,1);", 
      "+", 
      "+\t\t/* Create new chunk in NAND */", 
      "+\t\tnewChunkId =", 
      "+\t\t    yaffs_WriteNewChunkWithTagsToNAND(dev, buffer, &newTags,", 
      "+\t\t\t\t\t\t      (prevChunkId >= 0) ? 1 : 0);", 
      "+", 
      "+\t\tif (newChunkId >= 0) {", 
      "+", 
      "+\t\t\tin->hdrChunk = newChunkId;", 
      "+", 
      "+\t\t\tif (prevChunkId >= 0) {", 
      "+\t\t\t\tyaffs_DeleteChunk(dev, prevChunkId, 1,", 
      "+\t\t\t\t\t\t  __LINE__);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif(!yaffs_ObjectHasCachedWriteData(in))", 
      "+\t\t\t\tin->dirty = 0;", 
      "+", 
      "+\t\t\t/* If this was a shrink, then mark the block that the chunk lives on */", 
      "+\t\t\tif (isShrink) {", 
      "+\t\t\t\tbi = yaffs_GetBlockInfo(in->myDev,", 
      "+\t\t\t\t\t\t\tnewChunkId /in->myDev->\tnChunksPerBlock);", 
      "+\t\t\t\tbi->hasShrinkHeader = 1;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t\tretVal = newChunkId;", 
      "+", 
      "+\t}", 
      "+", 
      "+\tif (buffer)", 
      "+\t\tyaffs_ReleaseTempBuffer(dev, buffer, __LINE__);", 
      "+", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+/*------------------------ Short Operations Cache ----------------------------------------", 
      "+ *   In many situations where there is no high level buffering (eg WinCE) a lot of", 
      "+ *   reads might be short sequential reads, and a lot of writes may be short", 
      "+ *   sequential writes. eg. scanning/writing a jpeg file.", 
      "+ *   In these cases, a short read/write cache can provide a huge perfomance benefit", 
      "+ *   with dumb-as-a-rock code.", 
      "+ *   In Linux, the page cache provides read buffering aand the short op cache provides write", 
      "+ *   buffering.", 
      "+ *", 
      "+ *   There are a limited number (~10) of cache chunks per device so that we don't", 
      "+ *   need a very intelligent search.", 
      "+ */", 
      "+", 
      "+static int yaffs_ObjectHasCachedWriteData(yaffs_Object *obj)", 
      "+{", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+\tint i;", 
      "+\tyaffs_ChunkCache *cache;", 
      "+\tint nCaches = obj->myDev->nShortOpCaches;", 
      "+", 
      "+\tfor(i = 0; i < nCaches; i++){", 
      "+\t\tcache = &dev->srCache[i];", 
      "+\t\tif (cache->object == obj &&", 
      "+\t\t    cache->dirty)", 
      "+\t\t\treturn 1;", 
      "+\t}", 
      "+", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_FlushFilesChunkCache(yaffs_Object * obj)", 
      "+{", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+\tint lowest = -99;\t/* Stop compiler whining. */", 
      "+\tint i;", 
      "+\tyaffs_ChunkCache *cache;", 
      "+\tint chunkWritten = 0;", 
      "+\tint nCaches = obj->myDev->nShortOpCaches;", 
      "+", 
      "+\tif (nCaches > 0) {", 
      "+\t\tdo {", 
      "+\t\t\tcache = NULL;", 
      "+", 
      "+\t\t\t/* Find the dirty cache for this object with the lowest chunk id. */", 
      "+\t\t\tfor (i = 0; i < nCaches; i++) {", 
      "+\t\t\t\tif (dev->srCache[i].object == obj &&", 
      "+\t\t\t\t    dev->srCache[i].dirty) {", 
      "+\t\t\t\t\tif (!cache", 
      "+\t\t\t\t\t    || dev->srCache[i].chunkId <", 
      "+\t\t\t\t\t    lowest) {", 
      "+\t\t\t\t\t\tcache = &dev->srCache[i];", 
      "+\t\t\t\t\t\tlowest = cache->chunkId;", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (cache && !cache->locked) {", 
      "+\t\t\t\t/* Write it out and free it up */", 
      "+", 
      "+\t\t\t\tchunkWritten =", 
      "+\t\t\t\t    yaffs_WriteChunkDataToObject(cache->object,", 
      "+\t\t\t\t\t\t\t\t cache->chunkId,", 
      "+\t\t\t\t\t\t\t\t cache->data,", 
      "+\t\t\t\t\t\t\t\t cache->nBytes,", 
      "+\t\t\t\t\t\t\t\t 1);", 
      "+\t\t\t\tcache->dirty = 0;", 
      "+\t\t\t\tcache->object = NULL;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t} while (cache && chunkWritten > 0);", 
      "+", 
      "+\t\tif (cache) {", 
      "+\t\t\t/* Hoosterman, disk full while writing cache out. */", 
      "+\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t  (TSTR(\"yaffs tragedy: no space during cache write\" TENDSTR)));", 
      "+", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+/*yaffs_FlushEntireDeviceCache(dev)", 
      "+ *", 
      "+ *", 
      "+ */", 
      "+", 
      "+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tint nCaches = dev->nShortOpCaches;", 
      "+\tint i;", 
      "+", 
      "+\t/* Find a dirty object in the cache and flush it...", 
      "+\t * until there are no further dirty objects.", 
      "+\t */", 
      "+\tdo {", 
      "+\t\tobj = NULL;", 
      "+\t\tfor( i = 0; i < nCaches && !obj; i++) {", 
      "+\t\t\tif (dev->srCache[i].object &&", 
      "+\t\t\t    dev->srCache[i].dirty)", 
      "+\t\t\t\tobj = dev->srCache[i].object;", 
      "+", 
      "+\t\t}", 
      "+\t\tif(obj)", 
      "+\t\t\tyaffs_FlushFilesChunkCache(obj);", 
      "+", 
      "+\t} while(obj);", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+/* Grab us a cache chunk for use.", 
      "+ * First look for an empty one.", 
      "+ * Then look for the least recently used non-dirty one.", 
      "+ * Then look for the least recently used dirty one...., flush and look again.", 
      "+ */", 
      "+static yaffs_ChunkCache *yaffs_GrabChunkCacheWorker(yaffs_Device * dev)", 
      "+{", 
      "+\tint i;", 
      "+\tint usage;", 
      "+\tint theOne;", 
      "+", 
      "+\tif (dev->nShortOpCaches > 0) {", 
      "+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\tif (!dev->srCache[i].object)", 
      "+\t\t\t\treturn &dev->srCache[i];", 
      "+\t\t}", 
      "+", 
      "+\t\treturn NULL;", 
      "+", 
      "+\t\ttheOne = -1;", 
      "+\t\tusage = 0;\t/* just to stop the compiler grizzling */", 
      "+", 
      "+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\tif (!dev->srCache[i].dirty &&", 
      "+\t\t\t    ((dev->srCache[i].lastUse < usage && theOne >= 0) ||", 
      "+\t\t\t     theOne < 0)) {", 
      "+\t\t\t\tusage = dev->srCache[i].lastUse;", 
      "+\t\t\t\ttheOne = i;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+", 
      "+\t\treturn theOne >= 0 ? &dev->srCache[theOne] : NULL;", 
      "+\t} else {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static yaffs_ChunkCache *yaffs_GrabChunkCache(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_ChunkCache *cache;", 
      "+\tyaffs_Object *theObj;", 
      "+\tint usage;", 
      "+\tint i;", 
      "+\tint pushout;", 
      "+", 
      "+\tif (dev->nShortOpCaches > 0) {", 
      "+\t\t/* Try find a non-dirty one... */", 
      "+", 
      "+\t\tcache = yaffs_GrabChunkCacheWorker(dev);", 
      "+", 
      "+\t\tif (!cache) {", 
      "+\t\t\t/* They were all dirty, find the last recently used object and flush", 
      "+\t\t\t * its cache, then  find again.", 
      "+\t\t\t * NB what's here is not very accurate, we actually flush the object", 
      "+\t\t\t * the last recently used page.", 
      "+\t\t\t */", 
      "+", 
      "+\t\t\t/* With locking we can't assume we can use entry zero */", 
      "+", 
      "+\t\t\ttheObj = NULL;", 
      "+\t\t\tusage = -1;", 
      "+\t\t\tcache = NULL;", 
      "+\t\t\tpushout = -1;", 
      "+", 
      "+\t\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\t\tif (dev->srCache[i].object &&", 
      "+\t\t\t\t    !dev->srCache[i].locked &&", 
      "+\t\t\t\t    (dev->srCache[i].lastUse < usage || !cache))", 
      "+\t\t\t\t{", 
      "+\t\t\t\t\tusage = dev->srCache[i].lastUse;", 
      "+\t\t\t\t\ttheObj = dev->srCache[i].object;", 
      "+\t\t\t\t\tcache = &dev->srCache[i];", 
      "+\t\t\t\t\tpushout = i;", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (!cache || cache->dirty) {", 
      "+\t\t\t\t/* Flush and try again */", 
      "+\t\t\t\tyaffs_FlushFilesChunkCache(theObj);", 
      "+\t\t\t\tcache = yaffs_GrabChunkCacheWorker(dev);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t}", 
      "+\t\treturn cache;", 
      "+\t} else", 
      "+\t\treturn NULL;", 
      "+", 
      "+}", 
      "+", 
      "+/* Find a cached chunk */", 
      "+static yaffs_ChunkCache *yaffs_FindChunkCache(const yaffs_Object * obj,", 
      "+\t\t\t\t\t      int chunkId)", 
      "+{", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+\tint i;", 
      "+\tif (dev->nShortOpCaches > 0) {", 
      "+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\tif (dev->srCache[i].object == obj &&", 
      "+\t\t\t    dev->srCache[i].chunkId == chunkId) {", 
      "+\t\t\t\tdev->cacheHits++;", 
      "+", 
      "+\t\t\t\treturn &dev->srCache[i];", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+\treturn NULL;", 
      "+}", 
      "+", 
      "+/* Mark the chunk for the least recently used algorithym */", 
      "+static void yaffs_UseChunkCache(yaffs_Device * dev, yaffs_ChunkCache * cache,", 
      "+\t\t\t\tint isAWrite)", 
      "+{", 
      "+", 
      "+\tif (dev->nShortOpCaches > 0) {", 
      "+\t\tif (dev->srLastUse < 0 || dev->srLastUse > 100000000) {", 
      "+\t\t\t/* Reset the cache usages */", 
      "+\t\t\tint i;", 
      "+\t\t\tfor (i = 1; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\t\tdev->srCache[i].lastUse = 0;", 
      "+\t\t\t}", 
      "+\t\t\tdev->srLastUse = 0;", 
      "+\t\t}", 
      "+", 
      "+\t\tdev->srLastUse++;", 
      "+", 
      "+\t\tcache->lastUse = dev->srLastUse;", 
      "+", 
      "+\t\tif (isAWrite) {", 
      "+\t\t\tcache->dirty = 1;", 
      "+\t\t}", 
      "+\t}", 
      "+}", 
      "+", 
      "+/* Invalidate a single cache page.", 
      "+ * Do this when a whole page gets written,", 
      "+ * ie the short cache for this page is no longer valid.", 
      "+ */", 
      "+static void yaffs_InvalidateChunkCache(yaffs_Object * object, int chunkId)", 
      "+{", 
      "+\tif (object->myDev->nShortOpCaches > 0) {", 
      "+\t\tyaffs_ChunkCache *cache = yaffs_FindChunkCache(object, chunkId);", 
      "+", 
      "+\t\tif (cache) {", 
      "+\t\t\tcache->object = NULL;", 
      "+\t\t}", 
      "+\t}", 
      "+}", 
      "+", 
      "+/* Invalidate all the cache pages associated with this object", 
      "+ * Do this whenever ther file is deleted or resized.", 
      "+ */", 
      "+static void yaffs_InvalidateWholeChunkCache(yaffs_Object * in)", 
      "+{", 
      "+\tint i;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tif (dev->nShortOpCaches > 0) {", 
      "+\t\t/* Invalidate it. */", 
      "+\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\tif (dev->srCache[i].object == in) {", 
      "+\t\t\t\tdev->srCache[i].object = NULL;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+}", 
      "+", 
      "+/*--------------------- Checkpointing --------------------*/", 
      "+", 
      "+", 
      "+static int yaffs_WriteCheckpointValidityMarker(yaffs_Device *dev,int head)", 
      "+{", 
      "+\tyaffs_CheckpointValidity cp;", 
      "+", 
      "+\tmemset(&cp,0,sizeof(cp));", 
      "+", 
      "+\tcp.structType = sizeof(cp);", 
      "+\tcp.magic = YAFFS_MAGIC;", 
      "+\tcp.version = YAFFS_CHECKPOINT_VERSION;", 
      "+\tcp.head = (head) ? 1 : 0;", 
      "+", 
      "+\treturn (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp))?", 
      "+\t\t1 : 0;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointValidityMarker(yaffs_Device *dev, int head)", 
      "+{", 
      "+\tyaffs_CheckpointValidity cp;", 
      "+\tint ok;", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+", 
      "+\tif(ok)", 
      "+\t\tok = (cp.structType == sizeof(cp)) &&", 
      "+\t\t     (cp.magic == YAFFS_MAGIC) &&", 
      "+\t\t     (cp.version == YAFFS_CHECKPOINT_VERSION) &&", 
      "+\t\t     (cp.head == ((head) ? 1 : 0));", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+static void yaffs_DeviceToCheckpointDevice(yaffs_CheckpointDevice *cp,", 
      "+\t\t\t\t\t   yaffs_Device *dev)", 
      "+{", 
      "+\tcp->nErasedBlocks = dev->nErasedBlocks;", 
      "+\tcp->allocationBlock = dev->allocationBlock;", 
      "+\tcp->allocationPage = dev->allocationPage;", 
      "+\tcp->nFreeChunks = dev->nFreeChunks;", 
      "+", 
      "+\tcp->nDeletedFiles = dev->nDeletedFiles;", 
      "+\tcp->nUnlinkedFiles = dev->nUnlinkedFiles;", 
      "+\tcp->nBackgroundDeletions = dev->nBackgroundDeletions;", 
      "+\tcp->sequenceNumber = dev->sequenceNumber;", 
      "+\tcp->oldestDirtySequence = dev->oldestDirtySequence;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_CheckpointDeviceToDevice(yaffs_Device *dev,", 
      "+\t\t\t\t\t   yaffs_CheckpointDevice *cp)", 
      "+{", 
      "+\tdev->nErasedBlocks = cp->nErasedBlocks;", 
      "+\tdev->allocationBlock = cp->allocationBlock;", 
      "+\tdev->allocationPage = cp->allocationPage;", 
      "+\tdev->nFreeChunks = cp->nFreeChunks;", 
      "+", 
      "+\tdev->nDeletedFiles = cp->nDeletedFiles;", 
      "+\tdev->nUnlinkedFiles = cp->nUnlinkedFiles;", 
      "+\tdev->nBackgroundDeletions = cp->nBackgroundDeletions;", 
      "+\tdev->sequenceNumber = cp->sequenceNumber;", 
      "+\tdev->oldestDirtySequence = cp->oldestDirtySequence;", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_WriteCheckpointDevice(yaffs_Device *dev)", 
      "+{", 
      "+\tyaffs_CheckpointDevice cp;", 
      "+\t__u32 nBytes;", 
      "+\t__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);", 
      "+", 
      "+\tint ok;", 
      "+", 
      "+\t/* Write device runtime values*/", 
      "+\tyaffs_DeviceToCheckpointDevice(&cp,dev);", 
      "+\tcp.structType = sizeof(cp);", 
      "+", 
      "+\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+", 
      "+\t/* Write block info */", 
      "+\tif(ok) {", 
      "+\t\tnBytes = nBlocks * sizeof(yaffs_BlockInfo);", 
      "+\t\tok = (yaffs_CheckpointWrite(dev,dev->blockInfo,nBytes) == nBytes);", 
      "+\t}", 
      "+", 
      "+\t/* Write chunk bits */", 
      "+\tif(ok) {", 
      "+\t\tnBytes = nBlocks * dev->chunkBitmapStride;", 
      "+\t\tok = (yaffs_CheckpointWrite(dev,dev->chunkBits,nBytes) == nBytes);", 
      "+\t}", 
      "+\treturn\t ok ? 1 : 0;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointDevice(yaffs_Device *dev)", 
      "+{", 
      "+\tyaffs_CheckpointDevice cp;", 
      "+\t__u32 nBytes;", 
      "+\t__u32 nBlocks = (dev->internalEndBlock - dev->internalStartBlock + 1);", 
      "+", 
      "+\tint ok;", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+\tif(!ok)", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(cp.structType != sizeof(cp))", 
      "+\t\treturn 0;", 
      "+", 
      "+", 
      "+\tyaffs_CheckpointDeviceToDevice(dev,&cp);", 
      "+", 
      "+\tnBytes = nBlocks * sizeof(yaffs_BlockInfo);", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,dev->blockInfo,nBytes) == nBytes);", 
      "+", 
      "+\tif(!ok)", 
      "+\t\treturn 0;", 
      "+\tnBytes = nBlocks * dev->chunkBitmapStride;", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,dev->chunkBits,nBytes) == nBytes);", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+static void yaffs_ObjectToCheckpointObject(yaffs_CheckpointObject *cp,", 
      "+\t\t\t\t\t   yaffs_Object *obj)", 
      "+{", 
      "+", 
      "+\tcp->objectId = obj->objectId;", 
      "+\tcp->parentId = (obj->parent) ? obj->parent->objectId : 0;", 
      "+\tcp->hdrChunk = obj->hdrChunk;", 
      "+\tcp->variantType = obj->variantType;", 
      "+\tcp->deleted = obj->deleted;", 
      "+\tcp->softDeleted = obj->softDeleted;", 
      "+\tcp->unlinked = obj->unlinked;", 
      "+\tcp->fake = obj->fake;", 
      "+\tcp->renameAllowed = obj->renameAllowed;", 
      "+\tcp->unlinkAllowed = obj->unlinkAllowed;", 
      "+\tcp->serial = obj->serial;", 
      "+\tcp->nDataChunks = obj->nDataChunks;", 
      "+", 
      "+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE)", 
      "+\t\tcp->fileSizeOrEquivalentObjectId = obj->variant.fileVariant.fileSize;", 
      "+\telse if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)", 
      "+\t\tcp->fileSizeOrEquivalentObjectId = obj->variant.hardLinkVariant.equivalentObjectId;", 
      "+}", 
      "+", 
      "+static void yaffs_CheckpointObjectToObject( yaffs_Object *obj,yaffs_CheckpointObject *cp)", 
      "+{", 
      "+", 
      "+\tyaffs_Object *parent;", 
      "+", 
      "+\tobj->objectId = cp->objectId;", 
      "+", 
      "+\tif(cp->parentId)", 
      "+\t\tparent = yaffs_FindOrCreateObjectByNumber(", 
      "+\t\t\t\t\tobj->myDev,", 
      "+\t\t\t\t\tcp->parentId,", 
      "+\t\t\t\t\tYAFFS_OBJECT_TYPE_DIRECTORY);", 
      "+\telse", 
      "+\t\tparent = NULL;", 
      "+", 
      "+\tif(parent)", 
      "+\t\tyaffs_AddObjectToDirectory(parent, obj);", 
      "+", 
      "+\tobj->hdrChunk = cp->hdrChunk;", 
      "+\tobj->variantType = cp->variantType;", 
      "+\tobj->deleted = cp->deleted;", 
      "+\tobj->softDeleted = cp->softDeleted;", 
      "+\tobj->unlinked = cp->unlinked;", 
      "+\tobj->fake = cp->fake;", 
      "+\tobj->renameAllowed = cp->renameAllowed;", 
      "+\tobj->unlinkAllowed = cp->unlinkAllowed;", 
      "+\tobj->serial = cp->serial;", 
      "+\tobj->nDataChunks = cp->nDataChunks;", 
      "+", 
      "+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE)", 
      "+\t\tobj->variant.fileVariant.fileSize = cp->fileSizeOrEquivalentObjectId;", 
      "+\telse if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK)", 
      "+\t\tobj->variant.hardLinkVariant.equivalentObjectId = cp->fileSizeOrEquivalentObjectId;", 
      "+", 
      "+\tif(obj->hdrChunk > 0)", 
      "+\t\tobj->lazyLoaded = 1;", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+static int yaffs_CheckpointTnodeWorker(yaffs_Object * in, yaffs_Tnode * tn,", 
      "+\t\t\t\t  \t__u32 level, int chunkOffset)", 
      "+{", 
      "+\tint i;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+\tint ok = 1;", 
      "+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;", 
      "+", 
      "+\tif(tnodeSize < sizeof(yaffs_Tnode))", 
      "+\t\ttnodeSize = sizeof(yaffs_Tnode);", 
      "+", 
      "+", 
      "+\tif (tn) {", 
      "+\t\tif (level > 0) {", 
      "+", 
      "+\t\t\tfor (i = 0; i < YAFFS_NTNODES_INTERNAL && ok; i++){", 
      "+\t\t\t\tif (tn->internal[i]) {", 
      "+\t\t\t\t\tok = yaffs_CheckpointTnodeWorker(in,", 
      "+\t\t\t\t\t\t\ttn->internal[i],", 
      "+\t\t\t\t\t\t\tlevel - 1,", 
      "+\t\t\t\t\t\t\t(chunkOffset<<YAFFS_TNODES_INTERNAL_BITS) + i);", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t} else if (level == 0) {", 
      "+\t\t\t__u32 baseOffset = chunkOffset <<  YAFFS_TNODES_LEVEL0_BITS;", 
      "+\t\t\t/* printf(\"write tnode at %d\\n\",baseOffset); */", 
      "+\t\t\tok = (yaffs_CheckpointWrite(dev,&baseOffset,sizeof(baseOffset)) == sizeof(baseOffset));", 
      "+\t\t\tif(ok)", 
      "+\t\t\t\tok = (yaffs_CheckpointWrite(dev,tn,tnodeSize) == tnodeSize);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn ok;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_WriteCheckpointTnodes(yaffs_Object *obj)", 
      "+{", 
      "+\t__u32 endMarker = ~0;", 
      "+\tint ok = 1;", 
      "+", 
      "+\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE){", 
      "+\t\tok = yaffs_CheckpointTnodeWorker(obj,", 
      "+\t\t\t\t\t    obj->variant.fileVariant.top,", 
      "+\t\t\t\t\t    obj->variant.fileVariant.topLevel,", 
      "+\t\t\t\t\t    0);", 
      "+\t\tif(ok)", 
      "+\t\t\tok = (yaffs_CheckpointWrite(obj->myDev,&endMarker,sizeof(endMarker)) ==", 
      "+\t\t\t\tsizeof(endMarker));", 
      "+\t}", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointTnodes(yaffs_Object *obj)", 
      "+{", 
      "+\t__u32 baseChunk;", 
      "+\tint ok = 1;", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+\tyaffs_FileStructure *fileStructPtr = &obj->variant.fileVariant;", 
      "+\tyaffs_Tnode *tn;", 
      "+\tint nread = 0;", 
      "+\tint tnodeSize = (dev->tnodeWidth * YAFFS_NTNODES_LEVEL0)/8;", 
      "+", 
      "+\tif(tnodeSize < sizeof(yaffs_Tnode))", 
      "+\t\ttnodeSize = sizeof(yaffs_Tnode);", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));", 
      "+", 
      "+\twhile(ok && (~baseChunk)){", 
      "+\t\tnread++;", 
      "+\t\t/* Read level 0 tnode */", 
      "+", 
      "+", 
      "+\t\t/* printf(\"read  tnode at %d\\n\",baseChunk); */", 
      "+\t\ttn = yaffs_GetTnodeRaw(dev);", 
      "+\t\tif(tn)", 
      "+\t\t\tok = (yaffs_CheckpointRead(dev,tn,tnodeSize) == tnodeSize);", 
      "+\t\telse", 
      "+\t\t\tok = 0;", 
      "+", 
      "+\t\tif(tn && ok){", 
      "+\t\t\tok = yaffs_AddOrFindLevel0Tnode(dev,", 
      "+\t\t\t\t\t       \t\tfileStructPtr,", 
      "+\t\t\t\t\t       \t\tbaseChunk,", 
      "+\t\t\t\t\t       \t\ttn) ? 1 : 0;", 
      "+", 
      "+\t\t}", 
      "+", 
      "+\t\tif(ok)", 
      "+\t\t\tok = (yaffs_CheckpointRead(dev,&baseChunk,sizeof(baseChunk)) == sizeof(baseChunk));", 
      "+", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(", 
      "+\t\tTSTR(\"Checkpoint read tnodes %d records, last %d. ok %d\" TENDSTR),", 
      "+\t\tnread,baseChunk,ok));", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_WriteCheckpointObjects(yaffs_Device *dev)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+        yaffs_CheckpointObject cp;", 
      "+        int i;", 
      "+        int ok = 1;", 
      "+        struct ylist_head *lh;", 
      "+", 
      "+", 
      "+        /* Iterate through the objects in each hash entry,", 
      "+\t * dumping them to the checkpointing stream.", 
      "+         */", 
      "+", 
      "+         for(i = 0; ok &&  i <  YAFFS_NOBJECT_BUCKETS; i++){", 
      "+                ylist_for_each(lh, &dev->objectBucket[i].list) {", 
      "+                        if (lh) {", 
      "+                                obj = ylist_entry(lh, yaffs_Object, hashLink);", 
      "+                                if (!obj->deferedFree) {", 
      "+                                        yaffs_ObjectToCheckpointObject(&cp,obj);", 
      "+                                        cp.structType = sizeof(cp);", 
      "+", 
      "+\t\t\t\t\tT(YAFFS_TRACE_CHECKPOINT,(", 
      "+\t\t\t\t\t\tTSTR(\"Checkpoint write object %d parent %d type %d chunk %d obj addr %x\" TENDSTR),", 
      "+\t\t\t\t\t\tcp.objectId,cp.parentId,cp.variantType,cp.hdrChunk,(unsigned) obj));", 
      "+", 
      "+\t\t\t\t\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+", 
      "+\t\t\t\t\tif(ok && obj->variantType == YAFFS_OBJECT_TYPE_FILE){", 
      "+\t\t\t\t\t\tok = yaffs_WriteCheckpointTnodes(obj);", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t }", 
      "+", 
      "+\t /* Dump end of list */", 
      "+\tmemset(&cp,0xFF,sizeof(yaffs_CheckpointObject));", 
      "+\tcp.structType = sizeof(cp);", 
      "+", 
      "+\tif(ok)", 
      "+\t\tok = (yaffs_CheckpointWrite(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointObjects(yaffs_Device *dev)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+\tyaffs_CheckpointObject cp;", 
      "+\tint ok = 1;", 
      "+\tint done = 0;", 
      "+\tyaffs_Object *hardList = NULL;", 
      "+", 
      "+\twhile(ok && !done) {", 
      "+\t\tok = (yaffs_CheckpointRead(dev,&cp,sizeof(cp)) == sizeof(cp));", 
      "+\t\tif(cp.structType != sizeof(cp)) {", 
      "+\t\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"struct size %d instead of %d ok %d\"TENDSTR),", 
      "+\t\t\t\tcp.structType,sizeof(cp),ok));", 
      "+\t\t\tok = 0;", 
      "+\t\t}", 
      "+", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"Checkpoint read object %d parent %d type %d chunk %d \" TENDSTR),", 
      "+\t\t\tcp.objectId,cp.parentId,cp.variantType,cp.hdrChunk));", 
      "+", 
      "+\t\tif(ok && cp.objectId == ~0)", 
      "+\t\t\tdone = 1;", 
      "+\t\telse if(ok){", 
      "+\t\t\tobj = yaffs_FindOrCreateObjectByNumber(dev,cp.objectId, cp.variantType);", 
      "+\t\t\tif(obj) {", 
      "+\t\t\t\tyaffs_CheckpointObjectToObject(obj,&cp);", 
      "+\t\t\t\tif(obj->variantType == YAFFS_OBJECT_TYPE_FILE) {", 
      "+                                        ok = yaffs_ReadCheckpointTnodes(obj);", 
      "+                                } else if(obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {", 
      "+                                        obj->hardLinks.next =", 
      "+                                                    (struct ylist_head *)", 
      "+                                                    hardList;", 
      "+                                        hardList = obj;", 
      "+                                }", 
      "+", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tif(ok)", 
      "+\t\tyaffs_HardlinkFixup(dev,hardList);", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+}", 
      "+", 
      "+static int yaffs_WriteCheckpointSum(yaffs_Device *dev)", 
      "+{", 
      "+\t__u32 checkpointSum;", 
      "+\tint ok;", 
      "+", 
      "+\tyaffs_GetCheckpointSum(dev,&checkpointSum);", 
      "+", 
      "+\tok = (yaffs_CheckpointWrite(dev,&checkpointSum,sizeof(checkpointSum)) == sizeof(checkpointSum));", 
      "+", 
      "+\tif(!ok)", 
      "+\t\treturn 0;", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointSum(yaffs_Device *dev)", 
      "+{", 
      "+\t__u32 checkpointSum0;", 
      "+\t__u32 checkpointSum1;", 
      "+\tint ok;", 
      "+", 
      "+\tyaffs_GetCheckpointSum(dev,&checkpointSum0);", 
      "+", 
      "+\tok = (yaffs_CheckpointRead(dev,&checkpointSum1,sizeof(checkpointSum1)) == sizeof(checkpointSum1));", 
      "+", 
      "+\tif(!ok)", 
      "+\t\treturn 0;", 
      "+", 
      "+\tif(checkpointSum0 != checkpointSum1)", 
      "+\t\treturn 0;", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_WriteCheckpointData(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tint ok = 1;", 
      "+", 
      "+\tif(dev->skipCheckpointWrite || !dev->isYaffs2){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"skipping checkpoint write\" TENDSTR)));", 
      "+\t\tok = 0;", 
      "+\t}", 
      "+", 
      "+\tif(ok)", 
      "+\t\tok = yaffs_CheckpointOpen(dev,1);", 
      "+", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"write checkpoint validity\" TENDSTR)));", 
      "+\t\tok = yaffs_WriteCheckpointValidityMarker(dev,1);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"write checkpoint device\" TENDSTR)));", 
      "+\t\tok = yaffs_WriteCheckpointDevice(dev);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"write checkpoint objects\" TENDSTR)));", 
      "+\t\tok = yaffs_WriteCheckpointObjects(dev);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"write checkpoint validity\" TENDSTR)));", 
      "+\t\tok = yaffs_WriteCheckpointValidityMarker(dev,0);", 
      "+\t}", 
      "+", 
      "+\tif(ok){", 
      "+\t\tok = yaffs_WriteCheckpointSum(dev);", 
      "+\t}", 
      "+", 
      "+", 
      "+\tif(!yaffs_CheckpointClose(dev))", 
      "+\t\t ok = 0;", 
      "+", 
      "+\tif(ok)", 
      "+\t    \tdev->isCheckpointed = 1;", 
      "+\t else", 
      "+\t \tdev->isCheckpointed = 0;", 
      "+", 
      "+\treturn dev->isCheckpointed;", 
      "+}", 
      "+", 
      "+static int yaffs_ReadCheckpointData(yaffs_Device *dev)", 
      "+{", 
      "+\tint ok = 1;", 
      "+", 
      "+\tif(dev->skipCheckpointRead || !dev->isYaffs2){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"skipping checkpoint read\" TENDSTR)));", 
      "+\t\tok = 0;", 
      "+\t}", 
      "+", 
      "+\tif(ok)", 
      "+\t\tok = yaffs_CheckpointOpen(dev,0); /* open for read */", 
      "+", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"read checkpoint validity\" TENDSTR)));", 
      "+\t\tok = yaffs_ReadCheckpointValidityMarker(dev,1);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"read checkpoint device\" TENDSTR)));", 
      "+\t\tok = yaffs_ReadCheckpointDevice(dev);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"read checkpoint objects\" TENDSTR)));", 
      "+\t\tok = yaffs_ReadCheckpointObjects(dev);", 
      "+\t}", 
      "+\tif(ok){", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"read checkpoint validity\" TENDSTR)));", 
      "+\t\tok = yaffs_ReadCheckpointValidityMarker(dev,0);", 
      "+\t}", 
      "+", 
      "+\tif(ok){", 
      "+\t\tok = yaffs_ReadCheckpointSum(dev);", 
      "+\t\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"read checkpoint checksum %d\" TENDSTR),ok));", 
      "+\t}", 
      "+", 
      "+\tif(!yaffs_CheckpointClose(dev))", 
      "+\t\tok = 0;", 
      "+", 
      "+\tif(ok)", 
      "+\t    \tdev->isCheckpointed = 1;", 
      "+\t else", 
      "+\t \tdev->isCheckpointed = 0;", 
      "+", 
      "+\treturn ok ? 1 : 0;", 
      "+", 
      "+}", 
      "+", 
      "+static void yaffs_InvalidateCheckpoint(yaffs_Device *dev)", 
      "+{", 
      "+\tif(dev->isCheckpointed ||", 
      "+\t   dev->blocksInCheckpoint > 0){", 
      "+\t\tdev->isCheckpointed = 0;", 
      "+\t\tyaffs_CheckpointInvalidateStream(dev);", 
      "+\t\tif(dev->superBlock && dev->markSuperBlockDirty)", 
      "+\t\t\tdev->markSuperBlockDirty(dev->superBlock);", 
      "+\t}", 
      "+}", 
      "+", 
      "+", 
      "+int yaffs_CheckpointSave(yaffs_Device *dev)", 
      "+{", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"save entry: isCheckpointed %d\"TENDSTR),dev->isCheckpointed));", 
      "+", 
      "+\tyaffs_VerifyObjects(dev);", 
      "+\tyaffs_VerifyBlocks(dev);", 
      "+\tyaffs_VerifyFreeChunks(dev);", 
      "+", 
      "+\tif(!dev->isCheckpointed) {", 
      "+\t\tyaffs_InvalidateCheckpoint(dev);", 
      "+\t\tyaffs_WriteCheckpointData(dev);", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS,(TSTR(\"save exit: isCheckpointed %d\"TENDSTR),dev->isCheckpointed));", 
      "+", 
      "+\treturn dev->isCheckpointed;", 
      "+}", 
      "+", 
      "+int yaffs_CheckpointRestore(yaffs_Device *dev)", 
      "+{", 
      "+\tint retval;", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"restore entry: isCheckpointed %d\"TENDSTR),dev->isCheckpointed));", 
      "+", 
      "+\tretval = yaffs_ReadCheckpointData(dev);", 
      "+", 
      "+\tif(dev->isCheckpointed){", 
      "+\t\tyaffs_VerifyObjects(dev);", 
      "+\t\tyaffs_VerifyBlocks(dev);", 
      "+\t\tyaffs_VerifyFreeChunks(dev);", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_CHECKPOINT,(TSTR(\"restore exit: isCheckpointed %d\"TENDSTR),dev->isCheckpointed));", 
      "+", 
      "+\treturn retval;", 
      "+}", 
      "+", 
      "+/*--------------------- File read/write ------------------------", 
      "+ * Read and write have very similar structures.", 
      "+ * In general the read/write has three parts to it", 
      "+ * An incomplete chunk to start with (if the read/write is not chunk-aligned)", 
      "+ * Some complete chunks", 
      "+ * An incomplete chunk to end off with", 
      "+ *", 
      "+ * Curve-balls: the first chunk might also be the last chunk.", 
      "+ */", 
      "+", 
      "+int yaffs_ReadDataFromFile(yaffs_Object * in, __u8 * buffer, loff_t offset,", 
      "+\t\t\t   int nBytes)", 
      "+{", 
      "+", 
      "+\tint chunk;", 
      "+\t__u32 start;", 
      "+\tint nToCopy;", 
      "+\tint n = nBytes;", 
      "+\tint nDone = 0;", 
      "+\tyaffs_ChunkCache *cache;", 
      "+", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tdev = in->myDev;", 
      "+", 
      "+\twhile (n > 0) {", 
      "+\t\t//chunk = offset / dev->nDataBytesPerChunk + 1;", 
      "+\t\t//start = offset % dev->nDataBytesPerChunk;", 
      "+\t\tyaffs_AddrToChunk(dev,offset,&chunk,&start);", 
      "+\t\tchunk++;", 
      "+", 
      "+\t\t/* OK now check for the curveball where the start and end are in", 
      "+\t\t * the same chunk.", 
      "+\t\t */", 
      "+\t\tif ((start + n) < dev->nDataBytesPerChunk) {", 
      "+\t\t\tnToCopy = n;", 
      "+\t\t} else {", 
      "+\t\t\tnToCopy = dev->nDataBytesPerChunk - start;", 
      "+\t\t}", 
      "+", 
      "+\t\tcache = yaffs_FindChunkCache(in, chunk);", 
      "+", 
      "+\t\t/* If the chunk is already in the cache or it is less than a whole chunk", 
      "+\t\t * or we're using inband tags then use the cache (if there is caching)", 
      "+\t\t * else bypass the cache.", 
      "+\t\t */", 
      "+\t\tif (cache || nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {", 
      "+\t\t\tif (dev->nShortOpCaches > 0) {", 
      "+", 
      "+\t\t\t\t/* If we can't find the data in the cache, then load it up. */", 
      "+", 
      "+\t\t\t\tif (!cache) {", 
      "+\t\t\t\t\tcache = yaffs_GrabChunkCache(in->myDev);", 
      "+\t\t\t\t\tcache->object = in;", 
      "+\t\t\t\t\tcache->chunkId = chunk;", 
      "+\t\t\t\t\tcache->dirty = 0;", 
      "+\t\t\t\t\tcache->locked = 0;", 
      "+\t\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,", 
      "+\t\t\t\t\t\t\t\t      cache->", 
      "+\t\t\t\t\t\t\t\t      data);", 
      "+\t\t\t\t\tcache->nBytes = 0;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tyaffs_UseChunkCache(dev, cache, 0);", 
      "+", 
      "+\t\t\t\tcache->locked = 1;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\tmemcpy(buffer, &cache->data[start], nToCopy);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\tcache->locked = 0;", 
      "+\t\t\t} else {", 
      "+\t\t\t\t/* Read into the local buffer then copy..*/", 
      "+", 
      "+\t\t\t\t__u8 *localBuffer =", 
      "+\t\t\t\t    yaffs_GetTempBuffer(dev, __LINE__);", 
      "+\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,", 
      "+\t\t\t\t\t\t\t      localBuffer);", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\tmemcpy(buffer, &localBuffer[start], nToCopy);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer,", 
      "+\t\t\t\t\t\t\t__LINE__);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t} else {", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t\t\t/* Under WinCE can't do direct transfer. Need to use a local buffer.", 
      "+\t\t\t * This is because we otherwise screw up WinCE's memory mapper", 
      "+\t\t\t */", 
      "+\t\t\tyaffs_ReadChunkDataFromObject(in, chunk, localBuffer);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\tmemcpy(buffer, localBuffer, dev->nDataBytesPerChunk);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);", 
      "+#endif", 
      "+", 
      "+#else", 
      "+\t\t\t/* A full chunk. Read directly into the supplied buffer. */", 
      "+\t\t\tyaffs_ReadChunkDataFromObject(in, chunk, buffer);", 
      "+#endif", 
      "+\t\t}", 
      "+", 
      "+\t\tn -= nToCopy;", 
      "+\t\toffset += nToCopy;", 
      "+\t\tbuffer += nToCopy;", 
      "+\t\tnDone += nToCopy;", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn nDone;", 
      "+}", 
      "+", 
      "+int yaffs_WriteDataToFile(yaffs_Object * in, const __u8 * buffer, loff_t offset,", 
      "+\t\t\t  int nBytes, int writeThrough)", 
      "+{", 
      "+", 
      "+\tint chunk;", 
      "+\t__u32 start;", 
      "+\tint nToCopy;", 
      "+        int n = nBytes;", 
      "+        int nDone = 0;", 
      "+        int nToWriteBack;", 
      "+        int startOfWrite = offset;", 
      "+        int chunkWritten = 0;", 
      "+        int nBytesRead;", 
      "+", 
      "+\tyaffs_Device *dev;", 
      "+", 
      "+\tdev = in->myDev;", 
      "+", 
      "+\twhile (n > 0 && chunkWritten >= 0) {", 
      "+\t\t//chunk = offset / dev->nDataBytesPerChunk + 1;", 
      "+\t\t//start = offset % dev->nDataBytesPerChunk;", 
      "+\t\tyaffs_AddrToChunk(dev,offset,&chunk,&start);", 
      "+\t\tchunk++;", 
      "+", 
      "+\t\t/* OK now check for the curveball where the start and end are in", 
      "+\t\t * the same chunk.", 
      "+\t\t */", 
      "+", 
      "+\t\tif ((start + n) < dev->nDataBytesPerChunk) {", 
      "+\t\t\tnToCopy = n;", 
      "+", 
      "+\t\t\t/* Now folks, to calculate how many bytes to write back....", 
      "+\t\t\t * If we're overwriting and not writing to then end of file then", 
      "+\t\t\t * we need to write back as much as was there before.", 
      "+\t\t\t */", 
      "+", 
      "+\t\t\tnBytesRead =", 
      "+\t\t\t    in->variant.fileVariant.fileSize -", 
      "+\t\t\t    ((chunk - 1) * dev->nDataBytesPerChunk);", 
      "+", 
      "+\t\t\tif (nBytesRead > dev->nDataBytesPerChunk) {", 
      "+\t\t\t\tnBytesRead = dev->nDataBytesPerChunk;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tnToWriteBack =", 
      "+\t\t\t    (nBytesRead >", 
      "+\t\t\t     (start + n)) ? nBytesRead : (start + n);", 
      "+", 
      "+\t\t} else {", 
      "+\t\t\tnToCopy = dev->nDataBytesPerChunk - start;", 
      "+\t\t\tnToWriteBack = dev->nDataBytesPerChunk;", 
      "+\t\t}", 
      "+", 
      "+\t\tif (nToCopy != dev->nDataBytesPerChunk || dev->inbandTags) {", 
      "+\t\t\t/* An incomplete start or end chunk (or maybe both start and end chunk),", 
      "+\t\t\t * or we're using inband tags, so we want to use the cache buffers.", 
      "+\t\t\t */", 
      "+\t\t\tif (dev->nShortOpCaches > 0) {", 
      "+\t\t\t\tyaffs_ChunkCache *cache;", 
      "+\t\t\t\t/* If we can't find the data in the cache, then load the cache */", 
      "+\t\t\t\tcache = yaffs_FindChunkCache(in, chunk);", 
      "+", 
      "+\t\t\t\tif (!cache", 
      "+\t\t\t\t    && yaffs_CheckSpaceForAllocation(in->", 
      "+\t\t\t\t\t\t\t\t     myDev)) {", 
      "+\t\t\t\t\tcache = yaffs_GrabChunkCache(in->myDev);", 
      "+\t\t\t\t\tcache->object = in;", 
      "+\t\t\t\t\tcache->chunkId = chunk;", 
      "+\t\t\t\t\tcache->dirty = 0;", 
      "+\t\t\t\t\tcache->locked = 0;", 
      "+\t\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,", 
      "+\t\t\t\t\t\t\t\t      cache->", 
      "+\t\t\t\t\t\t\t\t      data);", 
      "+\t\t\t\t}", 
      "+\t\t\t\telse if(cache &&", 
      "+\t\t\t\t        !cache->dirty &&", 
      "+\t\t\t\t\t!yaffs_CheckSpaceForAllocation(in->myDev)){", 
      "+\t\t\t\t\t/* Drop the cache if it was a read cache item and", 
      "+\t\t\t\t\t * no space check has been made for it.", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\t cache = NULL;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (cache) {", 
      "+\t\t\t\t\tyaffs_UseChunkCache(dev, cache, 1);", 
      "+\t\t\t\t\tcache->locked = 1;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+", 
      "+\t\t\t\t\tmemcpy(&cache->data[start], buffer,", 
      "+\t\t\t\t\t       nToCopy);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\t\tcache->locked = 0;", 
      "+\t\t\t\t\tcache->nBytes = nToWriteBack;", 
      "+", 
      "+\t\t\t\t\tif (writeThrough) {", 
      "+\t\t\t\t\t\tchunkWritten =", 
      "+\t\t\t\t\t\t    yaffs_WriteChunkDataToObject", 
      "+\t\t\t\t\t\t    (cache->object,", 
      "+\t\t\t\t\t\t     cache->chunkId,", 
      "+\t\t\t\t\t\t     cache->data, cache->nBytes,", 
      "+\t\t\t\t\t\t     1);", 
      "+\t\t\t\t\t\tcache->dirty = 0;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t} else {", 
      "+\t\t\t\t\tchunkWritten = -1;\t/* fail the write */", 
      "+\t\t\t\t}", 
      "+\t\t\t} else {", 
      "+\t\t\t\t/* An incomplete start or end chunk (or maybe both start and end chunk)", 
      "+\t\t\t\t * Read into the local buffer then copy, then copy over and write back.", 
      "+\t\t\t\t */", 
      "+", 
      "+\t\t\t\t__u8 *localBuffer =", 
      "+\t\t\t\t    yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t\t\t\tyaffs_ReadChunkDataFromObject(in, chunk,", 
      "+\t\t\t\t\t\t\t      localBuffer);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+", 
      "+\t\t\t\tmemcpy(&localBuffer[start], buffer, nToCopy);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\t\tchunkWritten =", 
      "+\t\t\t\t    yaffs_WriteChunkDataToObject(in, chunk,", 
      "+\t\t\t\t\t\t\t\t localBuffer,", 
      "+\t\t\t\t\t\t\t\t nToWriteBack,", 
      "+\t\t\t\t\t\t\t\t 0);", 
      "+", 
      "+\t\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer,", 
      "+\t\t\t\t\t\t\t__LINE__);", 
      "+", 
      "+\t\t\t}", 
      "+", 
      "+\t\t} else {", 
      "+\t\t\t/* A full chunk. Write directly from the supplied buffer. */", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t/* Under WinCE can't do direct transfer. Need to use a local buffer.", 
      "+\t\t\t * This is because we otherwise screw up WinCE's memory mapper", 
      "+\t\t\t */", 
      "+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\tyfsd_UnlockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\tmemcpy(localBuffer, buffer, dev->nDataBytesPerChunk);", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\tyfsd_LockYAFFS(TRUE);", 
      "+#endif", 
      "+\t\t\tchunkWritten =", 
      "+\t\t\t    yaffs_WriteChunkDataToObject(in, chunk, localBuffer,", 
      "+\t\t\t\t\t\t\t dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t\t\t 0);", 
      "+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);", 
      "+#else", 
      "+", 
      "+\t\t\tchunkWritten =", 
      "+\t\t\t    yaffs_WriteChunkDataToObject(in, chunk, buffer,", 
      "+\t\t\t\t\t\t\t dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t\t\t 0);", 
      "+#endif", 
      "+\t\t\t/* Since we've overwritten the cached data, we better invalidate it. */", 
      "+\t\t\tyaffs_InvalidateChunkCache(in, chunk);", 
      "+\t\t}", 
      "+", 
      "+\t\tif (chunkWritten >= 0) {", 
      "+\t\t\tn -= nToCopy;", 
      "+\t\t\toffset += nToCopy;", 
      "+\t\t\tbuffer += nToCopy;", 
      "+\t\t\tnDone += nToCopy;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\t/* Update file object */", 
      "+", 
      "+\tif ((startOfWrite + nDone) > in->variant.fileVariant.fileSize) {", 
      "+\t\tin->variant.fileVariant.fileSize = (startOfWrite + nDone);", 
      "+\t}", 
      "+", 
      "+\tin->dirty = 1;", 
      "+", 
      "+\treturn nDone;", 
      "+}", 
      "+", 
      "+", 
      "+/* ---------------------- File resizing stuff ------------------ */", 
      "+", 
      "+static void yaffs_PruneResizedChunks(yaffs_Object * in, int newSize)", 
      "+{", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+\tint oldFileSize = in->variant.fileVariant.fileSize;", 
      "+", 
      "+\tint lastDel = 1 + (oldFileSize - 1) / dev->nDataBytesPerChunk;", 
      "+", 
      "+\tint startDel = 1 + (newSize + dev->nDataBytesPerChunk - 1) /", 
      "+\t    dev->nDataBytesPerChunk;", 
      "+\tint i;", 
      "+\tint chunkId;", 
      "+", 
      "+\t/* Delete backwards so that we don't end up with holes if", 
      "+\t * power is lost part-way through the operation.", 
      "+\t */", 
      "+\tfor (i = lastDel; i >= startDel; i--) {", 
      "+\t\t/* NB this could be optimised somewhat,", 
      "+\t\t * eg. could retrieve the tags and write them without", 
      "+\t\t * using yaffs_DeleteChunk", 
      "+\t\t */", 
      "+", 
      "+\t\tchunkId = yaffs_FindAndDeleteChunkInFile(in, i, NULL);", 
      "+\t\tif (chunkId > 0) {", 
      "+\t\t\tif (chunkId <", 
      "+\t\t\t    (dev->internalStartBlock * dev->nChunksPerBlock)", 
      "+\t\t\t    || chunkId >=", 
      "+\t\t\t    ((dev->internalEndBlock +", 
      "+\t\t\t      1) * dev->nChunksPerBlock)) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t\t  (TSTR(\"Found daft chunkId %d for %d\" TENDSTR),", 
      "+\t\t\t\t   chunkId, i));", 
      "+\t\t\t} else {", 
      "+\t\t\t\tin->nDataChunks--;", 
      "+\t\t\t\tyaffs_DeleteChunk(dev, chunkId, 1, __LINE__);", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_ResizeFile(yaffs_Object * in, loff_t newSize)", 
      "+{", 
      "+", 
      "+\tint oldFileSize = in->variant.fileVariant.fileSize;", 
      "+\t__u32 newSizeOfPartialChunk;", 
      "+\tint newFullChunks;", 
      "+", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+", 
      "+\tyaffs_AddrToChunk(dev, newSize, &newFullChunks, &newSizeOfPartialChunk);", 
      "+", 
      "+\tyaffs_FlushFilesChunkCache(in);", 
      "+\tyaffs_InvalidateWholeChunkCache(in);", 
      "+", 
      "+        yaffs_CheckGarbageCollection(dev);", 
      "+", 
      "+        if (in->variantType != YAFFS_OBJECT_TYPE_FILE) {", 
      "+                return YAFFS_FAIL;", 
      "+        }", 
      "+", 
      "+        if (newSize == oldFileSize) {", 
      "+                return YAFFS_OK;", 
      "+        }", 
      "+", 
      "+        if (newSize < oldFileSize) {", 
      "+", 
      "+\t\tyaffs_PruneResizedChunks(in, newSize);", 
      "+", 
      "+\t\tif (newSizeOfPartialChunk != 0) {", 
      "+\t\t\tint lastChunk = 1 + newFullChunks;", 
      "+", 
      "+\t\t\t__u8 *localBuffer = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t\t\t/* Got to read and rewrite the last chunk with its new size and zero pad */", 
      "+\t\t\tyaffs_ReadChunkDataFromObject(in, lastChunk,", 
      "+\t\t\t\t\t\t      localBuffer);", 
      "+", 
      "+\t\t\tmemset(localBuffer + newSizeOfPartialChunk, 0,", 
      "+\t\t\t       dev->nDataBytesPerChunk - newSizeOfPartialChunk);", 
      "+", 
      "+\t\t\tyaffs_WriteChunkDataToObject(in, lastChunk, localBuffer,", 
      "+\t\t\t\t\t\t     newSizeOfPartialChunk, 1);", 
      "+", 
      "+\t\t\tyaffs_ReleaseTempBuffer(dev, localBuffer, __LINE__);", 
      "+\t\t}", 
      "+", 
      "+\t\tin->variant.fileVariant.fileSize = newSize;", 
      "+", 
      "+\t\tyaffs_PruneFileStructure(dev, &in->variant.fileVariant);", 
      "+\t} else {", 
      "+\t\t/* newsSize > oldFileSize */", 
      "+\t\tin->variant.fileVariant.fileSize = newSize;", 
      "+\t}", 
      "+", 
      "+", 
      "+", 
      "+\t/* Write a new object header.", 
      "+\t * show we've shrunk the file, if need be", 
      "+\t * Do this only if the file is not in the deleted directories.", 
      "+\t */", 
      "+\tif (in->parent->objectId != YAFFS_OBJECTID_UNLINKED &&", 
      "+\t    in->parent->objectId != YAFFS_OBJECTID_DELETED) {", 
      "+\t\tyaffs_UpdateObjectHeader(in, NULL, 0,", 
      "+\t\t\t\t\t (newSize < oldFileSize) ? 1 : 0, 0);", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+loff_t yaffs_GetFileSize(yaffs_Object * obj)", 
      "+{", 
      "+\tobj = yaffs_GetEquivalentObject(obj);", 
      "+", 
      "+\tswitch (obj->variantType) {", 
      "+\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\treturn obj->variant.fileVariant.fileSize;", 
      "+\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\treturn yaffs_strlen(obj->variant.symLinkVariant.alias);", 
      "+\tdefault:", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+int yaffs_FlushFile(yaffs_Object * in, int updateTime)", 
      "+{", 
      "+\tint retVal;", 
      "+\tif (in->dirty) {", 
      "+\t\tyaffs_FlushFilesChunkCache(in);", 
      "+\t\tif (updateTime) {", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\tyfsd_WinFileTimeNow(in->win_mtime);", 
      "+#else", 
      "+", 
      "+\t\t\tin->yst_mtime = Y_CURRENT_TIME;", 
      "+", 
      "+#endif", 
      "+\t\t}", 
      "+", 
      "+\t\tretVal =", 
      "+\t\t    (yaffs_UpdateObjectHeader(in, NULL, 0, 0, 0) >=", 
      "+\t\t     0) ? YAFFS_OK : YAFFS_FAIL;", 
      "+\t} else {", 
      "+\t\tretVal = YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\treturn retVal;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_DoGenericObjectDeletion(yaffs_Object * in)", 
      "+{", 
      "+", 
      "+\t/* First off, invalidate the file's data in the cache, without flushing. */", 
      "+\tyaffs_InvalidateWholeChunkCache(in);", 
      "+", 
      "+\tif (in->myDev->isYaffs2 && (in->parent != in->myDev->deletedDir)) {", 
      "+\t\t/* Move to the unlinked directory so we have a record that it was deleted. */", 
      "+\t\tyaffs_ChangeObjectName(in, in->myDev->deletedDir,_Y(\"deleted\"), 0, 0);", 
      "+", 
      "+\t}", 
      "+", 
      "+\tyaffs_RemoveObjectFromDirectory(in);", 
      "+\tyaffs_DeleteChunk(in->myDev, in->hdrChunk, 1, __LINE__);", 
      "+\tin->hdrChunk = 0;", 
      "+", 
      "+\tyaffs_FreeObject(in);", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+", 
      "+/* yaffs_DeleteFile deletes the whole file data", 
      "+ * and the inode associated with the file.", 
      "+ * It does not delete the links associated with the file.", 
      "+ */", 
      "+static int yaffs_UnlinkFile(yaffs_Object * in)", 
      "+{", 
      "+", 
      "+\tint retVal;", 
      "+\tint immediateDeletion = 0;", 
      "+", 
      "+\tif (1) {", 
      "+#ifdef __KERNEL__", 
      "+\t\tif (!in->myInode) {", 
      "+\t\t\timmediateDeletion = 1;", 
      "+", 
      "+\t\t}", 
      "+#else", 
      "+\t\tif (in->inUse <= 0) {", 
      "+\t\t\timmediateDeletion = 1;", 
      "+", 
      "+\t\t}", 
      "+#endif", 
      "+\t\tif (immediateDeletion) {", 
      "+\t\t\tretVal =", 
      "+\t\t\t    yaffs_ChangeObjectName(in, in->myDev->deletedDir,", 
      "+\t\t\t\t\t\t   _Y(\"deleted\"), 0, 0);", 
      "+\t\t\tT(YAFFS_TRACE_TRACING,", 
      "+\t\t\t  (TSTR(\"yaffs: immediate deletion of file %d\" TENDSTR),", 
      "+\t\t\t   in->objectId));", 
      "+\t\t\tin->deleted = 1;", 
      "+\t\t\tin->myDev->nDeletedFiles++;", 
      "+\t\t\tif (0 && in->myDev->isYaffs2) {", 
      "+\t\t\t\tyaffs_ResizeFile(in, 0);", 
      "+\t\t\t}", 
      "+\t\t\tyaffs_SoftDeleteFile(in);", 
      "+\t\t} else {", 
      "+\t\t\tretVal =", 
      "+\t\t\t    yaffs_ChangeObjectName(in, in->myDev->unlinkedDir,", 
      "+\t\t\t\t\t\t   _Y(\"unlinked\"), 0, 0);", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+int yaffs_DeleteFile(yaffs_Object * in)", 
      "+{", 
      "+\tint retVal = YAFFS_OK;", 
      "+", 
      "+\tif (in->nDataChunks > 0) {", 
      "+\t\t/* Use soft deletion if there is data in the file */", 
      "+\t\tif (!in->unlinked) {", 
      "+\t\t\tretVal = yaffs_UnlinkFile(in);", 
      "+\t\t}", 
      "+\t\tif (retVal == YAFFS_OK && in->unlinked && !in->deleted) {", 
      "+\t\t\tin->deleted = 1;", 
      "+\t\t\tin->myDev->nDeletedFiles++;", 
      "+\t\t\tyaffs_SoftDeleteFile(in);", 
      "+\t\t}", 
      "+\t\treturn in->deleted ? YAFFS_OK : YAFFS_FAIL;", 
      "+\t} else {", 
      "+\t\t/* The file has no data chunks so we toss it immediately */", 
      "+\t\tyaffs_FreeTnode(in->myDev, in->variant.fileVariant.top);", 
      "+\t\tin->variant.fileVariant.top = NULL;", 
      "+\t\tyaffs_DoGenericObjectDeletion(in);", 
      "+", 
      "+\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+}", 
      "+", 
      "+static int yaffs_DeleteDirectory(yaffs_Object * in)", 
      "+{", 
      "+        /* First check that the directory is empty. */", 
      "+        if (ylist_empty(&in->variant.directoryVariant.children)) {", 
      "+                return yaffs_DoGenericObjectDeletion(in);", 
      "+        }", 
      "+", 
      "+\treturn YAFFS_FAIL;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_DeleteSymLink(yaffs_Object * in)", 
      "+{", 
      "+\tYFREE(in->variant.symLinkVariant.alias);", 
      "+", 
      "+\treturn yaffs_DoGenericObjectDeletion(in);", 
      "+}", 
      "+", 
      "+static int yaffs_DeleteHardLink(yaffs_Object * in)", 
      "+{", 
      "+        /* remove this hardlink from the list assocaited with the equivalent", 
      "+         * object", 
      "+         */", 
      "+        ylist_del(&in->hardLinks);", 
      "+        return yaffs_DoGenericObjectDeletion(in);", 
      "+}", 
      "+", 
      "+static void yaffs_DestroyObject(yaffs_Object * obj)", 
      "+{", 
      "+\tswitch (obj->variantType) {", 
      "+\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\tyaffs_DeleteFile(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\tyaffs_DeleteDirectory(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\tyaffs_DeleteSymLink(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\tyaffs_DeleteHardLink(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\tyaffs_DoGenericObjectDeletion(obj);", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\tbreak;\t\t/* should not happen. */", 
      "+\t}", 
      "+}", 
      "+", 
      "+static int yaffs_UnlinkWorker(yaffs_Object * obj)", 
      "+{", 
      "+", 
      "+        if (obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {", 
      "+                return yaffs_DeleteHardLink(obj);", 
      "+        } else if (!ylist_empty(&obj->hardLinks)) {", 
      "+                /* Curve ball: We're unlinking an object that has a hardlink.", 
      "+                 *", 
      "+                 * This problem arises because we are not strictly following", 
      "+\t\t * The Linux link/inode model.", 
      "+\t\t *", 
      "+\t\t * We can't really delete the object.", 
      "+\t\t * Instead, we do the following:", 
      "+\t\t * - Select a hardlink.", 
      "+\t\t * - Unhook it from the hard links", 
      "+\t\t * - Unhook it from its parent directory (so that the rename can work)", 
      "+\t\t * - Rename the object to the hardlink's name.", 
      "+\t\t * - Delete the hardlink", 
      "+\t\t */", 
      "+", 
      "+\t\tyaffs_Object *hl;", 
      "+                int retVal;", 
      "+                YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];", 
      "+", 
      "+                hl = ylist_entry(obj->hardLinks.next, yaffs_Object, hardLinks);", 
      "+", 
      "+                ylist_del_init(&hl->hardLinks);", 
      "+                ylist_del_init(&hl->siblings);", 
      "+", 
      "+                yaffs_GetObjectName(hl, name, YAFFS_MAX_NAME_LENGTH + 1);", 
      "+", 
      "+\t\tretVal = yaffs_ChangeObjectName(obj, hl->parent, name, 0, 0);", 
      "+", 
      "+\t\tif (retVal == YAFFS_OK) {", 
      "+\t\t\tretVal = yaffs_DoGenericObjectDeletion(hl);", 
      "+\t\t}", 
      "+\t\treturn retVal;", 
      "+", 
      "+\t} else {", 
      "+\t\tswitch (obj->variantType) {", 
      "+\t\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\t\treturn yaffs_UnlinkFile(obj);", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\t\treturn yaffs_DeleteDirectory(obj);", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\t\treturn yaffs_DeleteSymLink(obj);", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\t\treturn yaffs_DoGenericObjectDeletion(obj);", 
      "+\t\t\tbreak;", 
      "+\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\tdefault:", 
      "+\t\t\treturn YAFFS_FAIL;", 
      "+\t\t}", 
      "+\t}", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_UnlinkObject( yaffs_Object *obj)", 
      "+{", 
      "+", 
      "+\tif (obj && obj->unlinkAllowed) {", 
      "+\t\treturn yaffs_UnlinkWorker(obj);", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_FAIL;", 
      "+", 
      "+}", 
      "+int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+", 
      "+\tobj = yaffs_FindObjectByName(dir, name);", 
      "+\treturn yaffs_UnlinkObject(obj);", 
      "+}", 
      "+", 
      "+/*----------------------- Initialisation Scanning ---------------------- */", 
      "+", 
      "+static void yaffs_HandleShadowedObject(yaffs_Device * dev, int objId,", 
      "+\t\t\t\t       int backwardScanning)", 
      "+{", 
      "+\tyaffs_Object *obj;", 
      "+", 
      "+\tif (!backwardScanning) {", 
      "+\t\t/* Handle YAFFS1 forward scanning case", 
      "+\t\t * For YAFFS1 we always do the deletion", 
      "+\t\t */", 
      "+", 
      "+\t} else {", 
      "+\t\t/* Handle YAFFS2 case (backward scanning)", 
      "+\t\t * If the shadowed object exists then ignore.", 
      "+\t\t */", 
      "+\t\tif (yaffs_FindObjectByNumber(dev, objId)) {", 
      "+\t\t\treturn;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\t/* Let's create it (if it does not exist) assuming it is a file so that it can do shrinking etc.", 
      "+\t * We put it in unlinked dir to be cleaned up after the scanning", 
      "+\t */", 
      "+\tobj =", 
      "+\t    yaffs_FindOrCreateObjectByNumber(dev, objId,", 
      "+\t\t\t\t\t     YAFFS_OBJECT_TYPE_FILE);", 
      "+\tyaffs_AddObjectToDirectory(dev->unlinkedDir, obj);", 
      "+\tobj->variant.fileVariant.shrinkSize = 0;", 
      "+\tobj->valid = 1;\t\t/* So that we don't read any other info for this file */", 
      "+", 
      "+}", 
      "+", 
      "+typedef struct {", 
      "+\tint seq;", 
      "+\tint block;", 
      "+} yaffs_BlockIndex;", 
      "+", 
      "+", 
      "+static void yaffs_HardlinkFixup(yaffs_Device *dev, yaffs_Object *hardList)", 
      "+{", 
      "+\tyaffs_Object *hl;", 
      "+\tyaffs_Object *in;", 
      "+", 
      "+\twhile (hardList) {", 
      "+\t\thl = hardList;", 
      "+\t\thardList = (yaffs_Object *) (hardList->hardLinks.next);", 
      "+", 
      "+\t\tin = yaffs_FindObjectByNumber(dev,", 
      "+\t\t\t\t\t      hl->variant.hardLinkVariant.", 
      "+\t\t\t\t\t      equivalentObjectId);", 
      "+", 
      "+                if (in) {", 
      "+                        /* Add the hardlink pointers */", 
      "+                        hl->variant.hardLinkVariant.equivalentObject = in;", 
      "+                        ylist_add(&hl->hardLinks, &in->hardLinks);", 
      "+                } else {", 
      "+                        /* Todo Need to report/handle this better.", 
      "+                         * Got a problem... hardlink to a non-existant object", 
      "+                         */", 
      "+                        hl->variant.hardLinkVariant.equivalentObject = NULL;", 
      "+                        YINIT_LIST_HEAD(&hl->hardLinks);", 
      "+", 
      "+                }", 
      "+", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+", 
      "+", 
      "+", 
      "+static int ybicmp(const void *a, const void *b){", 
      "+    register int aseq = ((yaffs_BlockIndex *)a)->seq;", 
      "+    register int bseq = ((yaffs_BlockIndex *)b)->seq;", 
      "+    register int ablock = ((yaffs_BlockIndex *)a)->block;", 
      "+    register int bblock = ((yaffs_BlockIndex *)b)->block;", 
      "+    if( aseq == bseq )", 
      "+        return ablock - bblock;", 
      "+    else", 
      "+        return aseq - bseq;", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+struct yaffs_ShadowFixerStruct {", 
      "+\tint objectId;", 
      "+\tint shadowedId;", 
      "+\tstruct yaffs_ShadowFixerStruct *next;", 
      "+};", 
      "+", 
      "+static int yaffs_Scan(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tint blk;", 
      "+\tint blockIterator;", 
      "+\tint startIterator;", 
      "+\tint endIterator;", 
      "+\tint result;", 
      "+", 
      "+\tint chunk;", 
      "+\tint c;", 
      "+\tint deleted;", 
      "+\tyaffs_BlockState state;", 
      "+\tyaffs_Object *hardList = NULL;", 
      "+\tyaffs_BlockInfo *bi;", 
      "+\t__u32 sequenceNumber;", 
      "+\tyaffs_ObjectHeader *oh;", 
      "+\tyaffs_Object *in;", 
      "+\tyaffs_Object *parent;", 
      "+", 
      "+\tint alloc_failed = 0;", 
      "+", 
      "+\tstruct yaffs_ShadowFixerStruct *shadowFixerList = NULL;", 
      "+", 
      "+", 
      "+\t__u8 *chunkData;", 
      "+", 
      "+", 
      "+\t//TODO  Throw all the yaffs2 stuuf out of yaffs_Scan since it is only for yaffs1 format.", 
      "+", 
      "+\tT(YAFFS_TRACE_SCAN,", 
      "+\t  (TSTR(\"yaffs_Scan starts  intstartblk %d intendblk %d...\" TENDSTR),", 
      "+\t   dev->internalStartBlock, dev->internalEndBlock));", 
      "+", 
      "+\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\tdev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;", 
      "+", 
      "+\t/* Scan all the blocks to determine their state */", 
      "+\tfor (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, blk);", 
      "+\t\tyaffs_ClearChunkBits(dev, blk);", 
      "+\t\tbi->pagesInUse = 0;", 
      "+\t\tbi->softDeletions = 0;", 
      "+", 
      "+\t\tyaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);", 
      "+", 
      "+\t\tbi->blockState = state;", 
      "+\t\tbi->sequenceNumber = sequenceNumber;", 
      "+", 
      "+\t\tT(YAFFS_TRACE_SCAN_DEBUG,", 
      "+\t\t  (TSTR(\"Block scanning block %d state %d seq %d\" TENDSTR), blk,", 
      "+\t\t   state, sequenceNumber));", 
      "+", 
      "+\t\tif (state == YAFFS_BLOCK_STATE_DEAD) {", 
      "+\t\t\tT(YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t\t  (TSTR(\"block %d is bad\" TENDSTR), blk));", 
      "+\t\t} else if (state == YAFFS_BLOCK_STATE_EMPTY) {", 
      "+\t\t\tT(YAFFS_TRACE_SCAN_DEBUG,", 
      "+\t\t\t  (TSTR(\"Block empty \" TENDSTR)));", 
      "+\t\t\tdev->nErasedBlocks++;", 
      "+\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tstartIterator = dev->internalStartBlock;", 
      "+\tendIterator = dev->internalEndBlock;", 
      "+", 
      "+\t/* For each block.... */", 
      "+\tfor (blockIterator = startIterator; !alloc_failed && blockIterator <= endIterator;", 
      "+\t     blockIterator++) {", 
      "+", 
      "+\t\tYYIELD();", 
      "+", 
      "+\t     \tYYIELD();", 
      "+", 
      "+\t\tblk = blockIterator;", 
      "+", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, blk);", 
      "+\t\tstate = bi->blockState;", 
      "+", 
      "+\t\tdeleted = 0;", 
      "+", 
      "+\t\t/* For each chunk in each block that needs scanning....*/", 
      "+\t\tfor (c = 0; !alloc_failed && c < dev->nChunksPerBlock &&", 
      "+\t\t     state == YAFFS_BLOCK_STATE_NEEDS_SCANNING; c++) {", 
      "+\t\t\t/* Read the tags and decide what to do */", 
      "+\t\t\tchunk = blk * dev->nChunksPerBlock + c;", 
      "+", 
      "+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,", 
      "+\t\t\t\t\t\t\t&tags);", 
      "+", 
      "+\t\t\t/* Let's have a good look at this chunk... */", 
      "+", 
      "+\t\t\tif (!dev->isYaffs2 && tags.chunkDeleted) {", 
      "+\t\t\t\t/* YAFFS1 only...", 
      "+\t\t\t\t * A deleted chunk", 
      "+\t\t\t\t */", 
      "+\t\t\t\tdeleted++;", 
      "+\t\t\t\tdev->nFreeChunks++;", 
      "+\t\t\t\t/*T((\" %d %d deleted\\n\",blk,c)); */", 
      "+\t\t\t} else if (!tags.chunkUsed) {", 
      "+\t\t\t\t/* An unassigned chunk in the block", 
      "+\t\t\t\t * This means that either the block is empty or", 
      "+\t\t\t\t * this is the one being allocated from", 
      "+\t\t\t\t */", 
      "+", 
      "+\t\t\t\tif (c == 0) {", 
      "+\t\t\t\t\t/* We're looking at the first chunk in the block so the block is unused */", 
      "+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t\t\t\t\tdev->nErasedBlocks++;", 
      "+\t\t\t\t} else {", 
      "+\t\t\t\t\t/* this is the block being allocated from */", 
      "+\t\t\t\t\tT(YAFFS_TRACE_SCAN,", 
      "+\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t   (\" Allocating from %d %d\" TENDSTR),", 
      "+\t\t\t\t\t   blk, c));", 
      "+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_ALLOCATING;", 
      "+\t\t\t\t\tdev->allocationBlock = blk;", 
      "+\t\t\t\t\tdev->allocationPage = c;", 
      "+\t\t\t\t\tdev->allocationBlockFinder = blk;", 
      "+\t\t\t\t\t/* Set it to here to encourage the allocator to go forth from here. */", 
      "+", 
      "+\t\t\t\t\t/* Yaffs2 sanity check:", 
      "+\t\t\t\t\t * This should be the one with the highest sequence number", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\tif (dev->isYaffs2", 
      "+\t\t\t\t\t    && (dev->sequenceNumber !=", 
      "+\t\t\t\t\t\tbi->sequenceNumber)) {", 
      "+\t\t\t\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t\t   (\"yaffs: Allocation block %d was not highest sequence id: block seq = %d, dev seq = %d\"", 
      "+\t\t\t\t\t\t    TENDSTR), blk,bi->sequenceNumber,dev->sequenceNumber));", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tdev->nFreeChunks += (dev->nChunksPerBlock - c);", 
      "+\t\t\t} else if (tags.chunkId > 0) {", 
      "+\t\t\t\t/* chunkId > 0 so it is a data chunk... */", 
      "+\t\t\t\tunsigned int endpos;", 
      "+", 
      "+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);", 
      "+\t\t\t\tbi->pagesInUse++;", 
      "+", 
      "+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,", 
      "+\t\t\t\t\t\t\t\t      tags.", 
      "+\t\t\t\t\t\t\t\t      objectId,", 
      "+\t\t\t\t\t\t\t\t      YAFFS_OBJECT_TYPE_FILE);", 
      "+\t\t\t\t/* PutChunkIntoFile checks for a clash (two data chunks with", 
      "+\t\t\t\t * the same chunkId).", 
      "+\t\t\t\t */", 
      "+", 
      "+\t\t\t\tif(!in)", 
      "+\t\t\t\t\talloc_failed = 1;", 
      "+", 
      "+\t\t\t\tif(in){", 
      "+\t\t\t\t\tif(!yaffs_PutChunkIntoFile(in, tags.chunkId, chunk,1))", 
      "+\t\t\t\t\t\talloc_failed = 1;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tendpos =", 
      "+\t\t\t\t    (tags.chunkId - 1) * dev->nDataBytesPerChunk +", 
      "+\t\t\t\t    tags.byteCount;", 
      "+\t\t\t\tif (in &&", 
      "+\t\t\t\t    in->variantType == YAFFS_OBJECT_TYPE_FILE", 
      "+\t\t\t\t    && in->variant.fileVariant.scannedFileSize <", 
      "+\t\t\t\t    endpos) {", 
      "+\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t    scannedFileSize = endpos;", 
      "+\t\t\t\t\tif (!dev->useHeaderFileSize) {", 
      "+\t\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t\t    fileSize =", 
      "+\t\t\t\t\t\t    in->variant.fileVariant.", 
      "+\t\t\t\t\t\t    scannedFileSize;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t}", 
      "+\t\t\t\t/* T((\" %d %d data %d %d\\n\",blk,c,tags.objectId,tags.chunkId));   */", 
      "+\t\t\t} else {", 
      "+\t\t\t\t/* chunkId == 0, so it is an ObjectHeader.", 
      "+\t\t\t\t * Thus, we read in the object header and make the object", 
      "+\t\t\t\t */", 
      "+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);", 
      "+\t\t\t\tbi->pagesInUse++;", 
      "+", 
      "+\t\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk,", 
      "+\t\t\t\t\t\t\t\tchunkData,", 
      "+\t\t\t\t\t\t\t\tNULL);", 
      "+", 
      "+\t\t\t\toh = (yaffs_ObjectHeader *) chunkData;", 
      "+", 
      "+\t\t\t\tin = yaffs_FindObjectByNumber(dev,", 
      "+\t\t\t\t\t\t\t      tags.objectId);", 
      "+\t\t\t\tif (in && in->variantType != oh->type) {", 
      "+\t\t\t\t\t/* This should not happen, but somehow", 
      "+\t\t\t\t\t * Wev'e ended up with an objectId that has been reused but not yet", 
      "+\t\t\t\t\t * deleted, and worse still it has changed type. Delete the old object.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tyaffs_DestroyObject(in);", 
      "+", 
      "+\t\t\t\t\tin = 0;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,", 
      "+\t\t\t\t\t\t\t\t      tags.", 
      "+\t\t\t\t\t\t\t\t      objectId,", 
      "+\t\t\t\t\t\t\t\t      oh->type);", 
      "+", 
      "+\t\t\t\tif(!in)", 
      "+\t\t\t\t\talloc_failed = 1;", 
      "+", 
      "+\t\t\t\tif (in && oh->shadowsObject > 0) {", 
      "+", 
      "+\t\t\t\t\tstruct yaffs_ShadowFixerStruct *fixer;", 
      "+\t\t\t\t\tfixer = YMALLOC(sizeof(struct yaffs_ShadowFixerStruct));", 
      "+\t\t\t\t\tif(fixer){", 
      "+\t\t\t\t\t\tfixer-> next = shadowFixerList;", 
      "+\t\t\t\t\t\tshadowFixerList = fixer;", 
      "+\t\t\t\t\t\tfixer->objectId = tags.objectId;", 
      "+\t\t\t\t\t\tfixer->shadowedId = oh->shadowsObject;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (in && in->valid) {", 
      "+\t\t\t\t\t/* We have already filled this one. We have a duplicate and need to resolve it. */", 
      "+", 
      "+\t\t\t\t\tunsigned existingSerial = in->serial;", 
      "+\t\t\t\t\tunsigned newSerial = tags.serialNumber;", 
      "+", 
      "+\t\t\t\t\tif (dev->isYaffs2 ||", 
      "+\t\t\t\t\t    ((existingSerial + 1) & 3) ==", 
      "+\t\t\t\t\t    newSerial) {", 
      "+\t\t\t\t\t\t/* Use new one - destroy the exisiting one */", 
      "+\t\t\t\t\t\tyaffs_DeleteChunk(dev,", 
      "+\t\t\t\t\t\t\t\t  in->hdrChunk,", 
      "+\t\t\t\t\t\t\t\t  1, __LINE__);", 
      "+\t\t\t\t\t\tin->valid = 0;", 
      "+\t\t\t\t\t} else {", 
      "+\t\t\t\t\t\t/* Use existing - destroy this one. */", 
      "+\t\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1,", 
      "+\t\t\t\t\t\t\t\t  __LINE__);", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (in && !in->valid &&", 
      "+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||", 
      "+\t\t\t\t     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND)) {", 
      "+\t\t\t\t\t/* We only load some info, don't fiddle with directory structure */", 
      "+\t\t\t\t\tin->valid = 1;", 
      "+\t\t\t\t\tin->variantType = oh->type;", 
      "+", 
      "+\t\t\t\t\tin->yst_mode = oh->yst_mode;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];", 
      "+\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];", 
      "+\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];", 
      "+\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];", 
      "+\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];", 
      "+\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];", 
      "+#else", 
      "+\t\t\t\t\tin->yst_uid = oh->yst_uid;", 
      "+\t\t\t\t\tin->yst_gid = oh->yst_gid;", 
      "+\t\t\t\t\tin->yst_atime = oh->yst_atime;", 
      "+\t\t\t\t\tin->yst_mtime = oh->yst_mtime;", 
      "+\t\t\t\t\tin->yst_ctime = oh->yst_ctime;", 
      "+\t\t\t\t\tin->yst_rdev = oh->yst_rdev;", 
      "+#endif", 
      "+\t\t\t\t\tin->hdrChunk = chunk;", 
      "+", 
      "+\t\t\t\t} else if (in && !in->valid) {", 
      "+\t\t\t\t\t/* we need to load this info */", 
      "+", 
      "+\t\t\t\t\tin->valid = 1;", 
      "+\t\t\t\t\tin->variantType = oh->type;", 
      "+", 
      "+\t\t\t\t\tin->yst_mode = oh->yst_mode;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];", 
      "+\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];", 
      "+\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];", 
      "+\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];", 
      "+\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];", 
      "+\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];", 
      "+#else", 
      "+\t\t\t\t\tin->yst_uid = oh->yst_uid;", 
      "+\t\t\t\t\tin->yst_gid = oh->yst_gid;", 
      "+\t\t\t\t\tin->yst_atime = oh->yst_atime;", 
      "+\t\t\t\t\tin->yst_mtime = oh->yst_mtime;", 
      "+\t\t\t\t\tin->yst_ctime = oh->yst_ctime;", 
      "+\t\t\t\t\tin->yst_rdev = oh->yst_rdev;", 
      "+#endif", 
      "+\t\t\t\t\tin->hdrChunk = chunk;", 
      "+", 
      "+\t\t\t\t\tyaffs_SetObjectName(in, oh->name);", 
      "+\t\t\t\t\tin->dirty = 0;", 
      "+", 
      "+\t\t\t\t\t/* directory stuff...", 
      "+\t\t\t\t\t * hook up to parent", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tparent =", 
      "+\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber", 
      "+\t\t\t\t\t    (dev, oh->parentObjectId,", 
      "+\t\t\t\t\t     YAFFS_OBJECT_TYPE_DIRECTORY);", 
      "+\t\t\t\t\tif (parent->variantType ==", 
      "+\t\t\t\t\t    YAFFS_OBJECT_TYPE_UNKNOWN) {", 
      "+                                                /* Set up as a directory */", 
      "+                                                parent->variantType =", 
      "+                                                    YAFFS_OBJECT_TYPE_DIRECTORY;", 
      "+                                                YINIT_LIST_HEAD(&parent->variant.", 
      "+                                                               directoryVariant.", 
      "+                                                               children);", 
      "+                                        } else if (parent->variantType !=", 
      "+\t\t\t\t\t\t   YAFFS_OBJECT_TYPE_DIRECTORY)", 
      "+\t\t\t\t\t{", 
      "+\t\t\t\t\t\t/* Hoosterman, another problem....", 
      "+\t\t\t\t\t\t * We're trying to use a non-directory as a directory", 
      "+\t\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t\t   (\"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found.\"", 
      "+\t\t\t\t\t\t    TENDSTR)));", 
      "+\t\t\t\t\t\tparent = dev->lostNFoundDir;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tyaffs_AddObjectToDirectory(parent, in);", 
      "+", 
      "+\t\t\t\t\tif (0 && (parent == dev->deletedDir ||", 
      "+\t\t\t\t\t\t  parent == dev->unlinkedDir)) {", 
      "+\t\t\t\t\t\tin->deleted = 1;\t/* If it is unlinked at start up then it wants deleting */", 
      "+\t\t\t\t\t\tdev->nDeletedFiles++;", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\t/* Note re hardlinks.", 
      "+\t\t\t\t\t * Since we might scan a hardlink before its equivalent object is scanned", 
      "+\t\t\t\t\t * we put them all in a list.", 
      "+\t\t\t\t\t * After scanning is complete, we should have all the objects, so we run through this", 
      "+\t\t\t\t\t * list and fix up all the chains.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tswitch (in->variantType) {", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\t\t\t\t\t/* Todo got a problem */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\t\t\t\t\tif (dev->isYaffs2", 
      "+\t\t\t\t\t\t    && oh->isShrink) {", 
      "+\t\t\t\t\t\t\t/* Prune back the shrunken chunks */", 
      "+\t\t\t\t\t\t\tyaffs_PruneResizedChunks", 
      "+\t\t\t\t\t\t\t    (in, oh->fileSize);", 
      "+\t\t\t\t\t\t\t/* Mark the block as having a shrinkHeader */", 
      "+\t\t\t\t\t\t\tbi->hasShrinkHeader = 1;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t\tif (dev->useHeaderFileSize)", 
      "+", 
      "+\t\t\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t\t\t    fileSize =", 
      "+\t\t\t\t\t\t\t    oh->fileSize;", 
      "+", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\t\t\t\t\tin->variant.hardLinkVariant.", 
      "+                                                    equivalentObjectId =", 
      "+                                                    oh->equivalentObjectId;", 
      "+                                                in->hardLinks.next =", 
      "+                                                    (struct ylist_head *)", 
      "+                                                    hardList;", 
      "+                                                hardList = in;", 
      "+                                                break;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\t\t\t\t\t/* Do nothing */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\t\t\t\t\t/* Do nothing */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\t\t\t\t\tin->variant.symLinkVariant.alias =", 
      "+\t\t\t\t\t\t    yaffs_CloneString(oh->alias);", 
      "+\t\t\t\t\t\tif(!in->variant.symLinkVariant.alias)", 
      "+\t\t\t\t\t\t\talloc_failed = 1;", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tif (parent == dev->deletedDir) {", 
      "+\t\t\t\t\t\tyaffs_DestroyObject(in);", 
      "+\t\t\t\t\t\tbi->hasShrinkHeader = 1;", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t}", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {", 
      "+\t\t\t/* If we got this far while scanning, then the block is fully allocated.*/", 
      "+\t\t\tstate = YAFFS_BLOCK_STATE_FULL;", 
      "+\t\t}", 
      "+", 
      "+\t\tbi->blockState = state;", 
      "+", 
      "+\t\t/* Now let's see if it was dirty */", 
      "+\t\tif (bi->pagesInUse == 0 &&", 
      "+\t\t    !bi->hasShrinkHeader &&", 
      "+\t\t    bi->blockState == YAFFS_BLOCK_STATE_FULL) {", 
      "+\t\t\tyaffs_BlockBecameDirty(dev, blk);", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+", 
      "+\t/* Ok, we've done all the scanning.", 
      "+\t * Fix up the hard link chains.", 
      "+\t * We should now have scanned all the objects, now it's time to add these", 
      "+\t * hardlinks.", 
      "+\t */", 
      "+", 
      "+\tyaffs_HardlinkFixup(dev,hardList);", 
      "+", 
      "+\t/* Handle the unlinked files. Since they were left in an unlinked state we should", 
      "+         * just delete them.", 
      "+         */", 
      "+        {", 
      "+                struct ylist_head *i;", 
      "+                struct ylist_head *n;", 
      "+", 
      "+                yaffs_Object *l;", 
      "+                /* Soft delete all the unlinked files */", 
      "+                ylist_for_each_safe(i, n,", 
      "+                                   &dev->unlinkedDir->variant.directoryVariant.", 
      "+                                   children) {", 
      "+                        if (i) {", 
      "+                                l = ylist_entry(i, yaffs_Object, siblings);", 
      "+                                yaffs_DestroyObject(l);", 
      "+                        }", 
      "+                }", 
      "+\t}", 
      "+", 
      "+\t/* Fix up any shadowed objects */", 
      "+\t{", 
      "+\t\tstruct yaffs_ShadowFixerStruct *fixer;", 
      "+\t\tyaffs_Object *obj;", 
      "+", 
      "+\t\twhile(shadowFixerList){", 
      "+\t\t\tfixer = shadowFixerList;", 
      "+\t\t\tshadowFixerList = fixer->next;", 
      "+\t\t\t/* Complete the rename transaction by deleting the shadowed object", 
      "+\t\t\t * then setting the object header to unshadowed.", 
      "+\t\t\t */", 
      "+\t\t\tobj = yaffs_FindObjectByNumber(dev,fixer->shadowedId);", 
      "+\t\t\tif(obj)", 
      "+\t\t\t\tyaffs_DestroyObject(obj);", 
      "+", 
      "+\t\t\tobj = yaffs_FindObjectByNumber(dev,fixer->objectId);", 
      "+\t\t\tif(obj){", 
      "+\t\t\t\tyaffs_UpdateObjectHeader(obj,NULL,1,0,0);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tYFREE(fixer);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tyaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);", 
      "+", 
      "+\tif(alloc_failed){", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_SCAN, (TSTR(\"yaffs_Scan ends\" TENDSTR)));", 
      "+", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+static void yaffs_CheckObjectDetailsLoaded(yaffs_Object *in)", 
      "+{", 
      "+\t__u8 *chunkData;", 
      "+\tyaffs_ObjectHeader *oh;", 
      "+\tyaffs_Device *dev = in->myDev;", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tint result;", 
      "+\tint alloc_failed = 0;", 
      "+", 
      "+\tif(!in)", 
      "+\t\treturn;", 
      "+", 
      "+#if 0", 
      "+\tT(YAFFS_TRACE_SCAN,(TSTR(\"details for object %d %s loaded\" TENDSTR),", 
      "+\t\tin->objectId,", 
      "+\t\tin->lazyLoaded ? \"not yet\" : \"already\"));", 
      "+#endif", 
      "+", 
      "+\tif(in->lazyLoaded && in->hdrChunk > 0){", 
      "+\t\tin->lazyLoaded = 0;", 
      "+\t\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev,in->hdrChunk,chunkData,&tags);", 
      "+\t\toh = (yaffs_ObjectHeader *) chunkData;", 
      "+", 
      "+\t\tin->yst_mode = oh->yst_mode;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\tin->win_atime[0] = oh->win_atime[0];", 
      "+\t\tin->win_ctime[0] = oh->win_ctime[0];", 
      "+\t\tin->win_mtime[0] = oh->win_mtime[0];", 
      "+\t\tin->win_atime[1] = oh->win_atime[1];", 
      "+\t\tin->win_ctime[1] = oh->win_ctime[1];", 
      "+\t\tin->win_mtime[1] = oh->win_mtime[1];", 
      "+#else", 
      "+\t\tin->yst_uid = oh->yst_uid;", 
      "+\t\tin->yst_gid = oh->yst_gid;", 
      "+\t\tin->yst_atime = oh->yst_atime;", 
      "+\t\tin->yst_mtime = oh->yst_mtime;", 
      "+\t\tin->yst_ctime = oh->yst_ctime;", 
      "+\t\tin->yst_rdev = oh->yst_rdev;", 
      "+", 
      "+#endif", 
      "+\t\tyaffs_SetObjectName(in, oh->name);", 
      "+", 
      "+\t\tif(in->variantType == YAFFS_OBJECT_TYPE_SYMLINK){", 
      "+\t\t\t in->variant.symLinkVariant.alias =", 
      "+\t\t\t\t\t\t    yaffs_CloneString(oh->alias);", 
      "+\t\t\tif(!in->variant.symLinkVariant.alias)", 
      "+\t\t\t\talloc_failed = 1; /* Not returned to caller */", 
      "+\t\t}", 
      "+", 
      "+\t\tyaffs_ReleaseTempBuffer(dev,chunkData, __LINE__);", 
      "+\t}", 
      "+}", 
      "+", 
      "+static int yaffs_ScanBackwards(yaffs_Device * dev)", 
      "+{", 
      "+\tyaffs_ExtendedTags tags;", 
      "+\tint blk;", 
      "+\tint blockIterator;", 
      "+\tint startIterator;", 
      "+\tint endIterator;", 
      "+\tint nBlocksToScan = 0;", 
      "+", 
      "+\tint chunk;", 
      "+\tint result;", 
      "+\tint c;", 
      "+\tint deleted;", 
      "+\tyaffs_BlockState state;", 
      "+\tyaffs_Object *hardList = NULL;", 
      "+\tyaffs_BlockInfo *bi;", 
      "+\t__u32 sequenceNumber;", 
      "+\tyaffs_ObjectHeader *oh;", 
      "+\tyaffs_Object *in;", 
      "+\tyaffs_Object *parent;", 
      "+\tint nBlocks = dev->internalEndBlock - dev->internalStartBlock + 1;", 
      "+\tint itsUnlinked;", 
      "+\t__u8 *chunkData;", 
      "+", 
      "+\tint fileSize;", 
      "+\tint isShrink;", 
      "+\tint foundChunksInBlock;", 
      "+\tint equivalentObjectId;", 
      "+\tint alloc_failed = 0;", 
      "+", 
      "+", 
      "+\tyaffs_BlockIndex *blockIndex = NULL;", 
      "+\tint altBlockIndex = 0;", 
      "+", 
      "+\tif (!dev->isYaffs2) {", 
      "+\t\tT(YAFFS_TRACE_SCAN,", 
      "+\t\t  (TSTR(\"yaffs_ScanBackwards is only for YAFFS2!\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_SCAN,", 
      "+\t  (TSTR", 
      "+\t   (\"yaffs_ScanBackwards starts  intstartblk %d intendblk %d...\"", 
      "+\t    TENDSTR), dev->internalStartBlock, dev->internalEndBlock));", 
      "+", 
      "+", 
      "+\tdev->sequenceNumber = YAFFS_LOWEST_SEQUENCE_NUMBER;", 
      "+", 
      "+\tblockIndex = YMALLOC(nBlocks * sizeof(yaffs_BlockIndex));", 
      "+", 
      "+\tif(!blockIndex) {", 
      "+\t\tblockIndex = YMALLOC_ALT(nBlocks * sizeof(yaffs_BlockIndex));", 
      "+\t\taltBlockIndex = 1;", 
      "+\t}", 
      "+", 
      "+\tif(!blockIndex) {", 
      "+\t\tT(YAFFS_TRACE_SCAN,", 
      "+\t\t  (TSTR(\"yaffs_Scan() could not allocate block index!\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tdev->blocksInCheckpoint = 0;", 
      "+", 
      "+\tchunkData = yaffs_GetTempBuffer(dev, __LINE__);", 
      "+", 
      "+\t/* Scan all the blocks to determine their state */", 
      "+\tfor (blk = dev->internalStartBlock; blk <= dev->internalEndBlock; blk++) {", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, blk);", 
      "+\t\tyaffs_ClearChunkBits(dev, blk);", 
      "+\t\tbi->pagesInUse = 0;", 
      "+\t\tbi->softDeletions = 0;", 
      "+", 
      "+\t\tyaffs_QueryInitialBlockState(dev, blk, &state, &sequenceNumber);", 
      "+", 
      "+\t\tbi->blockState = state;", 
      "+\t\tbi->sequenceNumber = sequenceNumber;", 
      "+", 
      "+\t\tif(bi->sequenceNumber == YAFFS_SEQUENCE_CHECKPOINT_DATA)", 
      "+\t\t\tbi->blockState = state = YAFFS_BLOCK_STATE_CHECKPOINT;", 
      "+", 
      "+\t\tT(YAFFS_TRACE_SCAN_DEBUG,", 
      "+\t\t  (TSTR(\"Block scanning block %d state %d seq %d\" TENDSTR), blk,", 
      "+\t\t   state, sequenceNumber));", 
      "+", 
      "+", 
      "+\t\tif(state == YAFFS_BLOCK_STATE_CHECKPOINT){", 
      "+\t\t\tdev->blocksInCheckpoint++;", 
      "+", 
      "+\t\t} else if (state == YAFFS_BLOCK_STATE_DEAD) {", 
      "+\t\t\tT(YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t\t  (TSTR(\"block %d is bad\" TENDSTR), blk));", 
      "+\t\t} else if (state == YAFFS_BLOCK_STATE_EMPTY) {", 
      "+\t\t\tT(YAFFS_TRACE_SCAN_DEBUG,", 
      "+\t\t\t  (TSTR(\"Block empty \" TENDSTR)));", 
      "+\t\t\tdev->nErasedBlocks++;", 
      "+\t\t\tdev->nFreeChunks += dev->nChunksPerBlock;", 
      "+\t\t} else if (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {", 
      "+", 
      "+\t\t\t/* Determine the highest sequence number */", 
      "+\t\t\tif (dev->isYaffs2 &&", 
      "+\t\t\t    sequenceNumber >= YAFFS_LOWEST_SEQUENCE_NUMBER &&", 
      "+\t\t\t    sequenceNumber < YAFFS_HIGHEST_SEQUENCE_NUMBER) {", 
      "+", 
      "+\t\t\t\tblockIndex[nBlocksToScan].seq = sequenceNumber;", 
      "+\t\t\t\tblockIndex[nBlocksToScan].block = blk;", 
      "+", 
      "+\t\t\t\tnBlocksToScan++;", 
      "+", 
      "+\t\t\t\tif (sequenceNumber >= dev->sequenceNumber) {", 
      "+\t\t\t\t\tdev->sequenceNumber = sequenceNumber;", 
      "+\t\t\t\t}", 
      "+\t\t\t} else if (dev->isYaffs2) {", 
      "+\t\t\t\t/* TODO: Nasty sequence number! */", 
      "+\t\t\t\tT(YAFFS_TRACE_SCAN,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"Block scanning block %d has bad sequence number %d\"", 
      "+\t\t\t\t    TENDSTR), blk, sequenceNumber));", 
      "+", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_SCAN,", 
      "+\t(TSTR(\"%d blocks to be sorted...\" TENDSTR), nBlocksToScan));", 
      "+", 
      "+", 
      "+", 
      "+\tYYIELD();", 
      "+", 
      "+\t/* Sort the blocks */", 
      "+#ifndef CONFIG_YAFFS_USE_OWN_SORT", 
      "+\t{", 
      "+\t\t/* Use qsort now. */", 
      "+\t\tyaffs_qsort(blockIndex, nBlocksToScan, sizeof(yaffs_BlockIndex), ybicmp);", 
      "+\t}", 
      "+#else", 
      "+\t{", 
      "+\t \t/* Dungy old bubble sort... */", 
      "+", 
      "+\t\tyaffs_BlockIndex temp;", 
      "+\t\tint i;", 
      "+\t\tint j;", 
      "+", 
      "+\t\tfor (i = 0; i < nBlocksToScan; i++)", 
      "+\t\t\tfor (j = i + 1; j < nBlocksToScan; j++)", 
      "+\t\t\t\tif (blockIndex[i].seq > blockIndex[j].seq) {", 
      "+\t\t\t\t\ttemp = blockIndex[j];", 
      "+\t\t\t\t\tblockIndex[j] = blockIndex[i];", 
      "+\t\t\t\t\tblockIndex[i] = temp;", 
      "+\t\t\t\t}", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tYYIELD();", 
      "+", 
      "+    \tT(YAFFS_TRACE_SCAN, (TSTR(\"...done\" TENDSTR)));", 
      "+", 
      "+\t/* Now scan the blocks looking at the data. */", 
      "+\tstartIterator = 0;", 
      "+\tendIterator = nBlocksToScan - 1;", 
      "+\tT(YAFFS_TRACE_SCAN_DEBUG,", 
      "+\t  (TSTR(\"%d blocks to be scanned\" TENDSTR), nBlocksToScan));", 
      "+", 
      "+\t/* For each block.... backwards */", 
      "+\tfor (blockIterator = endIterator; !alloc_failed && blockIterator >= startIterator;", 
      "+\t     blockIterator--) {", 
      "+\t        /* Cooperative multitasking! This loop can run for so", 
      "+\t\t   long that watchdog timers expire. */", 
      "+\t        YYIELD();", 
      "+", 
      "+\t\t/* get the block to scan in the correct order */", 
      "+\t\tblk = blockIndex[blockIterator].block;", 
      "+", 
      "+\t\tbi = yaffs_GetBlockInfo(dev, blk);", 
      "+", 
      "+", 
      "+\t\tstate = bi->blockState;", 
      "+", 
      "+\t\tdeleted = 0;", 
      "+", 
      "+\t\t/* For each chunk in each block that needs scanning.... */", 
      "+\t\tfoundChunksInBlock = 0;", 
      "+\t\tfor (c = dev->nChunksPerBlock - 1;", 
      "+\t\t     !alloc_failed && c >= 0 &&", 
      "+\t\t     (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||", 
      "+\t\t      state == YAFFS_BLOCK_STATE_ALLOCATING); c--) {", 
      "+\t\t\t/* Scan backwards...", 
      "+\t\t\t * Read the tags and decide what to do", 
      "+\t\t\t */", 
      "+", 
      "+\t\t\tchunk = blk * dev->nChunksPerBlock + c;", 
      "+", 
      "+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev, chunk, NULL,", 
      "+\t\t\t\t\t\t\t&tags);", 
      "+", 
      "+\t\t\t/* Let's have a good look at this chunk... */", 
      "+", 
      "+\t\t\tif (!tags.chunkUsed) {", 
      "+\t\t\t\t/* An unassigned chunk in the block.", 
      "+\t\t\t\t * If there are used chunks after this one, then", 
      "+\t\t\t\t * it is a chunk that was skipped due to failing the erased", 
      "+\t\t\t\t * check. Just skip it so that it can be deleted.", 
      "+\t\t\t\t * But, more typically, We get here when this is an unallocated", 
      "+\t\t\t\t * chunk and his means that either the block is empty or", 
      "+\t\t\t\t * this is the one being allocated from", 
      "+\t\t\t\t */", 
      "+", 
      "+\t\t\t\tif(foundChunksInBlock)", 
      "+\t\t\t\t{", 
      "+\t\t\t\t\t/* This is a chunk that was skipped due to failing the erased check */", 
      "+", 
      "+\t\t\t\t} else if (c == 0) {", 
      "+\t\t\t\t\t/* We're looking at the first chunk in the block so the block is unused */", 
      "+\t\t\t\t\tstate = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t\t\t\t\tdev->nErasedBlocks++;", 
      "+\t\t\t\t} else {", 
      "+\t\t\t\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING ||", 
      "+\t\t\t\t\t    state == YAFFS_BLOCK_STATE_ALLOCATING) {", 
      "+\t\t\t\t\t    \tif(dev->sequenceNumber == bi->sequenceNumber) {", 
      "+\t\t\t\t\t\t\t/* this is the block being allocated from */", 
      "+", 
      "+\t\t\t\t\t\t\tT(YAFFS_TRACE_SCAN,", 
      "+\t\t\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t\t\t   (\" Allocating from %d %d\"", 
      "+\t\t\t\t\t\t\t    TENDSTR), blk, c));", 
      "+", 
      "+\t\t\t\t\t\t\tstate = YAFFS_BLOCK_STATE_ALLOCATING;", 
      "+\t\t\t\t\t\t\tdev->allocationBlock = blk;", 
      "+\t\t\t\t\t\t\tdev->allocationPage = c;", 
      "+\t\t\t\t\t\t\tdev->allocationBlockFinder = blk;", 
      "+\t\t\t\t\t\t}", 
      "+\t\t\t\t\t\telse {", 
      "+\t\t\t\t\t\t\t/* This is a partially written block that is not", 
      "+\t\t\t\t\t\t\t * the current allocation block. This block must have", 
      "+\t\t\t\t\t\t\t * had a write failure, so set up for retirement.", 
      "+\t\t\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\t\t\t bi->needsRetiring = 1;", 
      "+\t\t\t\t\t\t\t bi->gcPrioritise = 1;", 
      "+", 
      "+\t\t\t\t\t\t\t T(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t\t\t\t\t (TSTR(\"Partially written block %d being set for retirement\" TENDSTR),", 
      "+\t\t\t\t\t\t\t blk));", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tdev->nFreeChunks++;", 
      "+", 
      "+\t\t\t} else if (tags.chunkId > 0) {", 
      "+\t\t\t\t/* chunkId > 0 so it is a data chunk... */", 
      "+\t\t\t\tunsigned int endpos;", 
      "+\t\t\t\t__u32 chunkBase =", 
      "+\t\t\t\t    (tags.chunkId - 1) * dev->nDataBytesPerChunk;", 
      "+", 
      "+\t\t\t\tfoundChunksInBlock = 1;", 
      "+", 
      "+", 
      "+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);", 
      "+\t\t\t\tbi->pagesInUse++;", 
      "+", 
      "+\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev,", 
      "+\t\t\t\t\t\t\t\t      tags.", 
      "+\t\t\t\t\t\t\t\t      objectId,", 
      "+\t\t\t\t\t\t\t\t      YAFFS_OBJECT_TYPE_FILE);", 
      "+\t\t\t\tif(!in){", 
      "+\t\t\t\t\t/* Out of memory */", 
      "+\t\t\t\t\talloc_failed = 1;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (in &&", 
      "+\t\t\t\t    in->variantType == YAFFS_OBJECT_TYPE_FILE", 
      "+\t\t\t\t    && chunkBase <", 
      "+\t\t\t\t    in->variant.fileVariant.shrinkSize) {", 
      "+\t\t\t\t\t/* This has not been invalidated by a resize */", 
      "+\t\t\t\t\tif(!yaffs_PutChunkIntoFile(in, tags.chunkId,", 
      "+\t\t\t\t\t\t\t       chunk, -1)){", 
      "+\t\t\t\t\t\talloc_failed = 1;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t/* File size is calculated by looking at the data chunks if we have not", 
      "+\t\t\t\t\t * seen an object header yet. Stop this practice once we find an object header.", 
      "+\t\t\t\t\t */", 
      "+\t\t\t\t\tendpos =", 
      "+\t\t\t\t\t    (tags.chunkId -", 
      "+\t\t\t\t\t     1) * dev->nDataBytesPerChunk +", 
      "+\t\t\t\t\t    tags.byteCount;", 
      "+", 
      "+\t\t\t\t\tif (!in->valid &&\t/* have not got an object header yet */", 
      "+\t\t\t\t\t    in->variant.fileVariant.", 
      "+\t\t\t\t\t    scannedFileSize < endpos) {", 
      "+\t\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t\t    scannedFileSize = endpos;", 
      "+\t\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t\t    fileSize =", 
      "+\t\t\t\t\t\t    in->variant.fileVariant.", 
      "+\t\t\t\t\t\t    scannedFileSize;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t} else if(in) {", 
      "+\t\t\t\t\t/* This chunk has been invalidated by a resize, so delete */", 
      "+\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);", 
      "+", 
      "+\t\t\t\t}", 
      "+\t\t\t} else {", 
      "+\t\t\t\t/* chunkId == 0, so it is an ObjectHeader.", 
      "+\t\t\t\t * Thus, we read in the object header and make the object", 
      "+\t\t\t\t */", 
      "+\t\t\t\tfoundChunksInBlock = 1;", 
      "+", 
      "+\t\t\t\tyaffs_SetChunkBit(dev, blk, c);", 
      "+\t\t\t\tbi->pagesInUse++;", 
      "+", 
      "+\t\t\t\toh = NULL;", 
      "+\t\t\t\tin = NULL;", 
      "+", 
      "+\t\t\t\tif (tags.extraHeaderInfoAvailable) {", 
      "+\t\t\t\t\tin = yaffs_FindOrCreateObjectByNumber", 
      "+\t\t\t\t\t    (dev, tags.objectId,", 
      "+\t\t\t\t\t     tags.extraObjectType);", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (!in ||", 
      "+#ifdef CONFIG_YAFFS_DISABLE_LAZY_LOAD", 
      "+\t\t\t\t    !in->valid ||", 
      "+#endif", 
      "+\t\t\t\t    tags.extraShadows ||", 
      "+\t\t\t\t    (!in->valid &&", 
      "+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||", 
      "+\t\t\t\t     tags.objectId == YAFFS_OBJECTID_LOSTNFOUND))", 
      "+\t\t\t\t    ) {", 
      "+", 
      "+\t\t\t\t\t/* If we don't have  valid info then we need to read the chunk", 
      "+\t\t\t\t\t * TODO In future we can probably defer reading the chunk and", 
      "+\t\t\t\t\t * living with invalid data until needed.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(dev,", 
      "+\t\t\t\t\t\t\t\t\tchunk,", 
      "+\t\t\t\t\t\t\t\t\tchunkData,", 
      "+\t\t\t\t\t\t\t\t\tNULL);", 
      "+", 
      "+\t\t\t\t\toh = (yaffs_ObjectHeader *) chunkData;", 
      "+", 
      "+\t\t\t\t\tif(dev->inbandTags){", 
      "+\t\t\t\t\t\t/* Fix up the header if they got corrupted by inband tags */", 
      "+\t\t\t\t\t\toh->shadowsObject = oh->inbandShadowsObject;", 
      "+\t\t\t\t\t\toh->isShrink = oh->inbandIsShrink;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tif (!in)", 
      "+\t\t\t\t\t\tin = yaffs_FindOrCreateObjectByNumber(dev, tags.objectId, oh->type);", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (!in) {", 
      "+\t\t\t\t\t/* TODO Hoosterman we have a problem! */", 
      "+\t\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t   (\"yaffs tragedy: Could not make object for object  %d at chunk %d during scan\"", 
      "+\t\t\t\t\t    TENDSTR), tags.objectId, chunk));", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (in->valid) {", 
      "+\t\t\t\t\t/* We have already filled this one.", 
      "+\t\t\t\t\t * We have a duplicate that will be discarded, but", 
      "+\t\t\t\t\t * we first have to suck out resize info if it is a file.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tif ((in->variantType == YAFFS_OBJECT_TYPE_FILE) &&", 
      "+\t\t\t\t\t     ((oh &&", 
      "+\t\t\t\t\t       oh-> type == YAFFS_OBJECT_TYPE_FILE)||", 
      "+\t\t\t\t\t      (tags.extraHeaderInfoAvailable  &&", 
      "+\t\t\t\t\t       tags.extraObjectType == YAFFS_OBJECT_TYPE_FILE))", 
      "+\t\t\t\t\t    ) {", 
      "+\t\t\t\t\t\t__u32 thisSize =", 
      "+\t\t\t\t\t\t    (oh) ? oh->fileSize : tags.", 
      "+\t\t\t\t\t\t    extraFileLength;", 
      "+\t\t\t\t\t\t__u32 parentObjectId =", 
      "+\t\t\t\t\t\t    (oh) ? oh->", 
      "+\t\t\t\t\t\t    parentObjectId : tags.", 
      "+\t\t\t\t\t\t    extraParentObjectId;", 
      "+\t\t\t\t\t\tunsigned isShrink =", 
      "+\t\t\t\t\t\t    (oh) ? oh->isShrink : tags.", 
      "+\t\t\t\t\t\t    extraIsShrinkHeader;", 
      "+", 
      "+\t\t\t\t\t\t/* If it is deleted (unlinked at start also means deleted)", 
      "+\t\t\t\t\t\t * we treat the file size as being zeroed at this point.", 
      "+\t\t\t\t\t\t */", 
      "+\t\t\t\t\t\tif (parentObjectId ==", 
      "+\t\t\t\t\t\t    YAFFS_OBJECTID_DELETED", 
      "+\t\t\t\t\t\t    || parentObjectId ==", 
      "+\t\t\t\t\t\t    YAFFS_OBJECTID_UNLINKED) {", 
      "+\t\t\t\t\t\t\tthisSize = 0;", 
      "+\t\t\t\t\t\t\tisShrink = 1;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t\tif (isShrink &&", 
      "+\t\t\t\t\t\t    in->variant.fileVariant.", 
      "+\t\t\t\t\t\t    shrinkSize > thisSize) {", 
      "+\t\t\t\t\t\t\tin->variant.fileVariant.", 
      "+\t\t\t\t\t\t\t    shrinkSize =", 
      "+\t\t\t\t\t\t\t    thisSize;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t\tif (isShrink) {", 
      "+\t\t\t\t\t\t\tbi->hasShrinkHeader = 1;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\t/* Use existing - destroy this one. */", 
      "+\t\t\t\t\tyaffs_DeleteChunk(dev, chunk, 1, __LINE__);", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t\tif (!in->valid &&", 
      "+\t\t\t\t    (tags.objectId == YAFFS_OBJECTID_ROOT ||", 
      "+\t\t\t\t     tags.objectId ==", 
      "+\t\t\t\t     YAFFS_OBJECTID_LOSTNFOUND)) {", 
      "+\t\t\t\t\t/* We only load some info, don't fiddle with directory structure */", 
      "+\t\t\t\t\tin->valid = 1;", 
      "+", 
      "+\t\t\t\t\tif(oh) {", 
      "+\t\t\t\t\t\tin->variantType = oh->type;", 
      "+", 
      "+\t\t\t\t\t\tin->yst_mode = oh->yst_mode;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];", 
      "+\t\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];", 
      "+\t\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];", 
      "+\t\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];", 
      "+\t\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];", 
      "+\t\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];", 
      "+#else", 
      "+\t\t\t\t\t\tin->yst_uid = oh->yst_uid;", 
      "+\t\t\t\t\t\tin->yst_gid = oh->yst_gid;", 
      "+\t\t\t\t\t\tin->yst_atime = oh->yst_atime;", 
      "+\t\t\t\t\t\tin->yst_mtime = oh->yst_mtime;", 
      "+\t\t\t\t\t\tin->yst_ctime = oh->yst_ctime;", 
      "+\t\t\t\t\t\tin->yst_rdev = oh->yst_rdev;", 
      "+", 
      "+#endif", 
      "+\t\t\t\t\t} else {", 
      "+\t\t\t\t\t\tin->variantType = tags.extraObjectType;", 
      "+\t\t\t\t\t\tin->lazyLoaded = 1;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tin->hdrChunk = chunk;", 
      "+", 
      "+\t\t\t\t} else if (!in->valid) {", 
      "+\t\t\t\t\t/* we need to load this info */", 
      "+", 
      "+\t\t\t\t\tin->valid = 1;", 
      "+\t\t\t\t\tin->hdrChunk = chunk;", 
      "+", 
      "+\t\t\t\t\tif(oh) {", 
      "+\t\t\t\t\t\tin->variantType = oh->type;", 
      "+", 
      "+\t\t\t\t\t\tin->yst_mode = oh->yst_mode;", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t\t\t\t\t\tin->win_atime[0] = oh->win_atime[0];", 
      "+\t\t\t\t\t\tin->win_ctime[0] = oh->win_ctime[0];", 
      "+\t\t\t\t\t\tin->win_mtime[0] = oh->win_mtime[0];", 
      "+\t\t\t\t\t\tin->win_atime[1] = oh->win_atime[1];", 
      "+\t\t\t\t\t\tin->win_ctime[1] = oh->win_ctime[1];", 
      "+\t\t\t\t\t\tin->win_mtime[1] = oh->win_mtime[1];", 
      "+#else", 
      "+\t\t\t\t\t\tin->yst_uid = oh->yst_uid;", 
      "+\t\t\t\t\t\tin->yst_gid = oh->yst_gid;", 
      "+\t\t\t\t\t\tin->yst_atime = oh->yst_atime;", 
      "+\t\t\t\t\t\tin->yst_mtime = oh->yst_mtime;", 
      "+\t\t\t\t\t\tin->yst_ctime = oh->yst_ctime;", 
      "+\t\t\t\t\t\tin->yst_rdev = oh->yst_rdev;", 
      "+#endif", 
      "+", 
      "+\t\t\t\t\t\tif (oh->shadowsObject > 0)", 
      "+\t\t\t\t\t\t\tyaffs_HandleShadowedObject(dev,", 
      "+\t\t\t\t\t\t\t\t\t   oh->", 
      "+\t\t\t\t\t\t\t\t\t   shadowsObject,", 
      "+\t\t\t\t\t\t\t\t\t   1);", 
      "+", 
      "+", 
      "+\t\t\t\t\t\tyaffs_SetObjectName(in, oh->name);", 
      "+\t\t\t\t\t\tparent =", 
      "+\t\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber", 
      "+\t\t\t\t\t    \t\t(dev, oh->parentObjectId,", 
      "+\t\t\t\t\t     \t\t YAFFS_OBJECT_TYPE_DIRECTORY);", 
      "+", 
      "+\t\t\t\t\t\t fileSize = oh->fileSize;", 
      "+ \t\t\t\t\t\t isShrink = oh->isShrink;", 
      "+\t\t\t\t\t\t equivalentObjectId = oh->equivalentObjectId;", 
      "+", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\telse {", 
      "+\t\t\t\t\t\tin->variantType = tags.extraObjectType;", 
      "+\t\t\t\t\t\tparent =", 
      "+\t\t\t\t\t\t    yaffs_FindOrCreateObjectByNumber", 
      "+\t\t\t\t\t    \t\t(dev, tags.extraParentObjectId,", 
      "+\t\t\t\t\t     \t\t YAFFS_OBJECT_TYPE_DIRECTORY);", 
      "+\t\t\t\t\t\t fileSize = tags.extraFileLength;", 
      "+\t\t\t\t\t\t isShrink = tags.extraIsShrinkHeader;", 
      "+\t\t\t\t\t\t equivalentObjectId = tags.extraEquivalentObjectId;", 
      "+\t\t\t\t\t\tin->lazyLoaded = 1;", 
      "+", 
      "+\t\t\t\t\t}", 
      "+\t\t\t\t\tin->dirty = 0;", 
      "+", 
      "+\t\t\t\t\t/* directory stuff...", 
      "+\t\t\t\t\t * hook up to parent", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tif (parent->variantType ==", 
      "+\t\t\t\t\t    YAFFS_OBJECT_TYPE_UNKNOWN) {", 
      "+                                                /* Set up as a directory */", 
      "+                                                parent->variantType =", 
      "+                                                    YAFFS_OBJECT_TYPE_DIRECTORY;", 
      "+                                                YINIT_LIST_HEAD(&parent->variant.", 
      "+                                                               directoryVariant.", 
      "+                                                               children);", 
      "+                                        } else if (parent->variantType !=", 
      "+\t\t\t\t\t\t   YAFFS_OBJECT_TYPE_DIRECTORY)", 
      "+\t\t\t\t\t{", 
      "+\t\t\t\t\t\t/* Hoosterman, another problem....", 
      "+\t\t\t\t\t\t * We're trying to use a non-directory as a directory", 
      "+\t\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t\t\t  (TSTR", 
      "+\t\t\t\t\t\t   (\"yaffs tragedy: attempting to use non-directory as a directory in scan. Put in lost+found.\"", 
      "+\t\t\t\t\t\t    TENDSTR)));", 
      "+\t\t\t\t\t\tparent = dev->lostNFoundDir;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\tyaffs_AddObjectToDirectory(parent, in);", 
      "+", 
      "+\t\t\t\t\titsUnlinked = (parent == dev->deletedDir) ||", 
      "+\t\t\t\t\t\t      (parent == dev->unlinkedDir);", 
      "+", 
      "+\t\t\t\t\tif (isShrink) {", 
      "+\t\t\t\t\t\t/* Mark the block as having a shrinkHeader */", 
      "+\t\t\t\t\t\tbi->hasShrinkHeader = 1;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t/* Note re hardlinks.", 
      "+\t\t\t\t\t * Since we might scan a hardlink before its equivalent object is scanned", 
      "+\t\t\t\t\t * we put them all in a list.", 
      "+\t\t\t\t\t * After scanning is complete, we should have all the objects, so we run", 
      "+\t\t\t\t\t * through this list and fix up all the chains.", 
      "+\t\t\t\t\t */", 
      "+", 
      "+\t\t\t\t\tswitch (in->variantType) {", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_UNKNOWN:", 
      "+\t\t\t\t\t\t/* Todo got a problem */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+", 
      "+\t\t\t\t\t\tif (in->variant.fileVariant.", 
      "+\t\t\t\t\t\t    scannedFileSize < fileSize) {", 
      "+\t\t\t\t\t\t\t/* This covers the case where the file size is greater", 
      "+\t\t\t\t\t\t\t * than where the data is", 
      "+\t\t\t\t\t\t\t * This will happen if the file is resized to be larger", 
      "+\t\t\t\t\t\t\t * than its current data extents.", 
      "+\t\t\t\t\t\t\t */", 
      "+\t\t\t\t\t\t\tin->variant.fileVariant.fileSize = fileSize;", 
      "+\t\t\t\t\t\t\tin->variant.fileVariant.scannedFileSize =", 
      "+\t\t\t\t\t\t\t    in->variant.fileVariant.fileSize;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t\tif (isShrink &&", 
      "+\t\t\t\t\t\t    in->variant.fileVariant.shrinkSize > fileSize) {", 
      "+\t\t\t\t\t\t\tin->variant.fileVariant.shrinkSize = fileSize;", 
      "+\t\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\t\t\t\t\tif(!itsUnlinked) {", 
      "+                                                  in->variant.hardLinkVariant.equivalentObjectId =", 
      "+                                                    equivalentObjectId;", 
      "+                                                  in->hardLinks.next =", 
      "+                                                    (struct ylist_head *) hardList;", 
      "+                                                  hardList = in;", 
      "+                                                }", 
      "+                                                break;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\t\t\t\t\t/* Do nothing */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\t\t\t\t\t/* Do nothing */", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\t\t\t\t\tif(oh){", 
      "+\t\t\t\t\t\t   in->variant.symLinkVariant.alias =", 
      "+\t\t\t\t\t\t    yaffs_CloneString(oh->", 
      "+\t\t\t\t\t\t\t\t      alias);", 
      "+\t\t\t\t\t\t   if(!in->variant.symLinkVariant.alias)", 
      "+\t\t\t\t\t\t   \talloc_failed = 1;", 
      "+\t\t\t\t\t\t}", 
      "+\t\t\t\t\t\tbreak;", 
      "+\t\t\t\t\t}", 
      "+", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t}", 
      "+", 
      "+\t\t} /* End of scanning for each chunk */", 
      "+", 
      "+\t\tif (state == YAFFS_BLOCK_STATE_NEEDS_SCANNING) {", 
      "+\t\t\t/* If we got this far while scanning, then the block is fully allocated. */", 
      "+\t\t\tstate = YAFFS_BLOCK_STATE_FULL;", 
      "+\t\t}", 
      "+", 
      "+\t\tbi->blockState = state;", 
      "+", 
      "+\t\t/* Now let's see if it was dirty */", 
      "+\t\tif (bi->pagesInUse == 0 &&", 
      "+\t\t    !bi->hasShrinkHeader &&", 
      "+\t\t    bi->blockState == YAFFS_BLOCK_STATE_FULL) {", 
      "+\t\t\tyaffs_BlockBecameDirty(dev, blk);", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\tif (altBlockIndex)", 
      "+\t\tYFREE_ALT(blockIndex);", 
      "+\telse", 
      "+\t\tYFREE(blockIndex);", 
      "+", 
      "+\t/* Ok, we've done all the scanning.", 
      "+\t * Fix up the hard link chains.", 
      "+\t * We should now have scanned all the objects, now it's time to add these", 
      "+\t * hardlinks.", 
      "+\t */", 
      "+\tyaffs_HardlinkFixup(dev,hardList);", 
      "+", 
      "+", 
      "+\t/*", 
      "+        *  Sort out state of unlinked and deleted objects.", 
      "+        */", 
      "+        {", 
      "+                struct ylist_head *i;", 
      "+                struct ylist_head *n;", 
      "+", 
      "+                yaffs_Object *l;", 
      "+", 
      "+                /* Soft delete all the unlinked files */", 
      "+                ylist_for_each_safe(i, n,", 
      "+                                   &dev->unlinkedDir->variant.directoryVariant.", 
      "+                                   children) {", 
      "+                        if (i) {", 
      "+                                l = ylist_entry(i, yaffs_Object, siblings);", 
      "+                                yaffs_DestroyObject(l);", 
      "+                        }", 
      "+                }", 
      "+", 
      "+                /* Soft delete all the deletedDir files */", 
      "+                ylist_for_each_safe(i, n,", 
      "+                                   &dev->deletedDir->variant.directoryVariant.", 
      "+                                   children) {", 
      "+                        if (i) {", 
      "+                                l = ylist_entry(i, yaffs_Object, siblings);", 
      "+                                yaffs_DestroyObject(l);", 
      "+", 
      "+                        }", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tyaffs_ReleaseTempBuffer(dev, chunkData, __LINE__);", 
      "+", 
      "+\tif(alloc_failed){", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tT(YAFFS_TRACE_SCAN, (TSTR(\"yaffs_ScanBackwards ends\" TENDSTR)));", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/*------------------------------  Directory Functions ----------------------------- */", 
      "+", 
      "+static void yaffs_RemoveObjectFromDirectory(yaffs_Object * obj)", 
      "+{", 
      "+\tyaffs_Device *dev = obj->myDev;", 
      "+", 
      "+        if(dev && dev->removeObjectCallback)", 
      "+                dev->removeObjectCallback(obj);", 
      "+", 
      "+        ylist_del_init(&obj->siblings);", 
      "+        obj->parent = NULL;", 
      "+}", 
      "+", 
      "+", 
      "+static void yaffs_AddObjectToDirectory(yaffs_Object * directory,", 
      "+\t\t\t\t       yaffs_Object * obj)", 
      "+{", 
      "+", 
      "+\tif (!directory) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: Trying to add an object to a null pointer directory\"", 
      "+\t\t    TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+\tif (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: Trying to add an object to a non-directory\"", 
      "+\t\t    TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+", 
      "+        if (obj->siblings.prev == NULL) {", 
      "+                /* Not initialised */", 
      "+                YINIT_LIST_HEAD(&obj->siblings);", 
      "+", 
      "+        } else if (!ylist_empty(&obj->siblings)) {", 
      "+                /* If it is holed up somewhere else, un hook it */", 
      "+                yaffs_RemoveObjectFromDirectory(obj);", 
      "+        }", 
      "+        /* Now add it */", 
      "+        ylist_add(&obj->siblings, &directory->variant.directoryVariant.children);", 
      "+        obj->parent = directory;", 
      "+", 
      "+        if (directory == obj->myDev->unlinkedDir", 
      "+\t    || directory == obj->myDev->deletedDir) {", 
      "+\t\tobj->unlinked = 1;", 
      "+\t\tobj->myDev->nUnlinkedFiles++;", 
      "+\t\tobj->renameAllowed = 0;", 
      "+\t}", 
      "+}", 
      "+", 
      "+yaffs_Object *yaffs_FindObjectByName(yaffs_Object * directory,", 
      "+\t\t\t\t     const YCHAR * name)", 
      "+{", 
      "+        int sum;", 
      "+", 
      "+        struct ylist_head *i;", 
      "+        YCHAR buffer[YAFFS_MAX_NAME_LENGTH + 1];", 
      "+", 
      "+        yaffs_Object *l;", 
      "+", 
      "+\tif (!name) {", 
      "+\t\treturn NULL;", 
      "+\t}", 
      "+", 
      "+\tif (!directory) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: yaffs_FindObjectByName: null pointer directory\"", 
      "+\t\t    TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+\tif (directory->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: yaffs_FindObjectByName: non-directory\" TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+", 
      "+        sum = yaffs_CalcNameSum(name);", 
      "+", 
      "+        ylist_for_each(i, &directory->variant.directoryVariant.children) {", 
      "+                if (i) {", 
      "+                        l = ylist_entry(i, yaffs_Object, siblings);", 
      "+", 
      "+                        yaffs_CheckObjectDetailsLoaded(l);", 
      "+", 
      "+\t\t\t/* Special case for lost-n-found */", 
      "+\t\t\tif (l->objectId == YAFFS_OBJECTID_LOSTNFOUND) {", 
      "+\t\t\t\tif (yaffs_strcmp(name, YAFFS_LOSTNFOUND_NAME) == 0) {", 
      "+\t\t\t\t\treturn l;", 
      "+\t\t\t\t}", 
      "+\t\t\t} else if (yaffs_SumCompare(l->sum, sum) || l->hdrChunk <= 0){", 
      "+\t\t\t\t/* LostnFound chunk called Objxxx", 
      "+\t\t\t\t * Do a real check", 
      "+\t\t\t\t */", 
      "+\t\t\t\tyaffs_GetObjectName(l, buffer,", 
      "+\t\t\t\t\t\t    YAFFS_MAX_NAME_LENGTH);", 
      "+\t\t\t\tif (yaffs_strncmp(name, buffer,YAFFS_MAX_NAME_LENGTH) == 0) {", 
      "+\t\t\t\t\treturn l;", 
      "+\t\t\t\t}", 
      "+", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn NULL;", 
      "+}", 
      "+", 
      "+", 
      "+#if 0", 
      "+int yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,", 
      "+                                   int (*fn) (yaffs_Object *))", 
      "+{", 
      "+        struct ylist_head *i;", 
      "+        yaffs_Object *l;", 
      "+", 
      "+        if (!theDir) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: yaffs_FindObjectByName: null pointer directory\"", 
      "+\t\t    TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+\tif (theDir->variantType != YAFFS_OBJECT_TYPE_DIRECTORY) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"tragedy: yaffs_FindObjectByName: non-directory\" TENDSTR)));", 
      "+                YBUG();", 
      "+        }", 
      "+", 
      "+        ylist_for_each(i, &theDir->variant.directoryVariant.children) {", 
      "+                if (i) {", 
      "+                        l = ylist_entry(i, yaffs_Object, siblings);", 
      "+                        if (l && !fn(l)) {", 
      "+                                return YAFFS_FAIL;", 
      "+                        }", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+#endif", 
      "+", 
      "+/* GetEquivalentObject dereferences any hard links to get to the", 
      "+ * actual object.", 
      "+ */", 
      "+", 
      "+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj)", 
      "+{", 
      "+\tif (obj && obj->variantType == YAFFS_OBJECT_TYPE_HARDLINK) {", 
      "+\t\t/* We want the object id of the equivalent object, not this one */", 
      "+\t\tobj = obj->variant.hardLinkVariant.equivalentObject;", 
      "+\t\tyaffs_CheckObjectDetailsLoaded(obj);", 
      "+\t}", 
      "+\treturn obj;", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize)", 
      "+{", 
      "+\tmemset(name, 0, buffSize * sizeof(YCHAR));", 
      "+", 
      "+\tyaffs_CheckObjectDetailsLoaded(obj);", 
      "+", 
      "+\tif (obj->objectId == YAFFS_OBJECTID_LOSTNFOUND) {", 
      "+\t\tyaffs_strncpy(name, YAFFS_LOSTNFOUND_NAME, buffSize - 1);", 
      "+\t} else if (obj->hdrChunk <= 0) {", 
      "+\t\tYCHAR locName[20];", 
      "+\t\t/* make up a name */", 
      "+\t\tyaffs_sprintf(locName, _Y(\"%s%d\"), YAFFS_LOSTNFOUND_PREFIX,", 
      "+\t\t\t      obj->objectId);", 
      "+\t\tyaffs_strncpy(name, locName, buffSize - 1);", 
      "+", 
      "+\t}", 
      "+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM", 
      "+\telse if (obj->shortName[0]) {", 
      "+\t\tyaffs_strcpy(name, obj->shortName);", 
      "+\t}", 
      "+#endif", 
      "+\telse {", 
      "+\t\tint result;", 
      "+\t\t__u8 *buffer = yaffs_GetTempBuffer(obj->myDev, __LINE__);", 
      "+", 
      "+\t\tyaffs_ObjectHeader *oh = (yaffs_ObjectHeader *) buffer;", 
      "+", 
      "+\t\tmemset(buffer, 0, obj->myDev->nDataBytesPerChunk);", 
      "+", 
      "+\t\tif (obj->hdrChunk > 0) {", 
      "+\t\t\tresult = yaffs_ReadChunkWithTagsFromNAND(obj->myDev,", 
      "+\t\t\t\t\t\t\tobj->hdrChunk, buffer,", 
      "+\t\t\t\t\t\t\tNULL);", 
      "+\t\t}", 
      "+\t\tyaffs_strncpy(name, oh->name, buffSize - 1);", 
      "+", 
      "+\t\tyaffs_ReleaseTempBuffer(obj->myDev, buffer, __LINE__);", 
      "+\t}", 
      "+", 
      "+\treturn yaffs_strlen(name);", 
      "+}", 
      "+", 
      "+int yaffs_GetObjectFileLength(yaffs_Object * obj)", 
      "+{", 
      "+", 
      "+\t/* Dereference any hard linking */", 
      "+\tobj = yaffs_GetEquivalentObject(obj);", 
      "+", 
      "+\tif (obj->variantType == YAFFS_OBJECT_TYPE_FILE) {", 
      "+\t\treturn obj->variant.fileVariant.fileSize;", 
      "+\t}", 
      "+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {", 
      "+\t\treturn yaffs_strlen(obj->variant.symLinkVariant.alias);", 
      "+\t} else {", 
      "+\t\t/* Only a directory should drop through to here */", 
      "+\t\treturn obj->myDev->nDataBytesPerChunk;", 
      "+\t}", 
      "+}", 
      "+", 
      "+int yaffs_GetObjectLinkCount(yaffs_Object * obj)", 
      "+{", 
      "+        int count = 0;", 
      "+        struct ylist_head *i;", 
      "+", 
      "+        if (!obj->unlinked) {", 
      "+                count++;        /* the object itself */", 
      "+        }", 
      "+        ylist_for_each(i, &obj->hardLinks) {", 
      "+                count++;        /* add the hard links; */", 
      "+        }", 
      "+        return count;", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_GetObjectInode(yaffs_Object * obj)", 
      "+{", 
      "+\tobj = yaffs_GetEquivalentObject(obj);", 
      "+", 
      "+\treturn obj->objectId;", 
      "+}", 
      "+", 
      "+unsigned yaffs_GetObjectType(yaffs_Object * obj)", 
      "+{", 
      "+\tobj = yaffs_GetEquivalentObject(obj);", 
      "+", 
      "+\tswitch (obj->variantType) {", 
      "+\tcase YAFFS_OBJECT_TYPE_FILE:", 
      "+\t\treturn DT_REG;", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_DIRECTORY:", 
      "+\t\treturn DT_DIR;", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SYMLINK:", 
      "+\t\treturn DT_LNK;", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_HARDLINK:", 
      "+\t\treturn DT_REG;", 
      "+\t\tbreak;", 
      "+\tcase YAFFS_OBJECT_TYPE_SPECIAL:", 
      "+\t\tif (S_ISFIFO(obj->yst_mode))", 
      "+\t\t\treturn DT_FIFO;", 
      "+\t\tif (S_ISCHR(obj->yst_mode))", 
      "+\t\t\treturn DT_CHR;", 
      "+\t\tif (S_ISBLK(obj->yst_mode))", 
      "+\t\t\treturn DT_BLK;", 
      "+\t\tif (S_ISSOCK(obj->yst_mode))", 
      "+\t\t\treturn DT_SOCK;", 
      "+\tdefault:", 
      "+\t\treturn DT_REG;", 
      "+\t\tbreak;", 
      "+\t}", 
      "+}", 
      "+", 
      "+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj)", 
      "+{", 
      "+\tobj = yaffs_GetEquivalentObject(obj);", 
      "+\tif (obj->variantType == YAFFS_OBJECT_TYPE_SYMLINK) {", 
      "+\t\treturn yaffs_CloneString(obj->variant.symLinkVariant.alias);", 
      "+\t} else {", 
      "+\t\treturn yaffs_CloneString(_Y(\"\"));", 
      "+\t}", 
      "+}", 
      "+", 
      "+#ifndef CONFIG_YAFFS_WINCE", 
      "+", 
      "+int yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr)", 
      "+{", 
      "+\tunsigned int valid = attr->ia_valid;", 
      "+", 
      "+\tif (valid & ATTR_MODE)", 
      "+\t\tobj->yst_mode = attr->ia_mode;", 
      "+\tif (valid & ATTR_UID)", 
      "+\t\tobj->yst_uid = attr->ia_uid;", 
      "+\tif (valid & ATTR_GID)", 
      "+\t\tobj->yst_gid = attr->ia_gid;", 
      "+", 
      "+\tif (valid & ATTR_ATIME)", 
      "+\t\tobj->yst_atime = Y_TIME_CONVERT(attr->ia_atime);", 
      "+\tif (valid & ATTR_CTIME)", 
      "+\t\tobj->yst_ctime = Y_TIME_CONVERT(attr->ia_ctime);", 
      "+\tif (valid & ATTR_MTIME)", 
      "+\t\tobj->yst_mtime = Y_TIME_CONVERT(attr->ia_mtime);", 
      "+", 
      "+\tif (valid & ATTR_SIZE)", 
      "+\t\tyaffs_ResizeFile(obj, attr->ia_size);", 
      "+", 
      "+\tyaffs_UpdateObjectHeader(obj, NULL, 1, 0, 0);", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+int yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr)", 
      "+{", 
      "+\tunsigned int valid = 0;", 
      "+", 
      "+\tattr->ia_mode = obj->yst_mode;", 
      "+\tvalid |= ATTR_MODE;", 
      "+\tattr->ia_uid = obj->yst_uid;", 
      "+\tvalid |= ATTR_UID;", 
      "+\tattr->ia_gid = obj->yst_gid;", 
      "+\tvalid |= ATTR_GID;", 
      "+", 
      "+\tY_TIME_CONVERT(attr->ia_atime) = obj->yst_atime;", 
      "+\tvalid |= ATTR_ATIME;", 
      "+\tY_TIME_CONVERT(attr->ia_ctime) = obj->yst_ctime;", 
      "+\tvalid |= ATTR_CTIME;", 
      "+\tY_TIME_CONVERT(attr->ia_mtime) = obj->yst_mtime;", 
      "+\tvalid |= ATTR_MTIME;", 
      "+", 
      "+\tattr->ia_size = yaffs_GetFileSize(obj);", 
      "+\tvalid |= ATTR_SIZE;", 
      "+", 
      "+\tattr->ia_valid = valid;", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+", 
      "+#endif", 
      "+", 
      "+#if 0", 
      "+int yaffs_DumpObject(yaffs_Object * obj)", 
      "+{", 
      "+\tYCHAR name[257];", 
      "+", 
      "+\tyaffs_GetObjectName(obj, name, 256);", 
      "+", 
      "+\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t  (TSTR", 
      "+\t   (\"Object %d, inode %d \\\"%s\\\"\\n dirty %d valid %d serial %d sum %d\"", 
      "+\t    \" chunk %d type %d size %d\\n\"", 
      "+\t    TENDSTR), obj->objectId, yaffs_GetObjectInode(obj), name,", 
      "+\t   obj->dirty, obj->valid, obj->serial, obj->sum, obj->hdrChunk,", 
      "+\t   yaffs_GetObjectType(obj), yaffs_GetObjectFileLength(obj)));", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+#endif", 
      "+", 
      "+/*---------------------------- Initialisation code -------------------------------------- */", 
      "+", 
      "+static int yaffs_CheckDevFunctions(const yaffs_Device * dev)", 
      "+{", 
      "+", 
      "+\t/* Common functions, gotta have */", 
      "+\tif (!dev->eraseBlockInNAND || !dev->initialiseNAND)", 
      "+\t\treturn 0;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_YAFFS2", 
      "+", 
      "+\t/* Can use the \"with tags\" style interface for yaffs1 or yaffs2 */", 
      "+\tif (dev->writeChunkWithTagsToNAND &&", 
      "+\t    dev->readChunkWithTagsFromNAND &&", 
      "+\t    !dev->writeChunkToNAND &&", 
      "+\t    !dev->readChunkFromNAND &&", 
      "+\t    dev->markNANDBlockBad && dev->queryNANDBlock)", 
      "+\t\treturn 1;", 
      "+#endif", 
      "+", 
      "+\t/* Can use the \"spare\" style interface for yaffs1 */", 
      "+\tif (!dev->isYaffs2 &&", 
      "+\t    !dev->writeChunkWithTagsToNAND &&", 
      "+\t    !dev->readChunkWithTagsFromNAND &&", 
      "+\t    dev->writeChunkToNAND &&", 
      "+\t    dev->readChunkFromNAND &&", 
      "+\t    !dev->markNANDBlockBad && !dev->queryNANDBlock)", 
      "+\t\treturn 1;", 
      "+", 
      "+\treturn 0;\t\t/* bad */", 
      "+}", 
      "+", 
      "+", 
      "+static int yaffs_CreateInitialDirectories(yaffs_Device *dev)", 
      "+{", 
      "+\t/* Initialise the unlinked, deleted, root and lost and found directories */", 
      "+", 
      "+\tdev->lostNFoundDir = dev->rootDir =  NULL;", 
      "+\tdev->unlinkedDir = dev->deletedDir = NULL;", 
      "+", 
      "+\tdev->unlinkedDir =", 
      "+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_UNLINKED, S_IFDIR);", 
      "+", 
      "+\tdev->deletedDir =", 
      "+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_DELETED, S_IFDIR);", 
      "+", 
      "+\tdev->rootDir =", 
      "+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_ROOT,", 
      "+\t\t\t\t      YAFFS_ROOT_MODE | S_IFDIR);", 
      "+\tdev->lostNFoundDir =", 
      "+\t    yaffs_CreateFakeDirectory(dev, YAFFS_OBJECTID_LOSTNFOUND,", 
      "+\t\t\t\t      YAFFS_LOSTNFOUND_MODE | S_IFDIR);", 
      "+", 
      "+\tif(dev->lostNFoundDir && dev->rootDir && dev->unlinkedDir && dev->deletedDir){", 
      "+\t\tyaffs_AddObjectToDirectory(dev->rootDir, dev->lostNFoundDir);", 
      "+\t\treturn YAFFS_OK;", 
      "+\t}", 
      "+", 
      "+\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int yaffs_GutsInitialise(yaffs_Device * dev)", 
      "+{", 
      "+\tint init_failed = 0;", 
      "+\tunsigned x;", 
      "+\tint bits;", 
      "+", 
      "+\tT(YAFFS_TRACE_TRACING, (TSTR(\"yaffs: yaffs_GutsInitialise()\" TENDSTR)));", 
      "+", 
      "+\t/* Check stuff that must be set */", 
      "+", 
      "+\tif (!dev) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS, (TSTR(\"yaffs: Need a device\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tdev->internalStartBlock = dev->startBlock;", 
      "+\tdev->internalEndBlock = dev->endBlock;", 
      "+\tdev->blockOffset = 0;", 
      "+\tdev->chunkOffset = 0;", 
      "+\tdev->nFreeChunks = 0;", 
      "+", 
      "+\tif (dev->startBlock == 0) {", 
      "+\t\tdev->internalStartBlock = dev->startBlock + 1;", 
      "+\t\tdev->internalEndBlock = dev->endBlock + 1;", 
      "+\t\tdev->blockOffset = 1;", 
      "+\t\tdev->chunkOffset = dev->nChunksPerBlock;", 
      "+\t}", 
      "+", 
      "+\t/* Check geometry parameters. */", 
      "+", 
      "+\tif ((!dev->inbandTags && dev->isYaffs2 && dev->totalBytesPerChunk < 1024) ||", 
      "+\t    (!dev->isYaffs2 && dev->totalBytesPerChunk != 512) ||", 
      "+\t    (dev->inbandTags && !dev->isYaffs2 ) ||", 
      "+\t     dev->nChunksPerBlock < 2 ||", 
      "+\t     dev->nReservedBlocks < 2 ||", 
      "+\t     dev->internalStartBlock <= 0 ||", 
      "+\t     dev->internalEndBlock <= 0 ||", 
      "+\t     dev->internalEndBlock <= (dev->internalStartBlock + dev->nReservedBlocks + 2)\t// otherwise it is too small", 
      "+\t    ) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"yaffs: NAND geometry problems: chunk size %d, type is yaffs%s, inbandTags %d \"", 
      "+\t\t    TENDSTR), dev->totalBytesPerChunk, dev->isYaffs2 ? \"2\" : \"\", dev->inbandTags));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tif (yaffs_InitialiseNAND(dev) != YAFFS_OK) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR(\"yaffs: InitialiseNAND failed\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* Sort out space for inband tags, if required */", 
      "+\tif(dev->inbandTags)", 
      "+\t\tdev->nDataBytesPerChunk = dev->totalBytesPerChunk - sizeof(yaffs_PackedTags2TagsPart);", 
      "+\telse", 
      "+\t\tdev->nDataBytesPerChunk = dev->totalBytesPerChunk;", 
      "+", 
      "+\t/* Got the right mix of functions? */", 
      "+\tif (!yaffs_CheckDevFunctions(dev)) {", 
      "+\t\t/* Function missing */", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR", 
      "+\t\t   (\"yaffs: device function(s) missing or wrong\\n\" TENDSTR)));", 
      "+", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* This is really a compilation check. */", 
      "+\tif (!yaffs_CheckStructures()) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR(\"yaffs_CheckStructures failed\\n\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tif (dev->isMounted) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR(\"yaffs: device already mounted\\n\" TENDSTR)));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* Finished with most checks. One or two more checks happen later on too. */", 
      "+", 
      "+\tdev->isMounted = 1;", 
      "+", 
      "+", 
      "+", 
      "+\t/* OK now calculate a few things for the device */", 
      "+", 
      "+\t/*", 
      "+\t *  Calculate all the chunk size manipulation numbers:", 
      "+\t */", 
      "+ \t {", 
      "+\t\t__u32 x = dev->nDataBytesPerChunk;", 
      "+\t\t /* We always use dev->chunkShift and dev->chunkDiv */", 
      "+\t\t dev->chunkShift = Shifts(x);", 
      "+\t\t x >>= dev->chunkShift;", 
      "+\t\t dev->chunkDiv = x;", 
      "+\t\t /* We only use chunk mask if chunkDiv is 1 */", 
      "+\t\t dev->chunkMask = (1<<dev->chunkShift) - 1;", 
      "+\t}", 
      "+", 
      "+", 
      "+\t/*", 
      "+\t * Calculate chunkGroupBits.", 
      "+\t * We need to find the next power of 2 > than internalEndBlock", 
      "+\t */", 
      "+", 
      "+\tx = dev->nChunksPerBlock * (dev->internalEndBlock + 1);", 
      "+", 
      "+\tbits = ShiftsGE(x);", 
      "+", 
      "+\t/* Set up tnode width if wide tnodes are enabled. */", 
      "+\tif(!dev->wideTnodesDisabled){", 
      "+\t\t/* bits must be even so that we end up with 32-bit words */", 
      "+\t\tif(bits & 1)", 
      "+\t\t\tbits++;", 
      "+\t\tif(bits < 16)", 
      "+\t\t\tdev->tnodeWidth = 16;", 
      "+\t\telse", 
      "+\t\t\tdev->tnodeWidth = bits;", 
      "+\t}", 
      "+\telse", 
      "+\t\tdev->tnodeWidth = 16;", 
      "+", 
      "+\tdev->tnodeMask = (1<<dev->tnodeWidth)-1;", 
      "+", 
      "+\t/* Level0 Tnodes are 16 bits or wider (if wide tnodes are enabled),", 
      "+\t * so if the bitwidth of the", 
      "+\t * chunk range we're using is greater than 16 we need", 
      "+\t * to figure out chunk shift and chunkGroupSize", 
      "+\t */", 
      "+", 
      "+\tif (bits <= dev->tnodeWidth)", 
      "+\t\tdev->chunkGroupBits = 0;", 
      "+\telse", 
      "+\t\tdev->chunkGroupBits = bits - dev->tnodeWidth;", 
      "+", 
      "+", 
      "+\tdev->chunkGroupSize = 1 << dev->chunkGroupBits;", 
      "+", 
      "+\tif (dev->nChunksPerBlock < dev->chunkGroupSize) {", 
      "+\t\t/* We have a problem because the soft delete won't work if", 
      "+\t\t * the chunk group size > chunks per block.", 
      "+\t\t * This can be remedied by using larger \"virtual blocks\".", 
      "+\t\t */", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR(\"yaffs: chunk group too large\\n\" TENDSTR)));", 
      "+", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* OK, we've finished verifying the device, lets continue with initialisation */", 
      "+", 
      "+\t/* More device initialisation */", 
      "+\tdev->garbageCollections = 0;", 
      "+\tdev->passiveGarbageCollections = 0;", 
      "+\tdev->currentDirtyChecker = 0;", 
      "+\tdev->bufferedBlock = -1;", 
      "+\tdev->doingBufferedBlockRewrite = 0;", 
      "+\tdev->nDeletedFiles = 0;", 
      "+\tdev->nBackgroundDeletions = 0;", 
      "+\tdev->nUnlinkedFiles = 0;", 
      "+\tdev->eccFixed = 0;", 
      "+\tdev->eccUnfixed = 0;", 
      "+\tdev->tagsEccFixed = 0;", 
      "+\tdev->tagsEccUnfixed = 0;", 
      "+\tdev->nErasureFailures = 0;", 
      "+\tdev->nErasedBlocks = 0;", 
      "+\tdev->isDoingGC = 0;", 
      "+\tdev->hasPendingPrioritisedGCs = 1; /* Assume the worst for now, will get fixed on first GC */", 
      "+", 
      "+\t/* Initialise temporary buffers and caches. */", 
      "+\tif(!yaffs_InitialiseTempBuffers(dev))", 
      "+\t\tinit_failed = 1;", 
      "+", 
      "+\tdev->srCache = NULL;", 
      "+\tdev->gcCleanupList = NULL;", 
      "+", 
      "+", 
      "+\tif (!init_failed &&", 
      "+\t    dev->nShortOpCaches > 0) {", 
      "+\t\tint i;", 
      "+\t\tvoid *buf;", 
      "+\t\tint srCacheBytes = dev->nShortOpCaches * sizeof(yaffs_ChunkCache);", 
      "+", 
      "+\t\tif (dev->nShortOpCaches > YAFFS_MAX_SHORT_OP_CACHES) {", 
      "+\t\t\tdev->nShortOpCaches = YAFFS_MAX_SHORT_OP_CACHES;", 
      "+\t\t}", 
      "+", 
      "+\t\tbuf = dev->srCache =  YMALLOC(srCacheBytes);", 
      "+", 
      "+\t\tif(dev->srCache)", 
      "+\t\t\tmemset(dev->srCache,0,srCacheBytes);", 
      "+", 
      "+\t\tfor (i = 0; i < dev->nShortOpCaches && buf; i++) {", 
      "+\t\t\tdev->srCache[i].object = NULL;", 
      "+\t\t\tdev->srCache[i].lastUse = 0;", 
      "+\t\t\tdev->srCache[i].dirty = 0;", 
      "+\t\t\tdev->srCache[i].data = buf = YMALLOC_DMA(dev->totalBytesPerChunk);", 
      "+\t\t}", 
      "+\t\tif(!buf)", 
      "+\t\t\tinit_failed = 1;", 
      "+", 
      "+\t\tdev->srLastUse = 0;", 
      "+\t}", 
      "+", 
      "+\tdev->cacheHits = 0;", 
      "+", 
      "+\tif(!init_failed){", 
      "+\t\tdev->gcCleanupList = YMALLOC(dev->nChunksPerBlock * sizeof(__u32));", 
      "+\t\tif(!dev->gcCleanupList)", 
      "+\t\t\tinit_failed = 1;", 
      "+\t}", 
      "+", 
      "+\tif (dev->isYaffs2) {", 
      "+\t\tdev->useHeaderFileSize = 1;", 
      "+\t}", 
      "+\tif(!init_failed && !yaffs_InitialiseBlocks(dev))", 
      "+\t\tinit_failed = 1;", 
      "+", 
      "+\tyaffs_InitialiseTnodes(dev);", 
      "+\tyaffs_InitialiseObjects(dev);", 
      "+", 
      "+\tif(!init_failed && !yaffs_CreateInitialDirectories(dev))", 
      "+\t\tinit_failed = 1;", 
      "+", 
      "+", 
      "+\tif(!init_failed){", 
      "+\t\t/* Now scan the flash. */", 
      "+\t\tif (dev->isYaffs2) {", 
      "+\t\t\tif(yaffs_CheckpointRestore(dev)) {", 
      "+\t\t\t\tyaffs_CheckObjectDetailsLoaded(dev->rootDir);", 
      "+\t\t\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t\t\t  (TSTR(\"yaffs: restored from checkpoint\" TENDSTR)));", 
      "+\t\t\t} else {", 
      "+", 
      "+\t\t\t\t/* Clean up the mess caused by an aborted checkpoint load", 
      "+\t\t\t\t * and scan backwards.", 
      "+\t\t\t\t */", 
      "+\t\t\t\tyaffs_DeinitialiseBlocks(dev);", 
      "+\t\t\t\tyaffs_DeinitialiseTnodes(dev);", 
      "+\t\t\t\tyaffs_DeinitialiseObjects(dev);", 
      "+", 
      "+", 
      "+\t\t\t\tdev->nErasedBlocks = 0;", 
      "+\t\t\t\tdev->nFreeChunks = 0;", 
      "+\t\t\t\tdev->allocationBlock = -1;", 
      "+\t\t\t\tdev->allocationPage = -1;", 
      "+\t\t\t\tdev->nDeletedFiles = 0;", 
      "+\t\t\t\tdev->nUnlinkedFiles = 0;", 
      "+\t\t\t\tdev->nBackgroundDeletions = 0;", 
      "+\t\t\t\tdev->oldestDirtySequence = 0;", 
      "+", 
      "+\t\t\t\tif(!init_failed && !yaffs_InitialiseBlocks(dev))", 
      "+\t\t\t\t\tinit_failed = 1;", 
      "+", 
      "+\t\t\t\tyaffs_InitialiseTnodes(dev);", 
      "+\t\t\t\tyaffs_InitialiseObjects(dev);", 
      "+", 
      "+\t\t\t\tif(!init_failed && !yaffs_CreateInitialDirectories(dev))", 
      "+\t\t\t\t\tinit_failed = 1;", 
      "+", 
      "+\t\t\t\tif(!init_failed && !yaffs_ScanBackwards(dev))", 
      "+\t\t\t\t\tinit_failed = 1;", 
      "+\t\t\t}", 
      "+\t\t}else", 
      "+\t\t\tif(!yaffs_Scan(dev))", 
      "+\t\t\t\tinit_failed = 1;", 
      "+\t}", 
      "+", 
      "+\tif(init_failed){", 
      "+\t\t/* Clean up the mess */", 
      "+\t\tT(YAFFS_TRACE_TRACING,", 
      "+\t\t  (TSTR(\"yaffs: yaffs_GutsInitialise() aborted.\\n\" TENDSTR)));", 
      "+", 
      "+\t\tyaffs_Deinitialise(dev);", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* Zero out stats */", 
      "+\tdev->nPageReads = 0;", 
      "+\tdev->nPageWrites = 0;", 
      "+\tdev->nBlockErasures = 0;", 
      "+\tdev->nGCCopies = 0;", 
      "+\tdev->nRetriedWrites = 0;", 
      "+", 
      "+\tdev->nRetiredBlocks = 0;", 
      "+", 
      "+\tyaffs_VerifyFreeChunks(dev);", 
      "+\tyaffs_VerifyBlocks(dev);", 
      "+", 
      "+", 
      "+\tT(YAFFS_TRACE_TRACING,", 
      "+\t  (TSTR(\"yaffs: yaffs_GutsInitialise() done.\\n\" TENDSTR)));", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+", 
      "+void yaffs_Deinitialise(yaffs_Device * dev)", 
      "+{", 
      "+\tif (dev->isMounted) {", 
      "+\t\tint i;", 
      "+", 
      "+\t\tyaffs_DeinitialiseBlocks(dev);", 
      "+\t\tyaffs_DeinitialiseTnodes(dev);", 
      "+\t\tyaffs_DeinitialiseObjects(dev);", 
      "+\t\tif (dev->nShortOpCaches > 0 &&", 
      "+\t\t    dev->srCache) {", 
      "+", 
      "+\t\t\tfor (i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\t\tif(dev->srCache[i].data)", 
      "+\t\t\t\t\tYFREE(dev->srCache[i].data);", 
      "+\t\t\t\tdev->srCache[i].data = NULL;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tYFREE(dev->srCache);", 
      "+\t\t\tdev->srCache = NULL;", 
      "+\t\t}", 
      "+", 
      "+\t\tYFREE(dev->gcCleanupList);", 
      "+", 
      "+\t\tfor (i = 0; i < YAFFS_N_TEMP_BUFFERS; i++) {", 
      "+\t\t\tYFREE(dev->tempBuffer[i].buffer);", 
      "+\t\t}", 
      "+", 
      "+", 
      "+\t\tdev->isMounted = 0;", 
      "+\t}", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_CountFreeChunks(yaffs_Device * dev)", 
      "+{", 
      "+\tint nFree;", 
      "+\tint b;", 
      "+", 
      "+\tyaffs_BlockInfo *blk;", 
      "+", 
      "+\tfor (nFree = 0, b = dev->internalStartBlock; b <= dev->internalEndBlock;", 
      "+\t     b++) {", 
      "+\t\tblk = yaffs_GetBlockInfo(dev, b);", 
      "+", 
      "+\t\tswitch (blk->blockState) {", 
      "+\t\tcase YAFFS_BLOCK_STATE_EMPTY:", 
      "+\t\tcase YAFFS_BLOCK_STATE_ALLOCATING:", 
      "+\t\tcase YAFFS_BLOCK_STATE_COLLECTING:", 
      "+\t\tcase YAFFS_BLOCK_STATE_FULL:", 
      "+\t\t\tnFree +=", 
      "+\t\t\t    (dev->nChunksPerBlock - blk->pagesInUse +", 
      "+\t\t\t     blk->softDeletions);", 
      "+\t\t\tbreak;", 
      "+\t\tdefault:", 
      "+\t\t\tbreak;", 
      "+\t\t}", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn nFree;", 
      "+}", 
      "+", 
      "+int yaffs_GetNumberOfFreeChunks(yaffs_Device * dev)", 
      "+{", 
      "+\t/* This is what we report to the outside world */", 
      "+", 
      "+\tint nFree;", 
      "+\tint nDirtyCacheChunks;", 
      "+\tint blocksForCheckpoint;", 
      "+", 
      "+#if 1", 
      "+\tnFree = dev->nFreeChunks;", 
      "+#else", 
      "+\tnFree = yaffs_CountFreeChunks(dev);", 
      "+#endif", 
      "+", 
      "+\tnFree += dev->nDeletedFiles;", 
      "+", 
      "+\t/* Now count the number of dirty chunks in the cache and subtract those */", 
      "+", 
      "+\t{", 
      "+\t\tint i;", 
      "+\t\tfor (nDirtyCacheChunks = 0, i = 0; i < dev->nShortOpCaches; i++) {", 
      "+\t\t\tif (dev->srCache[i].dirty)", 
      "+\t\t\t\tnDirtyCacheChunks++;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tnFree -= nDirtyCacheChunks;", 
      "+", 
      "+\tnFree -= ((dev->nReservedBlocks + 1) * dev->nChunksPerBlock);", 
      "+", 
      "+\t/* Now we figure out how much to reserve for the checkpoint and report that... */", 
      "+\tblocksForCheckpoint = yaffs_CalcCheckpointBlocksRequired(dev) - dev->blocksInCheckpoint;", 
      "+\tif(blocksForCheckpoint < 0)", 
      "+\t\tblocksForCheckpoint = 0;", 
      "+", 
      "+\tnFree -= (blocksForCheckpoint * dev->nChunksPerBlock);", 
      "+", 
      "+\tif (nFree < 0)", 
      "+\t\tnFree = 0;", 
      "+", 
      "+\treturn nFree;", 
      "+", 
      "+}", 
      "+", 
      "+static int yaffs_freeVerificationFailures;", 
      "+", 
      "+static void yaffs_VerifyFreeChunks(yaffs_Device * dev)", 
      "+{", 
      "+\tint counted;", 
      "+\tint difference;", 
      "+", 
      "+\tif(yaffs_SkipVerification(dev))", 
      "+\t\treturn;", 
      "+", 
      "+\tcounted = yaffs_CountFreeChunks(dev);", 
      "+", 
      "+\tdifference = dev->nFreeChunks - counted;", 
      "+", 
      "+\tif (difference) {", 
      "+\t\tT(YAFFS_TRACE_ALWAYS,", 
      "+\t\t  (TSTR(\"Freechunks verification failure %d %d %d\" TENDSTR),", 
      "+\t\t   dev->nFreeChunks, counted, difference));", 
      "+\t\tyaffs_freeVerificationFailures++;", 
      "+\t}", 
      "+}", 
      "+", 
      "+/*---------------------------------------- YAFFS test code ----------------------*/", 
      "+", 
      "+#define yaffs_CheckStruct(structure,syze, name) \\", 
      "+\tdo { \\", 
      "+           if(sizeof(structure) != syze) \\", 
      "+\t       { \\", 
      "+\t         T(YAFFS_TRACE_ALWAYS,(TSTR(\"%s should be %d but is %d\\n\" TENDSTR),\\", 
      "+\t\t name,syze,sizeof(structure))); \\", 
      "+\t         return YAFFS_FAIL; \\", 
      "+\t\t} \\", 
      "+\t} while(0)", 
      "+", 
      "+static int yaffs_CheckStructures(void)", 
      "+{", 
      "+/*      yaffs_CheckStruct(yaffs_Tags,8,\"yaffs_Tags\"); */", 
      "+/*      yaffs_CheckStruct(yaffs_TagsUnion,8,\"yaffs_TagsUnion\"); */", 
      "+/*      yaffs_CheckStruct(yaffs_Spare,16,\"yaffs_Spare\"); */", 
      "+#ifndef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+        yaffs_CheckStruct(yaffs_Tnode, 2 * YAFFS_NTNODES_LEVEL0, \"yaffs_Tnode\");", 
      "+#endif", 
      "+#ifndef CONFIG_YAFFS_WINCE", 
      "+\t\tyaffs_CheckStruct(yaffs_ObjectHeader, 512, \"yaffs_ObjectHeader\");", 
      "+#endif", 
      "+\t    return YAFFS_OK;", 
      "+}"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_guts.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_guts.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_guts.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_guts.h", 
      "@@ -0,0 +1,901 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_GUTS_H__", 
      "+#define __YAFFS_GUTS_H__", 
      "+", 
      "+#include \"devextras.h\"", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+#define YAFFS_OK\t1", 
      "+#define YAFFS_FAIL  0", 
      "+", 
      "+/* Give us a  Y=0x59,", 
      "+ * Give us an A=0x41,", 
      "+ * Give us an FF=0xFF", 
      "+ * Give us an S=0x53", 
      "+ * And what have we got...", 
      "+ */", 
      "+#define YAFFS_MAGIC\t\t\t0x5941FF53", 
      "+", 
      "+#define YAFFS_NTNODES_LEVEL0\t  \t16", 
      "+#define YAFFS_TNODES_LEVEL0_BITS\t4", 
      "+#define YAFFS_TNODES_LEVEL0_MASK\t0xf", 
      "+", 
      "+#define YAFFS_NTNODES_INTERNAL \t\t(YAFFS_NTNODES_LEVEL0 / 2)", 
      "+#define YAFFS_TNODES_INTERNAL_BITS \t(YAFFS_TNODES_LEVEL0_BITS - 1)", 
      "+#define YAFFS_TNODES_INTERNAL_MASK\t0x7", 
      "+#define YAFFS_TNODES_MAX_LEVEL\t\t6", 
      "+", 
      "+#ifndef CONFIG_YAFFS_NO_YAFFS1", 
      "+#define YAFFS_BYTES_PER_SPARE\t\t16", 
      "+#define YAFFS_BYTES_PER_CHUNK\t\t512", 
      "+#define YAFFS_CHUNK_SIZE_SHIFT\t\t9", 
      "+#define YAFFS_CHUNKS_PER_BLOCK\t\t32", 
      "+#define YAFFS_BYTES_PER_BLOCK\t\t(YAFFS_CHUNKS_PER_BLOCK*YAFFS_BYTES_PER_CHUNK)", 
      "+#endif", 
      "+", 
      "+#define YAFFS_MIN_YAFFS2_CHUNK_SIZE \t1024", 
      "+#define YAFFS_MIN_YAFFS2_SPARE_SIZE\t32", 
      "+", 
      "+#define YAFFS_MAX_CHUNK_ID\t\t0x000FFFFF", 
      "+", 
      "+#define YAFFS_UNUSED_OBJECT_ID\t\t0x0003FFFF", 
      "+", 
      "+#define YAFFS_ALLOCATION_NOBJECTS\t100", 
      "+#define YAFFS_ALLOCATION_NTNODES\t100", 
      "+#define YAFFS_ALLOCATION_NLINKS\t\t100", 
      "+", 
      "+#define YAFFS_NOBJECT_BUCKETS\t\t256", 
      "+", 
      "+", 
      "+#define YAFFS_OBJECT_SPACE\t\t0x40000", 
      "+", 
      "+#define YAFFS_CHECKPOINT_VERSION \t3", 
      "+", 
      "+#ifdef CONFIG_YAFFS_UNICODE", 
      "+#define YAFFS_MAX_NAME_LENGTH\t\t127", 
      "+#define YAFFS_MAX_ALIAS_LENGTH\t\t79", 
      "+#else", 
      "+#define YAFFS_MAX_NAME_LENGTH\t\t255", 
      "+#define YAFFS_MAX_ALIAS_LENGTH\t\t159", 
      "+#endif", 
      "+", 
      "+#define YAFFS_SHORT_NAME_LENGTH\t\t15", 
      "+", 
      "+/* Some special object ids for pseudo objects */", 
      "+#define YAFFS_OBJECTID_ROOT\t\t1", 
      "+#define YAFFS_OBJECTID_LOSTNFOUND\t2", 
      "+#define YAFFS_OBJECTID_UNLINKED\t\t3", 
      "+#define YAFFS_OBJECTID_DELETED\t\t4", 
      "+", 
      "+/* Sseudo object ids for checkpointing */", 
      "+#define YAFFS_OBJECTID_SB_HEADER\t0x10", 
      "+#define YAFFS_OBJECTID_CHECKPOINT_DATA\t0x20", 
      "+#define YAFFS_SEQUENCE_CHECKPOINT_DATA  0x21", 
      "+", 
      "+/* */", 
      "+", 
      "+#define YAFFS_MAX_SHORT_OP_CACHES\t20", 
      "+", 
      "+#define YAFFS_N_TEMP_BUFFERS\t\t6", 
      "+", 
      "+/* We limit the number attempts at sucessfully saving a chunk of data.", 
      "+ * Small-page devices have 32 pages per block; large-page devices have 64.", 
      "+ * Default to something in the order of 5 to 10 blocks worth of chunks.", 
      "+ */", 
      "+#define YAFFS_WR_ATTEMPTS\t\t(5*64)", 
      "+", 
      "+/* Sequence numbers are used in YAFFS2 to determine block allocation order.", 
      "+ * The range is limited slightly to help distinguish bad numbers from good.", 
      "+ * This also allows us to perhaps in the future use special numbers for", 
      "+ * special purposes.", 
      "+ * EFFFFF00 allows the allocation of 8 blocks per second (~1Mbytes) for 15 years,", 
      "+ * and is a larger number than the lifetime of a 2GB device.", 
      "+ */", 
      "+#define YAFFS_LOWEST_SEQUENCE_NUMBER\t0x00001000", 
      "+#define YAFFS_HIGHEST_SEQUENCE_NUMBER\t0xEFFFFF00", 
      "+", 
      "+/* ChunkCache is used for short read/write operations.*/", 
      "+typedef struct {", 
      "+\tstruct yaffs_ObjectStruct *object;", 
      "+\tint chunkId;", 
      "+\tint lastUse;", 
      "+\tint dirty;", 
      "+\tint nBytes;\t\t/* Only valid if the cache is dirty */", 
      "+\tint locked;\t\t/* Can't push out or flush while locked. */", 
      "+#ifdef CONFIG_YAFFS_YAFFS2", 
      "+\t__u8 *data;", 
      "+#else", 
      "+\t__u8 data[YAFFS_BYTES_PER_CHUNK];", 
      "+#endif", 
      "+} yaffs_ChunkCache;", 
      "+", 
      "+", 
      "+", 
      "+/* Tags structures in RAM", 
      "+ * NB This uses bitfield. Bitfields should not straddle a u32 boundary otherwise", 
      "+ * the structure size will get blown out.", 
      "+ */", 
      "+", 
      "+#ifndef CONFIG_YAFFS_NO_YAFFS1", 
      "+typedef struct {", 
      "+\tunsigned chunkId:20;", 
      "+\tunsigned serialNumber:2;", 
      "+\tunsigned byteCount:10;", 
      "+\tunsigned objectId:18;", 
      "+\tunsigned ecc:12;", 
      "+\tunsigned unusedStuff:2;", 
      "+", 
      "+} yaffs_Tags;", 
      "+", 
      "+typedef union {", 
      "+\tyaffs_Tags asTags;", 
      "+\t__u8 asBytes[8];", 
      "+} yaffs_TagsUnion;", 
      "+", 
      "+#endif", 
      "+", 
      "+/* Stuff used for extended tags in YAFFS2 */", 
      "+", 
      "+typedef enum {", 
      "+\tYAFFS_ECC_RESULT_UNKNOWN,", 
      "+\tYAFFS_ECC_RESULT_NO_ERROR,", 
      "+\tYAFFS_ECC_RESULT_FIXED,", 
      "+\tYAFFS_ECC_RESULT_UNFIXED", 
      "+} yaffs_ECCResult;", 
      "+", 
      "+typedef enum {", 
      "+\tYAFFS_OBJECT_TYPE_UNKNOWN,", 
      "+\tYAFFS_OBJECT_TYPE_FILE,", 
      "+\tYAFFS_OBJECT_TYPE_SYMLINK,", 
      "+\tYAFFS_OBJECT_TYPE_DIRECTORY,", 
      "+\tYAFFS_OBJECT_TYPE_HARDLINK,", 
      "+\tYAFFS_OBJECT_TYPE_SPECIAL", 
      "+} yaffs_ObjectType;", 
      "+", 
      "+#define YAFFS_OBJECT_TYPE_MAX YAFFS_OBJECT_TYPE_SPECIAL", 
      "+", 
      "+typedef struct {", 
      "+", 
      "+\tunsigned validMarker0;", 
      "+\tunsigned chunkUsed;\t/*  Status of the chunk: used or unused */", 
      "+\tunsigned objectId;\t/* If 0 then this is not part of an object (unused) */", 
      "+\tunsigned chunkId;\t/* If 0 then this is a header, else a data chunk */", 
      "+\tunsigned byteCount;\t/* Only valid for data chunks */", 
      "+", 
      "+\t/* The following stuff only has meaning when we read */", 
      "+\tyaffs_ECCResult eccResult;", 
      "+\tunsigned blockBad;", 
      "+", 
      "+\t/* YAFFS 1 stuff */", 
      "+\tunsigned chunkDeleted;\t/* The chunk is marked deleted */", 
      "+\tunsigned serialNumber;\t/* Yaffs1 2-bit serial number */", 
      "+", 
      "+\t/* YAFFS2 stuff */", 
      "+\tunsigned sequenceNumber;\t/* The sequence number of this block */", 
      "+", 
      "+\t/* Extra info if this is an object header (YAFFS2 only) */", 
      "+", 
      "+\tunsigned extraHeaderInfoAvailable;\t/* There is extra info available if this is not zero */", 
      "+\tunsigned extraParentObjectId;\t/* The parent object */", 
      "+\tunsigned extraIsShrinkHeader;\t/* Is it a shrink header? */", 
      "+\tunsigned extraShadows;\t\t/* Does this shadow another object? */", 
      "+", 
      "+\tyaffs_ObjectType extraObjectType;\t/* What object type? */", 
      "+", 
      "+\tunsigned extraFileLength;\t\t/* Length if it is a file */", 
      "+\tunsigned extraEquivalentObjectId;\t/* Equivalent object Id if it is a hard link */", 
      "+", 
      "+\tunsigned validMarker1;", 
      "+", 
      "+} yaffs_ExtendedTags;", 
      "+", 
      "+/* Spare structure for YAFFS1 */", 
      "+typedef struct {", 
      "+\t__u8 tagByte0;", 
      "+\t__u8 tagByte1;", 
      "+\t__u8 tagByte2;", 
      "+\t__u8 tagByte3;", 
      "+\t__u8 pageStatus;\t/* set to 0 to delete the chunk */", 
      "+\t__u8 blockStatus;", 
      "+\t__u8 tagByte4;", 
      "+\t__u8 tagByte5;", 
      "+\t__u8 ecc1[3];", 
      "+\t__u8 tagByte6;", 
      "+\t__u8 tagByte7;", 
      "+\t__u8 ecc2[3];", 
      "+} yaffs_Spare;", 
      "+", 
      "+/*Special structure for passing through to mtd */", 
      "+struct yaffs_NANDSpare {", 
      "+\tyaffs_Spare spare;", 
      "+\tint eccres1;", 
      "+\tint eccres2;", 
      "+};", 
      "+", 
      "+/* Block data in RAM */", 
      "+", 
      "+typedef enum {", 
      "+\tYAFFS_BLOCK_STATE_UNKNOWN = 0,", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_SCANNING,", 
      "+\tYAFFS_BLOCK_STATE_NEEDS_SCANNING,", 
      "+\t/* The block might have something on it (ie it is allocating or full, perhaps empty)", 
      "+\t * but it needs to be scanned to determine its true state.", 
      "+\t * This state is only valid during yaffs_Scan.", 
      "+\t * NB We tolerate empty because the pre-scanner might be incapable of deciding", 
      "+\t * However, if this state is returned on a YAFFS2 device, then we expect a sequence number", 
      "+\t */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_EMPTY,", 
      "+\t/* This block is empty */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_ALLOCATING,", 
      "+\t/* This block is partially allocated.", 
      "+\t * At least one page holds valid data.", 
      "+\t * This is the one currently being used for page", 
      "+\t * allocation. Should never be more than one of these", 
      "+\t */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_FULL,", 
      "+\t/* All the pages in this block have been allocated.", 
      "+\t */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_DIRTY,", 
      "+\t/* All pages have been allocated and deleted.", 
      "+\t * Erase me, reuse me.", 
      "+\t */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_CHECKPOINT,", 
      "+\t/* This block is assigned to holding checkpoint data.", 
      "+\t */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_COLLECTING,", 
      "+\t/* This block is being garbage collected */", 
      "+", 
      "+\tYAFFS_BLOCK_STATE_DEAD", 
      "+\t/* This block has failed and is not in use */", 
      "+} yaffs_BlockState;", 
      "+", 
      "+#define\tYAFFS_NUMBER_OF_BLOCK_STATES (YAFFS_BLOCK_STATE_DEAD + 1)", 
      "+", 
      "+", 
      "+typedef struct {", 
      "+", 
      "+\tint softDeletions:10;\t/* number of soft deleted pages */", 
      "+\tint pagesInUse:10;\t/* number of pages in use */", 
      "+\tunsigned blockState:4;\t/* One of the above block states. NB use unsigned because enum is sometimes an int */", 
      "+\t__u32 needsRetiring:1;\t/* Data has failed on this block, need to get valid data off */", 
      "+                        \t/* and retire the block. */", 
      "+\t__u32 skipErasedCheck: 1; /* If this is set we can skip the erased check on this block */", 
      "+\t__u32 gcPrioritise: 1; \t/* An ECC check or blank check has failed on this block.", 
      "+\t\t\t\t   It should be prioritised for GC */", 
      "+        __u32 chunkErrorStrikes:3; /* How many times we've had ecc etc failures on this block and tried to reuse it */", 
      "+", 
      "+#ifdef CONFIG_YAFFS_YAFFS2", 
      "+\t__u32 hasShrinkHeader:1; /* This block has at least one shrink object header */", 
      "+\t__u32 sequenceNumber;\t /* block sequence number for yaffs2 */", 
      "+#endif", 
      "+", 
      "+} yaffs_BlockInfo;", 
      "+", 
      "+/* -------------------------- Object structure -------------------------------*/", 
      "+/* This is the object structure as stored on NAND */", 
      "+", 
      "+typedef struct {", 
      "+\tyaffs_ObjectType type;", 
      "+", 
      "+\t/* Apply to everything  */", 
      "+\tint parentObjectId;", 
      "+        __u16 sum__NoLongerUsed;        /* checksum of name. No longer used */", 
      "+        YCHAR name[YAFFS_MAX_NAME_LENGTH + 1];", 
      "+", 
      "+        /* The following apply to directories, files, symlinks - not hard links */", 
      "+        __u32 yst_mode;         /* protection */", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t__u32 notForWinCE[5];", 
      "+#else", 
      "+\t__u32 yst_uid;", 
      "+\t__u32 yst_gid;", 
      "+\t__u32 yst_atime;", 
      "+\t__u32 yst_mtime;", 
      "+\t__u32 yst_ctime;", 
      "+#endif", 
      "+", 
      "+\t/* File size  applies to files only */", 
      "+\tint fileSize;", 
      "+", 
      "+\t/* Equivalent object id applies to hard links only. */", 
      "+\tint equivalentObjectId;", 
      "+", 
      "+\t/* Alias is for symlinks only. */", 
      "+\tYCHAR alias[YAFFS_MAX_ALIAS_LENGTH + 1];", 
      "+", 
      "+\t__u32 yst_rdev;\t\t/* device stuff for block and char devices (major/min) */", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t__u32 win_ctime[2];", 
      "+\t__u32 win_atime[2];", 
      "+\t__u32 win_mtime[2];", 
      "+#else", 
      "+\t__u32 roomToGrow[6];", 
      "+", 
      "+#endif", 
      "+\t__u32 inbandShadowsObject;", 
      "+\t__u32 inbandIsShrink;", 
      "+", 
      "+\t__u32 reservedSpace[2];", 
      "+\tint shadowsObject;\t/* This object header shadows the specified object if > 0 */", 
      "+", 
      "+\t/* isShrink applies to object headers written when we shrink the file (ie resize) */", 
      "+\t__u32 isShrink;", 
      "+", 
      "+} yaffs_ObjectHeader;", 
      "+", 
      "+/*--------------------------- Tnode -------------------------- */", 
      "+", 
      "+union yaffs_Tnode_union {", 
      "+#ifdef CONFIG_YAFFS_TNODE_LIST_DEBUG", 
      "+\tunion yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL + 1];", 
      "+#else", 
      "+\tunion yaffs_Tnode_union *internal[YAFFS_NTNODES_INTERNAL];", 
      "+#endif", 
      "+/*\t__u16 level0[YAFFS_NTNODES_LEVEL0]; */", 
      "+", 
      "+};", 
      "+", 
      "+typedef union yaffs_Tnode_union yaffs_Tnode;", 
      "+", 
      "+struct yaffs_TnodeList_struct {", 
      "+\tstruct yaffs_TnodeList_struct *next;", 
      "+\tyaffs_Tnode *tnodes;", 
      "+};", 
      "+", 
      "+typedef struct yaffs_TnodeList_struct yaffs_TnodeList;", 
      "+", 
      "+/*------------------------  Object -----------------------------*/", 
      "+/* An object can be one of:", 
      "+ * - a directory (no data, has children links", 
      "+ * - a regular file (data.... not prunes :->).", 
      "+ * - a symlink [symbolic link] (the alias).", 
      "+ * - a hard link", 
      "+ */", 
      "+", 
      "+typedef struct {", 
      "+\t__u32 fileSize;", 
      "+\t__u32 scannedFileSize;", 
      "+\t__u32 shrinkSize;", 
      "+\tint topLevel;", 
      "+\tyaffs_Tnode *top;", 
      "+} yaffs_FileStructure;", 
      "+", 
      "+typedef struct {", 
      "+        struct ylist_head children;     /* list of child links */", 
      "+} yaffs_DirectoryStructure;", 
      "+", 
      "+typedef struct {", 
      "+\tYCHAR *alias;", 
      "+} yaffs_SymLinkStructure;", 
      "+", 
      "+typedef struct {", 
      "+\tstruct yaffs_ObjectStruct *equivalentObject;", 
      "+\t__u32 equivalentObjectId;", 
      "+} yaffs_HardLinkStructure;", 
      "+", 
      "+typedef union {", 
      "+\tyaffs_FileStructure fileVariant;", 
      "+\tyaffs_DirectoryStructure directoryVariant;", 
      "+\tyaffs_SymLinkStructure symLinkVariant;", 
      "+\tyaffs_HardLinkStructure hardLinkVariant;", 
      "+} yaffs_ObjectVariant;", 
      "+", 
      "+struct yaffs_ObjectStruct {", 
      "+\t__u8 deleted:1;\t\t/* This should only apply to unlinked files. */", 
      "+\t__u8 softDeleted:1;\t/* it has also been soft deleted */", 
      "+\t__u8 unlinked:1;\t/* An unlinked file. The file should be in the unlinked directory.*/", 
      "+\t__u8 fake:1;\t\t/* A fake object has no presence on NAND. */", 
      "+\t__u8 renameAllowed:1;\t/* Some objects are not allowed to be renamed. */", 
      "+\t__u8 unlinkAllowed:1;", 
      "+\t__u8 dirty:1;\t\t/* the object needs to be written to flash */", 
      "+\t__u8 valid:1;\t\t/* When the file system is being loaded up, this", 
      "+\t\t\t\t * object might be created before the data", 
      "+\t\t\t\t * is available (ie. file data records appear before the header).", 
      "+\t\t\t\t */", 
      "+\t__u8 lazyLoaded:1;\t/* This object has been lazy loaded and is missing some detail */", 
      "+", 
      "+\t__u8 deferedFree:1;\t/* For Linux kernel. Object is removed from NAND, but is", 
      "+\t\t\t\t * still in the inode cache. Free of object is defered.", 
      "+\t\t\t\t * until the inode is released.", 
      "+\t\t\t\t */", 
      "+", 
      "+\t__u8 serial;\t\t/* serial number of chunk in NAND. Cached here */", 
      "+\t__u16 sum;\t\t/* sum of the name to speed searching */", 
      "+", 
      "+        struct yaffs_DeviceStruct *myDev;       /* The device I'm on */", 
      "+", 
      "+        struct ylist_head hashLink;     /* list of objects in this hash bucket */", 
      "+", 
      "+        struct ylist_head hardLinks;    /* all the equivalent hard linked objects */", 
      "+", 
      "+        /* directory structure stuff */", 
      "+        /* also used for linking up the free list */", 
      "+        struct yaffs_ObjectStruct *parent;", 
      "+        struct ylist_head siblings;", 
      "+", 
      "+\t/* Where's my object header in NAND? */", 
      "+\tint hdrChunk;", 
      "+", 
      "+\tint nDataChunks;\t/* Number of data chunks attached to the file. */", 
      "+", 
      "+\t__u32 objectId;\t\t/* the object id value */", 
      "+", 
      "+\t__u32 yst_mode;", 
      "+", 
      "+#ifdef CONFIG_YAFFS_SHORT_NAMES_IN_RAM", 
      "+\tYCHAR shortName[YAFFS_SHORT_NAME_LENGTH + 1];", 
      "+#endif", 
      "+", 
      "+#ifndef __KERNEL__", 
      "+\t__u32 inUse;", 
      "+#endif", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+\t__u32 win_ctime[2];", 
      "+\t__u32 win_mtime[2];", 
      "+\t__u32 win_atime[2];", 
      "+#else", 
      "+\t__u32 yst_uid;", 
      "+\t__u32 yst_gid;", 
      "+\t__u32 yst_atime;", 
      "+\t__u32 yst_mtime;", 
      "+\t__u32 yst_ctime;", 
      "+#endif", 
      "+", 
      "+\t__u32 yst_rdev;", 
      "+", 
      "+#ifdef __KERNEL__", 
      "+\tstruct inode *myInode;", 
      "+", 
      "+#endif", 
      "+", 
      "+\tyaffs_ObjectType variantType;", 
      "+", 
      "+\tyaffs_ObjectVariant variant;", 
      "+", 
      "+};", 
      "+", 
      "+typedef struct yaffs_ObjectStruct yaffs_Object;", 
      "+", 
      "+struct yaffs_ObjectList_struct {", 
      "+\tyaffs_Object *objects;", 
      "+\tstruct yaffs_ObjectList_struct *next;", 
      "+};", 
      "+", 
      "+typedef struct yaffs_ObjectList_struct yaffs_ObjectList;", 
      "+", 
      "+typedef struct {", 
      "+        struct ylist_head list;", 
      "+        int count;", 
      "+} yaffs_ObjectBucket;", 
      "+", 
      "+", 
      "+/* yaffs_CheckpointObject holds the definition of an object as dumped", 
      "+ * by checkpointing.", 
      "+ */", 
      "+", 
      "+typedef struct {", 
      "+        int structType;", 
      "+\t__u32 objectId;", 
      "+\t__u32 parentId;", 
      "+\tint hdrChunk;", 
      "+\tyaffs_ObjectType variantType:3;", 
      "+\t__u8 deleted:1;", 
      "+\t__u8 softDeleted:1;", 
      "+\t__u8 unlinked:1;", 
      "+\t__u8 fake:1;", 
      "+\t__u8 renameAllowed:1;", 
      "+\t__u8 unlinkAllowed:1;", 
      "+\t__u8 serial;", 
      "+", 
      "+\tint nDataChunks;", 
      "+\t__u32 fileSizeOrEquivalentObjectId;", 
      "+", 
      "+}yaffs_CheckpointObject;", 
      "+", 
      "+/*--------------------- Temporary buffers ----------------", 
      "+ *", 
      "+ * These are chunk-sized working buffers. Each device has a few", 
      "+ */", 
      "+", 
      "+typedef struct {", 
      "+\t__u8 *buffer;", 
      "+\tint line;\t/* track from whence this buffer was allocated */", 
      "+\tint maxLine;", 
      "+} yaffs_TempBuffer;", 
      "+", 
      "+/*----------------- Device ---------------------------------*/", 
      "+", 
      "+struct yaffs_DeviceStruct {", 
      "+        struct ylist_head devList;", 
      "+        const char *name;", 
      "+", 
      "+        /* Entry parameters set up way early. Yaffs sets up the rest.*/", 
      "+        int nDataBytesPerChunk; /* Should be a power of 2 >= 512 */", 
      "+        int nChunksPerBlock;    /* does not need to be a power of 2 */", 
      "+        int spareBytesPerChunk;/* spare area size */", 
      "+        int startBlock;         /* Start block we're allowed to use */", 
      "+        int endBlock;           /* End block we're allowed to use */", 
      "+        int nReservedBlocks;    /* We want this tuneable so that we can reduce */", 
      "+\t\t\t\t/* reserved blocks on NOR and RAM. */", 
      "+", 
      "+", 
      "+\t/* Stuff used by the shared space checkpointing mechanism */", 
      "+\t/* If this value is zero, then this mechanism is disabled */", 
      "+", 
      "+//\tint nCheckpointReservedBlocks; /* Blocks to reserve for checkpoint data */", 
      "+", 
      "+", 
      "+", 
      "+", 
      "+\tint nShortOpCaches;\t/* If <= 0, then short op caching is disabled, else", 
      "+\t\t\t\t * the number of short op caches (don't use too many)", 
      "+\t\t\t\t */", 
      "+", 
      "+\tint useHeaderFileSize;\t/* Flag to determine if we should use file sizes from the header */", 
      "+", 
      "+\tint useNANDECC;\t\t/* Flag to decide whether or not to use NANDECC */", 
      "+", 
      "+\tvoid *genericDevice;\t/* Pointer to device context", 
      "+\t\t\t\t * On an mtd this holds the mtd pointer.", 
      "+\t\t\t\t */", 
      "+        void *superBlock;", 
      "+", 
      "+\t/* NAND access functions (Must be set before calling YAFFS)*/", 
      "+", 
      "+\tint (*writeChunkToNAND) (struct yaffs_DeviceStruct * dev,", 
      "+\t\t\t\t int chunkInNAND, const __u8 * data,", 
      "+\t\t\t\t const yaffs_Spare * spare);", 
      "+\tint (*readChunkFromNAND) (struct yaffs_DeviceStruct * dev,", 
      "+\t\t\t\t  int chunkInNAND, __u8 * data,", 
      "+\t\t\t\t  yaffs_Spare * spare);", 
      "+\tint (*eraseBlockInNAND) (struct yaffs_DeviceStruct * dev,", 
      "+\t\t\t\t int blockInNAND);", 
      "+\tint (*initialiseNAND) (struct yaffs_DeviceStruct * dev);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_YAFFS2", 
      "+\tint (*writeChunkWithTagsToNAND) (struct yaffs_DeviceStruct * dev,", 
      "+\t\t\t\t\t int chunkInNAND, const __u8 * data,", 
      "+\t\t\t\t\t const yaffs_ExtendedTags * tags);", 
      "+\tint (*readChunkWithTagsFromNAND) (struct yaffs_DeviceStruct * dev,", 
      "+\t\t\t\t\t  int chunkInNAND, __u8 * data,", 
      "+\t\t\t\t\t  yaffs_ExtendedTags * tags);", 
      "+\tint (*markNANDBlockBad) (struct yaffs_DeviceStruct * dev, int blockNo);", 
      "+\tint (*queryNANDBlock) (struct yaffs_DeviceStruct * dev, int blockNo,", 
      "+\t\t\t       yaffs_BlockState * state, __u32 *sequenceNumber);", 
      "+#endif", 
      "+", 
      "+\tint isYaffs2;", 
      "+", 
      "+\t/* The removeObjectCallback function must be supplied by OS flavours that", 
      "+\t * need it. The Linux kernel does not use this, but yaffs direct does use", 
      "+\t * it to implement the faster readdir", 
      "+\t */", 
      "+\tvoid (*removeObjectCallback)(struct yaffs_ObjectStruct *obj);", 
      "+", 
      "+\t/* Callback to mark the superblock dirsty */", 
      "+\tvoid (*markSuperBlockDirty)(void * superblock);", 
      "+", 
      "+\tint wideTnodesDisabled; /* Set to disable wide tnodes */", 
      "+", 
      "+\tYCHAR *pathDividers;\t/* String of legal path dividers */", 
      "+", 
      "+", 
      "+\t/* End of stuff that must be set before initialisation. */", 
      "+", 
      "+\t/* Checkpoint control. Can be set before or after initialisation */", 
      "+\t__u8 skipCheckpointRead;", 
      "+\t__u8 skipCheckpointWrite;", 
      "+", 
      "+\t/* Runtime parameters. Set up by YAFFS. */", 
      "+", 
      "+\t__u16 chunkGroupBits;\t/* 0 for devices <= 32MB. else log2(nchunks) - 16 */", 
      "+\t__u16 chunkGroupSize;\t/* == 2^^chunkGroupBits */", 
      "+", 
      "+\t/* Stuff to support wide tnodes */", 
      "+\t__u32 tnodeWidth;", 
      "+\t__u32 tnodeMask;", 
      "+", 
      "+\t/* Stuff for figuring out file offset to chunk conversions */", 
      "+\t__u32 chunkShift; /* Shift value */", 
      "+\t__u32 chunkDiv;   /* Divisor after shifting: 1 for power-of-2 sizes */", 
      "+\t__u32 chunkMask;  /* Mask to use for power-of-2 case */", 
      "+", 
      "+\t/* Stuff to handle inband tags */", 
      "+\tint inbandTags;", 
      "+\t__u32 totalBytesPerChunk;", 
      "+", 
      "+#ifdef __KERNEL__", 
      "+", 
      "+\tstruct semaphore sem;\t/* Semaphore for waiting on erasure.*/", 
      "+\tstruct semaphore grossLock;\t/* Gross locking semaphore */", 
      "+\t__u8 *spareBuffer;\t/* For mtdif2 use. Don't know the size of the buffer", 
      "+\t\t\t\t * at compile time so we have to allocate it.", 
      "+\t\t\t\t */", 
      "+\tvoid (*putSuperFunc) (struct super_block * sb);", 
      "+#endif", 
      "+", 
      "+\tint isMounted;", 
      "+", 
      "+\tint isCheckpointed;", 
      "+", 
      "+", 
      "+\t/* Stuff to support block offsetting to support start block zero */", 
      "+\tint internalStartBlock;", 
      "+\tint internalEndBlock;", 
      "+\tint blockOffset;", 
      "+\tint chunkOffset;", 
      "+", 
      "+", 
      "+\t/* Runtime checkpointing stuff */", 
      "+\tint checkpointPageSequence;   /* running sequence number of checkpoint pages */", 
      "+\tint checkpointByteCount;", 
      "+\tint checkpointByteOffset;", 
      "+\t__u8 *checkpointBuffer;", 
      "+\tint checkpointOpenForWrite;", 
      "+\tint blocksInCheckpoint;", 
      "+\tint checkpointCurrentChunk;", 
      "+\tint checkpointCurrentBlock;", 
      "+\tint checkpointNextBlock;", 
      "+\tint *checkpointBlockList;", 
      "+\tint checkpointMaxBlocks;", 
      "+\t__u32 checkpointSum;", 
      "+\t__u32 checkpointXor;", 
      "+", 
      "+\tint nCheckpointBlocksRequired; /* Number of blocks needed to store current checkpoint set */", 
      "+", 
      "+\t/* Block Info */", 
      "+\tyaffs_BlockInfo *blockInfo;", 
      "+\t__u8 *chunkBits;\t/* bitmap of chunks in use */", 
      "+\tunsigned blockInfoAlt:1;\t/* was allocated using alternative strategy */", 
      "+\tunsigned chunkBitsAlt:1;\t/* was allocated using alternative strategy */", 
      "+\tint chunkBitmapStride;\t/* Number of bytes of chunkBits per block.", 
      "+\t\t\t\t * Must be consistent with nChunksPerBlock.", 
      "+\t\t\t\t */", 
      "+", 
      "+\tint nErasedBlocks;", 
      "+\tint allocationBlock;\t/* Current block being allocated off */", 
      "+\t__u32 allocationPage;", 
      "+\tint allocationBlockFinder;\t/* Used to search for next allocation block */", 
      "+", 
      "+\t/* Runtime state */", 
      "+\tint nTnodesCreated;", 
      "+\tyaffs_Tnode *freeTnodes;", 
      "+\tint nFreeTnodes;", 
      "+\tyaffs_TnodeList *allocatedTnodeList;", 
      "+", 
      "+\tint isDoingGC;", 
      "+", 
      "+\tint nObjectsCreated;", 
      "+\tyaffs_Object *freeObjects;", 
      "+\tint nFreeObjects;", 
      "+", 
      "+\tint nHardLinks;", 
      "+", 
      "+\tyaffs_ObjectList *allocatedObjectList;", 
      "+", 
      "+\tyaffs_ObjectBucket objectBucket[YAFFS_NOBJECT_BUCKETS];", 
      "+", 
      "+\tint nFreeChunks;", 
      "+", 
      "+\tint currentDirtyChecker;\t/* Used to find current dirtiest block */", 
      "+", 
      "+\t__u32 *gcCleanupList;\t/* objects to delete at the end of a GC. */", 
      "+\tint nonAggressiveSkip;\t/* GC state/mode */", 
      "+", 
      "+\t/* Statistcs */", 
      "+\tint nPageWrites;", 
      "+\tint nPageReads;", 
      "+\tint nBlockErasures;", 
      "+\tint nErasureFailures;", 
      "+\tint nGCCopies;", 
      "+\tint garbageCollections;", 
      "+\tint passiveGarbageCollections;", 
      "+\tint nRetriedWrites;", 
      "+\tint nRetiredBlocks;", 
      "+\tint eccFixed;", 
      "+\tint eccUnfixed;", 
      "+\tint tagsEccFixed;", 
      "+\tint tagsEccUnfixed;", 
      "+\tint nDeletions;", 
      "+\tint nUnmarkedDeletions;", 
      "+", 
      "+\tint hasPendingPrioritisedGCs; /* We think this device might have pending prioritised gcs */", 
      "+", 
      "+\t/* Special directories */", 
      "+\tyaffs_Object *rootDir;", 
      "+\tyaffs_Object *lostNFoundDir;", 
      "+", 
      "+\t/* Buffer areas for storing data to recover from write failures TODO", 
      "+\t *      __u8            bufferedData[YAFFS_CHUNKS_PER_BLOCK][YAFFS_BYTES_PER_CHUNK];", 
      "+\t *      yaffs_Spare bufferedSpare[YAFFS_CHUNKS_PER_BLOCK];", 
      "+\t */", 
      "+", 
      "+\tint bufferedBlock;\t/* Which block is buffered here? */", 
      "+\tint doingBufferedBlockRewrite;", 
      "+", 
      "+\tyaffs_ChunkCache *srCache;", 
      "+\tint srLastUse;", 
      "+", 
      "+\tint cacheHits;", 
      "+", 
      "+\t/* Stuff for background deletion and unlinked files.*/", 
      "+\tyaffs_Object *unlinkedDir;\t/* Directory where unlinked and deleted files live. */", 
      "+\tyaffs_Object *deletedDir;\t/* Directory where deleted objects are sent to disappear. */", 
      "+\tyaffs_Object *unlinkedDeletion;\t/* Current file being background deleted.*/", 
      "+\tint nDeletedFiles;\t\t/* Count of files awaiting deletion;*/", 
      "+\tint nUnlinkedFiles;\t\t/* Count of unlinked files. */", 
      "+\tint nBackgroundDeletions;\t/* Count of background deletions. */", 
      "+", 
      "+", 
      "+\t/* Temporary buffer management */", 
      "+\tyaffs_TempBuffer tempBuffer[YAFFS_N_TEMP_BUFFERS];", 
      "+\tint maxTemp;", 
      "+\tint tempInUse;", 
      "+\tint unmanagedTempAllocations;", 
      "+\tint unmanagedTempDeallocations;", 
      "+", 
      "+\t/* yaffs2 runtime stuff */", 
      "+\tunsigned sequenceNumber;\t/* Sequence number of currently allocating block */", 
      "+\tunsigned oldestDirtySequence;", 
      "+", 
      "+};", 
      "+", 
      "+typedef struct yaffs_DeviceStruct yaffs_Device;", 
      "+", 
      "+/* The static layout of block usage etc is stored in the super block header */", 
      "+typedef struct {", 
      "+        int StructType;", 
      "+        int version;", 
      "+\tint checkpointStartBlock;", 
      "+\tint checkpointEndBlock;", 
      "+\tint startBlock;", 
      "+\tint endBlock;", 
      "+\tint rfu[100];", 
      "+} yaffs_SuperBlockHeader;", 
      "+", 
      "+/* The CheckpointDevice structure holds the device information that changes at runtime and", 
      "+ * must be preserved over unmount/mount cycles.", 
      "+ */", 
      "+typedef struct {", 
      "+        int structType;", 
      "+\tint nErasedBlocks;", 
      "+\tint allocationBlock;\t/* Current block being allocated off */", 
      "+\t__u32 allocationPage;", 
      "+\tint nFreeChunks;", 
      "+", 
      "+\tint nDeletedFiles;\t\t/* Count of files awaiting deletion;*/", 
      "+\tint nUnlinkedFiles;\t\t/* Count of unlinked files. */", 
      "+\tint nBackgroundDeletions;\t/* Count of background deletions. */", 
      "+", 
      "+\t/* yaffs2 runtime stuff */", 
      "+\tunsigned sequenceNumber;\t/* Sequence number of currently allocating block */", 
      "+\tunsigned oldestDirtySequence;", 
      "+", 
      "+} yaffs_CheckpointDevice;", 
      "+", 
      "+", 
      "+typedef struct {", 
      "+    int structType;", 
      "+    __u32 magic;", 
      "+    __u32 version;", 
      "+    __u32 head;", 
      "+} yaffs_CheckpointValidity;", 
      "+", 
      "+", 
      "+/*----------------------- YAFFS Functions -----------------------*/", 
      "+", 
      "+int yaffs_GutsInitialise(yaffs_Device * dev);", 
      "+void yaffs_Deinitialise(yaffs_Device * dev);", 
      "+", 
      "+int yaffs_GetNumberOfFreeChunks(yaffs_Device * dev);", 
      "+", 
      "+int yaffs_RenameObject(yaffs_Object * oldDir, const YCHAR * oldName,", 
      "+\t\t       yaffs_Object * newDir, const YCHAR * newName);", 
      "+", 
      "+int yaffs_Unlink(yaffs_Object * dir, const YCHAR * name);", 
      "+int yaffs_DeleteFile(yaffs_Object * obj);", 
      "+", 
      "+int yaffs_GetObjectName(yaffs_Object * obj, YCHAR * name, int buffSize);", 
      "+int yaffs_GetObjectFileLength(yaffs_Object * obj);", 
      "+int yaffs_GetObjectInode(yaffs_Object * obj);", 
      "+unsigned yaffs_GetObjectType(yaffs_Object * obj);", 
      "+int yaffs_GetObjectLinkCount(yaffs_Object * obj);", 
      "+", 
      "+int yaffs_SetAttributes(yaffs_Object * obj, struct iattr *attr);", 
      "+int yaffs_GetAttributes(yaffs_Object * obj, struct iattr *attr);", 
      "+", 
      "+/* File operations */", 
      "+int yaffs_ReadDataFromFile(yaffs_Object * obj, __u8 * buffer, loff_t offset,", 
      "+                           int nBytes);", 
      "+int yaffs_WriteDataToFile(yaffs_Object * obj, const __u8 * buffer, loff_t offset,", 
      "+                          int nBytes, int writeThrough);", 
      "+int yaffs_ResizeFile(yaffs_Object * obj, loff_t newSize);", 
      "+", 
      "+yaffs_Object *yaffs_MknodFile(yaffs_Object * parent, const YCHAR * name,", 
      "+                              __u32 mode, __u32 uid, __u32 gid);", 
      "+int yaffs_FlushFile(yaffs_Object * obj, int updateTime);", 
      "+", 
      "+/* Flushing and checkpointing */", 
      "+void yaffs_FlushEntireDeviceCache(yaffs_Device *dev);", 
      "+", 
      "+int yaffs_CheckpointSave(yaffs_Device *dev);", 
      "+int yaffs_CheckpointRestore(yaffs_Device *dev);", 
      "+", 
      "+/* Directory operations */", 
      "+yaffs_Object *yaffs_MknodDirectory(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t   __u32 mode, __u32 uid, __u32 gid);", 
      "+yaffs_Object *yaffs_FindObjectByName(yaffs_Object * theDir, const YCHAR * name);", 
      "+int yaffs_ApplyToDirectoryChildren(yaffs_Object * theDir,", 
      "+\t\t\t\t   int (*fn) (yaffs_Object *));", 
      "+", 
      "+yaffs_Object *yaffs_FindObjectByNumber(yaffs_Device * dev, __u32 number);", 
      "+", 
      "+/* Link operations */", 
      "+yaffs_Object *yaffs_Link(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t yaffs_Object * equivalentObject);", 
      "+", 
      "+yaffs_Object *yaffs_GetEquivalentObject(yaffs_Object * obj);", 
      "+", 
      "+/* Symlink operations */", 
      "+yaffs_Object *yaffs_MknodSymLink(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t __u32 mode, __u32 uid, __u32 gid,", 
      "+\t\t\t\t const YCHAR * alias);", 
      "+YCHAR *yaffs_GetSymlinkAlias(yaffs_Object * obj);", 
      "+", 
      "+/* Special inodes (fifos, sockets and devices) */", 
      "+yaffs_Object *yaffs_MknodSpecial(yaffs_Object * parent, const YCHAR * name,", 
      "+\t\t\t\t __u32 mode, __u32 uid, __u32 gid, __u32 rdev);", 
      "+", 
      "+/* Special directories */", 
      "+yaffs_Object *yaffs_Root(yaffs_Device * dev);", 
      "+yaffs_Object *yaffs_LostNFound(yaffs_Device * dev);", 
      "+", 
      "+#ifdef CONFIG_YAFFS_WINCE", 
      "+/* CONFIG_YAFFS_WINCE special stuff */", 
      "+void yfsd_WinFileTimeNow(__u32 target[2]);", 
      "+#endif", 
      "+", 
      "+#ifdef __KERNEL__", 
      "+", 
      "+void yaffs_HandleDeferedFree(yaffs_Object * obj);", 
      "+#endif", 
      "+", 
      "+/* Debug dump  */", 
      "+int yaffs_DumpObject(yaffs_Object * obj);", 
      "+", 
      "+void yaffs_GutsTest(yaffs_Device * dev);", 
      "+", 
      "+/* A few useful functions */", 
      "+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags);", 
      "+void yaffs_DeleteChunk(yaffs_Device * dev, int chunkId, int markNAND, int lyn);", 
      "+int yaffs_CheckFF(__u8 * buffer, int nBytes);", 
      "+void yaffs_HandleChunkError(yaffs_Device *dev, yaffs_BlockInfo *bi);", 
      "+", 
      "+__u8 *yaffs_GetTempBuffer(yaffs_Device * dev, int lineNo);", 
      "+void yaffs_ReleaseTempBuffer(yaffs_Device * dev, __u8 * buffer, int lineNo);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffsinterface.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffsinterface.h linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffsinterface.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffsinterface.h", 
      "@@ -0,0 +1,21 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFSINTERFACE_H__", 
      "+#define __YAFFSINTERFACE_H__", 
      "+", 
      "+int yaffs_Initialise(unsigned nBlocks);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif1.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.c", 
      "@@ -0,0 +1,369 @@", 
      "+/*", 
      "+ * YAFFS: Yet another FFS. A NAND-flash specific file system.", 
      "+ * yaffs_mtdif1.c  NAND mtd interface functions for small-page NAND.", 
      "+ *", 
      "+ * Copyright (C) 2002 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+/*", 
      "+ * This module provides the interface between yaffs_nand.c and the", 
      "+ * MTD API.  This version is used when the MTD interface supports the", 
      "+ * 'mtd_oob_ops' style calls to read_oob and write_oob, circa 2.6.17,", 
      "+ * and we have small-page NAND device.", 
      "+ *", 
      "+ * These functions are invoked via function pointers in yaffs_nand.c.", 
      "+ * This replaces functionality provided by functions in yaffs_mtdif.c", 
      "+ * and the yaffs_TagsCompatability functions in yaffs_tagscompat.c that are", 
      "+ * called in yaffs_mtdif.c when the function pointers are NULL.", 
      "+ * We assume the MTD layer is performing ECC (useNANDECC is true).", 
      "+ */", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+#include \"yaffs_guts.h\"", 
      "+#include \"yaffs_packedtags1.h\"", 
      "+#include \"yaffs_tagscompat.h\"\t// for yaffs_CalcTagsECC", 
      "+", 
      "+#include \"linux/kernel.h\"", 
      "+#include \"linux/version.h\"", 
      "+#include \"linux/types.h\"", 
      "+#include \"linux/mtd/mtd.h\"", 
      "+", 
      "+/* Don't compile this module if we don't have MTD's mtd_oob_ops interface */", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+", 
      "+const char *yaffs_mtdif1_c_version = \"$Id: yaffs_mtdif1.c,v 1.7 2007/12/13 15:35:18 wookey Exp $\";", 
      "+", 
      "+#ifndef CONFIG_YAFFS_9BYTE_TAGS", 
      "+# define YTAG1_SIZE 8", 
      "+#else", 
      "+# define YTAG1_SIZE 9", 
      "+#endif", 
      "+", 
      "+#if 0", 
      "+/* Use the following nand_ecclayout with MTD when using", 
      "+ * CONFIG_YAFFS_9BYTE_TAGS and the older on-NAND tags layout.", 
      "+ * If you have existing Yaffs images and the byte order differs from this,", 
      "+ * adjust 'oobfree' to match your existing Yaffs data.", 
      "+ *", 
      "+ * This nand_ecclayout scatters/gathers to/from the old-yaffs layout with the", 
      "+ * pageStatus byte (at NAND spare offset 4) scattered/gathered from/to", 
      "+ * the 9th byte.", 
      "+ *", 
      "+ * Old-style on-NAND format: T0,T1,T2,T3,P,B,T4,T5,E0,E1,E2,T6,T7,E3,E4,E5", 
      "+ * We have/need PackedTags1 plus pageStatus: T0,T1,T2,T3,T4,T5,T6,T7,P", 
      "+ * where Tn are the tag bytes, En are MTD's ECC bytes, P is the pageStatus", 
      "+ * byte and B is the small-page bad-block indicator byte.", 
      "+ */", 
      "+static struct nand_ecclayout nand_oob_16 = {", 
      "+\t.eccbytes = 6,", 
      "+\t.eccpos = { 8, 9, 10, 13, 14, 15 },", 
      "+\t.oobavail = 9,", 
      "+\t.oobfree = { { 0, 4 }, { 6, 2 }, { 11, 2 }, { 4, 1 } }", 
      "+};", 
      "+#endif", 
      "+", 
      "+/* Write a chunk (page) of data to NAND.", 
      "+ *", 
      "+ * Caller always provides ExtendedTags data which are converted to a more", 
      "+ * compact (packed) form for storage in NAND.  A mini-ECC runs over the", 
      "+ * contents of the tags meta-data; used to valid the tags when read.", 
      "+ *", 
      "+ *  - Pack ExtendedTags to PackedTags1 form", 
      "+ *  - Compute mini-ECC for PackedTags1", 
      "+ *  - Write data and packed tags to NAND.", 
      "+ *", 
      "+ * Note: Due to the use of the PackedTags1 meta-data which does not include", 
      "+ * a full sequence number (as found in the larger PackedTags2 form) it is", 
      "+ * necessary for Yaffs to re-write a chunk/page (just once) to mark it as", 
      "+ * discarded and dirty.  This is not ideal: newer NAND parts are supposed", 
      "+ * to be written just once.  When Yaffs performs this operation, this", 
      "+ * function is called with a NULL data pointer -- calling MTD write_oob", 
      "+ * without data is valid usage (2.6.17).", 
      "+ *", 
      "+ * Any underlying MTD error results in YAFFS_FAIL.", 
      "+ * Returns YAFFS_OK or YAFFS_FAIL.", 
      "+ */", 
      "+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device *dev,", 
      "+\tint chunkInNAND, const __u8 * data, const yaffs_ExtendedTags * etags)", 
      "+{", 
      "+\tstruct mtd_info * mtd = dev->genericDevice;", 
      "+\tint chunkBytes = dev->nDataBytesPerChunk;", 
      "+\tloff_t addr = ((loff_t)chunkInNAND) * chunkBytes;", 
      "+\tstruct mtd_oob_ops ops;", 
      "+\tyaffs_PackedTags1 pt1;", 
      "+\tint retval;", 
      "+", 
      "+\t/* we assume that PackedTags1 and yaffs_Tags are compatible */", 
      "+\tcompile_time_assertion(sizeof(yaffs_PackedTags1) == 12);", 
      "+\tcompile_time_assertion(sizeof(yaffs_Tags) == 8);", 
      "+", 
      "+\tdev->nPageWrites++;", 
      "+", 
      "+\tyaffs_PackTags1(&pt1, etags);", 
      "+\tyaffs_CalcTagsECC((yaffs_Tags *)&pt1);", 
      "+", 
      "+\t/* When deleting a chunk, the upper layer provides only skeletal", 
      "+\t * etags, one with chunkDeleted set.  However, we need to update the", 
      "+\t * tags, not erase them completely.  So we use the NAND write property", 
      "+\t * that only zeroed-bits stick and set tag bytes to all-ones and", 
      "+\t * zero just the (not) deleted bit.", 
      "+\t */", 
      "+#ifndef CONFIG_YAFFS_9BYTE_TAGS", 
      "+\tif (etags->chunkDeleted) {", 
      "+\t\tmemset(&pt1, 0xff, 8);", 
      "+\t\t/* clear delete status bit to indicate deleted */", 
      "+\t\tpt1.deleted = 0;", 
      "+\t}", 
      "+#else", 
      "+\t((__u8 *)&pt1)[8] = 0xff;", 
      "+\tif (etags->chunkDeleted) {", 
      "+\t\tmemset(&pt1, 0xff, 8);", 
      "+\t\t/* zero pageStatus byte to indicate deleted */", 
      "+\t\t((__u8 *)&pt1)[8] = 0;", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tmemset(&ops, 0, sizeof(ops));", 
      "+\tops.mode = MTD_OOB_AUTO;", 
      "+\tops.len = (data) ? chunkBytes : 0;", 
      "+\tops.ooblen = YTAG1_SIZE;", 
      "+\tops.datbuf = (__u8 *)data;", 
      "+\tops.oobbuf = (__u8 *)&pt1;", 
      "+", 
      "+\tretval = mtd->write_oob(mtd, addr, &ops);", 
      "+\tif (retval) {", 
      "+\t\tyaffs_trace(YAFFS_TRACE_MTD,", 
      "+\t\t\t\"write_oob failed, chunk %d, mtd error %d\\n\",", 
      "+\t\t\tchunkInNAND, retval);", 
      "+\t}", 
      "+\treturn retval ? YAFFS_FAIL : YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* Return with empty ExtendedTags but add eccResult.", 
      "+ */", 
      "+static int rettags(yaffs_ExtendedTags * etags, int eccResult, int retval)", 
      "+{", 
      "+\tif (etags) {", 
      "+\t\tmemset(etags, 0, sizeof(*etags));", 
      "+\t\tetags->eccResult = eccResult;", 
      "+\t}", 
      "+\treturn retval;", 
      "+}", 
      "+", 
      "+/* Read a chunk (page) from NAND.", 
      "+ *", 
      "+ * Caller expects ExtendedTags data to be usable even on error; that is,", 
      "+ * all members except eccResult and blockBad are zeroed.", 
      "+ *", 
      "+ *  - Check ECC results for data (if applicable)", 
      "+ *  - Check for blank/erased block (return empty ExtendedTags if blank)", 
      "+ *  - Check the PackedTags1 mini-ECC (correct if necessary/possible)", 
      "+ *  - Convert PackedTags1 to ExtendedTags", 
      "+ *  - Update eccResult and blockBad members to refect state.", 
      "+ *", 
      "+ * Returns YAFFS_OK or YAFFS_FAIL.", 
      "+ */", 
      "+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device *dev,", 
      "+\tint chunkInNAND, __u8 * data, yaffs_ExtendedTags * etags)", 
      "+{", 
      "+\tstruct mtd_info * mtd = dev->genericDevice;", 
      "+\tint chunkBytes = dev->nDataBytesPerChunk;", 
      "+\tloff_t addr = ((loff_t)chunkInNAND) * chunkBytes;", 
      "+\tint eccres = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+\tstruct mtd_oob_ops ops;", 
      "+\tyaffs_PackedTags1 pt1;", 
      "+\tint retval;", 
      "+\tint deleted;", 
      "+", 
      "+\tdev->nPageReads++;", 
      "+", 
      "+\tmemset(&ops, 0, sizeof(ops));", 
      "+\tops.mode = MTD_OOB_AUTO;", 
      "+\tops.len = (data) ? chunkBytes : 0;", 
      "+\tops.ooblen = YTAG1_SIZE;", 
      "+\tops.datbuf = data;", 
      "+\tops.oobbuf = (__u8 *)&pt1;", 
      "+", 
      "+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,20))", 
      "+\t/* In MTD 2.6.18 to 2.6.19 nand_base.c:nand_do_read_oob() has a bug;", 
      "+\t * help it out with ops.len = ops.ooblen when ops.datbuf == NULL.", 
      "+\t */", 
      "+\tops.len = (ops.datbuf) ? ops.len : ops.ooblen;", 
      "+#endif", 
      "+\t/* Read page and oob using MTD.", 
      "+\t * Check status and determine ECC result.", 
      "+\t */", 
      "+\tretval = mtd->read_oob(mtd, addr, &ops);", 
      "+\tif (retval) {", 
      "+\t\tyaffs_trace(YAFFS_TRACE_MTD,", 
      "+\t\t\t\"read_oob failed, chunk %d, mtd error %d\\n\",", 
      "+\t\t\tchunkInNAND, retval);", 
      "+\t}", 
      "+", 
      "+\tswitch (retval) {", 
      "+\tcase 0:", 
      "+\t\t/* no error */", 
      "+\t\tbreak;", 
      "+", 
      "+\tcase -EUCLEAN:", 
      "+\t\t/* MTD's ECC fixed the data */", 
      "+\t\teccres = YAFFS_ECC_RESULT_FIXED;", 
      "+\t\tdev->eccFixed++;", 
      "+\t\tbreak;", 
      "+", 
      "+\tcase -EBADMSG:", 
      "+\t\t/* MTD's ECC could not fix the data */", 
      "+\t\tdev->eccUnfixed++;", 
      "+\t\t/* fall into... */", 
      "+\tdefault:", 
      "+\t\trettags(etags, YAFFS_ECC_RESULT_UNFIXED, 0);", 
      "+\t\tetags->blockBad = (mtd->block_isbad)(mtd, addr);", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\t/* Check for a blank/erased chunk.", 
      "+\t */", 
      "+\tif (yaffs_CheckFF((__u8 *)&pt1, 8)) {", 
      "+\t\t/* when blank, upper layers want eccResult to be <= NO_ERROR */", 
      "+\t\treturn rettags(etags, YAFFS_ECC_RESULT_NO_ERROR, YAFFS_OK);", 
      "+\t}", 
      "+", 
      "+#ifndef CONFIG_YAFFS_9BYTE_TAGS", 
      "+\t/* Read deleted status (bit) then return it to it's non-deleted", 
      "+\t * state before performing tags mini-ECC check. pt1.deleted is", 
      "+\t * inverted.", 
      "+\t */", 
      "+\tdeleted = !pt1.deleted;", 
      "+\tpt1.deleted = 1;", 
      "+#else", 
      "+\tdeleted = (yaffs_CountBits(((__u8 *)&pt1)[8]) < 7);", 
      "+#endif", 
      "+", 
      "+\t/* Check the packed tags mini-ECC and correct if necessary/possible.", 
      "+\t */", 
      "+\tretval = yaffs_CheckECCOnTags((yaffs_Tags *)&pt1);", 
      "+\tswitch (retval) {", 
      "+\tcase 0:", 
      "+\t\t/* no tags error, use MTD result */", 
      "+\t\tbreak;", 
      "+\tcase 1:", 
      "+\t\t/* recovered tags-ECC error */", 
      "+\t\tdev->tagsEccFixed++;", 
      "+\t\tif (eccres == YAFFS_ECC_RESULT_NO_ERROR)", 
      "+\t\t\teccres = YAFFS_ECC_RESULT_FIXED;", 
      "+\t\tbreak;", 
      "+\tdefault:", 
      "+\t\t/* unrecovered tags-ECC error */", 
      "+\t\tdev->tagsEccUnfixed++;", 
      "+\t\treturn rettags(etags, YAFFS_ECC_RESULT_UNFIXED, YAFFS_FAIL);", 
      "+\t}", 
      "+", 
      "+\t/* Unpack the tags to extended form and set ECC result.", 
      "+\t * [set shouldBeFF just to keep yaffs_UnpackTags1 happy]", 
      "+\t */", 
      "+\tpt1.shouldBeFF = 0xFFFFFFFF;", 
      "+\tyaffs_UnpackTags1(etags, &pt1);", 
      "+\tetags->eccResult = eccres;", 
      "+", 
      "+\t/* Set deleted state */", 
      "+\tetags->chunkDeleted = deleted;", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* Mark a block bad.", 
      "+ *", 
      "+ * This is a persistant state.", 
      "+ * Use of this function should be rare.", 
      "+ *", 
      "+ * Returns YAFFS_OK or YAFFS_FAIL.", 
      "+ */", 
      "+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)", 
      "+{", 
      "+\tstruct mtd_info * mtd = dev->genericDevice;", 
      "+\tint blocksize = dev->nChunksPerBlock * dev->nDataBytesPerChunk;", 
      "+\tint retval;", 
      "+", 
      "+\tyaffs_trace(YAFFS_TRACE_BAD_BLOCKS, \"marking block %d bad\\n\", blockNo);", 
      "+", 
      "+\tretval = mtd->block_markbad(mtd, (loff_t)blocksize * blockNo);", 
      "+\treturn (retval) ? YAFFS_FAIL : YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* Check any MTD prerequists.", 
      "+ *", 
      "+ * Returns YAFFS_OK or YAFFS_FAIL.", 
      "+ */", 
      "+static int nandmtd1_TestPrerequists(struct mtd_info * mtd)", 
      "+{", 
      "+\t/* 2.6.18 has mtd->ecclayout->oobavail */", 
      "+\t/* 2.6.21 has mtd->ecclayout->oobavail and mtd->oobavail */", 
      "+\tint oobavail = mtd->ecclayout->oobavail;", 
      "+", 
      "+\tif (oobavail < YTAG1_SIZE) {", 
      "+\t\tyaffs_trace(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\"mtd device has only %d bytes for tags, need %d\\n\",", 
      "+\t\t\toobavail, YTAG1_SIZE);", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+/* Query for the current state of a specific block.", 
      "+ *", 
      "+ * Examine the tags of the first chunk of the block and return the state:", 
      "+ *  - YAFFS_BLOCK_STATE_DEAD, the block is marked bad", 
      "+ *  - YAFFS_BLOCK_STATE_NEEDS_SCANNING, the block is in use", 
      "+ *  - YAFFS_BLOCK_STATE_EMPTY, the block is clean", 
      "+ *", 
      "+ * Always returns YAFFS_OK.", 
      "+ */", 
      "+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,", 
      "+\tyaffs_BlockState * pState, int *pSequenceNumber)", 
      "+{", 
      "+\tstruct mtd_info * mtd = dev->genericDevice;", 
      "+\tint chunkNo = blockNo * dev->nChunksPerBlock;", 
      "+\tloff_t addr = (loff_t)chunkNo * dev->nDataBytesPerChunk;", 
      "+\tyaffs_ExtendedTags etags;", 
      "+\tint state = YAFFS_BLOCK_STATE_DEAD;", 
      "+\tint seqnum = 0;", 
      "+\tint retval;", 
      "+", 
      "+\t/* We don't yet have a good place to test for MTD config prerequists.", 
      "+\t * Do it here as we are called during the initial scan.", 
      "+\t */", 
      "+\tif (nandmtd1_TestPrerequists(mtd) != YAFFS_OK) {", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tretval = nandmtd1_ReadChunkWithTagsFromNAND(dev, chunkNo, NULL, &etags);", 
      "+\tetags.blockBad = (mtd->block_isbad)(mtd, addr);", 
      "+\tif (etags.blockBad) {", 
      "+\t\tyaffs_trace(YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t\t\tKERN_WARNING \"block %d is marked bad\\n\", blockNo);", 
      "+\t\tstate = YAFFS_BLOCK_STATE_DEAD;", 
      "+\t}", 
      "+\telse if (etags.eccResult != YAFFS_ECC_RESULT_NO_ERROR) {", 
      "+\t\t/* bad tags, need to look more closely */", 
      "+\t\tstate = YAFFS_BLOCK_STATE_NEEDS_SCANNING;", 
      "+\t}", 
      "+\telse if (etags.chunkUsed) {", 
      "+\t\tstate = YAFFS_BLOCK_STATE_NEEDS_SCANNING;", 
      "+\t\tseqnum = etags.sequenceNumber;", 
      "+\t}", 
      "+\telse {", 
      "+\t\tstate = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t}", 
      "+", 
      "+\t*pState = state;", 
      "+\t*pSequenceNumber = seqnum;", 
      "+", 
      "+\t/* query always succeeds */", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+", 
      "+#endif /*MTD_VERSION*/"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif1.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif1.h", 
      "@@ -0,0 +1,28 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_MTDIF1_H__", 
      "+#define __YAFFS_MTDIF1_H__", 
      "+", 
      "+int nandmtd1_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\tconst __u8 * data, const yaffs_ExtendedTags * tags);", 
      "+", 
      "+int nandmtd1_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t__u8 * data, yaffs_ExtendedTags * tags);", 
      "+", 
      "+int nandmtd1_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);", 
      "+", 
      "+int nandmtd1_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,", 
      "+\tyaffs_BlockState * state, int *sequenceNumber);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif2.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.c", 
      "@@ -0,0 +1,248 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+/* mtd interface for YAFFS2 */", 
      "+", 
      "+const char *yaffs_mtdif2_c_version =", 
      "+    \"$Id: yaffs_mtdif2.c,v 1.20 2008/05/05 07:58:58 charles Exp $\";", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+", 
      "+#include \"yaffs_mtdif2.h\"", 
      "+", 
      "+#include \"linux/mtd/mtd.h\"", 
      "+#include \"linux/types.h\"", 
      "+#include \"linux/time.h\"", 
      "+", 
      "+#include \"yaffs_packedtags2.h\"", 
      "+", 
      "+/* NB For use with inband tags....", 
      "+ * We assume that the data buffer is of size totalBytersPerChunk so that we can also", 
      "+ * use it to load the tags.", 
      "+ */", 
      "+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t      const __u8 * data,", 
      "+\t\t\t\t      const yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\tstruct mtd_oob_ops ops;", 
      "+#else", 
      "+\tsize_t dummy;", 
      "+#endif", 
      "+\tint retval = 0;", 
      "+", 
      "+\tloff_t addr;", 
      "+", 
      "+\tyaffs_PackedTags2 pt;", 
      "+", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR", 
      "+\t   (\"nandmtd2_WriteChunkWithTagsToNAND chunk %d data %p tags %p\"", 
      "+\t    TENDSTR), chunkInNAND, data, tags));", 
      "+", 
      "+", 
      "+\taddr  = ((loff_t) chunkInNAND) * dev->totalBytesPerChunk;", 
      "+", 
      "+\t/* For yaffs2 writing there must be both data and tags.", 
      "+\t * If we're using inband tags, then the tags are stuffed into", 
      "+\t * the end of the data buffer.", 
      "+\t */", 
      "+\tif(!data || !tags)", 
      "+\t\tBUG();", 
      "+\telse if(dev->inbandTags){", 
      "+\t\tyaffs_PackedTags2TagsPart *pt2tp;", 
      "+\t\tpt2tp = (yaffs_PackedTags2TagsPart *)(data + dev->nDataBytesPerChunk);", 
      "+\t\tyaffs_PackTags2TagsPart(pt2tp,tags);", 
      "+\t}", 
      "+\telse", 
      "+\t\tyaffs_PackTags2(&pt, tags);", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\tops.mode = MTD_OOB_AUTO;", 
      "+\tops.ooblen = (dev->inbandTags) ? 0 : sizeof(pt);", 
      "+\tops.len = dev->totalBytesPerChunk;", 
      "+\tops.ooboffs = 0;", 
      "+\tops.datbuf = (__u8 *)data;", 
      "+\tops.oobbuf = (dev->inbandTags) ? NULL : (void *)&pt;", 
      "+\tretval = mtd->write_oob(mtd, addr, &ops);", 
      "+", 
      "+#else", 
      "+\tif (!dev->inbandTags) {", 
      "+\t\tretval =", 
      "+\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t   &dummy, data, (__u8 *) & pt, NULL);", 
      "+\t} else {", 
      "+\t\tretval =", 
      "+\t\t    mtd->write(mtd, addr, dev->totalBytesPerChunk, &dummy,", 
      "+\t\t\t       data);", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t       __u8 * data, yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\tstruct mtd_oob_ops ops;", 
      "+#endif", 
      "+\tsize_t dummy;", 
      "+\tint retval = 0;", 
      "+\tint localData = 0;", 
      "+", 
      "+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;", 
      "+", 
      "+\tyaffs_PackedTags2 pt;", 
      "+", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR", 
      "+\t   (\"nandmtd2_ReadChunkWithTagsFromNAND chunk %d data %p tags %p\"", 
      "+\t    TENDSTR), chunkInNAND, data, tags));", 
      "+", 
      "+\tif(dev->inbandTags){", 
      "+", 
      "+\t\tif(!data) {", 
      "+\t\t\tlocalData = 1;", 
      "+\t\t\tdata = yaffs_GetTempBuffer(dev,__LINE__);", 
      "+\t\t}", 
      "+", 
      "+", 
      "+\t}", 
      "+", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,17))", 
      "+\tif (dev->inbandTags || (data && !tags))", 
      "+\t\tretval = mtd->read(mtd, addr, dev->totalBytesPerChunk,", 
      "+\t\t\t\t&dummy, data);", 
      "+\telse if (tags) {", 
      "+\t\tops.mode = MTD_OOB_AUTO;", 
      "+\t\tops.ooblen = sizeof(pt);", 
      "+\t\tops.len = data ? dev->nDataBytesPerChunk : sizeof(pt);", 
      "+\t\tops.ooboffs = 0;", 
      "+\t\tops.datbuf = data;", 
      "+\t\tops.oobbuf = dev->spareBuffer;", 
      "+\t\tretval = mtd->read_oob(mtd, addr, &ops);", 
      "+\t}", 
      "+#else", 
      "+\tif (!dev->inbandTags && data && tags) {", 
      "+", 
      "+\t\tretval = mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t  &dummy, data, dev->spareBuffer,", 
      "+\t\t\t\t\t  NULL);", 
      "+\t} else {", 
      "+\t\tif (data)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,", 
      "+\t\t\t\t      data);", 
      "+\t\tif (!dev->inbandTags && tags)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read_oob(mtd, addr, mtd->oobsize, &dummy,", 
      "+\t\t\t\t\t  dev->spareBuffer);", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+", 
      "+\tif(dev->inbandTags){", 
      "+\t\tif(tags){", 
      "+\t\t\tyaffs_PackedTags2TagsPart * pt2tp;", 
      "+\t\t\tpt2tp = (yaffs_PackedTags2TagsPart *)&data[dev->nDataBytesPerChunk];", 
      "+\t\t\tyaffs_UnpackTags2TagsPart(tags,pt2tp);", 
      "+\t\t}", 
      "+\t}", 
      "+\telse {", 
      "+\t\tif (tags){", 
      "+\t\t\tmemcpy(&pt, dev->spareBuffer, sizeof(pt));", 
      "+\t\t\tyaffs_UnpackTags2(tags, &pt);", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tif(localData)", 
      "+\t\tyaffs_ReleaseTempBuffer(dev,data,__LINE__);", 
      "+", 
      "+\tif(tags && retval == -EBADMSG && tags->eccResult == YAFFS_ECC_RESULT_NO_ERROR)", 
      "+\t\ttags->eccResult = YAFFS_ECC_RESULT_UNFIXED;", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+\tint retval;", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR(\"nandmtd2_MarkNANDBlockBad %d\" TENDSTR), blockNo));", 
      "+", 
      "+\tretval =", 
      "+\t    mtd->block_markbad(mtd,", 
      "+\t\t\t       blockNo * dev->nChunksPerBlock *", 
      "+\t\t\t       dev->nDataBytesPerChunk);", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+", 
      "+}", 
      "+", 
      "+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,", 
      "+\t\t\t    yaffs_BlockState * state, int *sequenceNumber)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+\tint retval;", 
      "+", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR(\"nandmtd2_QueryNANDBlock %d\" TENDSTR), blockNo));", 
      "+\tretval =", 
      "+\t    mtd->block_isbad(mtd,", 
      "+\t\t\t     blockNo * dev->nChunksPerBlock *", 
      "+\t\t\t     dev->nDataBytesPerChunk);", 
      "+", 
      "+\tif (retval) {", 
      "+\t\tT(YAFFS_TRACE_MTD, (TSTR(\"block is bad\" TENDSTR)));", 
      "+", 
      "+\t\t*state = YAFFS_BLOCK_STATE_DEAD;", 
      "+\t\t*sequenceNumber = 0;", 
      "+\t} else {", 
      "+\t\tyaffs_ExtendedTags t;", 
      "+\t\tnandmtd2_ReadChunkWithTagsFromNAND(dev,", 
      "+\t\t\t\t\t\t   blockNo *", 
      "+\t\t\t\t\t\t   dev->nChunksPerBlock, NULL,", 
      "+\t\t\t\t\t\t   &t);", 
      "+", 
      "+\t\tif (t.chunkUsed) {", 
      "+\t\t\t*sequenceNumber = t.sequenceNumber;", 
      "+\t\t\t*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;", 
      "+\t\t} else {", 
      "+\t\t\t*sequenceNumber = 0;", 
      "+\t\t\t*state = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\t\t}", 
      "+\t}", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR(\"block is bad seq %d state %d\" TENDSTR), *sequenceNumber,", 
      "+\t   *state));", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif2.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif2.h", 
      "@@ -0,0 +1,29 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_MTDIF2_H__", 
      "+#define __YAFFS_MTDIF2_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+int nandmtd2_WriteChunkWithTagsToNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t      const __u8 * data,", 
      "+\t\t\t\t      const yaffs_ExtendedTags * tags);", 
      "+int nandmtd2_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t       __u8 * data, yaffs_ExtendedTags * tags);", 
      "+int nandmtd2_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);", 
      "+int nandmtd2_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,", 
      "+\t\t\t    yaffs_BlockState * state, int *sequenceNumber);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.c", 
      "@@ -0,0 +1,241 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+const char *yaffs_mtdif_c_version =", 
      "+    \"$Id: yaffs_mtdif.c,v 1.21 2007/12/13 15:35:18 wookey Exp $\";", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+", 
      "+#include \"yaffs_mtdif.h\"", 
      "+", 
      "+#include \"linux/mtd/mtd.h\"", 
      "+#include \"linux/types.h\"", 
      "+#include \"linux/time.h\"", 
      "+#include \"linux/mtd/nand.h\"", 
      "+", 
      "+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,18))", 
      "+static struct nand_oobinfo yaffs_oobinfo = {", 
      "+\t.useecc = 1,", 
      "+\t.eccbytes = 6,", 
      "+\t.eccpos = {8, 9, 10, 13, 14, 15}", 
      "+};", 
      "+", 
      "+static struct nand_oobinfo yaffs_noeccinfo = {", 
      "+\t.useecc = 0,", 
      "+};", 
      "+#endif", 
      "+", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+static inline void translate_spare2oob(const yaffs_Spare *spare, __u8 *oob)", 
      "+{", 
      "+\toob[0] = spare->tagByte0;", 
      "+\toob[1] = spare->tagByte1;", 
      "+\toob[2] = spare->tagByte2;", 
      "+\toob[3] = spare->tagByte3;", 
      "+\toob[4] = spare->tagByte4;", 
      "+\toob[5] = spare->tagByte5 & 0x3f;", 
      "+\toob[5] |= spare->blockStatus == 'Y' ? 0: 0x80;", 
      "+\toob[5] |= spare->pageStatus == 0 ? 0: 0x40;", 
      "+\toob[6] = spare->tagByte6;", 
      "+\toob[7] = spare->tagByte7;", 
      "+}", 
      "+", 
      "+static inline void translate_oob2spare(yaffs_Spare *spare, __u8 *oob)", 
      "+{", 
      "+\tstruct yaffs_NANDSpare *nspare = (struct yaffs_NANDSpare *)spare;", 
      "+\tspare->tagByte0 = oob[0];", 
      "+\tspare->tagByte1 = oob[1];", 
      "+\tspare->tagByte2 = oob[2];", 
      "+\tspare->tagByte3 = oob[3];", 
      "+\tspare->tagByte4 = oob[4];", 
      "+\tspare->tagByte5 = oob[5] == 0xff ? 0xff : oob[5] & 0x3f;", 
      "+\tspare->blockStatus = oob[5] & 0x80 ? 0xff : 'Y';", 
      "+\tspare->pageStatus = oob[5] & 0x40 ? 0xff : 0;", 
      "+\tspare->ecc1[0] = spare->ecc1[1] = spare->ecc1[2] = 0xff;", 
      "+\tspare->tagByte6 = oob[6];", 
      "+\tspare->tagByte7 = oob[7];", 
      "+\tspare->ecc2[0] = spare->ecc2[1] = spare->ecc2[2] = 0xff;", 
      "+", 
      "+\tnspare->eccres1 = nspare->eccres2 = 0; /* FIXME */", 
      "+}", 
      "+#endif", 
      "+", 
      "+int nandmtd_WriteChunkToNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t     const __u8 * data, const yaffs_Spare * spare)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\tstruct mtd_oob_ops ops;", 
      "+#endif", 
      "+\tsize_t dummy;", 
      "+\tint retval = 0;", 
      "+", 
      "+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\t__u8 spareAsBytes[8]; /* OOB */", 
      "+", 
      "+\tif (data && !spare)", 
      "+\t\tretval = mtd->write(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t&dummy, data);", 
      "+\telse if (spare) {", 
      "+\t\tif (dev->useNANDECC) {", 
      "+\t\t\ttranslate_spare2oob(spare, spareAsBytes);", 
      "+\t\t\tops.mode = MTD_OOB_AUTO;", 
      "+\t\t\tops.ooblen = 8; /* temp hack */", 
      "+\t\t} else {", 
      "+\t\t\tops.mode = MTD_OOB_RAW;", 
      "+\t\t\tops.ooblen = YAFFS_BYTES_PER_SPARE;", 
      "+\t\t}", 
      "+\t\tops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;", 
      "+\t\tops.datbuf = (u8 *)data;", 
      "+\t\tops.ooboffs = 0;", 
      "+\t\tops.oobbuf = spareAsBytes;", 
      "+\t\tretval = mtd->write_oob(mtd, addr, &ops);", 
      "+\t}", 
      "+#else", 
      "+\t__u8 *spareAsBytes = (__u8 *) spare;", 
      "+", 
      "+\tif (data && spare) {", 
      "+\t\tif (dev->useNANDECC)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t   &dummy, data, spareAsBytes,", 
      "+\t\t\t\t\t   &yaffs_oobinfo);", 
      "+\t\telse", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->write_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t   &dummy, data, spareAsBytes,", 
      "+\t\t\t\t\t   &yaffs_noeccinfo);", 
      "+\t} else {", 
      "+\t\tif (data)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->write(mtd, addr, dev->nDataBytesPerChunk, &dummy,", 
      "+\t\t\t\t       data);", 
      "+\t\tif (spare)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->write_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,", 
      "+\t\t\t\t\t   &dummy, spareAsBytes);", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int nandmtd_ReadChunkFromNAND(yaffs_Device * dev, int chunkInNAND, __u8 * data,", 
      "+\t\t\t      yaffs_Spare * spare)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\tstruct mtd_oob_ops ops;", 
      "+#endif", 
      "+\tsize_t dummy;", 
      "+\tint retval = 0;", 
      "+", 
      "+\tloff_t addr = ((loff_t) chunkInNAND) * dev->nDataBytesPerChunk;", 
      "+#if (MTD_VERSION_CODE > MTD_VERSION(2,6,17))", 
      "+\t__u8 spareAsBytes[8]; /* OOB */", 
      "+", 
      "+\tif (data && !spare)", 
      "+\t\tretval = mtd->read(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t&dummy, data);", 
      "+\telse if (spare) {", 
      "+\t\tif (dev->useNANDECC) {", 
      "+\t\t\tops.mode = MTD_OOB_AUTO;", 
      "+\t\t\tops.ooblen = 8; /* temp hack */", 
      "+\t\t} else {", 
      "+\t\t\tops.mode = MTD_OOB_RAW;", 
      "+\t\t\tops.ooblen = YAFFS_BYTES_PER_SPARE;", 
      "+\t\t}", 
      "+\t\tops.len = data ? dev->nDataBytesPerChunk : ops.ooblen;", 
      "+\t\tops.datbuf = data;", 
      "+\t\tops.ooboffs = 0;", 
      "+\t\tops.oobbuf = spareAsBytes;", 
      "+\t\tretval = mtd->read_oob(mtd, addr, &ops);", 
      "+\t\tif (dev->useNANDECC)", 
      "+\t\t\ttranslate_oob2spare(spare, spareAsBytes);", 
      "+\t}", 
      "+#else", 
      "+\t__u8 *spareAsBytes = (__u8 *) spare;", 
      "+", 
      "+\tif (data && spare) {", 
      "+\t\tif (dev->useNANDECC) {", 
      "+\t\t\t/* Careful, this call adds 2 ints */", 
      "+\t\t\t/* to the end of the spare data.  Calling function */", 
      "+\t\t\t/* should allocate enough memory for spare, */", 
      "+\t\t\t/* i.e. [YAFFS_BYTES_PER_SPARE+2*sizeof(int)]. */", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t  &dummy, data, spareAsBytes,", 
      "+\t\t\t\t\t  &yaffs_oobinfo);", 
      "+\t\t} else {", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read_ecc(mtd, addr, dev->nDataBytesPerChunk,", 
      "+\t\t\t\t\t  &dummy, data, spareAsBytes,", 
      "+\t\t\t\t\t  &yaffs_noeccinfo);", 
      "+\t\t}", 
      "+\t} else {", 
      "+\t\tif (data)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read(mtd, addr, dev->nDataBytesPerChunk, &dummy,", 
      "+\t\t\t\t      data);", 
      "+\t\tif (spare)", 
      "+\t\t\tretval =", 
      "+\t\t\t    mtd->read_oob(mtd, addr, YAFFS_BYTES_PER_SPARE,", 
      "+\t\t\t\t\t  &dummy, spareAsBytes);", 
      "+\t}", 
      "+#endif", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int nandmtd_EraseBlockInNAND(yaffs_Device * dev, int blockNumber)", 
      "+{", 
      "+\tstruct mtd_info *mtd = (struct mtd_info *)(dev->genericDevice);", 
      "+\t__u32 addr =", 
      "+\t    ((loff_t) blockNumber) * dev->nDataBytesPerChunk", 
      "+\t\t* dev->nChunksPerBlock;", 
      "+\tstruct erase_info ei;", 
      "+\tint retval = 0;", 
      "+", 
      "+\tei.mtd = mtd;", 
      "+\tei.addr = addr;", 
      "+\tei.len = dev->nDataBytesPerChunk * dev->nChunksPerBlock;", 
      "+\tei.time = 1000;", 
      "+\tei.retries = 2;", 
      "+\tei.callback = NULL;", 
      "+\tei.priv = (u_long) dev;", 
      "+", 
      "+\t/* Todo finish off the ei if required */", 
      "+", 
      "+\tsema_init(&dev->sem, 0);", 
      "+", 
      "+\tretval = mtd->erase(mtd, &ei);", 
      "+", 
      "+\tif (retval == 0)", 
      "+\t\treturn YAFFS_OK;", 
      "+\telse", 
      "+\t\treturn YAFFS_FAIL;", 
      "+}", 
      "+", 
      "+int nandmtd_InitialiseNAND(yaffs_Device * dev)", 
      "+{", 
      "+\treturn YAFFS_OK;", 
      "+}", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_mtdif.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_mtdif.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_mtdif.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_mtdif.h", 
      "@@ -0,0 +1,32 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_MTDIF_H__", 
      "+#define __YAFFS_MTDIF_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+#if (MTD_VERSION_CODE < MTD_VERSION(2,6,18))", 
      "+extern struct nand_oobinfo yaffs_oobinfo;", 
      "+extern struct nand_oobinfo yaffs_noeccinfo;", 
      "+#endif", 
      "+", 
      "+int nandmtd_WriteChunkToNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t     const __u8 * data, const yaffs_Spare * spare);", 
      "+int nandmtd_ReadChunkFromNAND(yaffs_Device * dev, int chunkInNAND, __u8 * data,", 
      "+\t\t\t      yaffs_Spare * spare);", 
      "+int nandmtd_EraseBlockInNAND(yaffs_Device * dev, int blockNumber);", 
      "+int nandmtd_InitialiseNAND(yaffs_Device * dev);", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_nand.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nand.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_nand.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.c", 
      "@@ -0,0 +1,135 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+const char *yaffs_nand_c_version =", 
      "+    \"$Id: yaffs_nand.c,v 1.9 2008/05/05 07:58:58 charles Exp $\";", 
      "+", 
      "+#include \"yaffs_nand.h\"", 
      "+#include \"yaffs_tagscompat.h\"", 
      "+#include \"yaffs_tagsvalidity.h\"", 
      "+", 
      "+#include \"yaffs_getblockinfo.h\"", 
      "+", 
      "+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t\t   __u8 * buffer,", 
      "+\t\t\t\t\t   yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\tint result;", 
      "+\tyaffs_ExtendedTags localTags;", 
      "+", 
      "+\tint realignedChunkInNAND = chunkInNAND - dev->chunkOffset;", 
      "+", 
      "+\t/* If there are no tags provided, use local tags to get prioritised gc working */", 
      "+\tif(!tags)", 
      "+\t\ttags = &localTags;", 
      "+", 
      "+\tif (dev->readChunkWithTagsFromNAND)", 
      "+\t\tresult = dev->readChunkWithTagsFromNAND(dev, realignedChunkInNAND, buffer,", 
      "+\t\t\t\t\t\t      tags);", 
      "+\telse", 
      "+\t\tresult = yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(dev,", 
      "+\t\t\t\t\t\t\t\t\trealignedChunkInNAND,", 
      "+\t\t\t\t\t\t\t\t\tbuffer,", 
      "+\t\t\t\t\t\t\t\t\ttags);", 
      "+\tif(tags &&", 
      "+\t   tags->eccResult > YAFFS_ECC_RESULT_NO_ERROR){", 
      "+", 
      "+\t\tyaffs_BlockInfo *bi = yaffs_GetBlockInfo(dev, chunkInNAND/dev->nChunksPerBlock);", 
      "+                yaffs_HandleChunkError(dev,bi);", 
      "+\t}", 
      "+", 
      "+\treturn result;", 
      "+}", 
      "+", 
      "+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t   int chunkInNAND,", 
      "+\t\t\t\t\t\t   const __u8 * buffer,", 
      "+\t\t\t\t\t\t   yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\tchunkInNAND -= dev->chunkOffset;", 
      "+", 
      "+", 
      "+\tif (tags) {", 
      "+\t\ttags->sequenceNumber = dev->sequenceNumber;", 
      "+\t\ttags->chunkUsed = 1;", 
      "+\t\tif (!yaffs_ValidateTags(tags)) {", 
      "+\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t  (TSTR(\"Writing uninitialised tags\" TENDSTR)));", 
      "+\t\t\tYBUG();", 
      "+\t\t}", 
      "+\t\tT(YAFFS_TRACE_WRITE,", 
      "+\t\t  (TSTR(\"Writing chunk %d tags %d %d\" TENDSTR), chunkInNAND,", 
      "+\t\t   tags->objectId, tags->chunkId));", 
      "+\t} else {", 
      "+\t\tT(YAFFS_TRACE_ERROR, (TSTR(\"Writing with no tags\" TENDSTR)));", 
      "+\t\tYBUG();", 
      "+\t}", 
      "+", 
      "+\tif (dev->writeChunkWithTagsToNAND)", 
      "+\t\treturn dev->writeChunkWithTagsToNAND(dev, chunkInNAND, buffer,", 
      "+\t\t\t\t\t\t     tags);", 
      "+\telse", 
      "+\t\treturn yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(dev,", 
      "+\t\t\t\t\t\t\t\t       chunkInNAND,", 
      "+\t\t\t\t\t\t\t\t       buffer,", 
      "+\t\t\t\t\t\t\t\t       tags);", 
      "+}", 
      "+", 
      "+int yaffs_MarkBlockBad(yaffs_Device * dev, int blockNo)", 
      "+{", 
      "+\tblockNo -= dev->blockOffset;", 
      "+", 
      "+;", 
      "+\tif (dev->markNANDBlockBad)", 
      "+\t\treturn dev->markNANDBlockBad(dev, blockNo);", 
      "+\telse", 
      "+\t\treturn yaffs_TagsCompatabilityMarkNANDBlockBad(dev, blockNo);", 
      "+}", 
      "+", 
      "+int yaffs_QueryInitialBlockState(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t int blockNo,", 
      "+\t\t\t\t\t\t yaffs_BlockState * state,", 
      "+\t\t\t\t\t\t __u32 *sequenceNumber)", 
      "+{", 
      "+\tblockNo -= dev->blockOffset;", 
      "+", 
      "+\tif (dev->queryNANDBlock)", 
      "+\t\treturn dev->queryNANDBlock(dev, blockNo, state, sequenceNumber);", 
      "+\telse", 
      "+\t\treturn yaffs_TagsCompatabilityQueryNANDBlock(dev, blockNo,", 
      "+\t\t\t\t\t\t\t     state,", 
      "+\t\t\t\t\t\t\t     sequenceNumber);", 
      "+}", 
      "+", 
      "+", 
      "+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int blockInNAND)", 
      "+{", 
      "+\tint result;", 
      "+", 
      "+\tblockInNAND -= dev->blockOffset;", 
      "+", 
      "+", 
      "+\tdev->nBlockErasures++;", 
      "+\tresult = dev->eraseBlockInNAND(dev, blockInNAND);", 
      "+", 
      "+\treturn result;", 
      "+}", 
      "+", 
      "+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev)", 
      "+{", 
      "+\treturn dev->initialiseNAND(dev);", 
      "+}", 
      "+", 
      "+", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_nandemul2k.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nandemul2k.h", 
      "@@ -0,0 +1,39 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+/* Interface to emulated NAND functions (2k page size) */", 
      "+", 
      "+#ifndef __YAFFS_NANDEMUL2K_H__", 
      "+#define __YAFFS_NANDEMUL2K_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+int nandemul2k_WriteChunkWithTagsToNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\tint chunkInNAND, const __u8 * data,", 
      "+\t\t\t\t\tconst yaffs_ExtendedTags * tags);", 
      "+int nandemul2k_ReadChunkWithTagsFromNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t int chunkInNAND, __u8 * data,", 
      "+\t\t\t\t\t yaffs_ExtendedTags * tags);", 
      "+int nandemul2k_MarkNANDBlockBad(struct yaffs_DeviceStruct *dev, int blockNo);", 
      "+int nandemul2k_QueryNANDBlock(struct yaffs_DeviceStruct *dev, int blockNo,", 
      "+\t\t\t      yaffs_BlockState * state, __u32 *sequenceNumber);", 
      "+int nandemul2k_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\tint blockInNAND);", 
      "+int nandemul2k_InitialiseNAND(struct yaffs_DeviceStruct *dev);", 
      "+int nandemul2k_GetBytesPerChunk(void);", 
      "+int nandemul2k_GetChunksPerBlock(void);", 
      "+int nandemul2k_GetNumberOfBlocks(void);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_nand.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_nand.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_nand.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_nand.h", 
      "@@ -0,0 +1,44 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_NAND_H__", 
      "+#define __YAFFS_NAND_H__", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+", 
      "+", 
      "+int yaffs_ReadChunkWithTagsFromNAND(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t\t   __u8 * buffer,", 
      "+\t\t\t\t\t   yaffs_ExtendedTags * tags);", 
      "+", 
      "+int yaffs_WriteChunkWithTagsToNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t   int chunkInNAND,", 
      "+\t\t\t\t\t\t   const __u8 * buffer,", 
      "+\t\t\t\t\t\t   yaffs_ExtendedTags * tags);", 
      "+", 
      "+int yaffs_MarkBlockBad(yaffs_Device * dev, int blockNo);", 
      "+", 
      "+int yaffs_QueryInitialBlockState(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t int blockNo,", 
      "+\t\t\t\t\t\t yaffs_BlockState * state,", 
      "+\t\t\t\t\t\t unsigned *sequenceNumber);", 
      "+", 
      "+int yaffs_EraseBlockInNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int blockInNAND);", 
      "+", 
      "+int yaffs_InitialiseNAND(struct yaffs_DeviceStruct *dev);", 
      "+", 
      "+#endif", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_packedtags1.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.c", 
      "@@ -0,0 +1,52 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+#include \"yaffs_packedtags1.h\"", 
      "+#include \"yportenv.h\"", 
      "+", 
      "+void yaffs_PackTags1(yaffs_PackedTags1 * pt, const yaffs_ExtendedTags * t)", 
      "+{", 
      "+\tpt->chunkId = t->chunkId;", 
      "+\tpt->serialNumber = t->serialNumber;", 
      "+\tpt->byteCount = t->byteCount;", 
      "+\tpt->objectId = t->objectId;", 
      "+\tpt->ecc = 0;", 
      "+\tpt->deleted = (t->chunkDeleted) ? 0 : 1;", 
      "+\tpt->unusedStuff = 0;", 
      "+\tpt->shouldBeFF = 0xFFFFFFFF;", 
      "+", 
      "+}", 
      "+", 
      "+void yaffs_UnpackTags1(yaffs_ExtendedTags * t, const yaffs_PackedTags1 * pt)", 
      "+{", 
      "+\tstatic const __u8 allFF[] =", 
      "+\t    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,", 
      "+0xff };", 
      "+", 
      "+\tif (memcmp(allFF, pt, sizeof(yaffs_PackedTags1))) {", 
      "+\t\tt->blockBad = 0;", 
      "+\t\tif (pt->shouldBeFF != 0xFFFFFFFF) {", 
      "+\t\t\tt->blockBad = 1;", 
      "+\t\t}", 
      "+\t\tt->chunkUsed = 1;", 
      "+\t\tt->objectId = pt->objectId;", 
      "+\t\tt->chunkId = pt->chunkId;", 
      "+\t\tt->byteCount = pt->byteCount;", 
      "+\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+\t\tt->chunkDeleted = (pt->deleted) ? 0 : 1;", 
      "+\t\tt->serialNumber = pt->serialNumber;", 
      "+\t} else {", 
      "+\t\tmemset(t, 0, sizeof(yaffs_ExtendedTags));", 
      "+", 
      "+\t}", 
      "+}"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_packedtags1.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags1.h", 
      "@@ -0,0 +1,37 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+/* This is used to pack YAFFS1 tags, not YAFFS2 tags. */", 
      "+", 
      "+#ifndef __YAFFS_PACKEDTAGS1_H__", 
      "+#define __YAFFS_PACKEDTAGS1_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+typedef struct {", 
      "+\tunsigned chunkId:20;", 
      "+\tunsigned serialNumber:2;", 
      "+\tunsigned byteCount:10;", 
      "+\tunsigned objectId:18;", 
      "+\tunsigned ecc:12;", 
      "+\tunsigned deleted:1;", 
      "+\tunsigned unusedStuff:1;", 
      "+\tunsigned shouldBeFF;", 
      "+", 
      "+} yaffs_PackedTags1;", 
      "+", 
      "+void yaffs_PackTags1(yaffs_PackedTags1 * pt, const yaffs_ExtendedTags * t);", 
      "+void yaffs_UnpackTags1(yaffs_ExtendedTags * t, const yaffs_PackedTags1 * pt);", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_packedtags2.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.c", 
      "@@ -0,0 +1,208 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+#include \"yaffs_packedtags2.h\"", 
      "+#include \"yportenv.h\"", 
      "+#include \"yaffs_tagsvalidity.h\"", 
      "+", 
      "+/* This code packs a set of extended tags into a binary structure for", 
      "+ * NAND storage", 
      "+ */", 
      "+", 
      "+/* Some of the information is \"extra\" struff which can be packed in to", 
      "+ * speed scanning", 
      "+ * This is defined by having the EXTRA_HEADER_INFO_FLAG set.", 
      "+ */", 
      "+", 
      "+/* Extra flags applied to chunkId */", 
      "+", 
      "+#define EXTRA_HEADER_INFO_FLAG\t0x80000000", 
      "+#define EXTRA_SHRINK_FLAG\t0x40000000", 
      "+#define EXTRA_SHADOWS_FLAG\t0x20000000", 
      "+#define EXTRA_SPARE_FLAGS\t0x10000000", 
      "+", 
      "+#define ALL_EXTRA_FLAGS\t\t0xF0000000", 
      "+", 
      "+/* Also, the top 4 bits of the object Id are set to the object type. */", 
      "+#define EXTRA_OBJECT_TYPE_SHIFT (28)", 
      "+#define EXTRA_OBJECT_TYPE_MASK  ((0x0F) << EXTRA_OBJECT_TYPE_SHIFT)", 
      "+", 
      "+", 
      "+static void yaffs_DumpPackedTags2TagsPart(const yaffs_PackedTags2TagsPart * ptt)", 
      "+{", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR(\"packed tags obj %d chunk %d byte %d seq %d\" TENDSTR),", 
      "+\t   ptt->objectId, ptt->chunkId, ptt->byteCount,", 
      "+\t   ptt->sequenceNumber));", 
      "+}", 
      "+static void yaffs_DumpPackedTags2(const yaffs_PackedTags2 * pt)", 
      "+{", 
      "+\tyaffs_DumpPackedTags2TagsPart(&pt->t);", 
      "+}", 
      "+", 
      "+static void yaffs_DumpTags2(const yaffs_ExtendedTags * t)", 
      "+{", 
      "+\tT(YAFFS_TRACE_MTD,", 
      "+\t  (TSTR", 
      "+\t   (\"ext.tags eccres %d blkbad %d chused %d obj %d chunk%d byte %d del %d ser %d seq %d\"", 
      "+\t    TENDSTR), t->eccResult, t->blockBad, t->chunkUsed, t->objectId,", 
      "+\t   t->chunkId, t->byteCount, t->chunkDeleted, t->serialNumber,", 
      "+\t   t->sequenceNumber));", 
      "+", 
      "+}", 
      "+", 
      "+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart * ptt, const yaffs_ExtendedTags * t)", 
      "+{", 
      "+\tptt->chunkId = t->chunkId;", 
      "+\tptt->sequenceNumber = t->sequenceNumber;", 
      "+\tptt->byteCount = t->byteCount;", 
      "+\tptt->objectId = t->objectId;", 
      "+", 
      "+\tif (t->chunkId == 0 && t->extraHeaderInfoAvailable) {", 
      "+\t\t/* Store the extra header info instead */", 
      "+\t\t/* We save the parent object in the chunkId */", 
      "+\t\tptt->chunkId = EXTRA_HEADER_INFO_FLAG", 
      "+\t\t\t| t->extraParentObjectId;", 
      "+\t\tif (t->extraIsShrinkHeader) {", 
      "+\t\t\tptt->chunkId |= EXTRA_SHRINK_FLAG;", 
      "+\t\t}", 
      "+\t\tif (t->extraShadows) {", 
      "+\t\t\tptt->chunkId |= EXTRA_SHADOWS_FLAG;", 
      "+\t\t}", 
      "+", 
      "+\t\tptt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;", 
      "+\t\tptt->objectId |=", 
      "+\t\t    (t->extraObjectType << EXTRA_OBJECT_TYPE_SHIFT);", 
      "+", 
      "+\t\tif (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK) {", 
      "+\t\t\tptt->byteCount = t->extraEquivalentObjectId;", 
      "+\t\t} else if (t->extraObjectType == YAFFS_OBJECT_TYPE_FILE) {", 
      "+\t\t\tptt->byteCount = t->extraFileLength;", 
      "+\t\t} else {", 
      "+\t\t\tptt->byteCount = 0;", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tyaffs_DumpPackedTags2TagsPart(ptt);", 
      "+\tyaffs_DumpTags2(t);", 
      "+}", 
      "+", 
      "+", 
      "+void yaffs_PackTags2(yaffs_PackedTags2 * pt, const yaffs_ExtendedTags * t)", 
      "+{", 
      "+\tyaffs_PackTags2TagsPart(&pt->t,t);", 
      "+", 
      "+#ifndef YAFFS_IGNORE_TAGS_ECC", 
      "+\t{", 
      "+\t\tyaffs_ECCCalculateOther((unsigned char *)&pt->t,", 
      "+\t\t\t\t\tsizeof(yaffs_PackedTags2TagsPart),", 
      "+\t\t\t\t\t&pt->ecc);", 
      "+\t}", 
      "+#endif", 
      "+}", 
      "+", 
      "+", 
      "+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags * t, yaffs_PackedTags2TagsPart * ptt)", 
      "+{", 
      "+", 
      "+\tmemset(t, 0, sizeof(yaffs_ExtendedTags));", 
      "+", 
      "+\tyaffs_InitialiseTags(t);", 
      "+", 
      "+\tif (ptt->sequenceNumber != 0xFFFFFFFF) {", 
      "+\t\tt->blockBad = 0;", 
      "+\t\tt->chunkUsed = 1;", 
      "+\t\tt->objectId = ptt->objectId;", 
      "+\t\tt->chunkId = ptt->chunkId;", 
      "+\t\tt->byteCount = ptt->byteCount;", 
      "+\t\tt->chunkDeleted = 0;", 
      "+\t\tt->serialNumber = 0;", 
      "+\t\tt->sequenceNumber = ptt->sequenceNumber;", 
      "+", 
      "+\t\t/* Do extra header info stuff */", 
      "+", 
      "+\t\tif (ptt->chunkId & EXTRA_HEADER_INFO_FLAG) {", 
      "+\t\t\tt->chunkId = 0;", 
      "+\t\t\tt->byteCount = 0;", 
      "+", 
      "+\t\t\tt->extraHeaderInfoAvailable = 1;", 
      "+\t\t\tt->extraParentObjectId =", 
      "+\t\t\t    ptt->chunkId & (~(ALL_EXTRA_FLAGS));", 
      "+\t\t\tt->extraIsShrinkHeader =", 
      "+\t\t\t    (ptt->chunkId & EXTRA_SHRINK_FLAG) ? 1 : 0;", 
      "+\t\t\tt->extraShadows =", 
      "+\t\t\t    (ptt->chunkId & EXTRA_SHADOWS_FLAG) ? 1 : 0;", 
      "+\t\t\tt->extraObjectType =", 
      "+\t\t\t    ptt->objectId >> EXTRA_OBJECT_TYPE_SHIFT;", 
      "+\t\t\tt->objectId &= ~EXTRA_OBJECT_TYPE_MASK;", 
      "+", 
      "+\t\t\tif (t->extraObjectType == YAFFS_OBJECT_TYPE_HARDLINK) {", 
      "+\t\t\t\tt->extraEquivalentObjectId = ptt->byteCount;", 
      "+\t\t\t} else {", 
      "+\t\t\t\tt->extraFileLength = ptt->byteCount;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\tyaffs_DumpPackedTags2TagsPart(ptt);", 
      "+\tyaffs_DumpTags2(t);", 
      "+", 
      "+}", 
      "+", 
      "+", 
      "+void yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt)", 
      "+{", 
      "+", 
      "+\tyaffs_UnpackTags2TagsPart(t,&pt->t);", 
      "+", 
      "+\tif (pt->t.sequenceNumber != 0xFFFFFFFF) {", 
      "+\t\t/* Page is in use */", 
      "+#ifdef YAFFS_IGNORE_TAGS_ECC", 
      "+\t\t{", 
      "+\t\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+\t\t}", 
      "+#else", 
      "+\t\t{", 
      "+\t\t\tyaffs_ECCOther ecc;", 
      "+\t\t\tint result;", 
      "+\t\t\tyaffs_ECCCalculateOther((unsigned char *)&pt->t,", 
      "+\t\t\t\t\t\tsizeof", 
      "+\t\t\t\t\t\t(yaffs_PackedTags2TagsPart),", 
      "+\t\t\t\t\t\t&ecc);", 
      "+\t\t\tresult =", 
      "+\t\t\t    yaffs_ECCCorrectOther((unsigned char *)&pt->t,", 
      "+\t\t\t\t\t\t  sizeof", 
      "+\t\t\t\t\t\t  (yaffs_PackedTags2TagsPart),", 
      "+\t\t\t\t\t\t  &pt->ecc, &ecc);", 
      "+\t\t\tswitch(result){", 
      "+\t\t\t\tcase 0:", 
      "+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+\t\t\t\t\tbreak;", 
      "+\t\t\t\tcase 1:", 
      "+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_FIXED;", 
      "+\t\t\t\t\tbreak;", 
      "+\t\t\t\tcase -1:", 
      "+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_UNFIXED;", 
      "+\t\t\t\t\tbreak;", 
      "+\t\t\t\tdefault:", 
      "+\t\t\t\t\tt->eccResult = YAFFS_ECC_RESULT_UNKNOWN;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+#endif", 
      "+\t}", 
      "+", 
      "+\tyaffs_DumpPackedTags2(pt);", 
      "+\tyaffs_DumpTags2(t);", 
      "+", 
      "+}", 
      "+"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_packedtags2.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_packedtags2.h", 
      "@@ -0,0 +1,43 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+/* This is used to pack YAFFS2 tags, not YAFFS1tags. */", 
      "+", 
      "+#ifndef __YAFFS_PACKEDTAGS2_H__", 
      "+#define __YAFFS_PACKEDTAGS2_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+#include \"yaffs_ecc.h\"", 
      "+", 
      "+typedef struct {", 
      "+\tunsigned sequenceNumber;", 
      "+\tunsigned objectId;", 
      "+\tunsigned chunkId;", 
      "+\tunsigned byteCount;", 
      "+} yaffs_PackedTags2TagsPart;", 
      "+", 
      "+typedef struct {", 
      "+\tyaffs_PackedTags2TagsPart t;", 
      "+\tyaffs_ECCOther ecc;", 
      "+} yaffs_PackedTags2;", 
      "+", 
      "+/* Full packed tags with ECC, used for oob tags */", 
      "+void yaffs_PackTags2(yaffs_PackedTags2 * pt, const yaffs_ExtendedTags * t);", 
      "+void yaffs_UnpackTags2(yaffs_ExtendedTags * t, yaffs_PackedTags2 * pt);", 
      "+", 
      "+/* Only the tags part (no ECC for use with inband tags */", 
      "+void yaffs_PackTags2TagsPart(yaffs_PackedTags2TagsPart * pt, const yaffs_ExtendedTags * t);", 
      "+void yaffs_UnpackTags2TagsPart(yaffs_ExtendedTags * t, yaffs_PackedTags2TagsPart * pt);", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_qsort.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_qsort.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_qsort.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.c", 
      "@@ -0,0 +1,160 @@", 
      "+/*", 
      "+ * Copyright (c) 1992, 1993", 
      "+ *\tThe Regents of the University of California.  All rights reserved.", 
      "+ *", 
      "+ * Redistribution and use in source and binary forms, with or without", 
      "+ * modification, are permitted provided that the following conditions", 
      "+ * are met:", 
      "+ * 1. Redistributions of source code must retain the above copyright", 
      "+ *    notice, this list of conditions and the following disclaimer.", 
      "+ * 2. Redistributions in binary form must reproduce the above copyright", 
      "+ *    notice, this list of conditions and the following disclaimer in the", 
      "+ *    documentation and/or other materials provided with the distribution.", 
      "+ * 3. Neither the name of the University nor the names of its contributors", 
      "+ *    may be used to endorse or promote products derived from this software", 
      "+ *    without specific prior written permission.", 
      "+ *", 
      "+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND", 
      "+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE", 
      "+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE", 
      "+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE", 
      "+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL", 
      "+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS", 
      "+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)", 
      "+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT", 
      "+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY", 
      "+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF", 
      "+ * SUCH DAMAGE.", 
      "+ */", 
      "+", 
      "+#include \"yportenv.h\"", 
      "+//#include <linux/string.h>", 
      "+", 
      "+/*", 
      "+ * Qsort routine from Bentley & McIlroy's \"Engineering a Sort Function\".", 
      "+ */", 
      "+#define swapcode(TYPE, parmi, parmj, n) { \t\t\\", 
      "+\tlong i = (n) / sizeof (TYPE); \t\t\t\\", 
      "+\tregister TYPE *pi = (TYPE *) (parmi); \t\t\\", 
      "+\tregister TYPE *pj = (TYPE *) (parmj); \t\t\\", 
      "+\tdo { \t\t\t\t\t\t\\", 
      "+\t\tregister TYPE\tt = *pi;\t\t\\", 
      "+\t\t*pi++ = *pj;\t\t\t\t\\", 
      "+\t\t*pj++ = t;\t\t\t\t\\", 
      "+        } while (--i > 0);\t\t\t\t\\", 
      "+}", 
      "+", 
      "+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \\", 
      "+\tes % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;", 
      "+", 
      "+static __inline void", 
      "+swapfunc(char *a, char *b, int n, int swaptype)", 
      "+{", 
      "+\tif (swaptype <= 1)", 
      "+\t\tswapcode(long, a, b, n)", 
      "+\telse", 
      "+\t\tswapcode(char, a, b, n)", 
      "+}", 
      "+", 
      "+#define swap(a, b)\t\t\t\t\t\\", 
      "+\tif (swaptype == 0) {\t\t\t\t\\", 
      "+\t\tlong t = *(long *)(a);\t\t\t\\", 
      "+\t\t*(long *)(a) = *(long *)(b);\t\t\\", 
      "+\t\t*(long *)(b) = t;\t\t\t\\", 
      "+\t} else\t\t\t\t\t\t\\", 
      "+\t\tswapfunc(a, b, es, swaptype)", 
      "+", 
      "+#define vecswap(a, b, n) \tif ((n) > 0) swapfunc(a, b, n, swaptype)", 
      "+", 
      "+static __inline char *", 
      "+med3(char *a, char *b, char *c, int (*cmp)(const void *, const void *))", 
      "+{", 
      "+\treturn cmp(a, b) < 0 ?", 
      "+\t       (cmp(b, c) < 0 ? b : (cmp(a, c) < 0 ? c : a ))", 
      "+              :(cmp(b, c) > 0 ? b : (cmp(a, c) < 0 ? a : c ));", 
      "+}", 
      "+", 
      "+#ifndef min", 
      "+#define min(a,b) (((a) < (b)) ? (a) : (b))", 
      "+#endif", 
      "+", 
      "+void", 
      "+yaffs_qsort(void *aa, size_t n, size_t es,", 
      "+\tint (*cmp)(const void *, const void *))", 
      "+{", 
      "+\tchar *pa, *pb, *pc, *pd, *pl, *pm, *pn;", 
      "+\tint d, r, swaptype, swap_cnt;", 
      "+\tregister char *a = aa;", 
      "+", 
      "+loop:\tSWAPINIT(a, es);", 
      "+\tswap_cnt = 0;", 
      "+\tif (n < 7) {", 
      "+\t\tfor (pm = (char *)a + es; pm < (char *) a + n * es; pm += es)", 
      "+\t\t\tfor (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;", 
      "+\t\t\t     pl -= es)", 
      "+\t\t\t\tswap(pl, pl - es);", 
      "+\t\treturn;", 
      "+\t}", 
      "+\tpm = (char *)a + (n / 2) * es;", 
      "+\tif (n > 7) {", 
      "+\t\tpl = (char *)a;", 
      "+\t\tpn = (char *)a + (n - 1) * es;", 
      "+\t\tif (n > 40) {", 
      "+\t\t\td = (n / 8) * es;", 
      "+\t\t\tpl = med3(pl, pl + d, pl + 2 * d, cmp);", 
      "+\t\t\tpm = med3(pm - d, pm, pm + d, cmp);", 
      "+\t\t\tpn = med3(pn - 2 * d, pn - d, pn, cmp);", 
      "+\t\t}", 
      "+\t\tpm = med3(pl, pm, pn, cmp);", 
      "+\t}", 
      "+\tswap(a, pm);", 
      "+\tpa = pb = (char *)a + es;", 
      "+", 
      "+\tpc = pd = (char *)a + (n - 1) * es;", 
      "+\tfor (;;) {", 
      "+\t\twhile (pb <= pc && (r = cmp(pb, a)) <= 0) {", 
      "+\t\t\tif (r == 0) {", 
      "+\t\t\t\tswap_cnt = 1;", 
      "+\t\t\t\tswap(pa, pb);", 
      "+\t\t\t\tpa += es;", 
      "+\t\t\t}", 
      "+\t\t\tpb += es;", 
      "+\t\t}", 
      "+\t\twhile (pb <= pc && (r = cmp(pc, a)) >= 0) {", 
      "+\t\t\tif (r == 0) {", 
      "+\t\t\t\tswap_cnt = 1;", 
      "+\t\t\t\tswap(pc, pd);", 
      "+\t\t\t\tpd -= es;", 
      "+\t\t\t}", 
      "+\t\t\tpc -= es;", 
      "+\t\t}", 
      "+\t\tif (pb > pc)", 
      "+\t\t\tbreak;", 
      "+\t\tswap(pb, pc);", 
      "+\t\tswap_cnt = 1;", 
      "+\t\tpb += es;", 
      "+\t\tpc -= es;", 
      "+\t}", 
      "+\tif (swap_cnt == 0) {  /* Switch to insertion sort */", 
      "+\t\tfor (pm = (char *) a + es; pm < (char *) a + n * es; pm += es)", 
      "+\t\t\tfor (pl = pm; pl > (char *) a && cmp(pl - es, pl) > 0;", 
      "+\t\t\t     pl -= es)", 
      "+\t\t\t\tswap(pl, pl - es);", 
      "+\t\treturn;", 
      "+\t}", 
      "+", 
      "+\tpn = (char *)a + n * es;", 
      "+\tr = min(pa - (char *)a, pb - pa);", 
      "+\tvecswap(a, pb - r, r);", 
      "+\tr = min((long)(pd - pc), (long)(pn - pd - es));", 
      "+\tvecswap(pb, pn - r, r);", 
      "+\tif ((r = pb - pa) > es)", 
      "+\t\tyaffs_qsort(a, r / es, es, cmp);", 
      "+\tif ((r = pd - pc) > es) {", 
      "+\t\t/* Iterate rather than recurse to save stack space */", 
      "+\t\ta = pn - r;", 
      "+\t\tn = r / es;", 
      "+\t\tgoto loop;", 
      "+\t}", 
      "+/*\t\tyaffs_qsort(pn - r, r / es, es, cmp);*/", 
      "+}"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_qsort.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_qsort.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_qsort.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_qsort.h", 
      "@@ -0,0 +1,23 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+", 
      "+#ifndef __YAFFS_QSORT_H__", 
      "+#define __YAFFS_QSORT_H__", 
      "+", 
      "+extern void yaffs_qsort (void *const base, size_t total_elems, size_t size,", 
      "+                   int (*cmp)(const void *, const void *));", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_tagscompat.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.c", 
      "@@ -0,0 +1,534 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+#include \"yaffs_tagscompat.h\"", 
      "+#include \"yaffs_ecc.h\"", 
      "+#include \"yaffs_getblockinfo.h\"", 
      "+", 
      "+static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND);", 
      "+#ifdef NOTYET", 
      "+static void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND);", 
      "+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t     const __u8 * data,", 
      "+\t\t\t\t     const yaffs_Spare * spare);", 
      "+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t    const yaffs_Spare * spare);", 
      "+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND);", 
      "+#endif", 
      "+", 
      "+static const char yaffs_countBitsTable[256] = {", 
      "+\t0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,", 
      "+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,", 
      "+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,", 
      "+\t1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,", 
      "+\t2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,", 
      "+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,", 
      "+\t3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,", 
      "+\t4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8", 
      "+};", 
      "+", 
      "+int yaffs_CountBits(__u8 x)", 
      "+{", 
      "+\tint retVal;", 
      "+\tretVal = yaffs_countBitsTable[x];", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+/********** Tags ECC calculations  *********/", 
      "+", 
      "+void yaffs_CalcECC(const __u8 * data, yaffs_Spare * spare)", 
      "+{", 
      "+\tyaffs_ECCCalculate(data, spare->ecc1);", 
      "+\tyaffs_ECCCalculate(&data[256], spare->ecc2);", 
      "+}", 
      "+", 
      "+void yaffs_CalcTagsECC(yaffs_Tags * tags)", 
      "+{", 
      "+\t/* Calculate an ecc */", 
      "+", 
      "+\tunsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;", 
      "+\tunsigned i, j;", 
      "+\tunsigned ecc = 0;", 
      "+\tunsigned bit = 0;", 
      "+", 
      "+\ttags->ecc = 0;", 
      "+", 
      "+\tfor (i = 0; i < 8; i++) {", 
      "+\t\tfor (j = 1; j & 0xff; j <<= 1) {", 
      "+\t\t\tbit++;", 
      "+\t\t\tif (b[i] & j) {", 
      "+\t\t\t\tecc ^= bit;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+\t}", 
      "+", 
      "+\ttags->ecc = ecc;", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_CheckECCOnTags(yaffs_Tags * tags)", 
      "+{", 
      "+\tunsigned ecc = tags->ecc;", 
      "+", 
      "+\tyaffs_CalcTagsECC(tags);", 
      "+", 
      "+\tecc ^= tags->ecc;", 
      "+", 
      "+\tif (ecc && ecc <= 64) {", 
      "+\t\t/* TODO: Handle the failure better. Retire? */", 
      "+\t\tunsigned char *b = ((yaffs_TagsUnion *) tags)->asBytes;", 
      "+", 
      "+\t\tecc--;", 
      "+", 
      "+\t\tb[ecc / 8] ^= (1 << (ecc & 7));", 
      "+", 
      "+\t\t/* Now recvalc the ecc */", 
      "+\t\tyaffs_CalcTagsECC(tags);", 
      "+", 
      "+\t\treturn 1;\t/* recovered error */", 
      "+\t} else if (ecc) {", 
      "+\t\t/* Wierd ecc failure value */", 
      "+\t\t/* TODO Need to do somethiong here */", 
      "+\t\treturn -1;\t/* unrecovered error */", 
      "+\t}", 
      "+", 
      "+\treturn 0;", 
      "+}", 
      "+", 
      "+/********** Tags **********/", 
      "+", 
      "+static void yaffs_LoadTagsIntoSpare(yaffs_Spare * sparePtr,", 
      "+\t\t\t\t    yaffs_Tags * tagsPtr)", 
      "+{", 
      "+\tyaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;", 
      "+", 
      "+\tyaffs_CalcTagsECC(tagsPtr);", 
      "+", 
      "+\tsparePtr->tagByte0 = tu->asBytes[0];", 
      "+\tsparePtr->tagByte1 = tu->asBytes[1];", 
      "+\tsparePtr->tagByte2 = tu->asBytes[2];", 
      "+\tsparePtr->tagByte3 = tu->asBytes[3];", 
      "+\tsparePtr->tagByte4 = tu->asBytes[4];", 
      "+\tsparePtr->tagByte5 = tu->asBytes[5];", 
      "+\tsparePtr->tagByte6 = tu->asBytes[6];", 
      "+\tsparePtr->tagByte7 = tu->asBytes[7];", 
      "+}", 
      "+", 
      "+static void yaffs_GetTagsFromSpare(yaffs_Device * dev, yaffs_Spare * sparePtr,", 
      "+\t\t\t\t   yaffs_Tags * tagsPtr)", 
      "+{", 
      "+\tyaffs_TagsUnion *tu = (yaffs_TagsUnion *) tagsPtr;", 
      "+\tint result;", 
      "+", 
      "+\ttu->asBytes[0] = sparePtr->tagByte0;", 
      "+\ttu->asBytes[1] = sparePtr->tagByte1;", 
      "+\ttu->asBytes[2] = sparePtr->tagByte2;", 
      "+\ttu->asBytes[3] = sparePtr->tagByte3;", 
      "+\ttu->asBytes[4] = sparePtr->tagByte4;", 
      "+\ttu->asBytes[5] = sparePtr->tagByte5;", 
      "+\ttu->asBytes[6] = sparePtr->tagByte6;", 
      "+\ttu->asBytes[7] = sparePtr->tagByte7;", 
      "+", 
      "+\tresult = yaffs_CheckECCOnTags(tagsPtr);", 
      "+\tif (result > 0) {", 
      "+\t\tdev->tagsEccFixed++;", 
      "+\t} else if (result < 0) {", 
      "+\t\tdev->tagsEccUnfixed++;", 
      "+\t}", 
      "+}", 
      "+", 
      "+static void yaffs_SpareInitialise(yaffs_Spare * spare)", 
      "+{", 
      "+\tmemset(spare, 0xFF, sizeof(yaffs_Spare));", 
      "+}", 
      "+", 
      "+static int yaffs_WriteChunkToNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int chunkInNAND, const __u8 * data,", 
      "+\t\t\t\t  yaffs_Spare * spare)", 
      "+{", 
      "+\tif (chunkInNAND < dev->startBlock * dev->nChunksPerBlock) {", 
      "+\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t  (TSTR(\"**>> yaffs chunk %d is not valid\" TENDSTR),", 
      "+\t\t   chunkInNAND));", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+", 
      "+\tdev->nPageWrites++;", 
      "+\treturn dev->writeChunkToNAND(dev, chunkInNAND, data, spare);", 
      "+}", 
      "+", 
      "+static int yaffs_ReadChunkFromNAND(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t   int chunkInNAND,", 
      "+\t\t\t\t   __u8 * data,", 
      "+\t\t\t\t   yaffs_Spare * spare,", 
      "+\t\t\t\t   yaffs_ECCResult * eccResult,", 
      "+\t\t\t\t   int doErrorCorrection)", 
      "+{", 
      "+\tint retVal;", 
      "+\tyaffs_Spare localSpare;", 
      "+", 
      "+\tdev->nPageReads++;", 
      "+", 
      "+\tif (!spare && data) {", 
      "+\t\t/* If we don't have a real spare, then we use a local one. */", 
      "+\t\t/* Need this for the calculation of the ecc */", 
      "+\t\tspare = &localSpare;", 
      "+\t}", 
      "+", 
      "+\tif (!dev->useNANDECC) {", 
      "+\t\tretVal = dev->readChunkFromNAND(dev, chunkInNAND, data, spare);", 
      "+\t\tif (data && doErrorCorrection) {", 
      "+\t\t\t/* Do ECC correction */", 
      "+\t\t\t/* Todo handle any errors */", 
      "+\t\t\tint eccResult1, eccResult2;", 
      "+\t\t\t__u8 calcEcc[3];", 
      "+", 
      "+\t\t\tyaffs_ECCCalculate(data, calcEcc);", 
      "+\t\t\teccResult1 =", 
      "+\t\t\t    yaffs_ECCCorrect(data, spare->ecc1, calcEcc);", 
      "+\t\t\tyaffs_ECCCalculate(&data[256], calcEcc);", 
      "+\t\t\teccResult2 =", 
      "+\t\t\t    yaffs_ECCCorrect(&data[256], spare->ecc2, calcEcc);", 
      "+", 
      "+\t\t\tif (eccResult1 > 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>yaffs ecc error fix performed on chunk %d:0\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t\tdev->eccFixed++;", 
      "+\t\t\t} else if (eccResult1 < 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>yaffs ecc error unfixed on chunk %d:0\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t\tdev->eccUnfixed++;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (eccResult2 > 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>yaffs ecc error fix performed on chunk %d:1\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t\tdev->eccFixed++;", 
      "+\t\t\t} else if (eccResult2 < 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>yaffs ecc error unfixed on chunk %d:1\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t\tdev->eccUnfixed++;", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (eccResult1 || eccResult2) {", 
      "+\t\t\t\t/* We had a data problem on this page */", 
      "+\t\t\t\tyaffs_HandleReadDataError(dev, chunkInNAND);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (eccResult1 < 0 || eccResult2 < 0)", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_UNFIXED;", 
      "+\t\t\telse if (eccResult1 > 0 || eccResult2 > 0)", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_FIXED;", 
      "+\t\t\telse", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+\t\t}", 
      "+\t} else {", 
      "+\t\t/* Must allocate enough memory for spare+2*sizeof(int) */", 
      "+\t\t/* for ecc results from device. */", 
      "+\t\tstruct yaffs_NANDSpare nspare;", 
      "+", 
      "+\t\tmemset(&nspare,0,sizeof(nspare));", 
      "+", 
      "+\t\tretVal =", 
      "+\t\t    dev->readChunkFromNAND(dev, chunkInNAND, data,", 
      "+\t\t\t\t\t   (yaffs_Spare *) & nspare);", 
      "+\t\tmemcpy(spare, &nspare, sizeof(yaffs_Spare));", 
      "+\t\tif (data && doErrorCorrection) {", 
      "+\t\t\tif (nspare.eccres1 > 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>mtd ecc error fix performed on chunk %d:0\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t} else if (nspare.eccres1 < 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>mtd ecc error unfixed on chunk %d:0\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (nspare.eccres2 > 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>mtd ecc error fix performed on chunk %d:1\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t} else if (nspare.eccres2 < 0) {", 
      "+\t\t\t\tT(YAFFS_TRACE_ERROR,", 
      "+\t\t\t\t  (TSTR", 
      "+\t\t\t\t   (\"**>>mtd ecc error unfixed on chunk %d:1\"", 
      "+\t\t\t\t    TENDSTR), chunkInNAND));", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (nspare.eccres1 || nspare.eccres2) {", 
      "+\t\t\t\t/* We had a data problem on this page */", 
      "+\t\t\t\tyaffs_HandleReadDataError(dev, chunkInNAND);", 
      "+\t\t\t}", 
      "+", 
      "+\t\t\tif (nspare.eccres1 < 0 || nspare.eccres2 < 0)", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_UNFIXED;", 
      "+\t\t\telse if (nspare.eccres1 > 0 || nspare.eccres2 > 0)", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_FIXED;", 
      "+\t\t\telse", 
      "+\t\t\t\t*eccResult = YAFFS_ECC_RESULT_NO_ERROR;", 
      "+", 
      "+\t\t}", 
      "+\t}", 
      "+\treturn retVal;", 
      "+}", 
      "+", 
      "+#ifdef NOTYET", 
      "+static int yaffs_CheckChunkErased(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t  int chunkInNAND)", 
      "+{", 
      "+", 
      "+\tstatic int init = 0;", 
      "+\tstatic __u8 cmpbuf[YAFFS_BYTES_PER_CHUNK];", 
      "+\tstatic __u8 data[YAFFS_BYTES_PER_CHUNK];", 
      "+\t/* Might as well always allocate the larger size for */", 
      "+\t/* dev->useNANDECC == true; */", 
      "+\tstatic __u8 spare[sizeof(struct yaffs_NANDSpare)];", 
      "+", 
      "+\tdev->readChunkFromNAND(dev, chunkInNAND, data, (yaffs_Spare *) spare);", 
      "+", 
      "+\tif (!init) {", 
      "+\t\tmemset(cmpbuf, 0xff, YAFFS_BYTES_PER_CHUNK);", 
      "+\t\tinit = 1;", 
      "+\t}", 
      "+", 
      "+\tif (memcmp(cmpbuf, data, YAFFS_BYTES_PER_CHUNK))", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\tif (memcmp(cmpbuf, spare, 16))", 
      "+\t\treturn YAFFS_FAIL;", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+#endif", 
      "+", 
      "+/*", 
      "+ * Functions for robustisizing", 
      "+ */", 
      "+", 
      "+static void yaffs_HandleReadDataError(yaffs_Device * dev, int chunkInNAND)", 
      "+{", 
      "+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;", 
      "+", 
      "+\t/* Mark the block for retirement */", 
      "+\tyaffs_GetBlockInfo(dev, blockInNAND + dev->blockOffset)->needsRetiring = 1;", 
      "+\tT(YAFFS_TRACE_ERROR | YAFFS_TRACE_BAD_BLOCKS,", 
      "+\t  (TSTR(\"**>>Block %d marked for retirement\" TENDSTR), blockInNAND));", 
      "+", 
      "+\t/* TODO:", 
      "+\t * Just do a garbage collection on the affected block", 
      "+\t * then retire the block", 
      "+\t * NB recursion", 
      "+\t */", 
      "+}", 
      "+", 
      "+#ifdef NOTYET", 
      "+static void yaffs_CheckWrittenBlock(yaffs_Device * dev, int chunkInNAND)", 
      "+{", 
      "+}", 
      "+", 
      "+static void yaffs_HandleWriteChunkOk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t     const __u8 * data,", 
      "+\t\t\t\t     const yaffs_Spare * spare)", 
      "+{", 
      "+}", 
      "+", 
      "+static void yaffs_HandleUpdateChunk(yaffs_Device * dev, int chunkInNAND,", 
      "+\t\t\t\t    const yaffs_Spare * spare)", 
      "+{", 
      "+}", 
      "+", 
      "+static void yaffs_HandleWriteChunkError(yaffs_Device * dev, int chunkInNAND)", 
      "+{", 
      "+\tint blockInNAND = chunkInNAND / dev->nChunksPerBlock;", 
      "+", 
      "+\t/* Mark the block for retirement */", 
      "+\tyaffs_GetBlockInfo(dev, blockInNAND)->needsRetiring = 1;", 
      "+\t/* Delete the chunk */", 
      "+\tyaffs_DeleteChunk(dev, chunkInNAND, 1, __LINE__);", 
      "+}", 
      "+", 
      "+static int yaffs_VerifyCompare(const __u8 * d0, const __u8 * d1,", 
      "+\t\t\t       const yaffs_Spare * s0, const yaffs_Spare * s1)", 
      "+{", 
      "+", 
      "+\tif (memcmp(d0, d1, YAFFS_BYTES_PER_CHUNK) != 0 ||", 
      "+\t    s0->tagByte0 != s1->tagByte0 ||", 
      "+\t    s0->tagByte1 != s1->tagByte1 ||", 
      "+\t    s0->tagByte2 != s1->tagByte2 ||", 
      "+\t    s0->tagByte3 != s1->tagByte3 ||", 
      "+\t    s0->tagByte4 != s1->tagByte4 ||", 
      "+\t    s0->tagByte5 != s1->tagByte5 ||", 
      "+\t    s0->tagByte6 != s1->tagByte6 ||", 
      "+\t    s0->tagByte7 != s1->tagByte7 ||", 
      "+\t    s0->ecc1[0] != s1->ecc1[0] ||", 
      "+\t    s0->ecc1[1] != s1->ecc1[1] ||", 
      "+\t    s0->ecc1[2] != s1->ecc1[2] ||", 
      "+\t    s0->ecc2[0] != s1->ecc2[0] ||", 
      "+\t    s0->ecc2[1] != s1->ecc2[1] || s0->ecc2[2] != s1->ecc2[2]) {", 
      "+\t\treturn 0;", 
      "+\t}", 
      "+", 
      "+\treturn 1;", 
      "+}", 
      "+#endif\t\t\t\t/* NOTYET */", 
      "+", 
      "+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t    int chunkInNAND,", 
      "+\t\t\t\t\t\t    const __u8 * data,", 
      "+\t\t\t\t\t\t    const yaffs_ExtendedTags *", 
      "+\t\t\t\t\t\t    eTags)", 
      "+{", 
      "+\tyaffs_Spare spare;", 
      "+\tyaffs_Tags tags;", 
      "+", 
      "+\tyaffs_SpareInitialise(&spare);", 
      "+", 
      "+\tif (eTags->chunkDeleted) {", 
      "+\t\tspare.pageStatus = 0;", 
      "+\t} else {", 
      "+\t\ttags.objectId = eTags->objectId;", 
      "+\t\ttags.chunkId = eTags->chunkId;", 
      "+\t\ttags.byteCount = eTags->byteCount;", 
      "+\t\ttags.serialNumber = eTags->serialNumber;", 
      "+", 
      "+\t\tif (!dev->useNANDECC && data) {", 
      "+\t\t\tyaffs_CalcECC(data, &spare);", 
      "+\t\t}", 
      "+\t\tyaffs_LoadTagsIntoSpare(&spare, &tags);", 
      "+", 
      "+\t}", 
      "+", 
      "+\treturn yaffs_WriteChunkToNAND(dev, chunkInNAND, data, &spare);", 
      "+}", 
      "+", 
      "+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t     int chunkInNAND,", 
      "+\t\t\t\t\t\t     __u8 * data,", 
      "+\t\t\t\t\t\t     yaffs_ExtendedTags * eTags)", 
      "+{", 
      "+", 
      "+\tyaffs_Spare spare;", 
      "+\tyaffs_Tags tags;", 
      "+\tyaffs_ECCResult eccResult;", 
      "+", 
      "+\tstatic yaffs_Spare spareFF;", 
      "+\tstatic int init = 0;", 
      "+", 
      "+\tif (!init) {", 
      "+\t\tmemset(&spareFF, 0xFF, sizeof(spareFF));", 
      "+\t\tinit = 1;", 
      "+\t}", 
      "+", 
      "+\tif (yaffs_ReadChunkFromNAND", 
      "+\t    (dev, chunkInNAND, data, &spare, &eccResult, 1)) {", 
      "+\t\t/* eTags may be NULL */", 
      "+\t\tif (eTags) {", 
      "+", 
      "+\t\t\tint deleted =", 
      "+\t\t\t    (yaffs_CountBits(spare.pageStatus) < 7) ? 1 : 0;", 
      "+", 
      "+\t\t\teTags->chunkDeleted = deleted;", 
      "+\t\t\teTags->eccResult = eccResult;", 
      "+\t\t\teTags->blockBad = 0;\t/* We're reading it */", 
      "+\t\t\t/* therefore it is not a bad block */", 
      "+\t\t\teTags->chunkUsed =", 
      "+\t\t\t    (memcmp(&spareFF, &spare, sizeof(spareFF)) !=", 
      "+\t\t\t     0) ? 1 : 0;", 
      "+", 
      "+\t\t\tif (eTags->chunkUsed) {", 
      "+\t\t\t\tyaffs_GetTagsFromSpare(dev, &spare, &tags);", 
      "+", 
      "+\t\t\t\teTags->objectId = tags.objectId;", 
      "+\t\t\t\teTags->chunkId = tags.chunkId;", 
      "+\t\t\t\teTags->byteCount = tags.byteCount;", 
      "+\t\t\t\teTags->serialNumber = tags.serialNumber;", 
      "+\t\t\t}", 
      "+\t\t}", 
      "+", 
      "+\t\treturn YAFFS_OK;", 
      "+\t} else {", 
      "+\t\treturn YAFFS_FAIL;", 
      "+\t}", 
      "+}", 
      "+", 
      "+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t    int blockInNAND)", 
      "+{", 
      "+", 
      "+\tyaffs_Spare spare;", 
      "+", 
      "+\tmemset(&spare, 0xff, sizeof(yaffs_Spare));", 
      "+", 
      "+\tspare.blockStatus = 'Y';", 
      "+", 
      "+\tyaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock, NULL,", 
      "+\t\t\t       &spare);", 
      "+\tyaffs_WriteChunkToNAND(dev, blockInNAND * dev->nChunksPerBlock + 1,", 
      "+\t\t\t       NULL, &spare);", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+", 
      "+}", 
      "+", 
      "+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t  int blockNo,", 
      "+\t\t\t\t\t  yaffs_BlockState *state,", 
      "+\t\t\t\t\t  __u32 *sequenceNumber)", 
      "+{", 
      "+", 
      "+\tyaffs_Spare spare0, spare1;", 
      "+\tstatic yaffs_Spare spareFF;", 
      "+\tstatic int init;", 
      "+\tyaffs_ECCResult dummy;", 
      "+", 
      "+\tif (!init) {", 
      "+\t\tmemset(&spareFF, 0xFF, sizeof(spareFF));", 
      "+\t\tinit = 1;", 
      "+\t}", 
      "+", 
      "+\t*sequenceNumber = 0;", 
      "+", 
      "+\tyaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock, NULL,", 
      "+\t\t\t\t&spare0, &dummy, 1);", 
      "+\tyaffs_ReadChunkFromNAND(dev, blockNo * dev->nChunksPerBlock + 1, NULL,", 
      "+\t\t\t\t&spare1, &dummy, 1);", 
      "+", 
      "+\tif (yaffs_CountBits(spare0.blockStatus & spare1.blockStatus) < 7)", 
      "+\t\t*state = YAFFS_BLOCK_STATE_DEAD;", 
      "+\telse if (memcmp(&spareFF, &spare0, sizeof(spareFF)) == 0)", 
      "+\t\t*state = YAFFS_BLOCK_STATE_EMPTY;", 
      "+\telse", 
      "+\t\t*state = YAFFS_BLOCK_STATE_NEEDS_SCANNING;", 
      "+", 
      "+\treturn YAFFS_OK;", 
      "+}"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_tagscompat.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagscompat.h", 
      "@@ -0,0 +1,41 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+#ifndef __YAFFS_TAGSCOMPAT_H__", 
      "+#define __YAFFS_TAGSCOMPAT_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+int yaffs_TagsCompatabilityWriteChunkWithTagsToNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t    int chunkInNAND,", 
      "+\t\t\t\t\t\t    const __u8 * data,", 
      "+\t\t\t\t\t\t    const yaffs_ExtendedTags *", 
      "+\t\t\t\t\t\t    tags);", 
      "+int yaffs_TagsCompatabilityReadChunkWithTagsFromNAND(yaffs_Device * dev,", 
      "+\t\t\t\t\t\t     int chunkInNAND,", 
      "+\t\t\t\t\t\t     __u8 * data,", 
      "+\t\t\t\t\t\t     yaffs_ExtendedTags *", 
      "+\t\t\t\t\t\t     tags);", 
      "+int yaffs_TagsCompatabilityMarkNANDBlockBad(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t    int blockNo);", 
      "+int yaffs_TagsCompatabilityQueryNANDBlock(struct yaffs_DeviceStruct *dev,", 
      "+\t\t\t\t\t  int blockNo,", 
      "+\t\t\t\t\t  yaffs_BlockState *state,", 
      "+\t\t\t\t\t  __u32 *sequenceNumber);", 
      "+", 
      "+void yaffs_CalcTagsECC(yaffs_Tags * tags);", 
      "+int yaffs_CheckECCOnTags(yaffs_Tags * tags);", 
      "+int yaffs_CountBits(__u8 byte);", 
      "+", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.c", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.c", 
      "@@ -0,0 +1,28 @@", 
      "+/*", 
      "+ * YAFFS: Yet Another Flash File System. A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU General Public License version 2 as", 
      "+ * published by the Free Software Foundation.", 
      "+ */", 
      "+", 
      "+#include \"yaffs_tagsvalidity.h\"", 
      "+", 
      "+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\tmemset(tags, 0, sizeof(yaffs_ExtendedTags));", 
      "+\ttags->validMarker0 = 0xAAAAAAAA;", 
      "+\ttags->validMarker1 = 0x55555555;", 
      "+}", 
      "+", 
      "+int yaffs_ValidateTags(yaffs_ExtendedTags * tags)", 
      "+{", 
      "+\treturn (tags->validMarker0 == 0xAAAAAAAA &&", 
      "+\t\ttags->validMarker1 == 0x55555555);", 
      "+", 
      "+}"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h", 
      "--- linux-2.6.23/fs/yaffs2/yaffs_tagsvalidity.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yaffs_tagsvalidity.h", 
      "@@ -0,0 +1,24 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+", 
      "+#ifndef __YAFFS_TAGS_VALIDITY_H__", 
      "+#define __YAFFS_TAGS_VALIDITY_H__", 
      "+", 
      "+#include \"yaffs_guts.h\"", 
      "+", 
      "+void yaffs_InitialiseTags(yaffs_ExtendedTags * tags);", 
      "+int yaffs_ValidateTags(yaffs_ExtendedTags * tags);", 
      "+#endif"
    ]
  ], 
  [
    "linux-2.6.23/fs/yaffs2/yportenv.h", 
    "linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h", 
    [
      "diff -Naur linux-2.6.23/fs/yaffs2/yportenv.h linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h", 
      "--- linux-2.6.23/fs/yaffs2/yportenv.h", 
      "+++ linux-2.6.23-yaffs2/fs/yaffs2/yportenv.h", 
      "@@ -0,0 +1,200 @@", 
      "+/*", 
      "+ * YAFFS: Yet another Flash File System . A NAND-flash specific file system.", 
      "+ *", 
      "+ * Copyright (C) 2002-2007 Aleph One Ltd.", 
      "+ *   for Toby Churchill Ltd and Brightstar Engineering", 
      "+ *", 
      "+ * Created by Charles Manning <charles@aleph1.co.uk>", 
      "+ *", 
      "+ * This program is free software; you can redistribute it and/or modify", 
      "+ * it under the terms of the GNU Lesser General Public License version 2.1 as", 
      "+ * published by the Free Software Foundation.", 
      "+ *", 
      "+ * Note: Only YAFFS headers are LGPL, YAFFS C code is covered by GPL.", 
      "+ */", 
      "+", 
      "+", 
      "+#ifndef __YPORTENV_H__", 
      "+#define __YPORTENV_H__", 
      "+", 
      "+/*", 
      "+ * Define the MTD version in terms of Linux Kernel versions", 
      "+ * This allows yaffs to be used independantly of the kernel", 
      "+ * as well as with it.", 
      "+ */", 
      "+", 
      "+#define MTD_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))", 
      "+", 
      "+#if defined CONFIG_YAFFS_WINCE", 
      "+", 
      "+#include \"ywinceenv.h\"", 
      "+", 
      "+#elif  defined __KERNEL__", 
      "+", 
      "+#include \"moduleconfig.h\"", 
      "+", 
      "+/* Linux kernel */", 
      "+", 
      "+#include <linux/version.h>", 
      "+#define MTD_VERSION_CODE LINUX_VERSION_CODE", 
      "+", 
      "+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19))", 
      "+#include <linux/config.h>", 
      "+#endif", 
      "+#include <linux/kernel.h>", 
      "+#include <linux/mm.h>", 
      "+#include <linux/sched.h>", 
      "+#include <linux/string.h>", 
      "+#include <linux/slab.h>", 
      "+#include <linux/vmalloc.h>", 
      "+", 
      "+#define YCHAR char", 
      "+#define YUCHAR unsigned char", 
      "+#define _Y(x)     x", 
      "+#define yaffs_strcpy(a,b)    strcpy(a,b)", 
      "+#define yaffs_strncpy(a,b,c) strncpy(a,b,c)", 
      "+#define yaffs_strncmp(a,b,c) strncmp(a,b,c)", 
      "+#define yaffs_strlen(s)\t     strlen(s)", 
      "+#define yaffs_sprintf\t     sprintf", 
      "+#define yaffs_toupper(a)     toupper(a)", 
      "+", 
      "+#define Y_INLINE inline", 
      "+", 
      "+#define YAFFS_LOSTNFOUND_NAME\t\t\"lost+found\"", 
      "+#define YAFFS_LOSTNFOUND_PREFIX\t\t\"obj\"", 
      "+", 
      "+/* #define YPRINTF(x) printk x */", 
      "+#define YMALLOC(x) kmalloc(x,GFP_KERNEL)", 
      "+#define YFREE(x)   kfree(x)", 
      "+#define YMALLOC_ALT(x) vmalloc(x)", 
      "+#define YFREE_ALT(x)   vfree(x)", 
      "+#define YMALLOC_DMA(x) YMALLOC(x)", 
      "+", 
      "+// KR - added for use in scan so processes aren't blocked indefinitely.", 
      "+#define YYIELD() schedule()", 
      "+", 
      "+#define YAFFS_ROOT_MODE\t\t\t0666", 
      "+#define YAFFS_LOSTNFOUND_MODE\t\t0666", 
      "+", 
      "+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,5,0))", 
      "+#define Y_CURRENT_TIME CURRENT_TIME.tv_sec", 
      "+#define Y_TIME_CONVERT(x) (x).tv_sec", 
      "+#else", 
      "+#define Y_CURRENT_TIME CURRENT_TIME", 
      "+#define Y_TIME_CONVERT(x) (x)", 
      "+#endif", 
      "+", 
      "+#define yaffs_SumCompare(x,y) ((x) == (y))", 
      "+#define yaffs_strcmp(a,b) strcmp(a,b)", 
      "+", 
      "+#define TENDSTR \"\\n\"", 
      "+#define TSTR(x) KERN_WARNING x", 
      "+#define TOUT(p) printk p", 
      "+", 
      "+#define yaffs_trace(mask, fmt, args...) \\", 
      "+\tdo { if ((mask) & (yaffs_traceMask|YAFFS_TRACE_ERROR)) \\", 
      "+\t\tprintk(KERN_WARNING \"yaffs: \" fmt, ## args); \\", 
      "+\t} while (0)", 
      "+", 
      "+#define compile_time_assertion(assertion) \\", 
      "+\t({ int x = __builtin_choose_expr(assertion, 0, (void)0); (void) x; })", 
      "+", 
      "+#elif defined CONFIG_YAFFS_DIRECT", 
      "+", 
      "+#define MTD_VERSION_CODE MTD_VERSION(2,6,22)", 
      "+", 
      "+/* Direct interface */", 
      "+#include \"ydirectenv.h\"", 
      "+", 
      "+#elif defined CONFIG_YAFFS_UTIL", 
      "+", 
      "+/* Stuff for YAFFS utilities */", 
      "+", 
      "+#include \"stdlib.h\"", 
      "+#include \"stdio.h\"", 
      "+#include \"string.h\"", 
      "+", 
      "+#include \"devextras.h\"", 
      "+", 
      "+#define YMALLOC(x) malloc(x)", 
      "+#define YFREE(x)   free(x)", 
      "+#define YMALLOC_ALT(x) malloc(x)", 
      "+#define YFREE_ALT(x) free(x)", 
      "+", 
      "+#define YCHAR char", 
      "+#define YUCHAR unsigned char", 
      "+#define _Y(x)     x", 
      "+#define yaffs_strcpy(a,b)    strcpy(a,b)", 
      "+#define yaffs_strncpy(a,b,c) strncpy(a,b,c)", 
      "+#define yaffs_strlen(s)\t     strlen(s)", 
      "+#define yaffs_sprintf\t     sprintf", 
      "+#define yaffs_toupper(a)     toupper(a)", 
      "+", 
      "+#define Y_INLINE inline", 
      "+", 
      "+/* #define YINFO(s) YPRINTF(( __FILE__ \" %d %s\\n\",__LINE__,s)) */", 
      "+/* #define YALERT(s) YINFO(s) */", 
      "+", 
      "+#define TENDSTR \"\\n\"", 
      "+#define TSTR(x) x", 
      "+#define TOUT(p) printf p", 
      "+", 
      "+#define YAFFS_LOSTNFOUND_NAME\t\t\"lost+found\"", 
      "+#define YAFFS_LOSTNFOUND_PREFIX\t\t\"obj\"", 
      "+/* #define YPRINTF(x) printf x */", 
      "+", 
      "+#define YAFFS_ROOT_MODE\t\t\t\t0666", 
      "+#define YAFFS_LOSTNFOUND_MODE\t\t0666", 
      "+", 
      "+#define yaffs_SumCompare(x,y) ((x) == (y))", 
      "+#define yaffs_strcmp(a,b) strcmp(a,b)", 
      "+", 
      "+#else", 
      "+/* Should have specified a configuration type */", 
      "+#error Unknown configuration", 
      "+", 
      "+#endif", 
      "+", 
      "+/* see yaffs_fs.c */", 
      "+extern unsigned int yaffs_traceMask;", 
      "+extern unsigned int yaffs_wr_attempts;", 
      "+", 
      "+/*", 
      "+ * Tracing flags.", 
      "+ * The flags masked in YAFFS_TRACE_ALWAYS are always traced.", 
      "+ */", 
      "+", 
      "+#define YAFFS_TRACE_OS\t\t\t0x00000002", 
      "+#define YAFFS_TRACE_ALLOCATE\t\t0x00000004", 
      "+#define YAFFS_TRACE_SCAN\t\t0x00000008", 
      "+#define YAFFS_TRACE_BAD_BLOCKS\t\t0x00000010", 
      "+#define YAFFS_TRACE_ERASE\t\t0x00000020", 
      "+#define YAFFS_TRACE_GC\t\t\t0x00000040", 
      "+#define YAFFS_TRACE_WRITE\t\t0x00000080", 
      "+#define YAFFS_TRACE_TRACING\t\t0x00000100", 
      "+#define YAFFS_TRACE_DELETION\t\t0x00000200", 
      "+#define YAFFS_TRACE_BUFFERS\t\t0x00000400", 
      "+#define YAFFS_TRACE_NANDACCESS\t\t0x00000800", 
      "+#define YAFFS_TRACE_GC_DETAIL\t\t0x00001000", 
      "+#define YAFFS_TRACE_SCAN_DEBUG\t\t0x00002000", 
      "+#define YAFFS_TRACE_MTD\t\t\t0x00004000", 
      "+#define YAFFS_TRACE_CHECKPOINT\t\t0x00008000", 
      "+", 
      "+#define YAFFS_TRACE_VERIFY\t\t0x00010000", 
      "+#define YAFFS_TRACE_VERIFY_NAND\t\t0x00020000", 
      "+#define YAFFS_TRACE_VERIFY_FULL\t\t0x00040000", 
      "+#define YAFFS_TRACE_VERIFY_ALL\t\t0x000F0000", 
      "+", 
      "+", 
      "+#define YAFFS_TRACE_ERROR\t\t0x40000000", 
      "+#define YAFFS_TRACE_BUG\t\t\t0x80000000", 
      "+#define YAFFS_TRACE_ALWAYS\t\t0xF0000000", 
      "+", 
      "+", 
      "+#define T(mask,p) do{ if((mask) & (yaffs_traceMask | YAFFS_TRACE_ALWAYS)) TOUT(p);} while(0)", 
      "+", 
      "+#ifndef YBUG", 
      "+#define YBUG() do {T(YAFFS_TRACE_BUG,(TSTR(\"==>> yaffs bug: \" __FILE__ \" %d\" TENDSTR),__LINE__));} while(0)", 
      "+#endif", 
      "+", 
      "+#endif"
    ]
  ]
]