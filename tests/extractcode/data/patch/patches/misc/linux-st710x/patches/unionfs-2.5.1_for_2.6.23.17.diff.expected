[('a/Documentation/filesystems/00-INDEX',
  'b/Documentation/filesystems/00-INDEX',
  'diff --git a/Documentation/filesystems/00-INDEX b/Documentation/filesystems/00-INDEX\nindex 59db1bc..40816d4 100644\n--- a/Documentation/filesystems/00-INDEX\n+++ b/Documentation/filesystems/00-INDEX\n@@ -86,6 +86,8 @@ udf.txt\n- info and mount options for the UDF filesystem.\nufs.txt\n- info on the ufs filesystem.\n+unionfs/\n+\t- info on the unionfs filesystem\nvfat.txt\n- info on using the VFAT filesystem used in Windows NT and Windows 95\nvfs.txt'),
 ('dev/null',
  'b/Documentation/filesystems/unionfs/00-INDEX',
  'diff --git a/Documentation/filesystems/unionfs/00-INDEX b/Documentation/filesystems/unionfs/00-INDEX\nnew file mode 100644\nindex 0000000..96fdf67\n--- dev/null\n+++ b/Documentation/filesystems/unionfs/00-INDEX\n@@ -0,0 +1,10 @@\n+00-INDEX\n+\t- this file.\n+concepts.txt\n+\t- A brief introduction of concepts.\n+issues.txt\n+\t- A summary of known issues with unionfs.\n+rename.txt\n+\t- Information regarding rename operations.\n+usage.txt\n+\t- Usage information and examples.'),
 ('dev/null',
  'b/Documentation/filesystems/unionfs/concepts.txt',
  'diff --git a/Documentation/filesystems/unionfs/concepts.txt b/Documentation/filesystems/unionfs/concepts.txt\nnew file mode 100644\nindex 0000000..b853788\n--- dev/null\n+++ b/Documentation/filesystems/unionfs/concepts.txt\n@@ -0,0 +1,287 @@\n+Unionfs 2.x CONCEPTS:\n+=====================\n+\n+This file describes the concepts needed by a namespace unification file\n+system.\n+\n+\n+Branch Priority:\n+================\n+\n+Each branch is assigned a unique priority - starting from 0 (highest\n+priority).  No two branches can have the same priority.\n+\n+\n+Branch Mode:\n+============\n+\n+Each branch is assigned a mode - read-write or read-only. This allows\n+directories on media mounted read-write to be used in a read-only manner.\n+\n+\n+Whiteouts:\n+==========\n+\n+A whiteout removes a file name from the namespace. Whiteouts are needed when\n+one attempts to remove a file on a read-only branch.\n+\n+Suppose we have a two-branch union, where branch 0 is read-write and branch\n+1 is read-only. And a file \'foo\' on branch 1:\n+\n+./b0/\n+./b1/\n+./b1/foo\n+\n+The unified view would simply be:\n+\n+./union/\n+./union/foo\n+\n+Since \'foo\' is stored on a read-only branch, it cannot be removed. A\n+whiteout is used to remove the name \'foo\' from the unified namespace. Again,\n+since branch 1 is read-only, the whiteout cannot be created there. So, we\n+try on a higher priority (lower numerically) branch and create the whiteout\n+there.\n+\n+./b0/\n+./b0/.wh.foo\n+./b1/\n+./b1/foo\n+\n+Later, when Unionfs traverses branches (due to lookup or readdir), it\n+eliminate \'foo\' from the namespace (as well as the whiteout itself.)\n+\n+\n+Opaque Directories:\n+===================\n+\n+Assume we have a unionfs mount comprising of two branches.  Branch 0 is\n+empty; branch 1 has the directory /a and file /a/f.  Let\'s say we mount a\n+union of branch 0 as read-write and branch 1 as read-only.  Now, let\'s say\n+we try to perform the following operation in the union:\n+\n+\trm -fr a\n+\n+Because branch 1 is not writable, we cannot physically remove the file /a/f\n+or the directory /a.  So instead, we will create a whiteout in branch 0\n+named /.wh.a, masking out the name "a" from branch 1.  Next, let\'s say we\n+try to create a directory named "a" as follows:\n+\n+\tmkdir a\n+\n+Because we have a whiteout for "a" already, Unionfs behaves as if "a"\n+doesn\'t exist, and thus will delete the whiteout and replace it with an\n+actual directory named "a".\n+\n+The problem now is that if you try to "ls" in the union, Unionfs will\n+perform is normal directory name unification, for *all* directories named\n+"a" in all branches.  This will cause the file /a/f from branch 1 to\n+re-appear in the union\'s namespace, which violates Unix semantics.\n+\n+To avoid this problem, we have a different form of whiteouts for\n+directories, called "opaque directories" (same as BSD Union Mount does).\n+Whenever we replace a whiteout with a directory, that directory is marked as\n+opaque.  In Unionfs 2.x, it means that we create a file named\n+/a/.wh.__dir_opaque in branch 0, after having created directory /a there.\n+When unionfs notices that a directory is opaque, it stops all namespace\n+operations (including merging readdir contents) at that opaque directory.\n+This prevents re-exposing names from masked out directories.\n+\n+\n+Duplicate Elimination:\n+======================\n+\n+It is possible for files on different branches to have the same name.\n+Unionfs then has to select which instance of the file to show to the user.\n+Given the fact that each branch has a priority associated with it, the\n+simplest solution is to take the instance from the highest priority\n+(numerically lowest value) and "hide" the others.\n+\n+\n+Unlinking:\n+=========\n+\n+Unlink operation on non-directory instances is optimized to remove the\n+maximum possible objects in case multiple underlying branches have the same\n+file name.  The unlink operation will first try to delete file instances\n+from highest priority branch and then move further to delete from remaining\n+branches in order of their decreasing priority.  Consider a case (F..D..F),\n+where F is a file and D is a directory of the same name; here, some\n+intermediate branch could have an empty directory instance with the same\n+name, so this operation also tries to delete this directory instance and\n+proceed further to delete from next possible lower priority branch.  The\n+unionfs unlink operation will smoothly delete the files with same name from\n+all possible underlying branches.  In case if some error occurs, it creates\n+whiteout in highest priority branch that will hide file instance in rest of\n+the branches.  An error could occur either if an unlink operations in any of\n+the underlying branch failed or if a branch has no write permission.\n+\n+This unlinking policy is known as "delete all" and it has the benefit of\n+overall reducing the number of inodes used by duplicate files, and further\n+reducing the total number of inodes consumed by whiteouts.  The cost is of\n+extra processing, but testing shows this extra processing is well worth the\n+savings.\n+\n+\n+Copyup:\n+=======\n+\n+When a change is made to the contents of a file\'s data or meta-data, they\n+have to be stored somewhere.  The best way is to create a copy of the\n+original file on a branch that is writable, and then redirect the write\n+though to this copy.  The copy must be made on a higher priority branch so\n+that lookup and readdir return this newer "version" of the file rather than\n+the original (see duplicate elimination).\n+\n+An entire unionfs mount can be read-only or read-write.  If it\'s read-only,\n+then none of the branches will be written to, even if some of the branches\n+are physically writeable.  If the unionfs mount is read-write, then the\n+leftmost (highest priority) branch must be writeable (for copyup to take\n+place); the remaining branches can be any mix of read-write and read-only.\n+\n+In a writeable mount, unionfs will create new files/dir in the leftmost\n+branch.  If one tries to modify a file in a read-only branch/media, unionfs\n+will copyup the file to the leftmost branch and modify it there.  If you try\n+to modify a file from a writeable branch which is not the leftmost branch,\n+then unionfs will modify it in that branch; this is useful if you, say,\n+unify differnet packages (e.g., apache, sendmail, ftpd, etc.) and you want\n+changes to specific package files to remain logically in the directory where\n+they came from.\n+\n+Cache Coherency:\n+================\n+\n+Unionfs users often want to be able to modify files and directories directly\n+on the lower branches, and have those changes be visible at the Unionfs\n+level.  This means that data (e.g., pages) and meta-data (dentries, inodes,\n+open files, etc.) have to be synchronized between the upper and lower\n+layers.  In other words, the newest changes from a layer below have to be\n+propagated to the Unionfs layer above.  If the two layers are not in sync, a\n+cache incoherency ensues, which could lead to application failures and even\n+oopses.  The Linux kernel, however, has a rather limited set of mechanisms\n+to ensure this inter-layer cache coherency---so Unionfs has to do most of\n+the hard work on its own.\n+\n+Maintaining Invariants:\n+\n+The way Unionfs ensures cache coherency is as follows.  At each entry point\n+to a Unionfs file system method, we call a utility function to validate the\n+primary objects of this method.  Generally, we call unionfs_file_revalidate\n+on open files, and __unionfs_d_revalidate_chain on dentries (which also\n+validates inodes).  These utility functions check to see whether the upper\n+Unionfs object is in sync with any of the lower objects that it represents.\n+The checks we perform include whether the Unionfs superblock has a newer\n+generation number, or if any of the lower objects mtime\'s or ctime\'s are\n+newer.  (Note: generation numbers change when branch-management commands are\n+issued, so in a way, maintaining cache coherency is also very important for\n+branch-management.)  If indeed we determine that any Unionfs object is no\n+longer in sync with its lower counterparts, then we rebuild that object\n+similarly to how we do so for branch-management.\n+\n+While rebuilding Unionfs\'s objects, we also purge any page mappings and\n+truncate inode pages (see fs/unionfs/dentry.c:purge_inode_data).  This is to\n+ensure that Unionfs will re-get the newer data from the lower branches.  We\n+perform this purging only if the Unionfs operation in question is a reading\n+operation; if Unionfs is performing a data writing operation (e.g., ->write,\n+->commit_write, etc.) then we do NOT flush the lower mappings/pages: this is\n+because (1) a self-deadlock could occur and (2) the upper Unionfs pages are\n+considered more authoritative anyway, as they are newer and will overwrite\n+any lower pages.\n+\n+Unionfs maintains the following important invariant regarding mtime\'s,\n+ctime\'s, and atime\'s: the upper inode object\'s times are the max() of all of\n+the lower ones.  For non-directory objects, there\'s only one object below,\n+so the mapping is simple; for directory objects, there could me multiple\n+lower objects and we have to sync up with the newest one of all the lower\n+ones.  This invariant is important to maintain, especially for directories\n+(besides, we need this to be POSIX compliant).  A union could comprise\n+multiple writable branches, each of which could change.  If we don\'t reflect\n+the newest possible mtime/ctime, some applications could fail.  For example,\n+NFSv2/v3 exports check for newer directory mtimes on the server to determine\n+if the client-side attribute cache should be purged.\n+\n+To maintain these important invariants, of course, Unionfs carefully\n+synchronizes upper and lower times in various places.  For example, if we\n+copy-up a file to a top-level branch, the parent directory where the file\n+was copied up to will now have a new mtime: so after a successful copy-up,\n+we sync up with the new top-level branch\'s parent directory mtime.\n+\n+Implementation:\n+\n+This cache-coherency implementation is efficient because it defers any\n+synchronizing between the upper and lower layers until absolutely needed.\n+Consider the example a common situation where users perform a lot of lower\n+changes, such as untarring a whole package.  While these take place,\n+typically the user doesn\'t access the files via Unionfs; only after the\n+lower changes are done, does the user try to access the lower files.  With\n+our cache-coherency implementation, the entirety of the changes to the lower\n+branches will not result in a single CPU cycle spent at the Unionfs level\n+until the user invokes a system call that goes through Unionfs.\n+\n+We have considered two alternate cache-coherency designs.  (1) Using the\n+dentry/inode notify functionality to register interest in finding out about\n+any lower changes.  This is a somewhat limited and also a heavy-handed\n+approach which could result in many notifications to the Unionfs layer upon\n+each small change at the lower layer (imagine a file being modified multiple\n+times in rapid succession).  (2) Rewriting the VFS to support explicit\n+callbacks from lower objects to upper objects.  We began exploring such an\n+implementation, but found it to be very complicated--it would have resulted\n+in massive VFS/MM changes which are unlikely to be accepted by the LKML\n+community.  We therefore believe that our current cache-coherency design and\n+implementation represent the best approach at this time.\n+\n+Limitations:\n+\n+Our implementation works in that as long as a user process will have caused\n+Unionfs to be called, directly or indirectly, even to just do\n+->d_revalidate; then we will have purged the current Unionfs data and the\n+process will see the new data.  For example, a process that continually\n+re-reads the same file\'s data will see the NEW data as soon as the lower\n+file had changed, upon the next read(2) syscall (even if the file is still\n+open!)  However, this doesn\'t work when the process re-reads the open file\'s\n+data via mmap(2) (unless the user unmaps/closes the file and remaps/reopens\n+it).  Once we respond to ->readpage(s), then the kernel maps the page into\n+the process\'s address space and there doesn\'t appear to be a way to force\n+the kernel to invalidate those pages/mappings, and force the process to\n+re-issue ->readpage.  If there\'s a way to invalidate active mappings and\n+force a ->readpage, let us know please (invalidate_inode_pages2 doesn\'t do\n+the trick).\n+\n+Our current Unionfs code has to perform many file-revalidation calls.  It\n+would be really nice if the VFS would export an optional file system hook\n+->file_revalidate (similarly to dentry->d_revalidate) that will be called\n+before each VFS op that has a "struct file" in it.\n+\n+Certain file systems have micro-second granularity (or better) for inode\n+times, and asynchronous actions could cause those times to change with some\n+small delay.  In such cases, Unionfs may see a changed inode time that only\n+differs by a tiny fraction of a second: such a change may be a false\n+positive indication that the lower object has changed, whereas if unionfs\n+waits a little longer, that false indication will not be seen.  (These false\n+positives are harmless, because they would at most cause unionfs to\n+re-validate an object that may need no revalidation, and print a debugging\n+message that clutters the console/logs.)  Therefore, to minimize the chances\n+of these situations, we delay the detection of changed times by a small\n+factor of a few seconds, called UNIONFS_MIN_CC_TIME (which defaults to 3\n+seconds, as does NFS).  This means that we will detect the change, only a\n+couple of seconds later, if indeed the time change persists in the lower\n+file object.  This delayed detection has an added performance benefit: we\n+reduce the number of times that unionfs has to revalidate objects, in case\n+there\'s a lot of concurrent activity on both the upper and lower objects,\n+for the same file(s).  Lastly, this delayed time attribute detection is\n+similar to how NFS clients operate (e.g., acregmin).\n+\n+Finally, there is no way currently in Linux to prevent lower directories\n+from being moved around (i.e., topology changes); there\'s no way to prevent\n+modifications to directory sub-trees of whole file systems which are mounted\n+read-write.  It is therefore possible for in-flight operations in unionfs to\n+take place, while a lower directory is being moved around.  Therefore, if\n+you try to, say, create a new file in a directory through unionfs, while the\n+directory is being moved around directly, then the new file may get created\n+in the new location where that directory was moved to.  This is a somewhat\n+similar behaviour in NFS: an NFS client could be creating a new file while\n+th NFS server is moving th directory around; the file will get successfully\n+created in the new location.  (The one exception in unionfs is that if the\n+branch is marked read-only by unionfs, then a copyup will take place.)\n+\n+For more information, see <http://unionfs.filesystems.org/>.'),
 ('dev/null',
  'b/Documentation/filesystems/unionfs/issues.txt',
  "diff --git a/Documentation/filesystems/unionfs/issues.txt b/Documentation/filesystems/unionfs/issues.txt\nnew file mode 100644\nindex 0000000..f4b7e7e\n--- dev/null\n+++ b/Documentation/filesystems/unionfs/issues.txt\n@@ -0,0 +1,28 @@\n+KNOWN Unionfs 2.x ISSUES:\n+=========================\n+\n+1. Unionfs should not use lookup_one_len() on the underlying f/s as it\n+   confuses NFSv4.  Currently, unionfs_lookup() passes lookup intents to the\n+   lower file-system, this eliminates part of the problem.  The remaining\n+   calls to lookup_one_len may need to be changed to pass an intent.  We are\n+   currently introducing VFS changes to fs/namei.c's do_path_lookup() to\n+   allow proper file lookup and opening in stackable file systems.\n+\n+2. Lockdep (a debugging feature) isn't aware of stacking, and so it\n+   incorrectly complains about locking problems.  The problem boils down to\n+   this: Lockdep considers all objects of a certain type to be in the same\n+   class, for example, all inodes.  Lockdep doesn't like to see a lock held\n+   on two inodes within the same task, and warns that it could lead to a\n+   deadlock.  However, stackable file systems do precisely that: they lock\n+   an upper object, and then a lower object, in a strict order to avoid\n+   locking problems; in addition, Unionfs, as a fan-out file system, may\n+   have to lock several lower inodes.  We are currently looking into Lockdep\n+   to see how to make it aware of stackable file systems.  For now, we\n+   temporarily disable lockdep when calling vfs methods on lower objects,\n+   but only for those places where lockdep complained.  While this solution\n+   may seem unclean, it is not without precedent: other places in the kernel\n+   also do similar temporary disabling, of course after carefully having\n+   checked that it is the right thing to do.  Anyway, you get any warnings\n+   from Lockdep, please report them to the Unionfs maintainers.\n+\n+For more information, see <http://unionfs.filesystems.org/>."),
 ('dev/null',
  'b/Documentation/filesystems/unionfs/rename.txt',
  'diff --git a/Documentation/filesystems/unionfs/rename.txt b/Documentation/filesystems/unionfs/rename.txt\nnew file mode 100644\nindex 0000000..e20bb82\n--- dev/null\n+++ b/Documentation/filesystems/unionfs/rename.txt\n@@ -0,0 +1,31 @@\n+Rename is a complex beast. The following table shows which rename(2) operations\n+should succeed and which should fail.\n+\n+o: success\n+E: error (either unionfs or vfs)\n+X: EXDEV\n+\n+none = file does not exist\n+file = file is a file\n+dir  = file is a empty directory\n+child= file is a non-empty directory\n+wh   = file is a directory containing only whiteouts; this makes it logically\n+\t\tempty\n+\n+                      none    file    dir     child   wh\n+file                  o       o       E       E       E\n+dir                   o       E       o       E       o\n+child                 X       E       X       E       X\n+wh                    o       E       o       E       o\n+\n+\n+Renaming directories:\n+=====================\n+\n+Whenever a empty (either physically or logically) directory is being renamed,\n+the following sequence of events should take place:\n+\n+1) Remove whiteouts from both source and destination directory\n+2) Rename source to destination\n+3) Make destination opaque to prevent anything under it from showing up\n+'),
 ('dev/null',
  'b/Documentation/filesystems/unionfs/usage.txt',
  'diff --git a/Documentation/filesystems/unionfs/usage.txt b/Documentation/filesystems/unionfs/usage.txt\nnew file mode 100644\nindex 0000000..1adde69\n--- dev/null\n+++ b/Documentation/filesystems/unionfs/usage.txt\n@@ -0,0 +1,134 @@\n+Unionfs is a stackable unification file system, which can appear to merge\n+the contents of several directories (branches), while keeping their physical\n+content separate.  Unionfs is useful for unified source tree management,\n+merged contents of split CD-ROM, merged separate software package\n+directories, data grids, and more.  Unionfs allows any mix of read-only and\n+read-write branches, as well as insertion and deletion of branches anywhere\n+in the fan-out.  To maintain Unix semantics, Unionfs handles elimination of\n+duplicates, partial-error conditions, and more.\n+\n+GENERAL SYNTAX\n+==============\n+\n+# mount -t unionfs -o <OPTIONS>,<BRANCH-OPTIONS> none MOUNTPOINT\n+\n+OPTIONS can be any legal combination of:\n+\n+- ro\t\t# mount file system read-only\n+- rw\t\t# mount file system read-write\n+- remount\t# remount the file system (see Branch Management below)\n+- incgen\t# increment generation no. (see Cache Consistency below)\n+\n+BRANCH-OPTIONS can be either (1) a list of branches given to the "dirs="\n+option, or (2) a list of individual branch manipulation commands, combined\n+with the "remount" option, and is further described in the "Branch\n+Management" section below.\n+\n+The syntax for the "dirs=" mount option is:\n+\n+\tdirs=branch[=ro|=rw][:...]\n+\n+The "dirs=" option takes a colon-delimited list of directories to compose\n+the union, with an optional branch mode for each of those directories.\n+Directories that come earlier (specified first, on the left) in the list\n+have a higher precedence than those which come later.  Additionally,\n+read-only or read-write permissions of the branch can be specified by\n+appending =ro or =rw (default) to each directory.  See the Copyup section in\n+concepts.txt, for a description of Unionfs\'s behavior when mixing read-only\n+and read-write branches and mounts.\n+\n+Syntax:\n+\n+\tdirs=/branch1[=ro|=rw]:/branch2[=ro|=rw]:...:/branchN[=ro|=rw]\n+\n+Example:\n+\n+\tdirs=/writable_branch=rw:/read-only_branch=ro\n+\n+\n+BRANCH MANAGEMENT\n+=================\n+\n+Once you mount your union for the first time, using the "dirs=" option, you\n+can then change the union\'s overall mode or reconfigure the branches, using\n+the remount option, as follows.\n+\n+To downgrade a union from read-write to read-only:\n+\n+# mount -t unionfs -o remount,ro none MOUNTPOINT\n+\n+To upgrade a union from read-only to read-write:\n+\n+# mount -t unionfs -o remount,rw none MOUNTPOINT\n+\n+To delete a branch /foo, regardless where it is in the current union:\n+\n+# mount -t unionfs -o remount,del=/foo none MOUNTPOINT\n+\n+To insert (add) a branch /foo before /bar:\n+\n+# mount -t unionfs -o remount,add=/bar:/foo none MOUNTPOINT\n+\n+To insert (add) a branch /foo (with the "rw" mode flag) before /bar:\n+\n+# mount -t unionfs -o remount,add=/bar:/foo=rw none MOUNTPOINT\n+\n+To insert (add) a branch /foo (in "rw" mode) at the very beginning (i.e., a\n+new highest-priority branch), you can use the above syntax, or use a short\n+hand version as follows:\n+\n+# mount -t unionfs -o remount,add=/foo none MOUNTPOINT\n+\n+To append a branch to the very end (new lowest-priority branch):\n+\n+# mount -t unionfs -o remount,add=:/foo none MOUNTPOINT\n+\n+To append a branch to the very end (new lowest-priority branch), in\n+read-only mode:\n+\n+# mount -t unionfs -o remount,add=:/foo=ro none MOUNTPOINT\n+\n+Finally, to change the mode of one existing branch, say /foo, from read-only\n+to read-write, and change /bar from read-write to read-only:\n+\n+# mount -t unionfs -o remount,mode=/foo=rw,mode=/bar=ro none MOUNTPOINT\n+\n+Note: in Unionfs 2.x, you cannot set the leftmost branch to readonly because\n+then Unionfs won\'t have any writable place for copyups to take place.\n+Moreover, the VFS can get confused when it tries to modify something in a\n+file system mounted read-write, but isn\'t permitted to write to it.\n+Instead, you should set the whole union as readonly, as described above.\n+If, however, you must set the leftmost branch as readonly, perhaps so you\n+can get a snapshot of it at a point in time, then you should insert a new\n+writable top-level branch, and mark the one you want as readonly.  This can\n+be accomplished as follows, assuming that /foo is your current leftmost\n+branch:\n+\n+# mount -t tmpfs -o size=NNN /new\n+# mount -t unionfs -o remount,add=/new,mode=/foo=ro none MOUNTPOINT\n+<do what you want safely in /foo>\n+# mount -t unionfs -o remount,del=/new,mode=/foo=rw none MOUNTPOINT\n+<check if there\'s anything in /new you want to preserve>\n+# umount /new\n+\n+CACHE CONSISTENCY\n+=================\n+\n+If you modify any file on any of the lower branches directly, while there is\n+a Unionfs 2.x mounted above any of those branches, you should tell Unionfs\n+to purge its caches and re-get the objects.  To do that, you have to\n+increment the generation number of the superblock using the following\n+command:\n+\n+# mount -t unionfs -o remount,incgen none MOUNTPOINT\n+\n+Note that the older way of incrementing the generation number using an\n+ioctl, is no longer supported in Unionfs 2.0 and newer.  Ioctls in general\n+are not encouraged.  Plus, an ioctl is per-file concept, whereas the\n+generation number is a per-file-system concept.  Worse, such an ioctl\n+requires an open file, which then has to be invalidated by the very nature\n+of the generation number increase (read: the old generation increase ioctl\n+was pretty racy).\n+\n+\n+For more information, see <http://unionfs.filesystems.org/>.'),
 ('MAINTAINERS',
  'MAINTAINERS',
  'diff --git a/MAINTAINERS b/MAINTAINERS\nindex 9a91d9e..87e1e63 100644\n--- MAINTAINERS\n+++ MAINTAINERS\n@@ -3740,6 +3740,14 @@ L:\tlinux-kernel@vger.kernel.org\nW:\thttp://www.kernel.dk\nS:\tMaintained\n\n+UNIONFS\n+P:\tErez Zadok\n+M:\tezk@cs.sunysb.edu\n+L:\tunionfs@filesystems.org\n+W:\thttp://unionfs.filesystems.org\n+T:\tgit git.kernel.org/pub/scm/linux/kernel/git/ezk/unionfs.git\n+S:\tMaintained\n+\nUSB ACM DRIVER\nP:\tOliver Neukum\nM:\toliver@neukum.name'),
 ('fs/Kconfig',
  'fs/Kconfig',
  'diff --git a/fs/Kconfig b/fs/Kconfig\nindex f9eed6d..9afb8df 100644\n--- fs/Kconfig\n+++ fs/Kconfig\n@@ -1027,6 +1027,47 @@ config CONFIGFS_FS\n\nendmenu\n\n+menu "Layered filesystems"\n+\n+config ECRYPT_FS\n+\ttristate "eCrypt filesystem layer support (EXPERIMENTAL)"\n+\tdepends on EXPERIMENTAL && KEYS && CRYPTO && NET\n+\thelp\n+\t  Encrypted filesystem that operates on the VFS layer.  See\n+\t  <file:Documentation/ecryptfs.txt> to learn more about\n+\t  eCryptfs.  Userspace components are required and can be\n+\t  obtained from <http://ecryptfs.sf.net>.\n+\n+\t  To compile this file system support as a module, choose M here: the\n+\t  module will be called ecryptfs.\n+\n+config UNION_FS\n+\ttristate "Union file system (EXPERIMENTAL)"\n+\tdepends on EXPERIMENTAL\n+\thelp\n+\t  Unionfs is a stackable unification file system, which appears to\n+\t  merge the contents of several directories (branches), while keeping\n+\t  their physical content separate.\n+\n+\t  See <http://unionfs.filesystems.org> for details\n+\n+config UNION_FS_XATTR\n+\tbool "Unionfs extended attributes"\n+\tdepends on UNION_FS\n+\thelp\n+\t  Extended attributes are name:value pairs associated with inodes by\n+\t  the kernel or by users (see the attr(5) manual page).\n+\n+\t  If unsure, say N.\n+\n+config UNION_FS_DEBUG\n+\tbool "Debug Unionfs"\n+\tdepends on UNION_FS\n+\thelp\n+\t  If you say Y here, you can turn on debugging output from Unionfs.\n+\n+endmenu\n+\nmenu "Miscellaneous filesystems"\n\nconfig ADFS_FS\n@@ -1079,18 +1120,6 @@ config AFFS_FS\nTo compile this file system support as a module, choose M here: the\nmodule will be called affs.  If unsure, say N.\n\n-config ECRYPT_FS\n-\ttristate "eCrypt filesystem layer support (EXPERIMENTAL)"\n-\tdepends on EXPERIMENTAL && KEYS && CRYPTO && NET\n-\thelp\n-\t  Encrypted filesystem that operates on the VFS layer.  See\n-\t  <file:Documentation/ecryptfs.txt> to learn more about\n-\t  eCryptfs.  Userspace components are required and can be\n-\t  obtained from <http://ecryptfs.sf.net>.\n-\n-\t  To compile this file system support as a module, choose M here: the\n-\t  module will be called ecryptfs.\n-\nconfig HFS_FS\ntristate "Apple Macintosh file system support (EXPERIMENTAL)"\ndepends on BLOCK && EXPERIMENTAL'),
 ('fs/Makefile',
  'fs/Makefile',
  'diff --git a/fs/Makefile b/fs/Makefile\nindex 720c29d..f1301f3 100644\n--- fs/Makefile\n+++ fs/Makefile\n@@ -84,6 +84,7 @@ obj-$(CONFIG_ISO9660_FS)\t+= isofs/\nobj-$(CONFIG_HFSPLUS_FS)\t+= hfsplus/ # Before hfs to find wrapped HFS+\nobj-$(CONFIG_HFS_FS)\t\t+= hfs/\nobj-$(CONFIG_ECRYPT_FS)\t\t+= ecryptfs/\n+obj-$(CONFIG_UNION_FS)\t\t+= unionfs/\nobj-$(CONFIG_VXFS_FS)\t\t+= freevxfs/\nobj-$(CONFIG_NFS_FS)\t\t+= nfs/\nobj-$(CONFIG_EXPORTFS)\t\t+= exportfs/'),
 ('fs/ecryptfs/dentry.c',
  'fs/ecryptfs/dentry.c',
  'diff --git a/fs/ecryptfs/dentry.c b/fs/ecryptfs/dentry.c\nindex cb20b96..a8c1686 100644\n--- fs/ecryptfs/dentry.c\n+++ fs/ecryptfs/dentry.c\n@@ -62,7 +62,7 @@ static int ecryptfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)\nstruct inode *lower_inode =\necryptfs_inode_to_lower(dentry->d_inode);\n\n-\t\tfsstack_copy_attr_all(dentry->d_inode, lower_inode, NULL);\n+\t\tfsstack_copy_attr_all(dentry->d_inode, lower_inode);\n}\nout:\nreturn rc;'),
 ('fs/ecryptfs/inode.c',
  'fs/ecryptfs/inode.c',
  'diff --git a/fs/ecryptfs/inode.c b/fs/ecryptfs/inode.c\nindex 131954b..fc4c6cb 100644\n--- fs/ecryptfs/inode.c\n+++ fs/ecryptfs/inode.c\n@@ -601,9 +601,9 @@ ecryptfs_rename(struct inode *old_dir, struct dentry *old_dentry,\nlower_new_dir_dentry->d_inode, lower_new_dentry);\nif (rc)\ngoto out_lock;\n-\tfsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode, NULL);\n+\tfsstack_copy_attr_all(new_dir, lower_new_dir_dentry->d_inode);\nif (new_dir != old_dir)\n-\t\tfsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode, NULL);\n+\t\tfsstack_copy_attr_all(old_dir, lower_old_dir_dentry->d_inode);\nout_lock:\nunlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\ndput(lower_new_dentry->d_parent);\n@@ -961,7 +961,7 @@ static int ecryptfs_setattr(struct dentry *dentry, struct iattr *ia)\n}\nrc = notify_change(lower_dentry, ia);\nout:\n-\tfsstack_copy_attr_all(inode, lower_inode, NULL);\n+\tfsstack_copy_attr_all(inode, lower_inode);\nreturn rc;\n}\n'),
 ('fs/ecryptfs/main.c',
  'fs/ecryptfs/main.c',
  'diff --git a/fs/ecryptfs/main.c b/fs/ecryptfs/main.c\nindex a984972..cb349a4 100644\n--- fs/ecryptfs/main.c\n+++ fs/ecryptfs/main.c\n@@ -151,7 +151,7 @@ int ecryptfs_interpose(struct dentry *lower_dentry, struct dentry *dentry,\nd_add(dentry, inode);\nelse\nd_instantiate(dentry, inode);\n-\tfsstack_copy_attr_all(inode, lower_inode, NULL);\n+\tfsstack_copy_attr_all(inode, lower_inode);\n/* This size will be overwritten for real files w/ headers and\n* other metadata */\nfsstack_copy_inode_size(inode, lower_inode);'),
 ('fs/namei.c',
  'fs/namei.c',
  'diff --git a/fs/namei.c b/fs/namei.c\nindex 314afe6..c15ce85 100644\n--- fs/namei.c\n+++ fs/namei.c\n@@ -374,6 +374,7 @@ void release_open_intent(struct nameidata *nd)\nelse\nfput(nd->intent.open.file);\n}\n+EXPORT_SYMBOL_GPL(release_open_intent);\n\nstatic inline struct dentry *\ndo_revalidate(struct dentry *dentry, struct nameidata *nd)'),
 ('fs/splice.c',
  'fs/splice.c',
  'diff --git a/fs/splice.c b/fs/splice.c\nindex 1a9c0e6..f931be4 100644\n--- fs/splice.c\n+++ fs/splice.c\n@@ -943,8 +943,8 @@ EXPORT_SYMBOL(generic_splice_sendpage);\n/*\n* Attempt to initiate a splice from pipe to file.\n*/\n-static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n-\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n+long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,\n+\t\t     loff_t *ppos, size_t len, unsigned int flags)\n{\nint ret;\n\n@@ -964,13 +964,14 @@ static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\nreturn out->f_op->splice_write(pipe, out, ppos, len, flags);\n}\n+EXPORT_SYMBOL_GPL(vfs_splice_from);\n\n/*\n* Attempt to initiate a splice from a file to a pipe.\n*/\n-static long do_splice_to(struct file *in, loff_t *ppos,\n-\t\t\t struct pipe_inode_info *pipe, size_t len,\n-\t\t\t unsigned int flags)\n+long vfs_splice_to(struct file *in, loff_t *ppos,\n+\t\t   struct pipe_inode_info *pipe, size_t len,\n+\t\t   unsigned int flags)\n{\nint ret;\n\n@@ -990,6 +991,7 @@ static long do_splice_to(struct file *in, loff_t *ppos,\n\nreturn in->f_op->splice_read(in, ppos, pipe, len, flags);\n}\n+EXPORT_SYMBOL_GPL(vfs_splice_to);\n\n/**\n* splice_direct_to_actor - splices data directly between two non-pipes\n@@ -1059,7 +1061,7 @@ ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\nsize_t read_len;\nloff_t pos = sd->pos;\n\n-\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n+\t\tret = vfs_splice_to(in, &pos, pipe, len, flags);\nif (unlikely(ret <= 0))\ngoto out_release;\n\n@@ -1117,7 +1119,7 @@ static int direct_splice_actor(struct pipe_inode_info *pipe,\n{\nstruct file *file = sd->u.file;\n\n-\treturn do_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);\n+\treturn vfs_splice_from(pipe, file, &sd->pos, sd->total_len, sd->flags);\n}\n\n/**\n@@ -1191,7 +1193,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,\n} else\noff = &out->f_pos;\n\n-\t\tret = do_splice_from(pipe, out, off, len, flags);\n+\t\tret = vfs_splice_from(pipe, out, off, len, flags);\n\nif (off_out && copy_to_user(off_out, off, sizeof(loff_t)))\nret = -EFAULT;\n@@ -1212,7 +1214,7 @@ static long do_splice(struct file *in, loff_t __user *off_in,\n} else\noff = &in->f_pos;\n\n-\t\tret = do_splice_to(in, off, pipe, len, flags);\n+\t\tret = vfs_splice_to(in, off, pipe, len, flags);\n\nif (off_in && copy_to_user(off_in, off, sizeof(loff_t)))\nret = -EFAULT;'),
 ('fs/stack.c',
  'fs/stack.c',
  "diff --git a/fs/stack.c b/fs/stack.c\nindex 67716f6..cc1443d 100644\n--- fs/stack.c\n+++ fs/stack.c\n@@ -1,24 +1,82 @@\n+/*\n+ * Copyright (c) 2006-2009 Erez Zadok\n+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek\n+ * Copyright (c) 2006-2009 Stony Brook University\n+ * Copyright (c) 2006-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/fs_stack.h>\n\n-/* does _NOT_ require i_mutex to be held.\n+/*\n+ * does _NOT_ require i_mutex to be held.\n*\n* This function cannot be inlined since i_size_{read,write} is rather\n* heavy-weight on 32-bit systems\n*/\n-void fsstack_copy_inode_size(struct inode *dst, const struct inode *src)\n+void fsstack_copy_inode_size(struct inode *dst, struct inode *src)\n{\n-\ti_size_write(dst, i_size_read((struct inode *)src));\n-\tdst->i_blocks = src->i_blocks;\n+\tloff_t i_size;\n+\tblkcnt_t i_blocks;\n+\n+\t/*\n+\t * i_size_read() includes its own seqlocking and protection from\n+\t * preemption (see include/linux/fs.h): we need nothing extra for\n+\t * that here, and prefer to avoid nesting locks than attempt to\n+\t * keep i_size and i_blocks in synch together.\n+\t */\n+\ti_size = i_size_read(src);\n+\n+\t/*\n+\t * But if CONFIG_LSF (on 32-bit), we ought to make an effort to keep\n+\t * the two halves of i_blocks in synch despite SMP or PREEMPT - though\n+\t * stat's generic_fillattr() doesn't bother, and we won't be applying\n+\t * quotas (where i_blocks does become important) at the upper level.\n+\t *\n+\t * We don't actually know what locking is used at the lower level; but\n+\t * if it's a filesystem that supports quotas, it will be using i_lock\n+\t * as in inode_add_bytes().  tmpfs uses other locking, and its 32-bit\n+\t * is (just) able to exceed 2TB i_size with the aid of holes; but its\n+\t * i_blocks cannot carry into the upper long without almost 2TB swap -\n+\t * let's ignore that case.\n+\t */\n+\tif (sizeof(i_blocks) > sizeof(long))\n+\t\tspin_lock(&src->i_lock);\n+\ti_blocks = src->i_blocks;\n+\tif (sizeof(i_blocks) > sizeof(long))\n+\t\tspin_unlock(&src->i_lock);\n+\n+\t/*\n+\t * If CONFIG_SMP on 32-bit, it's vital for fsstack_copy_inode_size()\n+\t * to hold some lock around i_size_write(), otherwise i_size_read()\n+\t * may spin forever (see include/linux/fs.h).  We don't necessarily\n+\t * hold i_mutex when this is called, so take i_lock for that case.\n+\t *\n+\t * And if CONFIG_LSF (on 32-bit), continue our effort to keep the\n+\t * two halves of i_blocks in synch despite SMP or PREEMPT: use i_lock\n+\t * for that case too, and do both at once by combining the tests.\n+\t *\n+\t * There is none of this locking overhead in the 64-bit case.\n+\t */\n+\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n+\t\tspin_lock(&dst->i_lock);\n+\ti_size_write(dst, i_size);\n+\tdst->i_blocks = i_blocks;\n+\tif (sizeof(i_size) > sizeof(long) || sizeof(i_blocks) > sizeof(long))\n+\t\tspin_unlock(&dst->i_lock);\n}\nEXPORT_SYMBOL_GPL(fsstack_copy_inode_size);\n\n-/* copy all attributes; get_nlinks is optional way to override the i_nlink\n+/*\n+ * copy all attributes; get_nlinks is optional way to override the i_nlink\n* copying\n*/\n-void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,\n-\t\t\t\tint (*get_nlinks)(struct inode *))\n+void fsstack_copy_attr_all(struct inode *dest, const struct inode *src)\n{\ndest->i_mode = src->i_mode;\ndest->i_uid = src->i_uid;\n@@ -29,14 +87,6 @@ void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,\ndest->i_ctime = src->i_ctime;\ndest->i_blkbits = src->i_blkbits;\ndest->i_flags = src->i_flags;\n-\n-\t/*\n-\t * Update the nlinks AFTER updating the above fields, because the\n-\t * get_links callback may depend on them.\n-\t */\n-\tif (!get_nlinks)\n-\t\tdest->i_nlink = src->i_nlink;\n-\telse\n-\t\tdest->i_nlink = (*get_nlinks)(dest);\n+\tdest->i_nlink = src->i_nlink;\n}\nEXPORT_SYMBOL_GPL(fsstack_copy_attr_all);"),
 ('dev/null',
  'b/fs/unionfs/Makefile',
  'diff --git a/fs/unionfs/Makefile b/fs/unionfs/Makefile\nnew file mode 100644\nindex 0000000..1d71ee7\n--- dev/null\n+++ b/fs/unionfs/Makefile\n@@ -0,0 +1,17 @@\n+UNIONFS_VERSION="2.5.1 (for 2.6.23.17)"\n+\n+EXTRA_CFLAGS += -DUNIONFS_VERSION=\\"$(UNIONFS_VERSION)\\"\n+\n+obj-$(CONFIG_UNION_FS) += unionfs.o\n+\n+unionfs-y := subr.o dentry.o file.o inode.o main.o super.o \\\n+\trdstate.o copyup.o dirhelper.o rename.o unlink.o \\\n+\tlookup.o commonfops.o dirfops.o sioq.o mmap.o whiteout.o\n+\n+unionfs-$(CONFIG_UNION_FS_XATTR) += xattr.o\n+\n+unionfs-$(CONFIG_UNION_FS_DEBUG) += debug.o\n+\n+ifeq ($(CONFIG_UNION_FS_DEBUG),y)\n+EXTRA_CFLAGS += -DDEBUG\n+endif'),
 ('dev/null',
  'b/fs/unionfs/commonfops.c',
  'diff --git a/fs/unionfs/commonfops.c b/fs/unionfs/commonfops.c\nnew file mode 100644\nindex 0000000..63ee085\n--- dev/null\n+++ b/fs/unionfs/commonfops.c\n@@ -0,0 +1,879 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * 1) Copyup the file\n+ * 2) Rename the file to \'.unionfs<original inode#><counter>\' - obviously\n+ * stolen from NFS\'s silly rename\n+ */\n+static int copyup_deleted_file(struct file *file, struct dentry *dentry,\n+\t\t\t       struct dentry *parent, int bstart, int bindex)\n+{\n+\tstatic unsigned int counter;\n+\tconst int i_inosize = sizeof(dentry->d_inode->i_ino) * 2;\n+\tconst int countersize = sizeof(counter) * 2;\n+\tconst int nlen = sizeof(".unionfs") + i_inosize + countersize - 1;\n+\tchar name[nlen + 1];\n+\tint err;\n+\tstruct dentry *tmp_dentry = NULL;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\n+\tlower_dentry = unionfs_lower_dentry_idx(dentry, bstart);\n+\n+\tsprintf(name, ".unionfs%*.*lx",\n+\t\ti_inosize, i_inosize, lower_dentry->d_inode->i_ino);\n+\n+\t/*\n+\t * Loop, looking for an unused temp name to copyup to.\n+\t *\n+\t * It\'s somewhat silly that we look for a free temp tmp name in the\n+\t * source branch (bstart) instead of the dest branch (bindex), where\n+\t * the final name will be created.  We _will_ catch it if somehow\n+\t * the name exists in the dest branch, but it\'d be nice to catch it\n+\t * sooner than later.\n+\t */\n+retry:\n+\ttmp_dentry = NULL;\n+\tdo {\n+\t\tchar *suffix = name + nlen - countersize;\n+\n+\t\tdput(tmp_dentry);\n+\t\tcounter++;\n+\t\tsprintf(suffix, "%*.*x", countersize, countersize, counter);\n+\n+\t\tpr_debug("unionfs: trying to rename %s to %s\\n",\n+\t\t\t dentry->d_name.name, name);\n+\n+\t\ttmp_dentry = lookup_one_len(name, lower_dentry->d_parent,\n+\t\t\t\t\t    nlen);\n+\t\tif (IS_ERR(tmp_dentry)) {\n+\t\t\terr = PTR_ERR(tmp_dentry);\n+\t\t\tgoto out;\n+\t\t}\n+\t} while (tmp_dentry->d_inode != NULL);\t/* need negative dentry */\n+\tdput(tmp_dentry);\n+\n+\terr = copyup_named_file(parent->d_inode, file, name, bstart, bindex,\n+\t\t\t\ti_size_read(file->f_path.dentry->d_inode));\n+\tif (err) {\n+\t\tif (unlikely(err == -EEXIST))\n+\t\t\tgoto retry;\n+\t\tgoto out;\n+\t}\n+\n+\t/* bring it to the same state as an unlinked file */\n+\tlower_dentry = unionfs_lower_dentry_idx(dentry, dbstart(dentry));\n+\tif (!unionfs_lower_inode_idx(dentry->d_inode, bindex)) {\n+\t\tatomic_inc(&lower_dentry->d_inode->i_count);\n+\t\tunionfs_set_lower_inode_idx(dentry->d_inode, bindex,\n+\t\t\t\t\t    lower_dentry->d_inode);\n+\t}\n+\tlower_dir_dentry = lock_parent(lower_dentry);\n+\terr = vfs_unlink(lower_dir_dentry->d_inode, lower_dentry);\n+\tunlock_dir(lower_dir_dentry);\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_dentry(dentry);\n+\treturn err;\n+}\n+\n+/*\n+ * put all references held by upper struct file and free lower file pointer\n+ * array\n+ */\n+static void cleanup_file(struct file *file)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct file **lower_files;\n+\tstruct file *lower_file;\n+\tstruct super_block *sb = file->f_path.dentry->d_sb;\n+\n+\tlower_files = UNIONFS_F(file)->lower_files;\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tint i;\t/* holds (possibly) updated branch index */\n+\t\tint old_bid;\n+\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\tif (!lower_file)\n+\t\t\tcontinue;\n+\n+\t\t/*\n+\t\t * Find new index of matching branch with an open\n+\t\t * file, since branches could have been added or\n+\t\t * deleted causing the one with open files to shift.\n+\t\t */\n+\t\told_bid = UNIONFS_F(file)->saved_branch_ids[bindex];\n+\t\ti = branch_id_to_idx(sb, old_bid);\n+\t\tif (unlikely(i < 0)) {\n+\t\t\tprintk(KERN_ERR "unionfs: no superblock for "\n+\t\t\t       "file %p\\n", file);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* decrement count of open files */\n+\t\tbranchput(sb, i);\n+\t\t/*\n+\t\t * fput will perform an mntput for us on the correct branch.\n+\t\t * Although we\'re using the file\'s old branch configuration,\n+\t\t * bindex, which is the old index, correctly points to the\n+\t\t * right branch in the file\'s branch list.  In other words,\n+\t\t * we\'re going to mntput the correct branch even if branches\n+\t\t * have been added/removed.\n+\t\t */\n+\t\tfput(lower_file);\n+\t\tUNIONFS_F(file)->lower_files[bindex] = NULL;\n+\t\tUNIONFS_F(file)->saved_branch_ids[bindex] = -1;\n+\t}\n+\n+\tUNIONFS_F(file)->lower_files = NULL;\n+\tkfree(lower_files);\n+\tkfree(UNIONFS_F(file)->saved_branch_ids);\n+\t/* set to NULL because caller needs to know if to kfree on error */\n+\tUNIONFS_F(file)->saved_branch_ids = NULL;\n+}\n+\n+/* open all lower files for a given file */\n+static int open_all_files(struct file *file)\n+{\n+\tint bindex, bstart, bend, err = 0;\n+\tstruct file *lower_file;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct super_block *sb = dentry->d_sb;\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\n+\t\tdget(lower_dentry);\n+\t\tunionfs_mntget(dentry, bindex);\n+\t\tbranchget(sb, bindex);\n+\n+\t\tlower_file =\n+\t\t\tdentry_open(lower_dentry,\n+\t\t\t\t    unionfs_lower_mnt_idx(dentry, bindex),\n+\t\t\t\t    file->f_flags);\n+\t\tif (IS_ERR(lower_file)) {\n+\t\t\tbranchput(sb, bindex);\n+\t\t\terr = PTR_ERR(lower_file);\n+\t\t\tgoto out;\n+\t\t} else {\n+\t\t\tunionfs_set_lower_file_idx(file, bindex, lower_file);\n+\t\t}\n+\t}\n+out:\n+\treturn err;\n+}\n+\n+/* open the highest priority file for a given upper file */\n+static int open_highest_file(struct file *file, bool willwrite)\n+{\n+\tint bindex, bstart, bend, err = 0;\n+\tstruct file *lower_file;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent = dget_parent(dentry);\n+\tstruct inode *parent_inode = parent->d_inode;\n+\tstruct super_block *sb = dentry->d_sb;\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\tif (willwrite && IS_WRITE_FLAG(file->f_flags) && is_robranch(dentry)) {\n+\t\tfor (bindex = bstart - 1; bindex >= 0; bindex--) {\n+\t\t\terr = copyup_file(parent_inode, file, bstart, bindex,\n+\t\t\t\t\t  i_size_read(dentry->d_inode));\n+\t\t\tif (!err)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tatomic_set(&UNIONFS_F(file)->generation,\n+\t\t\t   atomic_read(&UNIONFS_I(dentry->d_inode)->\n+\t\t\t\t       generation));\n+\t\tgoto out;\n+\t}\n+\n+\tdget(lower_dentry);\n+\tunionfs_mntget(dentry, bstart);\n+\tlower_file = dentry_open(lower_dentry,\n+\t\t\t\t unionfs_lower_mnt_idx(dentry, bstart),\n+\t\t\t\t file->f_flags);\n+\tif (IS_ERR(lower_file)) {\n+\t\terr = PTR_ERR(lower_file);\n+\t\tgoto out;\n+\t}\n+\tbranchget(sb, bstart);\n+\tunionfs_set_lower_file(file, lower_file);\n+\t/* Fix up the position. */\n+\tlower_file->f_pos = file->f_pos;\n+\n+\tmemcpy(&lower_file->f_ra, &file->f_ra, sizeof(struct file_ra_state));\n+out:\n+\tdput(parent);\n+\treturn err;\n+}\n+\n+/* perform a delayed copyup of a read-write file on a read-only branch */\n+static int do_delayed_copyup(struct file *file, struct dentry *parent)\n+{\n+\tint bindex, bstart, bend, err = 0;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct inode *parent_inode = parent->d_inode;\n+\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\n+\tBUG_ON(!S_ISREG(dentry->d_inode->i_mode));\n+\n+\tunionfs_check_file(file);\n+\tfor (bindex = bstart - 1; bindex >= 0; bindex--) {\n+\t\tif (!d_deleted(dentry))\n+\t\t\terr = copyup_file(parent_inode, file, bstart,\n+\t\t\t\t\t  bindex,\n+\t\t\t\t\t  i_size_read(dentry->d_inode));\n+\t\telse\n+\t\t\terr = copyup_deleted_file(file, dentry, parent,\n+\t\t\t\t\t\t  bstart, bindex);\n+\t\t/* if succeeded, set lower open-file flags and break */\n+\t\tif (!err) {\n+\t\t\tstruct file *lower_file;\n+\t\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\t\tlower_file->f_flags = file->f_flags;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (err || (bstart <= fbstart(file)))\n+\t\tgoto out;\n+\tbend = fbend(file);\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tif (unionfs_lower_file_idx(file, bindex)) {\n+\t\t\tbranchput(dentry->d_sb, bindex);\n+\t\t\tfput(unionfs_lower_file_idx(file, bindex));\n+\t\t\tunionfs_set_lower_file_idx(file, bindex, NULL);\n+\t\t}\n+\t}\n+\tpath_put_lowers(dentry, bstart, bend, false);\n+\tiput_lowers(dentry->d_inode, bstart, bend, false);\n+\t/* for reg file, we only open it "once" */\n+\tfbend(file) = fbstart(file);\n+\tdbend(dentry) = dbstart(dentry);\n+\tibend(dentry->d_inode) = ibstart(dentry->d_inode);\n+\n+out:\n+\tunionfs_check_file(file);\n+\treturn err;\n+}\n+\n+/*\n+ * Helper function for unionfs_file_revalidate/locked.\n+ * Expects dentry/parent to be locked already, and revalidated.\n+ */\n+static int __unionfs_file_revalidate(struct file *file, struct dentry *dentry,\n+\t\t\t\t     struct dentry *parent,\n+\t\t\t\t     struct super_block *sb, int sbgen,\n+\t\t\t\t     int dgen, bool willwrite)\n+{\n+\tint fgen;\n+\tint bstart, bend, orig_brid;\n+\tint size;\n+\tint err = 0;\n+\n+\tfgen = atomic_read(&UNIONFS_F(file)->generation);\n+\n+\t/*\n+\t * There are two cases we are interested in.  The first is if the\n+\t * generation is lower than the super-block.  The second is if\n+\t * someone has copied up this file from underneath us, we also need\n+\t * to refresh things.\n+\t */\n+\tif (d_deleted(dentry) ||\n+\t    (sbgen <= fgen &&\n+\t     dbstart(dentry) == fbstart(file) &&\n+\t     unionfs_lower_file(file)))\n+\t\tgoto out_may_copyup;\n+\n+\t/* save orig branch ID */\n+\torig_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];\n+\n+\t/* First we throw out the existing files. */\n+\tcleanup_file(file);\n+\n+\t/* Now we reopen the file(s) as in unionfs_open. */\n+\tbstart = fbstart(file) = dbstart(dentry);\n+\tbend = fbend(file) = dbend(dentry);\n+\n+\tsize = sizeof(struct file *) * sbmax(sb);\n+\tUNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_F(file)->lower_files)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\tsize = sizeof(int) * sbmax(sb);\n+\tUNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tif (S_ISDIR(dentry->d_inode->i_mode)) {\n+\t\t/* We need to open all the files. */\n+\t\terr = open_all_files(file);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t} else {\n+\t\tint new_brid;\n+\t\t/* We only open the highest priority branch. */\n+\t\terr = open_highest_file(file, willwrite);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t\tnew_brid = UNIONFS_F(file)->saved_branch_ids[fbstart(file)];\n+\t\tif (unlikely(new_brid != orig_brid && sbgen > fgen)) {\n+\t\t\t/*\n+\t\t\t * If we re-opened the file on a different branch\n+\t\t\t * than the original one, and this was due to a new\n+\t\t\t * branch inserted, then update the mnt counts of\n+\t\t\t * the old and new branches accordingly.\n+\t\t\t */\n+\t\t\tunionfs_mntget(dentry, bstart);\n+\t\t\tunionfs_mntput(sb->s_root,\n+\t\t\t\t       branch_id_to_idx(sb, orig_brid));\n+\t\t}\n+\t\t/* regular files have only one open lower file */\n+\t\tfbend(file) = fbstart(file);\n+\t}\n+\tatomic_set(&UNIONFS_F(file)->generation,\n+\t\t   atomic_read(&UNIONFS_I(dentry->d_inode)->generation));\n+\n+out_may_copyup:\n+\t/* Copyup on the first write to a file on a readonly branch. */\n+\tif (willwrite && IS_WRITE_FLAG(file->f_flags) &&\n+\t    !IS_WRITE_FLAG(unionfs_lower_file(file)->f_flags) &&\n+\t    is_robranch(dentry)) {\n+\t\tpr_debug("unionfs: do delay copyup of \\"%s\\"\\n",\n+\t\t\t dentry->d_name.name);\n+\t\terr = do_delayed_copyup(file, parent);\n+\t\t/* regular files have only one open lower file */\n+\t\tif (!err && !S_ISDIR(dentry->d_inode->i_mode))\n+\t\t\tfbend(file) = fbstart(file);\n+\t}\n+\n+out:\n+\tif (err) {\n+\t\tkfree(UNIONFS_F(file)->lower_files);\n+\t\tkfree(UNIONFS_F(file)->saved_branch_ids);\n+\t}\n+\treturn err;\n+}\n+\n+/*\n+ * Revalidate the struct file\n+ * @file: file to revalidate\n+ * @parent: parent dentry (locked by caller)\n+ * @willwrite: true if caller may cause changes to the file; false otherwise.\n+ * Caller must lock/unlock dentry\'s branch configuration.\n+ */\n+int unionfs_file_revalidate(struct file *file, struct dentry *parent,\n+\t\t\t    bool willwrite)\n+{\n+\tstruct super_block *sb;\n+\tstruct dentry *dentry;\n+\tint sbgen, dgen;\n+\tint err = 0;\n+\n+\tdentry = file->f_path.dentry;\n+\tsb = dentry->d_sb;\n+\tverify_locked(dentry);\n+\tverify_locked(parent);\n+\n+\t/*\n+\t * First revalidate the dentry inside struct file,\n+\t * but not unhashed dentries.\n+\t */\n+\tif (!d_deleted(dentry) &&\n+\t    !__unionfs_d_revalidate(dentry, parent, willwrite)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tsbgen = atomic_read(&UNIONFS_SB(sb)->generation);\n+\tdgen = atomic_read(&UNIONFS_D(dentry)->generation);\n+\n+\tif (unlikely(sbgen > dgen)) { /* XXX: should never happen */\n+\t\tpr_debug("unionfs: failed to revalidate dentry (%s)\\n",\n+\t\t\t dentry->d_name.name);\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\terr = __unionfs_file_revalidate(file, dentry, parent, sb,\n+\t\t\t\t\tsbgen, dgen, willwrite);\n+out:\n+\treturn err;\n+}\n+\n+/* unionfs_open helper function: open a directory */\n+static int __open_dir(struct inode *inode, struct file *file)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct file *lower_file;\n+\tint bindex, bstart, bend;\n+\tstruct vfsmount *mnt;\n+\n+\tbstart = fbstart(file) = dbstart(file->f_path.dentry);\n+\tbend = fbend(file) = dbend(file->f_path.dentry);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry =\n+\t\t\tunionfs_lower_dentry_idx(file->f_path.dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\n+\t\tdget(lower_dentry);\n+\t\tunionfs_mntget(file->f_path.dentry, bindex);\n+\t\tmnt = unionfs_lower_mnt_idx(file->f_path.dentry, bindex);\n+\t\tlower_file = dentry_open(lower_dentry, mnt, file->f_flags);\n+\t\tif (IS_ERR(lower_file))\n+\t\t\treturn PTR_ERR(lower_file);\n+\n+\t\tunionfs_set_lower_file_idx(file, bindex, lower_file);\n+\n+\t\t/*\n+\t\t * The branchget goes after the open, because otherwise\n+\t\t * we would miss the reference on release.\n+\t\t */\n+\t\tbranchget(inode->i_sb, bindex);\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* unionfs_open helper function: open a file */\n+static int __open_file(struct inode *inode, struct file *file,\n+\t\t       struct dentry *parent)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct file *lower_file;\n+\tint lower_flags;\n+\tint bindex, bstart, bend;\n+\n+\tlower_dentry = unionfs_lower_dentry(file->f_path.dentry);\n+\tlower_flags = file->f_flags;\n+\n+\tbstart = fbstart(file) = dbstart(file->f_path.dentry);\n+\tbend = fbend(file) = dbend(file->f_path.dentry);\n+\n+\t/*\n+\t * check for the permission for lower file.  If the error is\n+\t * COPYUP_ERR, copyup the file.\n+\t */\n+\tif (lower_dentry->d_inode && is_robranch(file->f_path.dentry)) {\n+\t\t/*\n+\t\t * if the open will change the file, copy it up otherwise\n+\t\t * defer it.\n+\t\t */\n+\t\tif (lower_flags & O_TRUNC) {\n+\t\t\tint size = 0;\n+\t\t\tint err = -EROFS;\n+\n+\t\t\t/* copyup the file */\n+\t\t\tfor (bindex = bstart - 1; bindex >= 0; bindex--) {\n+\t\t\t\terr = copyup_file(parent->d_inode, file,\n+\t\t\t\t\t\t  bstart, bindex, size);\n+\t\t\t\tif (!err)\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\treturn err;\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * turn off writeable flags, to force delayed copyup\n+\t\t\t * by caller.\n+\t\t\t */\n+\t\t\tlower_flags &= ~(OPEN_WRITE_FLAGS);\n+\t\t}\n+\t}\n+\n+\tdget(lower_dentry);\n+\n+\t/*\n+\t * dentry_open will decrement mnt refcnt if err.\n+\t * otherwise fput() will do an mntput() for us upon file close.\n+\t */\n+\tunionfs_mntget(file->f_path.dentry, bstart);\n+\tlower_file =\n+\t\tdentry_open(lower_dentry,\n+\t\t\t    unionfs_lower_mnt_idx(file->f_path.dentry, bstart),\n+\t\t\t    lower_flags);\n+\tif (IS_ERR(lower_file))\n+\t\treturn PTR_ERR(lower_file);\n+\n+\tunionfs_set_lower_file(file, lower_file);\n+\tbranchget(inode->i_sb, bstart);\n+\n+\treturn 0;\n+}\n+\n+int unionfs_open(struct inode *inode, struct file *file)\n+{\n+\tint err = 0;\n+\tstruct file *lower_file = NULL;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tint bindex = 0, bstart = 0, bend = 0;\n+\tint size;\n+\tint valid = 0;\n+\n+\tunionfs_read_lock(inode->i_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\t/* don\'t open unhashed/deleted files */\n+\tif (d_deleted(dentry)) {\n+\t\terr = -ENOENT;\n+\t\tgoto out_nofree;\n+\t}\n+\n+\t/* XXX: should I change \'false\' below to the \'willwrite\' flag? */\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out_nofree;\n+\t}\n+\n+\tfile->private_data =\n+\t\tkzalloc(sizeof(struct unionfs_file_info), GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_F(file))) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_nofree;\n+\t}\n+\tfbstart(file) = -1;\n+\tfbend(file) = -1;\n+\tatomic_set(&UNIONFS_F(file)->generation,\n+\t\t   atomic_read(&UNIONFS_I(inode)->generation));\n+\n+\tsize = sizeof(struct file *) * sbmax(inode->i_sb);\n+\tUNIONFS_F(file)->lower_files = kzalloc(size, GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_F(file)->lower_files)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\tsize = sizeof(int) * sbmax(inode->i_sb);\n+\tUNIONFS_F(file)->saved_branch_ids = kzalloc(size, GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_F(file)->saved_branch_ids)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tbstart = fbstart(file) = dbstart(dentry);\n+\tbend = fbend(file) = dbend(dentry);\n+\n+\t/*\n+\t * open all directories and make the unionfs file struct point to\n+\t * these lower file structs\n+\t */\n+\tif (S_ISDIR(inode->i_mode))\n+\t\terr = __open_dir(inode, file);\t/* open a dir */\n+\telse\n+\t\terr = __open_file(inode, file, parent);\t/* open a file */\n+\n+\t/* freeing the allocated resources, and fput the opened files */\n+\tif (err) {\n+\t\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\t\tif (!lower_file)\n+\t\t\t\tcontinue;\n+\n+\t\t\tbranchput(dentry->d_sb, bindex);\n+\t\t\t/* fput calls dput for lower_dentry */\n+\t\t\tfput(lower_file);\n+\t\t}\n+\t}\n+\n+out:\n+\tif (err) {\n+\t\tkfree(UNIONFS_F(file)->lower_files);\n+\t\tkfree(UNIONFS_F(file)->saved_branch_ids);\n+\t\tkfree(UNIONFS_F(file));\n+\t}\n+out_nofree:\n+\tif (!err) {\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_copy_attr_times(inode);\n+\t\tunionfs_check_file(file);\n+\t\tunionfs_check_inode(inode);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(inode->i_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * release all lower object references & free the file info structure\n+ *\n+ * No need to grab sb info\'s rwsem.\n+ */\n+int unionfs_file_release(struct inode *inode, struct file *file)\n+{\n+\tstruct file *lower_file = NULL;\n+\tstruct unionfs_file_info *fileinfo;\n+\tstruct unionfs_inode_info *inodeinfo;\n+\tstruct super_block *sb = inode->i_sb;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tint bindex, bstart, bend;\n+\tint fgen, err = 0;\n+\n+\tunionfs_read_lock(sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\t/*\n+\t * We try to revalidate, but the VFS ignores return return values\n+\t * from file->release, so we must always try to succeed here,\n+\t * including to do the kfree and dput below.  So if revalidation\n+\t * failed, all we can do is print some message and keep going.\n+\t */\n+\terr = unionfs_file_revalidate(file, parent,\n+\t\t\t\t      UNIONFS_F(file)->wrote_to_file);\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tfileinfo = UNIONFS_F(file);\n+\tBUG_ON(file->f_path.dentry->d_inode != inode);\n+\tinodeinfo = UNIONFS_I(inode);\n+\n+\t/* fput all the lower files */\n+\tfgen = atomic_read(&fileinfo->generation);\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\n+\t\tif (lower_file) {\n+\t\t\tunionfs_set_lower_file_idx(file, bindex, NULL);\n+\t\t\tfput(lower_file);\n+\t\t\tbranchput(sb, bindex);\n+\t\t}\n+\n+\t\t/* if there are no more refs to the dentry, dput it */\n+\t\tif (d_deleted(dentry)) {\n+\t\t\tdput(unionfs_lower_dentry_idx(dentry, bindex));\n+\t\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t\t}\n+\t}\n+\n+\tkfree(fileinfo->lower_files);\n+\tkfree(fileinfo->saved_branch_ids);\n+\n+\tif (fileinfo->rdstate) {\n+\t\tfileinfo->rdstate->access = jiffies;\n+\t\tspin_lock(&inodeinfo->rdlock);\n+\t\tinodeinfo->rdcount++;\n+\t\tlist_add_tail(&fileinfo->rdstate->cache,\n+\t\t\t      &inodeinfo->readdircache);\n+\t\tmark_inode_dirty(inode);\n+\t\tspin_unlock(&inodeinfo->rdlock);\n+\t\tfileinfo->rdstate = NULL;\n+\t}\n+\tkfree(fileinfo);\n+\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(sb);\n+\treturn err;\n+}\n+\n+/* pass the ioctl to the lower fs */\n+static long do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tstruct file *lower_file;\n+\tint err;\n+\n+\tlower_file = unionfs_lower_file(file);\n+\n+\terr = -ENOTTY;\n+\tif (!lower_file || !lower_file->f_op)\n+\t\tgoto out;\n+\tif (lower_file->f_op->unlocked_ioctl) {\n+\t\terr = lower_file->f_op->unlocked_ioctl(lower_file, cmd, arg);\n+\t} else if (lower_file->f_op->ioctl) {\n+\t\tlock_kernel();\n+\t\terr = lower_file->f_op->ioctl(\n+\t\t\tlower_file->f_path.dentry->d_inode,\n+\t\t\tlower_file, cmd, arg);\n+\t\tunlock_kernel();\n+\t}\n+\n+out:\n+\treturn err;\n+}\n+\n+/*\n+ * return to user-space the branch indices containing the file in question\n+ *\n+ * We use fd_set and therefore we are limited to the number of the branches\n+ * to FD_SETSIZE, which is currently 1024 - plenty for most people\n+ */\n+static int unionfs_ioctl_queryfile(struct file *file, struct dentry *parent,\n+\t\t\t\t   unsigned int cmd, unsigned long arg)\n+{\n+\tint err = 0;\n+\tfd_set branchlist;\n+\tint bstart = 0, bend = 0, bindex = 0;\n+\tint orig_bstart, orig_bend;\n+\tstruct dentry *dentry, *lower_dentry;\n+\tstruct vfsmount *mnt;\n+\n+\tdentry = file->f_path.dentry;\n+\torig_bstart = dbstart(dentry);\n+\torig_bend = dbend(dentry);\n+\terr = unionfs_partial_lookup(dentry, parent);\n+\tif (err)\n+\t\tgoto out;\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\tFD_ZERO(&branchlist);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\t\tif (likely(lower_dentry->d_inode))\n+\t\t\tFD_SET(bindex, &branchlist);\n+\t\t/* purge any lower objects after partial_lookup */\n+\t\tif (bindex < orig_bstart || bindex > orig_bend) {\n+\t\t\tdput(lower_dentry);\n+\t\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t\t\tiput(unionfs_lower_inode_idx(dentry->d_inode, bindex));\n+\t\t\tunionfs_set_lower_inode_idx(dentry->d_inode, bindex,\n+\t\t\t\t\t\t    NULL);\n+\t\t\tmnt = unionfs_lower_mnt_idx(dentry, bindex);\n+\t\t\tif (!mnt)\n+\t\t\t\tcontinue;\n+\t\t\tunionfs_mntput(dentry, bindex);\n+\t\t\tunionfs_set_lower_mnt_idx(dentry, bindex, NULL);\n+\t\t}\n+\t}\n+\t/* restore original dentry\'s offsets */\n+\tdbstart(dentry) = orig_bstart;\n+\tdbend(dentry) = orig_bend;\n+\tibstart(dentry->d_inode) = orig_bstart;\n+\tibend(dentry->d_inode) = orig_bend;\n+\n+\terr = copy_to_user((void __user *)arg, &branchlist, sizeof(fd_set));\n+\tif (unlikely(err))\n+\t\terr = -EFAULT;\n+\n+out:\n+\treturn err < 0 ? err : bend;\n+}\n+\n+long unionfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n+{\n+\tlong err;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, true);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\t/* check if asked for local commands */\n+\tswitch (cmd) {\n+\tcase UNIONFS_IOCTL_INCGEN:\n+\t\t/* Increment the superblock generation count */\n+\t\tpr_info("unionfs: incgen ioctl deprecated; "\n+\t\t\t"use \\"-o remount,incgen\\"\\n");\n+\t\terr = -ENOSYS;\n+\t\tbreak;\n+\n+\tcase UNIONFS_IOCTL_QUERYFILE:\n+\t\t/* Return list of branches containing the given file */\n+\t\terr = unionfs_ioctl_queryfile(file, parent, cmd, arg);\n+\t\tbreak;\n+\n+\tdefault:\n+\t\t/* pass the ioctl down */\n+\t\terr = do_ioctl(file, cmd, arg);\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+int unionfs_flush(struct file *file, fl_owner_t id)\n+{\n+\tint err = 0;\n+\tstruct file *lower_file = NULL;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tint bindex, bstart, bend;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent,\n+\t\t\t\t      UNIONFS_F(file)->wrote_to_file);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\tunionfs_check_file(file);\n+\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\n+\t\tif (lower_file && lower_file->f_op &&\n+\t\t    lower_file->f_op->flush) {\n+\t\t\terr = lower_file->f_op->flush(lower_file, id);\n+\t\t\tif (err)\n+\t\t\t\tgoto out;\n+\t\t}\n+\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/copyup.c',
  'diff --git a/fs/unionfs/copyup.c b/fs/unionfs/copyup.c\nnew file mode 100644\nindex 0000000..064e5f4\n--- dev/null\n+++ b/fs/unionfs/copyup.c\n@@ -0,0 +1,889 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * For detailed explanation of copyup see:\n+ * Documentation/filesystems/unionfs/concepts.txt\n+ */\n+\n+#ifdef CONFIG_UNION_FS_XATTR\n+/* copyup all extended attrs for a given dentry */\n+static int copyup_xattrs(struct dentry *old_lower_dentry,\n+\t\t\t struct dentry *new_lower_dentry)\n+{\n+\tint err = 0;\n+\tssize_t list_size = -1;\n+\tchar *name_list = NULL;\n+\tchar *attr_value = NULL;\n+\tchar *name_list_buf = NULL;\n+\n+\t/* query the actual size of the xattr list */\n+\tlist_size = vfs_listxattr(old_lower_dentry, NULL, 0);\n+\tif (list_size <= 0) {\n+\t\terr = list_size;\n+\t\tgoto out;\n+\t}\n+\n+\t/* allocate space for the actual list */\n+\tname_list = unionfs_xattr_alloc(list_size + 1, XATTR_LIST_MAX);\n+\tif (unlikely(!name_list || IS_ERR(name_list))) {\n+\t\terr = PTR_ERR(name_list);\n+\t\tgoto out;\n+\t}\n+\n+\tname_list_buf = name_list; /* save for kfree at end */\n+\n+\t/* now get the actual xattr list of the source file */\n+\tlist_size = vfs_listxattr(old_lower_dentry, name_list, list_size);\n+\tif (list_size <= 0) {\n+\t\terr = list_size;\n+\t\tgoto out;\n+\t}\n+\n+\t/* allocate space to hold each xattr\'s value */\n+\tattr_value = unionfs_xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);\n+\tif (unlikely(!attr_value || IS_ERR(attr_value))) {\n+\t\terr = PTR_ERR(name_list);\n+\t\tgoto out;\n+\t}\n+\n+\t/* in a loop, get and set each xattr from src to dst file */\n+\twhile (*name_list) {\n+\t\tssize_t size;\n+\n+\t\t/* Lock here since vfs_getxattr doesn\'t lock for us */\n+\t\tmutex_lock(&old_lower_dentry->d_inode->i_mutex);\n+\t\tsize = vfs_getxattr(old_lower_dentry, name_list,\n+\t\t\t\t    attr_value, XATTR_SIZE_MAX);\n+\t\tmutex_unlock(&old_lower_dentry->d_inode->i_mutex);\n+\t\tif (size < 0) {\n+\t\t\terr = size;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tif (size > XATTR_SIZE_MAX) {\n+\t\t\terr = -E2BIG;\n+\t\t\tgoto out;\n+\t\t}\n+\t\t/* Don\'t lock here since vfs_setxattr does it for us. */\n+\t\terr = vfs_setxattr(new_lower_dentry, name_list, attr_value,\n+\t\t\t\t   size, 0);\n+\t\t/*\n+\t\t * Selinux depends on "security.*" xattrs, so to maintain\n+\t\t * the security of copied-up files, if Selinux is active,\n+\t\t * then we must copy these xattrs as well.  So we need to\n+\t\t * temporarily get FOWNER privileges.\n+\t\t * XXX: move entire copyup code to SIOQ.\n+\t\t */\n+\t\tif (err == -EPERM && !capable(CAP_FOWNER)) {\n+\t\t\tcap_raise(current->cap_effective, CAP_FOWNER);\n+\t\t\terr = vfs_setxattr(new_lower_dentry, name_list,\n+\t\t\t\t\t   attr_value, size, 0);\n+\t\t\tcap_lower(current->cap_effective, CAP_FOWNER);\n+\t\t}\n+\t\tif (err < 0)\n+\t\t\tgoto out;\n+\t\tname_list += strlen(name_list) + 1;\n+\t}\n+out:\n+\tunionfs_xattr_kfree(name_list_buf);\n+\tunionfs_xattr_kfree(attr_value);\n+\t/* Ignore if xattr isn\'t supported */\n+\tif (err == -ENOTSUPP || err == -EOPNOTSUPP)\n+\t\terr = 0;\n+\treturn err;\n+}\n+#endif /* CONFIG_UNION_FS_XATTR */\n+\n+/*\n+ * Determine the mode based on the copyup flags, and the existing dentry.\n+ *\n+ * Handle file systems which may not support certain options.  For example\n+ * jffs2 doesn\'t allow one to chmod a symlink.  So we ignore such harmless\n+ * errors, rather than propagating them up, which results in copyup errors\n+ * and errors returned back to users.\n+ */\n+static int copyup_permissions(struct super_block *sb,\n+\t\t\t      struct dentry *old_lower_dentry,\n+\t\t\t      struct dentry *new_lower_dentry)\n+{\n+\tstruct inode *i = old_lower_dentry->d_inode;\n+\tstruct iattr newattrs;\n+\tint err;\n+\n+\tnewattrs.ia_atime = i->i_atime;\n+\tnewattrs.ia_mtime = i->i_mtime;\n+\tnewattrs.ia_ctime = i->i_ctime;\n+\tnewattrs.ia_gid = i->i_gid;\n+\tnewattrs.ia_uid = i->i_uid;\n+\tnewattrs.ia_valid = ATTR_CTIME | ATTR_ATIME | ATTR_MTIME |\n+\t\tATTR_ATIME_SET | ATTR_MTIME_SET | ATTR_FORCE |\n+\t\tATTR_GID | ATTR_UID;\n+\tmutex_lock(&new_lower_dentry->d_inode->i_mutex);\n+\terr = notify_change(new_lower_dentry, &newattrs);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* now try to change the mode and ignore EOPNOTSUPP on symlinks */\n+\tnewattrs.ia_mode = i->i_mode;\n+\tnewattrs.ia_valid = ATTR_MODE | ATTR_FORCE;\n+\terr = notify_change(new_lower_dentry, &newattrs);\n+\tif (err == -EOPNOTSUPP &&\n+\t    S_ISLNK(new_lower_dentry->d_inode->i_mode)) {\n+\t\tprintk(KERN_WARNING\n+\t\t       "unionfs: changing \\"%s\\" symlink mode unsupported\\n",\n+\t\t       new_lower_dentry->d_name.name);\n+\t\terr = 0;\n+\t}\n+\n+out:\n+\tmutex_unlock(&new_lower_dentry->d_inode->i_mutex);\n+\treturn err;\n+}\n+\n+/*\n+ * create the new device/file/directory - use copyup_permission to copyup\n+ * times, and mode\n+ *\n+ * if the object being copied up is a regular file, the file is only created,\n+ * the contents have to be copied up separately\n+ */\n+static int __copyup_ndentry(struct dentry *old_lower_dentry,\n+\t\t\t    struct dentry *new_lower_dentry,\n+\t\t\t    struct dentry *new_lower_parent_dentry,\n+\t\t\t    char *symbuf)\n+{\n+\tint err = 0;\n+\tumode_t old_mode = old_lower_dentry->d_inode->i_mode;\n+\tstruct sioq_args args;\n+\n+\tif (S_ISDIR(old_mode)) {\n+\t\targs.mkdir.parent = new_lower_parent_dentry->d_inode;\n+\t\targs.mkdir.dentry = new_lower_dentry;\n+\t\targs.mkdir.mode = old_mode;\n+\n+\t\trun_sioq(__unionfs_mkdir, &args);\n+\t\terr = args.err;\n+\t} else if (S_ISLNK(old_mode)) {\n+\t\targs.symlink.parent = new_lower_parent_dentry->d_inode;\n+\t\targs.symlink.dentry = new_lower_dentry;\n+\t\targs.symlink.symbuf = symbuf;\n+\t\targs.symlink.mode = old_mode;\n+\n+\t\trun_sioq(__unionfs_symlink, &args);\n+\t\terr = args.err;\n+\t} else if (S_ISBLK(old_mode) || S_ISCHR(old_mode) ||\n+\t\t   S_ISFIFO(old_mode) || S_ISSOCK(old_mode)) {\n+\t\targs.mknod.parent = new_lower_parent_dentry->d_inode;\n+\t\targs.mknod.dentry = new_lower_dentry;\n+\t\targs.mknod.mode = old_mode;\n+\t\targs.mknod.dev = old_lower_dentry->d_inode->i_rdev;\n+\n+\t\trun_sioq(__unionfs_mknod, &args);\n+\t\terr = args.err;\n+\t} else if (S_ISREG(old_mode)) {\n+\t\tstruct nameidata nd;\n+\t\terr = init_lower_nd(&nd, LOOKUP_CREATE);\n+\t\tif (unlikely(err < 0))\n+\t\t\tgoto out;\n+\t\targs.create.nd = &nd;\n+\t\targs.create.parent = new_lower_parent_dentry->d_inode;\n+\t\targs.create.dentry = new_lower_dentry;\n+\t\targs.create.mode = old_mode;\n+\n+\t\trun_sioq(__unionfs_create, &args);\n+\t\terr = args.err;\n+\t\trelease_lower_nd(&nd, err);\n+\t} else {\n+\t\tprintk(KERN_CRIT "unionfs: unknown inode type %d\\n",\n+\t\t       old_mode);\n+\t\tBUG();\n+\t}\n+\n+out:\n+\treturn err;\n+}\n+\n+static int __copyup_reg_data(struct dentry *dentry,\n+\t\t\t     struct dentry *new_lower_dentry, int new_bindex,\n+\t\t\t     struct dentry *old_lower_dentry, int old_bindex,\n+\t\t\t     struct file **copyup_file, loff_t len)\n+{\n+\tstruct super_block *sb = dentry->d_sb;\n+\tstruct file *input_file;\n+\tstruct file *output_file;\n+\tstruct vfsmount *output_mnt;\n+\tmm_segment_t old_fs;\n+\tchar *buf = NULL;\n+\tssize_t read_bytes, write_bytes;\n+\tloff_t size;\n+\tint err = 0;\n+\n+\t/* open old file */\n+\tunionfs_mntget(dentry, old_bindex);\n+\tbranchget(sb, old_bindex);\n+\t/* dentry_open calls dput and mntput if it returns an error */\n+\tinput_file = dentry_open(old_lower_dentry,\n+\t\t\t\t unionfs_lower_mnt_idx(dentry, old_bindex),\n+\t\t\t\t O_RDONLY | O_LARGEFILE);\n+\tif (IS_ERR(input_file)) {\n+\t\tdput(old_lower_dentry);\n+\t\terr = PTR_ERR(input_file);\n+\t\tgoto out;\n+\t}\n+\tif (unlikely(!input_file->f_op || !input_file->f_op->read)) {\n+\t\terr = -EINVAL;\n+\t\tgoto out_close_in;\n+\t}\n+\n+\t/* open new file */\n+\tdget(new_lower_dentry);\n+\toutput_mnt = unionfs_mntget(sb->s_root, new_bindex);\n+\tbranchget(sb, new_bindex);\n+\toutput_file = dentry_open(new_lower_dentry, output_mnt,\n+\t\t\t\t  O_RDWR | O_LARGEFILE);\n+\tif (IS_ERR(output_file)) {\n+\t\terr = PTR_ERR(output_file);\n+\t\tgoto out_close_in2;\n+\t}\n+\tif (unlikely(!output_file->f_op || !output_file->f_op->write)) {\n+\t\terr = -EINVAL;\n+\t\tgoto out_close_out;\n+\t}\n+\n+\t/* allocating a buffer */\n+\tbuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\n+\tif (unlikely(!buf)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_close_out;\n+\t}\n+\n+\tinput_file->f_pos = 0;\n+\toutput_file->f_pos = 0;\n+\n+\told_fs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\n+\tsize = len;\n+\terr = 0;\n+\tdo {\n+\t\tif (len >= PAGE_SIZE)\n+\t\t\tsize = PAGE_SIZE;\n+\t\telse if ((len < PAGE_SIZE) && (len > 0))\n+\t\t\tsize = len;\n+\n+\t\tlen -= PAGE_SIZE;\n+\n+\t\tread_bytes =\n+\t\t\tinput_file->f_op->read(input_file,\n+\t\t\t\t\t       (char __user *)buf, size,\n+\t\t\t\t\t       &input_file->f_pos);\n+\t\tif (read_bytes <= 0) {\n+\t\t\terr = read_bytes;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\tlockdep_off();\n+\t\twrite_bytes =\n+\t\t\toutput_file->f_op->write(output_file,\n+\t\t\t\t\t\t (char __user *)buf,\n+\t\t\t\t\t\t read_bytes,\n+\t\t\t\t\t\t &output_file->f_pos);\n+\t\tlockdep_on();\n+\t\tif ((write_bytes < 0) || (write_bytes < read_bytes)) {\n+\t\t\terr = write_bytes;\n+\t\t\tbreak;\n+\t\t}\n+\t} while ((read_bytes > 0) && (len > 0));\n+\n+\tset_fs(old_fs);\n+\n+\tkfree(buf);\n+\n+\tif (!err)\n+\t\terr = output_file->f_op->fsync(output_file,\n+\t\t\t\t\t       new_lower_dentry, 0);\n+\n+\tif (err)\n+\t\tgoto out_close_out;\n+\n+\tif (copyup_file) {\n+\t\t*copyup_file = output_file;\n+\t\tgoto out_close_in;\n+\t}\n+\n+out_close_out:\n+\tfput(output_file);\n+\n+out_close_in2:\n+\tbranchput(sb, new_bindex);\n+\n+out_close_in:\n+\tfput(input_file);\n+\n+out:\n+\tbranchput(sb, old_bindex);\n+\n+\treturn err;\n+}\n+\n+/*\n+ * dput the lower references for old and new dentry & clear a lower dentry\n+ * pointer\n+ */\n+static void __clear(struct dentry *dentry, struct dentry *old_lower_dentry,\n+\t\t    int old_bstart, int old_bend,\n+\t\t    struct dentry *new_lower_dentry, int new_bindex)\n+{\n+\t/* get rid of the lower dentry and all its traces */\n+\tunionfs_set_lower_dentry_idx(dentry, new_bindex, NULL);\n+\tdbstart(dentry) = old_bstart;\n+\tdbend(dentry) = old_bend;\n+\n+\tdput(new_lower_dentry);\n+\tdput(old_lower_dentry);\n+}\n+\n+/*\n+ * Copy up a dentry to a file of specified name.\n+ *\n+ * @dir: used to pull the ->i_sb to access other branches\n+ * @dentry: the non-negative dentry whose lower_inode we should copy\n+ * @bstart: the branch of the lower_inode to copy from\n+ * @new_bindex: the branch to create the new file in\n+ * @name: the name of the file to create\n+ * @namelen: length of @name\n+ * @copyup_file: the "struct file" to return (optional)\n+ * @len: how many bytes to copy-up?\n+ */\n+int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,\n+\t\t  int new_bindex, const char *name, int namelen,\n+\t\t  struct file **copyup_file, loff_t len)\n+{\n+\tstruct dentry *new_lower_dentry;\n+\tstruct dentry *old_lower_dentry = NULL;\n+\tstruct super_block *sb;\n+\tint err = 0;\n+\tint old_bindex;\n+\tint old_bstart;\n+\tint old_bend;\n+\tstruct dentry *new_lower_parent_dentry = NULL;\n+\tmm_segment_t oldfs;\n+\tchar *symbuf = NULL;\n+\n+\tverify_locked(dentry);\n+\n+\told_bindex = bstart;\n+\told_bstart = dbstart(dentry);\n+\told_bend = dbend(dentry);\n+\n+\tBUG_ON(new_bindex < 0);\n+\tBUG_ON(new_bindex >= old_bindex);\n+\n+\tsb = dir->i_sb;\n+\n+\terr = is_robranch_super(sb, new_bindex);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* Create the directory structure above this dentry. */\n+\tnew_lower_dentry = create_parents(dir, dentry, name, new_bindex);\n+\tif (IS_ERR(new_lower_dentry)) {\n+\t\terr = PTR_ERR(new_lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\told_lower_dentry = unionfs_lower_dentry_idx(dentry, old_bindex);\n+\t/* we conditionally dput this old_lower_dentry at end of function */\n+\tdget(old_lower_dentry);\n+\n+\t/* For symlinks, we must read the link before we lock the directory. */\n+\tif (S_ISLNK(old_lower_dentry->d_inode->i_mode)) {\n+\n+\t\tsymbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n+\t\tif (unlikely(!symbuf)) {\n+\t\t\t__clear(dentry, old_lower_dentry,\n+\t\t\t\told_bstart, old_bend,\n+\t\t\t\tnew_lower_dentry, new_bindex);\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto out_free;\n+\t\t}\n+\n+\t\toldfs = get_fs();\n+\t\tset_fs(KERNEL_DS);\n+\t\terr = old_lower_dentry->d_inode->i_op->readlink(\n+\t\t\told_lower_dentry,\n+\t\t\t(char __user *)symbuf,\n+\t\t\tPATH_MAX);\n+\t\tset_fs(oldfs);\n+\t\tif (err < 0) {\n+\t\t\t__clear(dentry, old_lower_dentry,\n+\t\t\t\told_bstart, old_bend,\n+\t\t\t\tnew_lower_dentry, new_bindex);\n+\t\t\tgoto out_free;\n+\t\t}\n+\t\tsymbuf[err] = \'\\0\';\n+\t}\n+\n+\t/* Now we lock the parent, and create the object in the new branch. */\n+\tnew_lower_parent_dentry = lock_parent(new_lower_dentry);\n+\n+\t/* create the new inode */\n+\terr = __copyup_ndentry(old_lower_dentry, new_lower_dentry,\n+\t\t\t       new_lower_parent_dentry, symbuf);\n+\n+\tif (err) {\n+\t\t__clear(dentry, old_lower_dentry,\n+\t\t\told_bstart, old_bend,\n+\t\t\tnew_lower_dentry, new_bindex);\n+\t\tgoto out_unlock;\n+\t}\n+\n+\t/* We actually copyup the file here. */\n+\tif (S_ISREG(old_lower_dentry->d_inode->i_mode))\n+\t\terr = __copyup_reg_data(dentry, new_lower_dentry, new_bindex,\n+\t\t\t\t\told_lower_dentry, old_bindex,\n+\t\t\t\t\tcopyup_file, len);\n+\tif (err)\n+\t\tgoto out_unlink;\n+\n+\t/* Set permissions. */\n+\terr = copyup_permissions(sb, old_lower_dentry, new_lower_dentry);\n+\tif (err)\n+\t\tgoto out_unlink;\n+\n+#ifdef CONFIG_UNION_FS_XATTR\n+\t/* Selinux uses extended attributes for permissions. */\n+\terr = copyup_xattrs(old_lower_dentry, new_lower_dentry);\n+\tif (err)\n+\t\tgoto out_unlink;\n+#endif /* CONFIG_UNION_FS_XATTR */\n+\n+\t/* do not allow files getting deleted to be re-interposed */\n+\tif (!d_deleted(dentry))\n+\t\tunionfs_reinterpose(dentry);\n+\n+\tgoto out_unlock;\n+\n+out_unlink:\n+\t/*\n+\t * copyup failed, because we possibly ran out of space or\n+\t * quota, or something else happened so let\'s unlink; we don\'t\n+\t * really care about the return value of vfs_unlink\n+\t */\n+\tvfs_unlink(new_lower_parent_dentry->d_inode, new_lower_dentry);\n+\n+\tif (copyup_file) {\n+\t\t/* need to close the file */\n+\n+\t\tfput(*copyup_file);\n+\t\tbranchput(sb, new_bindex);\n+\t}\n+\n+\t/*\n+\t * TODO: should we reset the error to something like -EIO?\n+\t *\n+\t * If we don\'t reset, the user may get some nonsensical errors, but\n+\t * on the other hand, if we reset to EIO, we guarantee that the user\n+\t * will get a "confusing" error message.\n+\t */\n+\n+out_unlock:\n+\tunlock_dir(new_lower_parent_dentry);\n+\n+out_free:\n+\t/*\n+\t * If old_lower_dentry was not a file, then we need to dput it.  If\n+\t * it was a file, then it was already dput indirectly by other\n+\t * functions we call above which operate on regular files.\n+\t */\n+\tif (old_lower_dentry && old_lower_dentry->d_inode &&\n+\t    !S_ISREG(old_lower_dentry->d_inode->i_mode))\n+\t\tdput(old_lower_dentry);\n+\tkfree(symbuf);\n+\n+\tif (err) {\n+\t\t/*\n+\t\t * if directory creation succeeded, but inode copyup failed,\n+\t\t * then purge new dentries.\n+\t\t */\n+\t\tif (dbstart(dentry) < old_bstart &&\n+\t\t    ibstart(dentry->d_inode) > dbstart(dentry))\n+\t\t\t__clear(dentry, NULL, old_bstart, old_bend,\n+\t\t\t\tunionfs_lower_dentry(dentry), dbstart(dentry));\n+\t\tgoto out;\n+\t}\n+\tif (!S_ISDIR(dentry->d_inode->i_mode)) {\n+\t\tunionfs_postcopyup_release(dentry);\n+\t\tif (!unionfs_lower_inode(dentry->d_inode)) {\n+\t\t\t/*\n+\t\t\t * If we got here, then we copied up to an\n+\t\t\t * unlinked-open file, whose name is .unionfsXXXXX.\n+\t\t\t */\n+\t\t\tstruct inode *inode = new_lower_dentry->d_inode;\n+\t\t\tatomic_inc(&inode->i_count);\n+\t\t\tunionfs_set_lower_inode_idx(dentry->d_inode,\n+\t\t\t\t\t\t    ibstart(dentry->d_inode),\n+\t\t\t\t\t\t    inode);\n+\t\t}\n+\t}\n+\tunionfs_postcopyup_setmnt(dentry);\n+\t/* sync inode times from copied-up inode to our inode */\n+\tunionfs_copy_attr_times(dentry->d_inode);\n+\tunionfs_check_inode(dir);\n+\tunionfs_check_dentry(dentry);\n+out:\n+\treturn err;\n+}\n+\n+/*\n+ * This function creates a copy of a file represented by \'file\' which\n+ * currently resides in branch \'bstart\' to branch \'new_bindex.\'  The copy\n+ * will be named "name".\n+ */\n+int copyup_named_file(struct inode *dir, struct file *file, char *name,\n+\t\t      int bstart, int new_bindex, loff_t len)\n+{\n+\tint err = 0;\n+\tstruct file *output_file = NULL;\n+\n+\terr = copyup_dentry(dir, file->f_path.dentry, bstart, new_bindex,\n+\t\t\t    name, strlen(name), &output_file, len);\n+\tif (!err) {\n+\t\tfbstart(file) = new_bindex;\n+\t\tunionfs_set_lower_file_idx(file, new_bindex, output_file);\n+\t}\n+\n+\treturn err;\n+}\n+\n+/*\n+ * This function creates a copy of a file represented by \'file\' which\n+ * currently resides in branch \'bstart\' to branch \'new_bindex\'.\n+ */\n+int copyup_file(struct inode *dir, struct file *file, int bstart,\n+\t\tint new_bindex, loff_t len)\n+{\n+\tint err = 0;\n+\tstruct file *output_file = NULL;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\n+\terr = copyup_dentry(dir, dentry, bstart, new_bindex,\n+\t\t\t    dentry->d_name.name, dentry->d_name.len,\n+\t\t\t    &output_file, len);\n+\tif (!err) {\n+\t\tfbstart(file) = new_bindex;\n+\t\tunionfs_set_lower_file_idx(file, new_bindex, output_file);\n+\t}\n+\n+\treturn err;\n+}\n+\n+/* purge a dentry\'s lower-branch states (dput/mntput, etc.) */\n+static void __cleanup_dentry(struct dentry *dentry, int bindex,\n+\t\t\t     int old_bstart, int old_bend)\n+{\n+\tint loop_start;\n+\tint loop_end;\n+\tint new_bstart = -1;\n+\tint new_bend = -1;\n+\tint i;\n+\n+\tloop_start = min(old_bstart, bindex);\n+\tloop_end = max(old_bend, bindex);\n+\n+\t/*\n+\t * This loop sets the bstart and bend for the new dentry by\n+\t * traversing from left to right.  It also dputs all negative\n+\t * dentries except bindex\n+\t */\n+\tfor (i = loop_start; i <= loop_end; i++) {\n+\t\tif (!unionfs_lower_dentry_idx(dentry, i))\n+\t\t\tcontinue;\n+\n+\t\tif (i == bindex) {\n+\t\t\tnew_bend = i;\n+\t\t\tif (new_bstart < 0)\n+\t\t\t\tnew_bstart = i;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (!unionfs_lower_dentry_idx(dentry, i)->d_inode) {\n+\t\t\tdput(unionfs_lower_dentry_idx(dentry, i));\n+\t\t\tunionfs_set_lower_dentry_idx(dentry, i, NULL);\n+\n+\t\t\tunionfs_mntput(dentry, i);\n+\t\t\tunionfs_set_lower_mnt_idx(dentry, i, NULL);\n+\t\t} else {\n+\t\t\tif (new_bstart < 0)\n+\t\t\t\tnew_bstart = i;\n+\t\t\tnew_bend = i;\n+\t\t}\n+\t}\n+\n+\tif (new_bstart < 0)\n+\t\tnew_bstart = bindex;\n+\tif (new_bend < 0)\n+\t\tnew_bend = bindex;\n+\tdbstart(dentry) = new_bstart;\n+\tdbend(dentry) = new_bend;\n+\n+}\n+\n+/* set lower inode ptr and update bstart & bend if necessary */\n+static void __set_inode(struct dentry *upper, struct dentry *lower,\n+\t\t\tint bindex)\n+{\n+\tunionfs_set_lower_inode_idx(upper->d_inode, bindex,\n+\t\t\t\t    igrab(lower->d_inode));\n+\tif (likely(ibstart(upper->d_inode) > bindex))\n+\t\tibstart(upper->d_inode) = bindex;\n+\tif (likely(ibend(upper->d_inode) < bindex))\n+\t\tibend(upper->d_inode) = bindex;\n+\n+}\n+\n+/* set lower dentry ptr and update bstart & bend if necessary */\n+static void __set_dentry(struct dentry *upper, struct dentry *lower,\n+\t\t\t int bindex)\n+{\n+\tunionfs_set_lower_dentry_idx(upper, bindex, lower);\n+\tif (likely(dbstart(upper) > bindex))\n+\t\tdbstart(upper) = bindex;\n+\tif (likely(dbend(upper) < bindex))\n+\t\tdbend(upper) = bindex;\n+}\n+\n+/*\n+ * This function replicates the directory structure up-to given dentry\n+ * in the bindex branch.\n+ */\n+struct dentry *create_parents(struct inode *dir, struct dentry *dentry,\n+\t\t\t      const char *name, int bindex)\n+{\n+\tint err;\n+\tstruct dentry *child_dentry;\n+\tstruct dentry *parent_dentry;\n+\tstruct dentry *lower_parent_dentry = NULL;\n+\tstruct dentry *lower_dentry = NULL;\n+\tconst char *childname;\n+\tunsigned int childnamelen;\n+\tint nr_dentry;\n+\tint count = 0;\n+\tint old_bstart;\n+\tint old_bend;\n+\tstruct dentry **path = NULL;\n+\tstruct super_block *sb;\n+\n+\tverify_locked(dentry);\n+\n+\terr = is_robranch_super(dir->i_sb, bindex);\n+\tif (err) {\n+\t\tlower_dentry = ERR_PTR(err);\n+\t\tgoto out;\n+\t}\n+\n+\told_bstart = dbstart(dentry);\n+\told_bend = dbend(dentry);\n+\n+\tlower_dentry = ERR_PTR(-ENOMEM);\n+\n+\t/* There is no sense allocating any less than the minimum. */\n+\tnr_dentry = 1;\n+\tpath = kmalloc(nr_dentry * sizeof(struct dentry *), GFP_KERNEL);\n+\tif (unlikely(!path))\n+\t\tgoto out;\n+\n+\t/* assume the negative dentry of unionfs as the parent dentry */\n+\tparent_dentry = dentry;\n+\n+\t/*\n+\t * This loop finds the first parent that exists in the given branch.\n+\t * We start building the directory structure from there.  At the end\n+\t * of the loop, the following should hold:\n+\t *  - child_dentry is the first nonexistent child\n+\t *  - parent_dentry is the first existent parent\n+\t *  - path[0] is the = deepest child\n+\t *  - path[count] is the first child to create\n+\t */\n+\tdo {\n+\t\tchild_dentry = parent_dentry;\n+\n+\t\t/* find the parent directory dentry in unionfs */\n+\t\tparent_dentry = dget_parent(child_dentry);\n+\n+\t\t/* find out the lower_parent_dentry in the given branch */\n+\t\tlower_parent_dentry =\n+\t\t\tunionfs_lower_dentry_idx(parent_dentry, bindex);\n+\n+\t\t/* grow path table */\n+\t\tif (count == nr_dentry) {\n+\t\t\tvoid *p;\n+\n+\t\t\tnr_dentry *= 2;\n+\t\t\tp = krealloc(path, nr_dentry * sizeof(struct dentry *),\n+\t\t\t\t     GFP_KERNEL);\n+\t\t\tif (unlikely(!p)) {\n+\t\t\t\tlower_dentry = ERR_PTR(-ENOMEM);\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tpath = p;\n+\t\t}\n+\n+\t\t/* store the child dentry */\n+\t\tpath[count++] = child_dentry;\n+\t} while (!lower_parent_dentry);\n+\tcount--;\n+\n+\tsb = dentry->d_sb;\n+\n+\t/*\n+\t * This code goes between the begin/end labels and basically\n+\t * emulates a while(child_dentry != dentry), only cleaner and\n+\t * shorter than what would be a much longer while loop.\n+\t */\n+begin:\n+\t/* get lower parent dir in the current branch */\n+\tlower_parent_dentry = unionfs_lower_dentry_idx(parent_dentry, bindex);\n+\tdput(parent_dentry);\n+\n+\t/* init the values to lookup */\n+\tchildname = child_dentry->d_name.name;\n+\tchildnamelen = child_dentry->d_name.len;\n+\n+\tif (child_dentry != dentry) {\n+\t\t/* lookup child in the underlying file system */\n+\t\tlower_dentry = lookup_one_len(childname, lower_parent_dentry,\n+\t\t\t\t\t      childnamelen);\n+\t\tif (IS_ERR(lower_dentry))\n+\t\t\tgoto out;\n+\t} else {\n+\t\t/*\n+\t\t * Is the name a whiteout of the child name ?  lookup the\n+\t\t * whiteout child in the underlying file system\n+\t\t */\n+\t\tlower_dentry = lookup_one_len(name, lower_parent_dentry,\n+\t\t\t\t\t      strlen(name));\n+\t\tif (IS_ERR(lower_dentry))\n+\t\t\tgoto out;\n+\n+\t\t/* Replace the current dentry (if any) with the new one */\n+\t\tdput(unionfs_lower_dentry_idx(dentry, bindex));\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex,\n+\t\t\t\t\t     lower_dentry);\n+\n+\t\t__cleanup_dentry(dentry, bindex, old_bstart, old_bend);\n+\t\tgoto out;\n+\t}\n+\n+\tif (lower_dentry->d_inode) {\n+\t\t/*\n+\t\t * since this already exists we dput to avoid\n+\t\t * multiple references on the same dentry\n+\t\t */\n+\t\tdput(lower_dentry);\n+\t} else {\n+\t\tstruct sioq_args args;\n+\n+\t\t/* it\'s a negative dentry, create a new dir */\n+\t\tlower_parent_dentry = lock_parent(lower_dentry);\n+\n+\t\targs.mkdir.parent = lower_parent_dentry->d_inode;\n+\t\targs.mkdir.dentry = lower_dentry;\n+\t\targs.mkdir.mode = child_dentry->d_inode->i_mode;\n+\n+\t\trun_sioq(__unionfs_mkdir, &args);\n+\t\terr = args.err;\n+\n+\t\tif (!err)\n+\t\t\terr = copyup_permissions(dir->i_sb, child_dentry,\n+\t\t\t\t\t\t lower_dentry);\n+\t\tunlock_dir(lower_parent_dentry);\n+\t\tif (err) {\n+\t\t\tdput(lower_dentry);\n+\t\t\tlower_dentry = ERR_PTR(err);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t}\n+\n+\t__set_inode(child_dentry, lower_dentry, bindex);\n+\t__set_dentry(child_dentry, lower_dentry, bindex);\n+\t/*\n+\t * update times of this dentry, but also the parent, because if\n+\t * we changed, the parent may have changed too.\n+\t */\n+\tfsstack_copy_attr_times(parent_dentry->d_inode,\n+\t\t\t\tlower_parent_dentry->d_inode);\n+\tunionfs_copy_attr_times(child_dentry->d_inode);\n+\n+\tparent_dentry = child_dentry;\n+\tchild_dentry = path[--count];\n+\tgoto begin;\n+out:\n+\t/* cleanup any leftover locks from the do/while loop above */\n+\tif (IS_ERR(lower_dentry))\n+\t\twhile (count)\n+\t\t\tdput(path[count--]);\n+\tkfree(path);\n+\treturn lower_dentry;\n+}\n+\n+/*\n+ * Post-copyup helper to ensure we have valid mnts: set lower mnt of\n+ * dentry+parents to the first parent node that has an mnt.\n+ */\n+void unionfs_postcopyup_setmnt(struct dentry *dentry)\n+{\n+\tstruct dentry *parent, *hasone;\n+\tint bindex = dbstart(dentry);\n+\n+\tif (unionfs_lower_mnt_idx(dentry, bindex))\n+\t\treturn;\n+\thasone = dentry->d_parent;\n+\t/* this loop should stop at root dentry */\n+\twhile (!unionfs_lower_mnt_idx(hasone, bindex))\n+\t\thasone = hasone->d_parent;\n+\tparent = dentry;\n+\twhile (!unionfs_lower_mnt_idx(parent, bindex)) {\n+\t\tunionfs_set_lower_mnt_idx(parent, bindex,\n+\t\t\t\t\t  unionfs_mntget(hasone, bindex));\n+\t\tparent = parent->d_parent;\n+\t}\n+}\n+\n+/*\n+ * Post-copyup helper to release all non-directory source objects of a\n+ * copied-up file.  Regular files should have only one lower object.\n+ */\n+void unionfs_postcopyup_release(struct dentry *dentry)\n+{\n+\tint bstart, bend;\n+\n+\tBUG_ON(S_ISDIR(dentry->d_inode->i_mode));\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\tpath_put_lowers(dentry, bstart + 1, bend, false);\n+\tiput_lowers(dentry->d_inode, bstart + 1, bend, false);\n+\n+\tdbend(dentry) = bstart;\n+\tibend(dentry->d_inode) = ibstart(dentry->d_inode) = bstart;\n+}'),
 ('dev/null',
  'b/fs/unionfs/debug.c',
  'diff --git a/fs/unionfs/debug.c b/fs/unionfs/debug.c\nnew file mode 100644\nindex 0000000..db1ae1e\n--- dev/null\n+++ b/fs/unionfs/debug.c\n@@ -0,0 +1,537 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * Helper debugging functions for maintainers (and for users to report back\n+ * useful information back to maintainers)\n+ */\n+\n+#ifndef KERN_CONT\n+# define KERN_CONT\t""\n+#endif /* not KERN_CONT */\n+\n+/* it\'s always useful to know what part of the code called us */\n+#define PRINT_CALLER(fname, fxn, line)\t\t\t\t\t\\\n+\tdo {\t\t\t\t\t\t\t\t\\\n+\t\tif (!printed_caller) {\t\t\t\t\t\\\n+\t\t\tpr_debug("PC:%s:%s:%d\\n", (fname), (fxn), (line)); \\\n+\t\t\tprinted_caller = 1;\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t} while (0)\n+\n+/*\n+ * __unionfs_check_{inode,dentry,file} perform exhaustive sanity checking on\n+ * the fan-out of various Unionfs objects.  We check that no lower objects\n+ * exist  outside the start/end branch range; that all objects within are\n+ * non-NULL (with some allowed exceptions); that for every lower file\n+ * there\'s a lower dentry+inode; that the start/end ranges match for all\n+ * corresponding lower objects; that open files/symlinks have only one lower\n+ * objects, but directories can have several; and more.\n+ */\n+void __unionfs_check_inode(const struct inode *inode,\n+\t\t\t   const char *fname, const char *fxn, int line)\n+{\n+\tint bindex;\n+\tint istart, iend;\n+\tstruct inode *lower_inode;\n+\tstruct super_block *sb;\n+\tint printed_caller = 0;\n+\tvoid *poison_ptr;\n+\n+\t/* for inodes now */\n+\tBUG_ON(!inode);\n+\tsb = inode->i_sb;\n+\tistart = ibstart(inode);\n+\tiend = ibend(inode);\n+\t/* don\'t check inode if no lower branches */\n+\tif (istart < 0 && iend < 0)\n+\t\treturn;\n+\tif (unlikely(istart > iend)) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" Ci0: inode=%p istart/end=%d:%d\\n",\n+\t\t\t inode, istart, iend);\n+\t}\n+\tif (unlikely((istart == -1 && iend != -1) ||\n+\t\t     (istart != -1 && iend == -1))) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" Ci1: inode=%p istart/end=%d:%d\\n",\n+\t\t\t inode, istart, iend);\n+\t}\n+\tif (!S_ISDIR(inode->i_mode)) {\n+\t\tif (unlikely(iend != istart)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" Ci2: inode=%p istart=%d iend=%d\\n",\n+\t\t\t\t inode, istart, iend);\n+\t\t}\n+\t}\n+\n+\tfor (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {\n+\t\tif (unlikely(!UNIONFS_I(inode))) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" Ci3: no inode_info %p\\n", inode);\n+\t\t\treturn;\n+\t\t}\n+\t\tif (unlikely(!UNIONFS_I(inode)->lower_inodes)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" Ci4: no lower_inodes %p\\n", inode);\n+\t\t\treturn;\n+\t\t}\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (lower_inode) {\n+\t\t\tmemset(&poison_ptr, POISON_INUSE, sizeof(void *));\n+\t\t\tif (unlikely(bindex < istart || bindex > iend)) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" Ci5: inode/linode=%p:%p bindex=%d "\n+\t\t\t\t\t "istart/end=%d:%d\\n", inode,\n+\t\t\t\t\t lower_inode, bindex, istart, iend);\n+\t\t\t} else if (unlikely(lower_inode == poison_ptr)) {\n+\t\t\t\t/* freed inode! */\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" Ci6: inode/linode=%p:%p bindex=%d "\n+\t\t\t\t\t "istart/end=%d:%d\\n", inode,\n+\t\t\t\t\t lower_inode, bindex, istart, iend);\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/* if we get here, then lower_inode == NULL */\n+\t\tif (bindex < istart || bindex > iend)\n+\t\t\tcontinue;\n+\t\t/*\n+\t\t * directories can have NULL lower inodes in b/t start/end,\n+\t\t * but NOT if at the start/end range.\n+\t\t */\n+\t\tif (unlikely(S_ISDIR(inode->i_mode) &&\n+\t\t\t     bindex > istart && bindex < iend))\n+\t\t\tcontinue;\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" Ci7: inode/linode=%p:%p "\n+\t\t\t "bindex=%d istart/end=%d:%d\\n",\n+\t\t\t inode, lower_inode, bindex, istart, iend);\n+\t}\n+}\n+\n+void __unionfs_check_dentry(const struct dentry *dentry,\n+\t\t\t    const char *fname, const char *fxn, int line)\n+{\n+\tint bindex;\n+\tint dstart, dend, istart, iend;\n+\tstruct dentry *lower_dentry;\n+\tstruct inode *inode, *lower_inode;\n+\tstruct super_block *sb;\n+\tstruct vfsmount *lower_mnt;\n+\tint printed_caller = 0;\n+\tvoid *poison_ptr;\n+\n+\tBUG_ON(!dentry);\n+\tsb = dentry->d_sb;\n+\tinode = dentry->d_inode;\n+\tdstart = dbstart(dentry);\n+\tdend = dbend(dentry);\n+\t/* don\'t check dentry/mnt if no lower branches */\n+\tif (dstart < 0 && dend < 0)\n+\t\tgoto check_inode;\n+\tBUG_ON(dstart > dend);\n+\n+\tif (unlikely((dstart == -1 && dend != -1) ||\n+\t\t     (dstart != -1 && dend == -1))) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CD0: dentry=%p dstart/end=%d:%d\\n",\n+\t\t\t dentry, dstart, dend);\n+\t}\n+\t/*\n+\t * check for NULL dentries inside the start/end range, or\n+\t * non-NULL dentries outside the start/end range.\n+\t */\n+\tfor (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (lower_dentry) {\n+\t\t\tif (unlikely(bindex < dstart || bindex > dend)) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CD1: dentry/lower=%p:%p(%p) "\n+\t\t\t\t\t "bindex=%d dstart/end=%d:%d\\n",\n+\t\t\t\t\t dentry, lower_dentry,\n+\t\t\t\t\t (lower_dentry ? lower_dentry->d_inode :\n+\t\t\t\t\t  (void *) -1L),\n+\t\t\t\t\t bindex, dstart, dend);\n+\t\t\t}\n+\t\t} else {\t/* lower_dentry == NULL */\n+\t\t\tif (bindex < dstart || bindex > dend)\n+\t\t\t\tcontinue;\n+\t\t\t/*\n+\t\t\t * Directories can have NULL lower inodes in b/t\n+\t\t\t * start/end, but NOT if at the start/end range.\n+\t\t\t * Ignore this rule, however, if this is a NULL\n+\t\t\t * dentry or a deleted dentry.\n+\t\t\t */\n+\t\t\tif (unlikely(!d_deleted((struct dentry *) dentry) &&\n+\t\t\t\t     inode &&\n+\t\t\t\t     !(inode && S_ISDIR(inode->i_mode) &&\n+\t\t\t\t       bindex > dstart && bindex < dend))) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CD2: dentry/lower=%p:%p(%p) "\n+\t\t\t\t\t "bindex=%d dstart/end=%d:%d\\n",\n+\t\t\t\t\t dentry, lower_dentry,\n+\t\t\t\t\t (lower_dentry ?\n+\t\t\t\t\t  lower_dentry->d_inode :\n+\t\t\t\t\t  (void *) -1L),\n+\t\t\t\t\t bindex, dstart, dend);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/* check for vfsmounts same as for dentries */\n+\tfor (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {\n+\t\tlower_mnt = unionfs_lower_mnt_idx(dentry, bindex);\n+\t\tif (lower_mnt) {\n+\t\t\tif (unlikely(bindex < dstart || bindex > dend)) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CM0: dentry/lmnt=%p:%p bindex=%d "\n+\t\t\t\t\t "dstart/end=%d:%d\\n", dentry,\n+\t\t\t\t\t lower_mnt, bindex, dstart, dend);\n+\t\t\t}\n+\t\t} else {\t/* lower_mnt == NULL */\n+\t\t\tif (bindex < dstart || bindex > dend)\n+\t\t\t\tcontinue;\n+\t\t\t/*\n+\t\t\t * Directories can have NULL lower inodes in b/t\n+\t\t\t * start/end, but NOT if at the start/end range.\n+\t\t\t * Ignore this rule, however, if this is a NULL\n+\t\t\t * dentry.\n+\t\t\t */\n+\t\t\tif (unlikely(inode &&\n+\t\t\t\t     !(inode && S_ISDIR(inode->i_mode) &&\n+\t\t\t\t       bindex > dstart && bindex < dend))) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CM1: dentry/lmnt=%p:%p "\n+\t\t\t\t\t "bindex=%d dstart/end=%d:%d\\n",\n+\t\t\t\t\t dentry, lower_mnt, bindex,\n+\t\t\t\t\t dstart, dend);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+check_inode:\n+\t/* for inodes now */\n+\tif (!inode)\n+\t\treturn;\n+\tistart = ibstart(inode);\n+\tiend = ibend(inode);\n+\t/* don\'t check inode if no lower branches */\n+\tif (istart < 0 && iend < 0)\n+\t\treturn;\n+\tBUG_ON(istart > iend);\n+\tif (unlikely((istart == -1 && iend != -1) ||\n+\t\t     (istart != -1 && iend == -1))) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CI0: dentry/inode=%p:%p istart/end=%d:%d\\n",\n+\t\t\t dentry, inode, istart, iend);\n+\t}\n+\tif (unlikely(istart != dstart)) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CI1: dentry/inode=%p:%p istart=%d dstart=%d\\n",\n+\t\t\t dentry, inode, istart, dstart);\n+\t}\n+\tif (unlikely(iend != dend)) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CI2: dentry/inode=%p:%p iend=%d dend=%d\\n",\n+\t\t\t dentry, inode, iend, dend);\n+\t}\n+\n+\tif (!S_ISDIR(inode->i_mode)) {\n+\t\tif (unlikely(dend != dstart)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" CI3: dentry/inode=%p:%p dstart=%d dend=%d\\n",\n+\t\t\t\t dentry, inode, dstart, dend);\n+\t\t}\n+\t\tif (unlikely(iend != istart)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" CI4: dentry/inode=%p:%p istart=%d iend=%d\\n",\n+\t\t\t\t dentry, inode, istart, iend);\n+\t\t}\n+\t}\n+\n+\tfor (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (lower_inode) {\n+\t\t\tmemset(&poison_ptr, POISON_INUSE, sizeof(void *));\n+\t\t\tif (unlikely(bindex < istart || bindex > iend)) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CI5: dentry/linode=%p:%p bindex=%d "\n+\t\t\t\t\t "istart/end=%d:%d\\n", dentry,\n+\t\t\t\t\t lower_inode, bindex, istart, iend);\n+\t\t\t} else if (unlikely(lower_inode == poison_ptr)) {\n+\t\t\t\t/* freed inode! */\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CI6: dentry/linode=%p:%p bindex=%d "\n+\t\t\t\t\t "istart/end=%d:%d\\n", dentry,\n+\t\t\t\t\t lower_inode, bindex, istart, iend);\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\t\t/* if we get here, then lower_inode == NULL */\n+\t\tif (bindex < istart || bindex > iend)\n+\t\t\tcontinue;\n+\t\t/*\n+\t\t * directories can have NULL lower inodes in b/t start/end,\n+\t\t * but NOT if at the start/end range.\n+\t\t */\n+\t\tif (unlikely(S_ISDIR(inode->i_mode) &&\n+\t\t\t     bindex > istart && bindex < iend))\n+\t\t\tcontinue;\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CI7: dentry/linode=%p:%p "\n+\t\t\t "bindex=%d istart/end=%d:%d\\n",\n+\t\t\t dentry, lower_inode, bindex, istart, iend);\n+\t}\n+\n+\t/*\n+\t * If it\'s a directory, then intermediate objects b/t start/end can\n+\t * be NULL.  But, check that all three are NULL: lower dentry, mnt,\n+\t * and inode.\n+\t */\n+\tif (dstart >= 0 && dend >= 0 && S_ISDIR(inode->i_mode))\n+\t\tfor (bindex = dstart+1; bindex < dend; bindex++) {\n+\t\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\t\tlower_dentry = unionfs_lower_dentry_idx(dentry,\n+\t\t\t\t\t\t\t\tbindex);\n+\t\t\tlower_mnt = unionfs_lower_mnt_idx(dentry, bindex);\n+\t\t\tif (unlikely(!((lower_inode && lower_dentry &&\n+\t\t\t\t\tlower_mnt) ||\n+\t\t\t\t       (!lower_inode &&\n+\t\t\t\t\t!lower_dentry && !lower_mnt)))) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" Cx: lmnt/ldentry/linode=%p:%p:%p "\n+\t\t\t\t\t "bindex=%d dstart/end=%d:%d\\n",\n+\t\t\t\t\t lower_mnt, lower_dentry, lower_inode,\n+\t\t\t\t\t bindex, dstart, dend);\n+\t\t\t}\n+\t\t}\n+\t/* check if lower inode is newer than upper one (it shouldn\'t) */\n+\tif (unlikely(is_newer_lower(dentry) && !is_negative_lower(dentry))) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tfor (bindex = ibstart(inode); bindex <= ibend(inode);\n+\t\t     bindex++) {\n+\t\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\t\tif (unlikely(!lower_inode))\n+\t\t\t\tcontinue;\n+\t\t\tpr_debug(" CI8: bindex=%d mtime/lmtime=%lu.%lu/%lu.%lu "\n+\t\t\t\t "ctime/lctime=%lu.%lu/%lu.%lu\\n",\n+\t\t\t\t bindex,\n+\t\t\t\t inode->i_mtime.tv_sec,\n+\t\t\t\t inode->i_mtime.tv_nsec,\n+\t\t\t\t lower_inode->i_mtime.tv_sec,\n+\t\t\t\t lower_inode->i_mtime.tv_nsec,\n+\t\t\t\t inode->i_ctime.tv_sec,\n+\t\t\t\t inode->i_ctime.tv_nsec,\n+\t\t\t\t lower_inode->i_ctime.tv_sec,\n+\t\t\t\t lower_inode->i_ctime.tv_nsec);\n+\t\t}\n+\t}\n+}\n+\n+void __unionfs_check_file(const struct file *file,\n+\t\t\t  const char *fname, const char *fxn, int line)\n+{\n+\tint bindex;\n+\tint dstart, dend, fstart, fend;\n+\tstruct dentry *dentry;\n+\tstruct file *lower_file;\n+\tstruct inode *inode;\n+\tstruct super_block *sb;\n+\tint printed_caller = 0;\n+\n+\tBUG_ON(!file);\n+\tdentry = file->f_path.dentry;\n+\tsb = dentry->d_sb;\n+\tdstart = dbstart(dentry);\n+\tdend = dbend(dentry);\n+\tBUG_ON(dstart > dend);\n+\tfstart = fbstart(file);\n+\tfend = fbend(file);\n+\tBUG_ON(fstart > fend);\n+\n+\tif (unlikely((fstart == -1 && fend != -1) ||\n+\t\t     (fstart != -1 && fend == -1))) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CF0: file/dentry=%p:%p fstart/end=%d:%d\\n",\n+\t\t\t file, dentry, fstart, fend);\n+\t}\n+\tif (unlikely(fstart != dstart)) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CF1: file/dentry=%p:%p fstart=%d dstart=%d\\n",\n+\t\t\t file, dentry, fstart, dstart);\n+\t}\n+\tif (unlikely(fend != dend)) {\n+\t\tPRINT_CALLER(fname, fxn, line);\n+\t\tpr_debug(" CF2: file/dentry=%p:%p fend=%d dend=%d\\n",\n+\t\t\t file, dentry, fend, dend);\n+\t}\n+\tinode = dentry->d_inode;\n+\tif (!S_ISDIR(inode->i_mode)) {\n+\t\tif (unlikely(fend != fstart)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" CF3: file/inode=%p:%p fstart=%d fend=%d\\n",\n+\t\t\t\t file, inode, fstart, fend);\n+\t\t}\n+\t\tif (unlikely(dend != dstart)) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" CF4: file/dentry=%p:%p dstart=%d dend=%d\\n",\n+\t\t\t\t file, dentry, dstart, dend);\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * check for NULL dentries inside the start/end range, or\n+\t * non-NULL dentries outside the start/end range.\n+\t */\n+\tfor (bindex = sbstart(sb); bindex < sbmax(sb); bindex++) {\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\tif (lower_file) {\n+\t\t\tif (unlikely(bindex < fstart || bindex > fend)) {\n+\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\tpr_debug(" CF5: file/lower=%p:%p bindex=%d "\n+\t\t\t\t\t "fstart/end=%d:%d\\n", file,\n+\t\t\t\t\t lower_file, bindex, fstart, fend);\n+\t\t\t}\n+\t\t} else {\t/* lower_file == NULL */\n+\t\t\tif (bindex >= fstart && bindex <= fend) {\n+\t\t\t\t/*\n+\t\t\t\t * directories can have NULL lower inodes in\n+\t\t\t\t * b/t start/end, but NOT if at the\n+\t\t\t\t * start/end range.\n+\t\t\t\t */\n+\t\t\t\tif (unlikely(!(S_ISDIR(inode->i_mode) &&\n+\t\t\t\t\t       bindex > fstart &&\n+\t\t\t\t\t       bindex < fend))) {\n+\t\t\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\t\t\tpr_debug(" CF6: file/lower=%p:%p "\n+\t\t\t\t\t\t "bindex=%d fstart/end=%d:%d\\n",\n+\t\t\t\t\t\t file, lower_file, bindex,\n+\t\t\t\t\t\t fstart, fend);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t__unionfs_check_dentry(dentry, fname, fxn, line);\n+}\n+\n+void __unionfs_check_nd(const struct nameidata *nd,\n+\t\t\tconst char *fname, const char *fxn, int line)\n+{\n+\tstruct file *file;\n+\tint printed_caller = 0;\n+\n+\tif (unlikely(!nd))\n+\t\treturn;\n+\tif (nd->flags & LOOKUP_OPEN) {\n+\t\tfile = nd->intent.open.file;\n+\t\tif (unlikely(file->f_path.dentry &&\n+\t\t\t     strcmp(file->f_path.dentry->d_sb->s_type->name,\n+\t\t\t\t    UNIONFS_NAME))) {\n+\t\t\tPRINT_CALLER(fname, fxn, line);\n+\t\t\tpr_debug(" CND1: lower_file of type %s\\n",\n+\t\t\t\t file->f_path.dentry->d_sb->s_type->name);\n+\t\t\tBUG();\n+\t\t}\n+\t}\n+}\n+\n+/* useful to track vfsmount leaks that could cause EBUSY on unmount */\n+void __show_branch_counts(const struct super_block *sb,\n+\t\t\t  const char *file, const char *fxn, int line)\n+{\n+\tint i;\n+\tstruct vfsmount *mnt;\n+\n+\tpr_debug("BC:");\n+\tfor (i = 0; i < sbmax(sb); i++) {\n+\t\tif (likely(sb->s_root))\n+\t\t\tmnt = UNIONFS_D(sb->s_root)->lower_paths[i].mnt;\n+\t\telse\n+\t\t\tmnt = NULL;\n+\t\tprintk(KERN_CONT "%d:",\n+\t\t       (mnt ? atomic_read(&mnt->mnt_count) : -99));\n+\t}\n+\tprintk(KERN_CONT "%s:%s:%d\\n", file, fxn, line);\n+}\n+\n+void __show_inode_times(const struct inode *inode,\n+\t\t\tconst char *file, const char *fxn, int line)\n+{\n+\tstruct inode *lower_inode;\n+\tint bindex;\n+\n+\tfor (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (unlikely(!lower_inode))\n+\t\t\tcontinue;\n+\t\tpr_debug("IT(%lu:%d): %s:%s:%d "\n+\t\t\t "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\\n",\n+\t\t\t inode->i_ino, bindex,\n+\t\t\t file, fxn, line,\n+\t\t\t inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n+\t\t\t lower_inode->i_mtime.tv_sec,\n+\t\t\t lower_inode->i_mtime.tv_nsec,\n+\t\t\t inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n+\t\t\t lower_inode->i_ctime.tv_sec,\n+\t\t\t lower_inode->i_ctime.tv_nsec);\n+\t}\n+}\n+\n+void __show_dinode_times(const struct dentry *dentry,\n+\t\t\tconst char *file, const char *fxn, int line)\n+{\n+\tstruct inode *inode = dentry->d_inode;\n+\tstruct inode *lower_inode;\n+\tint bindex;\n+\n+\tfor (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode)\n+\t\t\tcontinue;\n+\t\tpr_debug("DT(%s:%lu:%d): %s:%s:%d "\n+\t\t\t "um=%lu/%lu lm=%lu/%lu uc=%lu/%lu lc=%lu/%lu\\n",\n+\t\t\t dentry->d_name.name, inode->i_ino, bindex,\n+\t\t\t file, fxn, line,\n+\t\t\t inode->i_mtime.tv_sec, inode->i_mtime.tv_nsec,\n+\t\t\t lower_inode->i_mtime.tv_sec,\n+\t\t\t lower_inode->i_mtime.tv_nsec,\n+\t\t\t inode->i_ctime.tv_sec, inode->i_ctime.tv_nsec,\n+\t\t\t lower_inode->i_ctime.tv_sec,\n+\t\t\t lower_inode->i_ctime.tv_nsec);\n+\t}\n+}\n+\n+void __show_inode_counts(const struct inode *inode,\n+\t\t\tconst char *file, const char *fxn, int line)\n+{\n+\tstruct inode *lower_inode;\n+\tint bindex;\n+\n+\tif (unlikely(!inode)) {\n+\t\tpr_debug("SiC: Null inode\\n");\n+\t\treturn;\n+\t}\n+\tfor (bindex = sbstart(inode->i_sb); bindex <= sbend(inode->i_sb);\n+\t     bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (unlikely(!lower_inode))\n+\t\t\tcontinue;\n+\t\tpr_debug("SIC(%lu:%d:%d): lc=%d %s:%s:%d\\n",\n+\t\t\t inode->i_ino, bindex,\n+\t\t\t atomic_read(&(inode)->i_count),\n+\t\t\t atomic_read(&(lower_inode)->i_count),\n+\t\t\t file, fxn, line);\n+\t}\n+}'),
 ('dev/null',
  'b/fs/unionfs/dentry.c',
  'diff --git a/fs/unionfs/dentry.c b/fs/unionfs/dentry.c\nnew file mode 100644\nindex 0000000..85b5d3c\n--- dev/null\n+++ b/fs/unionfs/dentry.c\n@@ -0,0 +1,397 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+bool is_negative_lower(const struct dentry *dentry)\n+{\n+\tint bindex;\n+\tstruct dentry *lower_dentry;\n+\n+\tBUG_ON(!dentry);\n+\t/* cache coherency: check if file was deleted on lower branch */\n+\tif (dbstart(dentry) < 0)\n+\t\treturn true;\n+\tfor (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\t/* unhashed (i.e., unlinked) lower dentries don\'t count */\n+\t\tif (lower_dentry && lower_dentry->d_inode &&\n+\t\t    !d_deleted(lower_dentry) &&\n+\t\t    !(lower_dentry->d_flags & DCACHE_NFSFS_RENAMED))\n+\t\t\treturn false;\n+\t}\n+\treturn true;\n+}\n+\n+static inline void __dput_lowers(struct dentry *dentry, int start, int end)\n+{\n+\tstruct dentry *lower_dentry;\n+\tint bindex;\n+\n+\tif (start < 0)\n+\t\treturn;\n+\tfor (bindex = start; bindex <= end; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t\tdput(lower_dentry);\n+\t}\n+}\n+\n+/*\n+ * Purge and invalidate as many data pages of a unionfs inode.  This is\n+ * called when the lower inode has changed, and we want to force processes\n+ * to re-get the new data.\n+ */\n+static inline void purge_inode_data(struct inode *inode)\n+{\n+\t/* remove all non-private mappings */\n+\tunmap_mapping_range(inode->i_mapping, 0, 0, 0);\n+\t/* invalidate as many pages as possible */\n+\tinvalidate_mapping_pages(inode->i_mapping, 0, -1);\n+\t/*\n+\t * Don\'t try to truncate_inode_pages here, because this could lead\n+\t * to a deadlock between some of address_space ops and dentry\n+\t * revalidation: the address space op is invoked with a lock on our\n+\t * own page, and truncate_inode_pages will block on locked pages.\n+\t */\n+}\n+\n+/*\n+ * Revalidate a single file/symlink/special dentry.  Assume that info nodes\n+ * of the @dentry and its @parent are locked.  Assume parent is valid,\n+ * otherwise return false (and let\'s hope the VFS will try to re-lookup this\n+ * dentry).  Returns true if valid, false otherwise.\n+ */\n+bool __unionfs_d_revalidate(struct dentry *dentry, struct dentry *parent,\n+\t\t\t    bool willwrite)\n+{\n+\tbool valid = true;\t/* default is valid */\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *result;\n+\tint bindex, bstart, bend;\n+\tint sbgen, dgen, pdgen;\n+\tint positive = 0;\n+\tint interpose_flag;\n+\n+\tverify_locked(dentry);\n+\tverify_locked(parent);\n+\n+\t/* if the dentry is unhashed, do NOT revalidate */\n+\tif (d_deleted(dentry))\n+\t\tgoto out;\n+\n+\tdgen = atomic_read(&UNIONFS_D(dentry)->generation);\n+\n+\tif (is_newer_lower(dentry)) {\n+\t\t/* root dentry is always valid */\n+\t\tif (IS_ROOT(dentry)) {\n+\t\t\tunionfs_copy_attr_times(dentry->d_inode);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * reset generation number to zero, guaranteed to be\n+\t\t\t * "old"\n+\t\t\t */\n+\t\t\tdgen = 0;\n+\t\t\tatomic_set(&UNIONFS_D(dentry)->generation, dgen);\n+\t\t}\n+\t\tif (!willwrite)\n+\t\t\tpurge_inode_data(dentry->d_inode);\n+\t}\n+\n+\tsbgen = atomic_read(&UNIONFS_SB(dentry->d_sb)->generation);\n+\n+\tBUG_ON(dbstart(dentry) == -1);\n+\tif (dentry->d_inode)\n+\t\tpositive = 1;\n+\n+\t/* if our dentry is valid, then validate all lower ones */\n+\tif (sbgen == dgen)\n+\t\tgoto validate_lowers;\n+\n+\t/* The root entry should always be valid */\n+\tBUG_ON(IS_ROOT(dentry));\n+\n+\t/* We can\'t work correctly if our parent isn\'t valid. */\n+\tpdgen = atomic_read(&UNIONFS_D(parent)->generation);\n+\n+\t/* Free the pointers for our inodes and this dentry. */\n+\tpath_put_lowers_all(dentry, false);\n+\n+\tinterpose_flag = INTERPOSE_REVAL_NEG;\n+\tif (positive) {\n+\t\tinterpose_flag = INTERPOSE_REVAL;\n+\t\tiput_lowers_all(dentry->d_inode, true);\n+\t}\n+\n+\tif (realloc_dentry_private_data(dentry) != 0) {\n+\t\tvalid = false;\n+\t\tgoto out;\n+\t}\n+\n+\tresult = unionfs_lookup_full(dentry, parent, interpose_flag);\n+\tif (result) {\n+\t\tif (IS_ERR(result)) {\n+\t\t\tvalid = false;\n+\t\t\tgoto out;\n+\t\t}\n+\t\t/*\n+\t\t * current unionfs_lookup_backend() doesn\'t return\n+\t\t * a valid dentry\n+\t\t */\n+\t\tdput(dentry);\n+\t\tdentry = result;\n+\t}\n+\n+\tif (unlikely(positive && is_negative_lower(dentry))) {\n+\t\t/* call make_bad_inode here ? */\n+\t\td_drop(dentry);\n+\t\tvalid = false;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * if we got here then we have revalidated our dentry and all lower\n+\t * ones, so we can return safely.\n+\t */\n+\tif (!valid)\t\t/* lower dentry revalidation failed */\n+\t\tgoto out;\n+\n+\t/*\n+\t * If the parent\'s gen no.  matches the superblock\'s gen no., then\n+\t * we can update our denty\'s gen no.  If they didn\'t match, then it\n+\t * was OK to revalidate this dentry with a stale parent, but we\'ll\n+\t * purposely not update our dentry\'s gen no. (so it can be redone);\n+\t * and, we\'ll mark our parent dentry as invalid so it\'ll force it\n+\t * (and our dentry) to be revalidated.\n+\t */\n+\tif (pdgen == sbgen)\n+\t\tatomic_set(&UNIONFS_D(dentry)->generation, sbgen);\n+\tgoto out;\n+\n+validate_lowers:\n+\n+\t/* The revalidation must occur across all branches */\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\tBUG_ON(bstart == -1);\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry || !lower_dentry->d_op\n+\t\t    || !lower_dentry->d_op->d_revalidate)\n+\t\t\tcontinue;\n+\t\t/*\n+\t\t * Don\'t pass nameidata to lower file system, because we\n+\t\t * don\'t want an arbitrary lower file being opened or\n+\t\t * returned to us: it may be useless to us because of the\n+\t\t * fanout nature of unionfs (cf. file/directory open-file\n+\t\t * invariants).  We will open lower files as and when needed\n+\t\t * later on.\n+\t\t */\n+\t\tif (!lower_dentry->d_op->d_revalidate(lower_dentry, NULL))\n+\t\t\tvalid = false;\n+\t}\n+\n+\tif (!dentry->d_inode ||\n+\t    ibstart(dentry->d_inode) < 0 ||\n+\t    ibend(dentry->d_inode) < 0) {\n+\t\tvalid = false;\n+\t\tgoto out;\n+\t}\n+\n+\tif (valid) {\n+\t\t/*\n+\t\t * If we get here, and we copy the meta-data from the lower\n+\t\t * inode to our inode, then it is vital that we have already\n+\t\t * purged all unionfs-level file data.  We do that in the\n+\t\t * caller (__unionfs_d_revalidate) by calling\n+\t\t * purge_inode_data.\n+\t\t */\n+\t\tunionfs_copy_attr_all(dentry->d_inode,\n+\t\t\t\t      unionfs_lower_inode(dentry->d_inode));\n+\t\tfsstack_copy_inode_size(dentry->d_inode,\n+\t\t\t\t\tunionfs_lower_inode(dentry->d_inode));\n+\t}\n+\n+out:\n+\treturn valid;\n+}\n+\n+/*\n+ * Determine if the lower inode objects have changed from below the unionfs\n+ * inode.  Return true if changed, false otherwise.\n+ *\n+ * We check if the mtime or ctime have changed.  However, the inode times\n+ * can be changed by anyone without much protection, including\n+ * asynchronously.  This can sometimes cause unionfs to find that the lower\n+ * file system doesn\'t change its inode times quick enough, resulting in a\n+ * false positive indication (which is harmless, it just makes unionfs do\n+ * extra work in re-validating the objects).  To minimize the chances of\n+ * these situations, we still consider such small time changes valid, but we\n+ * don\'t print debugging messages unless the time changes are greater than\n+ * UNIONFS_MIN_CC_TIME (which defaults to 3 seconds, as with NFS\'s acregmin)\n+ * because significant changes are more likely due to users manually\n+ * touching lower files.\n+ */\n+bool is_newer_lower(const struct dentry *dentry)\n+{\n+\tint bindex;\n+\tstruct inode *inode;\n+\tstruct inode *lower_inode;\n+\n+\t/* ignore if we\'re called on semi-initialized dentries/inodes */\n+\tif (!dentry || !UNIONFS_D(dentry))\n+\t\treturn false;\n+\tinode = dentry->d_inode;\n+\tif (!inode || !UNIONFS_I(inode)->lower_inodes ||\n+\t    ibstart(inode) < 0 || ibend(inode) < 0)\n+\t\treturn false;\n+\n+\tfor (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode)\n+\t\t\tcontinue;\n+\n+\t\t/* check if mtime/ctime have changed */\n+\t\tif (unlikely(timespec_compare(&inode->i_mtime,\n+\t\t\t\t\t      &lower_inode->i_mtime) < 0)) {\n+\t\t\tif ((lower_inode->i_mtime.tv_sec -\n+\t\t\t     inode->i_mtime.tv_sec) > UNIONFS_MIN_CC_TIME) {\n+\t\t\t\tpr_info("unionfs: new lower inode mtime "\n+\t\t\t\t\t"(bindex=%d, name=%s)\\n", bindex,\n+\t\t\t\t\tdentry->d_name.name);\n+\t\t\t\tshow_dinode_times(dentry);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (unlikely(timespec_compare(&inode->i_ctime,\n+\t\t\t\t\t      &lower_inode->i_ctime) < 0)) {\n+\t\t\tif ((lower_inode->i_ctime.tv_sec -\n+\t\t\t     inode->i_ctime.tv_sec) > UNIONFS_MIN_CC_TIME) {\n+\t\t\t\tpr_info("unionfs: new lower inode ctime "\n+\t\t\t\t\t"(bindex=%d, name=%s)\\n", bindex,\n+\t\t\t\t\tdentry->d_name.name);\n+\t\t\t\tshow_dinode_times(dentry);\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Last check: if this is a positive dentry, but somehow all lower\n+\t * dentries are negative or unhashed, then this dentry needs to be\n+\t * revalidated, because someone probably deleted the objects from\n+\t * the lower branches directly.\n+\t */\n+\tif (is_negative_lower(dentry))\n+\t\treturn true;\n+\n+\treturn false;\t\t/* default: lower is not newer */\n+}\n+\n+static int unionfs_d_revalidate(struct dentry *dentry,\n+\t\t\t\tstruct nameidata *nd_unused)\n+{\n+\tbool valid = true;\n+\tint err = 1;\t\t/* 1 means valid for the VFS */\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (valid) {\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_check_dentry(dentry);\n+\t} else {\n+\t\td_drop(dentry);\n+\t\terr = valid;\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn err;\n+}\n+\n+static void unionfs_d_release(struct dentry *dentry)\n+{\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tif (unlikely(!UNIONFS_D(dentry)))\n+\t\tgoto out;\t/* skip if no lower branches */\n+\t/* must lock our branch configuration here */\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tunionfs_check_dentry(dentry);\n+\t/* this could be a negative dentry, so check first */\n+\tif (dbstart(dentry) < 0) {\n+\t\tunionfs_unlock_dentry(dentry);\n+\t\tgoto out;\t/* due to a (normal) failed lookup */\n+\t}\n+\n+\t/* Release all the lower dentries */\n+\tpath_put_lowers_all(dentry, true);\n+\n+\tunionfs_unlock_dentry(dentry);\n+\n+out:\n+\tfree_dentry_private_data(dentry);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn;\n+}\n+\n+/*\n+ * Called when we\'re removing the last reference to our dentry.  So we\n+ * should drop all lower references too.\n+ */\n+static void unionfs_d_iput(struct dentry *dentry, struct inode *inode)\n+{\n+\tint rc;\n+\n+\tBUG_ON(!dentry);\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tif (!UNIONFS_D(dentry) || dbstart(dentry) < 0)\n+\t\tgoto drop_lower_inodes;\n+\tpath_put_lowers_all(dentry, false);\n+\n+drop_lower_inodes:\n+\trc = atomic_read(&inode->i_count);\n+\tif (rc == 1 && inode->i_nlink == 1 && ibstart(inode) >= 0) {\n+\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\tlockdep_off();\n+\t\tiput(unionfs_lower_inode(inode));\n+\t\tlockdep_on();\n+\t\tunionfs_set_lower_inode(inode, NULL);\n+\t\t/* XXX: may need to set start/end to -1? */\n+\t}\n+\n+\tiput(inode);\n+\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_read_unlock(dentry->d_sb);\n+}\n+\n+struct dentry_operations unionfs_dops = {\n+\t.d_revalidate\t= unionfs_d_revalidate,\n+\t.d_release\t= unionfs_d_release,\n+\t.d_iput\t\t= unionfs_d_iput,\n+};'),
 ('dev/null',
  'b/fs/unionfs/dirfops.c',
  'diff --git a/fs/unionfs/dirfops.c b/fs/unionfs/dirfops.c\nnew file mode 100644\nindex 0000000..eccb9ae\n--- dev/null\n+++ b/fs/unionfs/dirfops.c\n@@ -0,0 +1,302 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/* Make sure our rdstate is playing by the rules. */\n+static void verify_rdstate_offset(struct unionfs_dir_state *rdstate)\n+{\n+\tBUG_ON(rdstate->offset >= DIREOF);\n+\tBUG_ON(rdstate->cookie >= MAXRDCOOKIE);\n+}\n+\n+struct unionfs_getdents_callback {\n+\tstruct unionfs_dir_state *rdstate;\n+\tvoid *dirent;\n+\tint entries_written;\n+\tint filldir_called;\n+\tint filldir_error;\n+\tfilldir_t filldir;\n+\tstruct super_block *sb;\n+};\n+\n+/* based on generic filldir in fs/readir.c */\n+static int unionfs_filldir(void *dirent, const char *oname, int namelen,\n+\t\t\t   loff_t offset, u64 ino, unsigned int d_type)\n+{\n+\tstruct unionfs_getdents_callback *buf = dirent;\n+\tstruct filldir_node *found = NULL;\n+\tint err = 0;\n+\tint is_whiteout;\n+\tchar *name = (char *) oname;\n+\n+\tbuf->filldir_called++;\n+\n+\tis_whiteout = is_whiteout_name(&name, &namelen);\n+\n+\tfound = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);\n+\n+\tif (found) {\n+\t\t/*\n+\t\t * If we had non-whiteout entry in dir cache, then mark it\n+\t\t * as a whiteout and but leave it in the dir cache.\n+\t\t */\n+\t\tif (is_whiteout && !found->whiteout)\n+\t\t\tfound->whiteout = is_whiteout;\n+\t\tgoto out;\n+\t}\n+\n+\t/* if \'name\' isn\'t a whiteout, filldir it. */\n+\tif (!is_whiteout) {\n+\t\toff_t pos = rdstate2offset(buf->rdstate);\n+\t\tu64 unionfs_ino = ino;\n+\n+\t\terr = buf->filldir(buf->dirent, name, namelen, pos,\n+\t\t\t\t   unionfs_ino, d_type);\n+\t\tbuf->rdstate->offset++;\n+\t\tverify_rdstate_offset(buf->rdstate);\n+\t}\n+\t/*\n+\t * If we did fill it, stuff it in our hash, otherwise return an\n+\t * error.\n+\t */\n+\tif (err) {\n+\t\tbuf->filldir_error = err;\n+\t\tgoto out;\n+\t}\n+\tbuf->entries_written++;\n+\terr = add_filldir_node(buf->rdstate, name, namelen,\n+\t\t\t       buf->rdstate->bindex, is_whiteout);\n+\tif (err)\n+\t\tbuf->filldir_error = err;\n+\n+out:\n+\treturn err;\n+}\n+\n+static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)\n+{\n+\tint err = 0;\n+\tstruct file *lower_file = NULL;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tstruct inode *inode = NULL;\n+\tstruct unionfs_getdents_callback buf;\n+\tstruct unionfs_dir_state *uds;\n+\tint bend;\n+\tloff_t offset;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, false);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\tinode = dentry->d_inode;\n+\n+\tuds = UNIONFS_F(file)->rdstate;\n+\tif (!uds) {\n+\t\tif (file->f_pos == DIREOF) {\n+\t\t\tgoto out;\n+\t\t} else if (file->f_pos > 0) {\n+\t\t\tuds = find_rdstate(inode, file->f_pos);\n+\t\t\tif (unlikely(!uds)) {\n+\t\t\t\terr = -ESTALE;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t\tUNIONFS_F(file)->rdstate = uds;\n+\t\t} else {\n+\t\t\tinit_rdstate(file);\n+\t\t\tuds = UNIONFS_F(file)->rdstate;\n+\t\t}\n+\t}\n+\tbend = fbend(file);\n+\n+\twhile (uds->bindex <= bend) {\n+\t\tlower_file = unionfs_lower_file_idx(file, uds->bindex);\n+\t\tif (!lower_file) {\n+\t\t\tuds->bindex++;\n+\t\t\tuds->dirpos = 0;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* prepare callback buffer */\n+\t\tbuf.filldir_called = 0;\n+\t\tbuf.filldir_error = 0;\n+\t\tbuf.entries_written = 0;\n+\t\tbuf.dirent = dirent;\n+\t\tbuf.filldir = filldir;\n+\t\tbuf.rdstate = uds;\n+\t\tbuf.sb = inode->i_sb;\n+\n+\t\t/* Read starting from where we last left off. */\n+\t\toffset = vfs_llseek(lower_file, uds->dirpos, SEEK_SET);\n+\t\tif (offset < 0) {\n+\t\t\terr = offset;\n+\t\t\tgoto out;\n+\t\t}\n+\t\terr = vfs_readdir(lower_file, unionfs_filldir, &buf);\n+\n+\t\t/* Save the position for when we continue. */\n+\t\toffset = vfs_llseek(lower_file, 0, SEEK_CUR);\n+\t\tif (offset < 0) {\n+\t\t\terr = offset;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tuds->dirpos = offset;\n+\n+\t\t/* Copy the atime. */\n+\t\tfsstack_copy_attr_atime(inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\n+\t\tif (err < 0)\n+\t\t\tgoto out;\n+\n+\t\tif (buf.filldir_error)\n+\t\t\tbreak;\n+\n+\t\tif (!buf.entries_written) {\n+\t\t\tuds->bindex++;\n+\t\t\tuds->dirpos = 0;\n+\t\t}\n+\t}\n+\n+\tif (!buf.filldir_error && uds->bindex >= bend) {\n+\t\t/* Save the number of hash entries for next time. */\n+\t\tUNIONFS_I(inode)->hashsize = uds->hashentries;\n+\t\tfree_rdstate(uds);\n+\t\tUNIONFS_F(file)->rdstate = NULL;\n+\t\tfile->f_pos = DIREOF;\n+\t} else {\n+\t\tfile->f_pos = rdstate2offset(uds);\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * This is not meant to be a generic repositioning function.  If you do\n+ * things that aren\'t supported, then we return EINVAL.\n+ *\n+ * What is allowed:\n+ *  (1) seeking to the same position that you are currently at\n+ *\tThis really has no effect, but returns where you are.\n+ *  (2) seeking to the beginning of the file\n+ *\tThis throws out all state, and lets you begin again.\n+ */\n+static loff_t unionfs_dir_llseek(struct file *file, loff_t offset, int origin)\n+{\n+\tstruct unionfs_dir_state *rdstate;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tloff_t err;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, false);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\trdstate = UNIONFS_F(file)->rdstate;\n+\n+\t/*\n+\t * we let users seek to their current position, but not anywhere\n+\t * else.\n+\t */\n+\tif (!offset) {\n+\t\tswitch (origin) {\n+\t\tcase SEEK_SET:\n+\t\t\tif (rdstate) {\n+\t\t\t\tfree_rdstate(rdstate);\n+\t\t\t\tUNIONFS_F(file)->rdstate = NULL;\n+\t\t\t}\n+\t\t\tinit_rdstate(file);\n+\t\t\terr = 0;\n+\t\t\tbreak;\n+\t\tcase SEEK_CUR:\n+\t\t\terr = file->f_pos;\n+\t\t\tbreak;\n+\t\tcase SEEK_END:\n+\t\t\t/* Unsupported, because we would break everything.  */\n+\t\t\terr = -EINVAL;\n+\t\t\tbreak;\n+\t\t}\n+\t} else {\n+\t\tswitch (origin) {\n+\t\tcase SEEK_SET:\n+\t\t\tif (rdstate) {\n+\t\t\t\tif (offset == rdstate2offset(rdstate))\n+\t\t\t\t\terr = offset;\n+\t\t\t\telse if (file->f_pos == DIREOF)\n+\t\t\t\t\terr = DIREOF;\n+\t\t\t\telse\n+\t\t\t\t\terr = -EINVAL;\n+\t\t\t} else {\n+\t\t\t\tstruct inode *inode;\n+\t\t\t\tinode = dentry->d_inode;\n+\t\t\t\trdstate = find_rdstate(inode, offset);\n+\t\t\t\tif (rdstate) {\n+\t\t\t\t\tUNIONFS_F(file)->rdstate = rdstate;\n+\t\t\t\t\terr = rdstate->offset;\n+\t\t\t\t} else {\n+\t\t\t\t\terr = -EINVAL;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase SEEK_CUR:\n+\t\tcase SEEK_END:\n+\t\t\t/* Unsupported, because we would break everything.  */\n+\t\t\terr = -EINVAL;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * Trimmed directory options, we shouldn\'t pass everything down since\n+ * we don\'t want to operate on partial directories.\n+ */\n+struct file_operations unionfs_dir_fops = {\n+\t.llseek\t\t= unionfs_dir_llseek,\n+\t.read\t\t= generic_read_dir,\n+\t.readdir\t= unionfs_readdir,\n+\t.unlocked_ioctl\t= unionfs_ioctl,\n+\t.open\t\t= unionfs_open,\n+\t.release\t= unionfs_file_release,\n+\t.flush\t\t= unionfs_flush,\n+\t.fsync\t\t= unionfs_fsync,\n+\t.fasync\t\t= unionfs_fasync,\n+};'),
 ('dev/null',
  'b/fs/unionfs/dirhelper.c',
  'diff --git a/fs/unionfs/dirhelper.c b/fs/unionfs/dirhelper.c\nnew file mode 100644\nindex 0000000..b2c645e\n--- dev/null\n+++ b/fs/unionfs/dirhelper.c\n@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+#define RD_NONE 0\n+#define RD_CHECK_EMPTY 1\n+/* The callback structure for check_empty. */\n+struct unionfs_rdutil_callback {\n+\tint err;\n+\tint filldir_called;\n+\tstruct unionfs_dir_state *rdstate;\n+\tint mode;\n+};\n+\n+/* This filldir function makes sure only whiteouts exist within a directory. */\n+static int readdir_util_callback(void *dirent, const char *oname, int namelen,\n+\t\t\t\t loff_t offset, u64 ino, unsigned int d_type)\n+{\n+\tint err = 0;\n+\tstruct unionfs_rdutil_callback *buf = dirent;\n+\tint is_whiteout;\n+\tstruct filldir_node *found;\n+\tchar *name = (char *) oname;\n+\n+\tbuf->filldir_called = 1;\n+\n+\tif (name[0] == \'.\' && (namelen == 1 ||\n+\t\t\t       (name[1] == \'.\' && namelen == 2)))\n+\t\tgoto out;\n+\n+\tis_whiteout = is_whiteout_name(&name, &namelen);\n+\n+\tfound = find_filldir_node(buf->rdstate, name, namelen, is_whiteout);\n+\t/* If it was found in the table there was a previous whiteout. */\n+\tif (found)\n+\t\tgoto out;\n+\n+\t/*\n+\t * if it wasn\'t found and isn\'t a whiteout, the directory isn\'t\n+\t * empty.\n+\t */\n+\terr = -ENOTEMPTY;\n+\tif ((buf->mode == RD_CHECK_EMPTY) && !is_whiteout)\n+\t\tgoto out;\n+\n+\terr = add_filldir_node(buf->rdstate, name, namelen,\n+\t\t\t       buf->rdstate->bindex, is_whiteout);\n+\n+out:\n+\tbuf->err = err;\n+\treturn err;\n+}\n+\n+/* Is a directory logically empty? */\n+int check_empty(struct dentry *dentry, struct dentry *parent,\n+\t\tstruct unionfs_dir_state **namelist)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct vfsmount *mnt;\n+\tstruct super_block *sb;\n+\tstruct file *lower_file;\n+\tstruct unionfs_rdutil_callback *buf = NULL;\n+\tint bindex, bstart, bend, bopaque;\n+\n+\tsb = dentry->d_sb;\n+\n+\n+\tBUG_ON(!S_ISDIR(dentry->d_inode->i_mode));\n+\n+\terr = unionfs_partial_lookup(dentry, parent);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\tbopaque = dbopaque(dentry);\n+\tif (0 <= bopaque && bopaque < bend)\n+\t\tbend = bopaque;\n+\n+\tbuf = kmalloc(sizeof(struct unionfs_rdutil_callback), GFP_KERNEL);\n+\tif (unlikely(!buf)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\tbuf->err = 0;\n+\tbuf->mode = RD_CHECK_EMPTY;\n+\tbuf->rdstate = alloc_rdstate(dentry->d_inode, bstart);\n+\tif (unlikely(!buf->rdstate)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\t/* Process the lower directories with rdutil_callback as a filldir. */\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\t\tif (!lower_dentry->d_inode)\n+\t\t\tcontinue;\n+\t\tif (!S_ISDIR(lower_dentry->d_inode->i_mode))\n+\t\t\tcontinue;\n+\n+\t\tdget(lower_dentry);\n+\t\tmnt = unionfs_mntget(dentry, bindex);\n+\t\tbranchget(sb, bindex);\n+\t\tlower_file = dentry_open(lower_dentry, mnt, O_RDONLY);\n+\t\tif (IS_ERR(lower_file)) {\n+\t\t\terr = PTR_ERR(lower_file);\n+\t\t\tbranchput(sb, bindex);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tdo {\n+\t\t\tbuf->filldir_called = 0;\n+\t\t\tbuf->rdstate->bindex = bindex;\n+\t\t\terr = vfs_readdir(lower_file,\n+\t\t\t\t\t  readdir_util_callback, buf);\n+\t\t\tif (buf->err)\n+\t\t\t\terr = buf->err;\n+\t\t} while ((err >= 0) && buf->filldir_called);\n+\n+\t\t/* fput calls dput for lower_dentry */\n+\t\tfput(lower_file);\n+\t\tbranchput(sb, bindex);\n+\n+\t\tif (err < 0)\n+\t\t\tgoto out;\n+\t}\n+\n+out:\n+\tif (buf) {\n+\t\tif (namelist && !err)\n+\t\t\t*namelist = buf->rdstate;\n+\t\telse if (buf->rdstate)\n+\t\t\tfree_rdstate(buf->rdstate);\n+\t\tkfree(buf);\n+\t}\n+\n+\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/fanout.h',
  'diff --git a/fs/unionfs/fanout.h b/fs/unionfs/fanout.h\nnew file mode 100644\nindex 0000000..04ffa85\n--- dev/null\n+++ b/fs/unionfs/fanout.h\n@@ -0,0 +1,407 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#ifndef _FANOUT_H_\n+#define _FANOUT_H_\n+\n+/*\n+ * Inode to private data\n+ *\n+ * Since we use containers and the struct inode is _inside_ the\n+ * unionfs_inode_info structure, UNIONFS_I will always (given a non-NULL\n+ * inode pointer), return a valid non-NULL pointer.\n+ */\n+static inline struct unionfs_inode_info *UNIONFS_I(const struct inode *inode)\n+{\n+\treturn container_of(inode, struct unionfs_inode_info, vfs_inode);\n+}\n+\n+#define ibstart(ino) (UNIONFS_I(ino)->bstart)\n+#define ibend(ino) (UNIONFS_I(ino)->bend)\n+\n+/* Dentry to private data */\n+#define UNIONFS_D(dent) ((struct unionfs_dentry_info *)(dent)->d_fsdata)\n+#define dbstart(dent) (UNIONFS_D(dent)->bstart)\n+#define dbend(dent) (UNIONFS_D(dent)->bend)\n+#define dbopaque(dent) (UNIONFS_D(dent)->bopaque)\n+\n+/* Superblock to private data */\n+#define UNIONFS_SB(super) ((struct unionfs_sb_info *)(super)->s_fs_info)\n+#define sbstart(sb) 0\n+#define sbend(sb) (UNIONFS_SB(sb)->bend)\n+#define sbmax(sb) (UNIONFS_SB(sb)->bend + 1)\n+#define sbhbid(sb) (UNIONFS_SB(sb)->high_branch_id)\n+\n+/* File to private Data */\n+#define UNIONFS_F(file) ((struct unionfs_file_info *)((file)->private_data))\n+#define fbstart(file) (UNIONFS_F(file)->bstart)\n+#define fbend(file) (UNIONFS_F(file)->bend)\n+\n+/* macros to manipulate branch IDs in stored in our superblock */\n+static inline int branch_id(struct super_block *sb, int index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\treturn UNIONFS_SB(sb)->data[index].branch_id;\n+}\n+\n+static inline void set_branch_id(struct super_block *sb, int index, int val)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tUNIONFS_SB(sb)->data[index].branch_id = val;\n+}\n+\n+static inline void new_branch_id(struct super_block *sb, int index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tset_branch_id(sb, index, ++UNIONFS_SB(sb)->high_branch_id);\n+}\n+\n+/*\n+ * Find new index of matching branch with an existing superblock of a known\n+ * (possibly old) id.  This is needed because branches could have been\n+ * added/deleted causing the branches of any open files to shift.\n+ *\n+ * @sb: the new superblock which may have new/different branch IDs\n+ * @id: the old/existing id we\'re looking for\n+ * Returns index of newly found branch (0 or greater), -1 otherwise.\n+ */\n+static inline int branch_id_to_idx(struct super_block *sb, int id)\n+{\n+\tint i;\n+\tfor (i = 0; i < sbmax(sb); i++) {\n+\t\tif (branch_id(sb, i) == id)\n+\t\t\treturn i;\n+\t}\n+\t/* in the non-ODF code, this should really never happen */\n+\tprintk(KERN_WARNING "unionfs: cannot find branch with id %d\\n", id);\n+\treturn -1;\n+}\n+\n+/* File to lower file. */\n+static inline struct file *unionfs_lower_file(const struct file *f)\n+{\n+\tBUG_ON(!f);\n+\treturn UNIONFS_F(f)->lower_files[fbstart(f)];\n+}\n+\n+static inline struct file *unionfs_lower_file_idx(const struct file *f,\n+\t\t\t\t\t\t  int index)\n+{\n+\tBUG_ON(!f || index < 0);\n+\treturn UNIONFS_F(f)->lower_files[index];\n+}\n+\n+static inline void unionfs_set_lower_file_idx(struct file *f, int index,\n+\t\t\t\t\t      struct file *val)\n+{\n+\tBUG_ON(!f || index < 0);\n+\tUNIONFS_F(f)->lower_files[index] = val;\n+\t/* save branch ID (may be redundant?) */\n+\tUNIONFS_F(f)->saved_branch_ids[index] =\n+\t\tbranch_id((f)->f_path.dentry->d_sb, index);\n+}\n+\n+static inline void unionfs_set_lower_file(struct file *f, struct file *val)\n+{\n+\tBUG_ON(!f);\n+\tunionfs_set_lower_file_idx((f), fbstart(f), (val));\n+}\n+\n+/* Inode to lower inode. */\n+static inline struct inode *unionfs_lower_inode(const struct inode *i)\n+{\n+\tBUG_ON(!i);\n+\treturn UNIONFS_I(i)->lower_inodes[ibstart(i)];\n+}\n+\n+static inline struct inode *unionfs_lower_inode_idx(const struct inode *i,\n+\t\t\t\t\t\t    int index)\n+{\n+\tBUG_ON(!i || index < 0);\n+\treturn UNIONFS_I(i)->lower_inodes[index];\n+}\n+\n+static inline void unionfs_set_lower_inode_idx(struct inode *i, int index,\n+\t\t\t\t\t       struct inode *val)\n+{\n+\tBUG_ON(!i || index < 0);\n+\tUNIONFS_I(i)->lower_inodes[index] = val;\n+}\n+\n+static inline void unionfs_set_lower_inode(struct inode *i, struct inode *val)\n+{\n+\tBUG_ON(!i);\n+\tUNIONFS_I(i)->lower_inodes[ibstart(i)] = val;\n+}\n+\n+/* Superblock to lower superblock. */\n+static inline struct super_block *unionfs_lower_super(\n+\t\t\t\t\tconst struct super_block *sb)\n+{\n+\tBUG_ON(!sb);\n+\treturn UNIONFS_SB(sb)->data[sbstart(sb)].sb;\n+}\n+\n+static inline struct super_block *unionfs_lower_super_idx(\n+\t\t\t\t\tconst struct super_block *sb,\n+\t\t\t\t\tint index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\treturn UNIONFS_SB(sb)->data[index].sb;\n+}\n+\n+static inline void unionfs_set_lower_super_idx(struct super_block *sb,\n+\t\t\t\t\t       int index,\n+\t\t\t\t\t       struct super_block *val)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tUNIONFS_SB(sb)->data[index].sb = val;\n+}\n+\n+static inline void unionfs_set_lower_super(struct super_block *sb,\n+\t\t\t\t\t   struct super_block *val)\n+{\n+\tBUG_ON(!sb);\n+\tUNIONFS_SB(sb)->data[sbstart(sb)].sb = val;\n+}\n+\n+/* Branch count macros. */\n+static inline int branch_count(const struct super_block *sb, int index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\treturn atomic_read(&UNIONFS_SB(sb)->data[index].open_files);\n+}\n+\n+static inline void set_branch_count(struct super_block *sb, int index, int val)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tatomic_set(&UNIONFS_SB(sb)->data[index].open_files, val);\n+}\n+\n+static inline void branchget(struct super_block *sb, int index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tatomic_inc(&UNIONFS_SB(sb)->data[index].open_files);\n+}\n+\n+static inline void branchput(struct super_block *sb, int index)\n+{\n+\tBUG_ON(!sb || index < 0);\n+\tatomic_dec(&UNIONFS_SB(sb)->data[index].open_files);\n+}\n+\n+/* Dentry macros */\n+static inline void unionfs_set_lower_dentry_idx(struct dentry *dent, int index,\n+\t\t\t\t\t\tstruct dentry *val)\n+{\n+\tBUG_ON(!dent || index < 0);\n+\tUNIONFS_D(dent)->lower_paths[index].dentry = val;\n+}\n+\n+static inline struct dentry *unionfs_lower_dentry_idx(\n+\t\t\t\tconst struct dentry *dent,\n+\t\t\t\tint index)\n+{\n+\tBUG_ON(!dent || index < 0);\n+\treturn UNIONFS_D(dent)->lower_paths[index].dentry;\n+}\n+\n+static inline struct dentry *unionfs_lower_dentry(const struct dentry *dent)\n+{\n+\tBUG_ON(!dent);\n+\treturn unionfs_lower_dentry_idx(dent, dbstart(dent));\n+}\n+\n+static inline void unionfs_set_lower_mnt_idx(struct dentry *dent, int index,\n+\t\t\t\t\t     struct vfsmount *mnt)\n+{\n+\tBUG_ON(!dent || index < 0);\n+\tUNIONFS_D(dent)->lower_paths[index].mnt = mnt;\n+}\n+\n+static inline struct vfsmount *unionfs_lower_mnt_idx(\n+\t\t\t\t\tconst struct dentry *dent,\n+\t\t\t\t\tint index)\n+{\n+\tBUG_ON(!dent || index < 0);\n+\treturn UNIONFS_D(dent)->lower_paths[index].mnt;\n+}\n+\n+static inline struct vfsmount *unionfs_lower_mnt(const struct dentry *dent)\n+{\n+\tBUG_ON(!dent);\n+\treturn unionfs_lower_mnt_idx(dent, dbstart(dent));\n+}\n+\n+/* Macros for locking a dentry. */\n+enum unionfs_dentry_lock_class {\n+\tUNIONFS_DMUTEX_NORMAL,\n+\tUNIONFS_DMUTEX_ROOT,\n+\tUNIONFS_DMUTEX_PARENT,\n+\tUNIONFS_DMUTEX_CHILD,\n+\tUNIONFS_DMUTEX_WHITEOUT,\n+\tUNIONFS_DMUTEX_REVAL_PARENT, /* for file/dentry revalidate */\n+\tUNIONFS_DMUTEX_REVAL_CHILD,   /* for file/dentry revalidate */\n+};\n+\n+static inline void unionfs_lock_dentry(struct dentry *d,\n+\t\t\t\t       unsigned int subclass)\n+{\n+\tBUG_ON(!d);\n+\tmutex_lock_nested(&UNIONFS_D(d)->lock, subclass);\n+}\n+\n+static inline void unionfs_unlock_dentry(struct dentry *d)\n+{\n+\tBUG_ON(!d);\n+\tmutex_unlock(&UNIONFS_D(d)->lock);\n+}\n+\n+static inline struct dentry *unionfs_lock_parent(struct dentry *d,\n+\t\t\t\t\t\t unsigned int subclass)\n+{\n+\tstruct dentry *p;\n+\n+\tBUG_ON(!d);\n+\tp = dget_parent(d);\n+\tif (p != d)\n+\t\tmutex_lock_nested(&UNIONFS_D(p)->lock, subclass);\n+\treturn p;\n+}\n+\n+static inline void unionfs_unlock_parent(struct dentry *d, struct dentry *p)\n+{\n+\tBUG_ON(!d);\n+\tBUG_ON(!p);\n+\tif (p != d) {\n+\t\tBUG_ON(!mutex_is_locked(&UNIONFS_D(p)->lock));\n+\t\tmutex_unlock(&UNIONFS_D(p)->lock);\n+\t}\n+\tdput(p);\n+}\n+\n+static inline void verify_locked(struct dentry *d)\n+{\n+\tBUG_ON(!d);\n+\tBUG_ON(!mutex_is_locked(&UNIONFS_D(d)->lock));\n+}\n+\n+/* macros to put lower objects */\n+\n+/*\n+ * iput lower inodes of an unionfs dentry, from bstart to bend.  If\n+ * @free_lower is true, then also kfree the memory used to hold the lower\n+ * object pointers.\n+ */\n+static inline void iput_lowers(struct inode *inode,\n+\t\t\t       int bstart, int bend, bool free_lower)\n+{\n+\tstruct inode *lower_inode;\n+\tint bindex;\n+\n+\tBUG_ON(!inode);\n+\tBUG_ON(!UNIONFS_I(inode));\n+\tBUG_ON(bstart < 0);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (lower_inode) {\n+\t\t\tunionfs_set_lower_inode_idx(inode, bindex, NULL);\n+\t\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\t\tlockdep_off();\n+\t\t\tiput(lower_inode);\n+\t\t\tlockdep_on();\n+\t\t}\n+\t}\n+\n+\tif (free_lower) {\n+\t\tkfree(UNIONFS_I(inode)->lower_inodes);\n+\t\tUNIONFS_I(inode)->lower_inodes = NULL;\n+\t}\n+}\n+\n+/* iput all lower inodes, and reset start/end branch indices to -1 */\n+static inline void iput_lowers_all(struct inode *inode, bool free_lower)\n+{\n+\tint bstart, bend;\n+\n+\tBUG_ON(!inode);\n+\tBUG_ON(!UNIONFS_I(inode));\n+\tbstart = ibstart(inode);\n+\tbend = ibend(inode);\n+\tBUG_ON(bstart < 0);\n+\n+\tiput_lowers(inode, bstart, bend, free_lower);\n+\tibstart(inode) = ibend(inode) = -1;\n+}\n+\n+/*\n+ * dput/mntput all lower dentries and vfsmounts of an unionfs dentry, from\n+ * bstart to bend.  If @free_lower is true, then also kfree the memory used\n+ * to hold the lower object pointers.\n+ *\n+ * XXX: implement using path_put VFS macros\n+ */\n+static inline void path_put_lowers(struct dentry *dentry,\n+\t\t\t\t   int bstart, int bend, bool free_lower)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct vfsmount *lower_mnt;\n+\tint bindex;\n+\n+\tBUG_ON(!dentry);\n+\tBUG_ON(!UNIONFS_D(dentry));\n+\tBUG_ON(bstart < 0);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (lower_dentry) {\n+\t\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t\t\tdput(lower_dentry);\n+\t\t}\n+\t\tlower_mnt = unionfs_lower_mnt_idx(dentry, bindex);\n+\t\tif (lower_mnt) {\n+\t\t\tunionfs_set_lower_mnt_idx(dentry, bindex, NULL);\n+\t\t\tmntput(lower_mnt);\n+\t\t}\n+\t}\n+\n+\tif (free_lower) {\n+\t\tkfree(UNIONFS_D(dentry)->lower_paths);\n+\t\tUNIONFS_D(dentry)->lower_paths = NULL;\n+\t}\n+}\n+\n+/*\n+ * dput/mntput all lower dentries and vfsmounts, and reset start/end branch\n+ * indices to -1.\n+ */\n+static inline void path_put_lowers_all(struct dentry *dentry, bool free_lower)\n+{\n+\tint bstart, bend;\n+\n+\tBUG_ON(!dentry);\n+\tBUG_ON(!UNIONFS_D(dentry));\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\tBUG_ON(bstart < 0);\n+\n+\tpath_put_lowers(dentry, bstart, bend, free_lower);\n+\tdbstart(dentry) = dbend(dentry) = -1;\n+}\n+\n+#endif\t/* not _FANOUT_H */'),
 ('dev/null',
  'b/fs/unionfs/file.c',
  'diff --git a/fs/unionfs/file.c b/fs/unionfs/file.c\nnew file mode 100644\nindex 0000000..af6f8a7\n--- dev/null\n+++ b/fs/unionfs/file.c\n@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+static ssize_t unionfs_read(struct file *file, char __user *buf,\n+\t\t\t    size_t count, loff_t *ppos)\n+{\n+\tint err;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, false);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\tlower_file = unionfs_lower_file(file);\n+\terr = vfs_read(lower_file, buf, count, ppos);\n+\t/* update our inode atime upon a successful lower read */\n+\tif (err >= 0) {\n+\t\tfsstack_copy_attr_atime(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tunionfs_check_file(file);\n+\t}\n+\n+out:\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static ssize_t unionfs_write(struct file *file, const char __user *buf,\n+\t\t\t     size_t count, loff_t *ppos)\n+{\n+\tint err = 0;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, true);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\tlower_file = unionfs_lower_file(file);\n+\terr = vfs_write(lower_file, buf, count, ppos);\n+\t/* update our inode times+sizes upon a successful lower write */\n+\tif (err >= 0) {\n+\t\tfsstack_copy_inode_size(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tfsstack_copy_attr_times(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tUNIONFS_F(file)->wrote_to_file = true; /* for delayed copyup */\n+\t\tunionfs_check_file(file);\n+\t}\n+\n+out:\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static int unionfs_file_readdir(struct file *file, void *dirent,\n+\t\t\t\tfilldir_t filldir)\n+{\n+\treturn -ENOTDIR;\n+}\n+\n+static int unionfs_mmap(struct file *file, struct vm_area_struct *vma)\n+{\n+\tint err = 0;\n+\tbool willwrite;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tstruct vm_operations_struct *saved_vm_ops = NULL;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\t/* This might be deferred to mmap\'s writepage */\n+\twillwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);\n+\terr = unionfs_file_revalidate(file, parent, willwrite);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\tunionfs_check_file(file);\n+\n+\t/*\n+\t * File systems which do not implement ->writepage may use\n+\t * generic_file_readonly_mmap as their ->mmap op.  If you call\n+\t * generic_file_readonly_mmap with VM_WRITE, you\'d get an -EINVAL.\n+\t * But we cannot call the lower ->mmap op, so we can\'t tell that\n+\t * writeable mappings won\'t work.  Therefore, our only choice is to\n+\t * check if the lower file system supports the ->writepage, and if\n+\t * not, return EINVAL (the same error that\n+\t * generic_file_readonly_mmap returns in that case).\n+\t */\n+\tlower_file = unionfs_lower_file(file);\n+\tif (willwrite && !lower_file->f_mapping->a_ops->writepage) {\n+\t\terr = -EINVAL;\n+\t\tprintk(KERN_ERR "unionfs: branch %d file system does not "\n+\t\t       "support writeable mmap\\n", fbstart(file));\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * find and save lower vm_ops.\n+\t *\n+\t * XXX: the VFS should have a cleaner way of finding the lower vm_ops\n+\t */\n+\tif (!UNIONFS_F(file)->lower_vm_ops) {\n+\t\terr = lower_file->f_op->mmap(lower_file, vma);\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: lower mmap failed %d\\n", err);\n+\t\t\tgoto out;\n+\t\t}\n+\t\tsaved_vm_ops = vma->vm_ops;\n+\t\terr = do_munmap(current->mm, vma->vm_start,\n+\t\t\t\tvma->vm_end - vma->vm_start);\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: do_munmap failed %d\\n", err);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\tfile->f_mapping->a_ops = &unionfs_dummy_aops;\n+\terr = generic_file_mmap(file, vma);\n+\tfile->f_mapping->a_ops = &unionfs_aops;\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: generic_file_mmap failed %d\\n", err);\n+\t\tgoto out;\n+\t}\n+\tvma->vm_ops = &unionfs_vm_ops;\n+\tif (!UNIONFS_F(file)->lower_vm_ops)\n+\t\tUNIONFS_F(file)->lower_vm_ops = saved_vm_ops;\n+\n+out:\n+\tif (!err) {\n+\t\t/* copyup could cause parent dir times to change */\n+\t\tunionfs_copy_attr_times(parent->d_inode);\n+\t\tunionfs_check_file(file);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+int unionfs_fsync(struct file *file, struct dentry *dentry, int datasync)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct file *lower_file;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *parent;\n+\tstruct inode *lower_inode, *inode;\n+\tint err = -EINVAL;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, true);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\tunionfs_check_file(file);\n+\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\tif (bstart < 0 || bend < 0)\n+\t\tgoto out;\n+\n+\tinode = dentry->d_inode;\n+\tif (unlikely(!inode)) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: null lower inode in unionfs_fsync\\n");\n+\t\tgoto out;\n+\t}\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode || !lower_inode->i_fop->fsync)\n+\t\t\tcontinue;\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tmutex_lock(&lower_inode->i_mutex);\n+\t\terr = lower_inode->i_fop->fsync(lower_file,\n+\t\t\t\t\t\tlower_dentry,\n+\t\t\t\t\t\tdatasync);\n+\t\tif (!err && bindex == bstart)\n+\t\t\tfsstack_copy_attr_times(inode, lower_inode);\n+\t\tmutex_unlock(&lower_inode->i_mutex);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+int unionfs_fasync(int fd, struct file *file, int flag)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\tstruct inode *lower_inode, *inode;\n+\tint err = 0;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, true);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\tunionfs_check_file(file);\n+\n+\tbstart = fbstart(file);\n+\tbend = fbend(file);\n+\tif (bstart < 0 || bend < 0)\n+\t\tgoto out;\n+\n+\tinode = dentry->d_inode;\n+\tif (unlikely(!inode)) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: null lower inode in unionfs_fasync\\n");\n+\t\tgoto out;\n+\t}\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode || !lower_inode->i_fop->fasync)\n+\t\t\tcontinue;\n+\t\tlower_file = unionfs_lower_file_idx(file, bindex);\n+\t\tmutex_lock(&lower_inode->i_mutex);\n+\t\terr = lower_inode->i_fop->fasync(fd, lower_file, flag);\n+\t\tif (!err && bindex == bstart)\n+\t\t\tfsstack_copy_attr_times(inode, lower_inode);\n+\t\tmutex_unlock(&lower_inode->i_mutex);\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_file(file);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static ssize_t unionfs_splice_read(struct file *file, loff_t *ppos,\n+\t\t\t\t   struct pipe_inode_info *pipe, size_t len,\n+\t\t\t\t   unsigned int flags)\n+{\n+\tssize_t err;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, false);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\tlower_file = unionfs_lower_file(file);\n+\terr = vfs_splice_to(lower_file, ppos, pipe, len, flags);\n+\t/* update our inode atime upon a successful lower splice-read */\n+\tif (err >= 0) {\n+\t\tfsstack_copy_attr_atime(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tunionfs_check_file(file);\n+\t}\n+\n+out:\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static ssize_t unionfs_splice_write(struct pipe_inode_info *pipe,\n+\t\t\t\t    struct file *file, loff_t *ppos,\n+\t\t\t\t    size_t len, unsigned int flags)\n+{\n+\tssize_t err = 0;\n+\tstruct file *lower_file;\n+\tstruct dentry *dentry = file->f_path.dentry;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_PARENT);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\terr = unionfs_file_revalidate(file, parent, true);\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\n+\tlower_file = unionfs_lower_file(file);\n+\terr = vfs_splice_from(pipe, lower_file, ppos, len, flags);\n+\t/* update our inode times+sizes upon a successful lower write */\n+\tif (err >= 0) {\n+\t\tfsstack_copy_inode_size(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tfsstack_copy_attr_times(dentry->d_inode,\n+\t\t\t\t\tlower_file->f_path.dentry->d_inode);\n+\t\tunionfs_check_file(file);\n+\t}\n+\n+out:\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+struct file_operations unionfs_main_fops = {\n+\t.llseek\t\t= generic_file_llseek,\n+\t.read\t\t= unionfs_read,\n+\t.write\t\t= unionfs_write,\n+\t.readdir\t= unionfs_file_readdir,\n+\t.unlocked_ioctl\t= unionfs_ioctl,\n+\t.mmap\t\t= unionfs_mmap,\n+\t.open\t\t= unionfs_open,\n+\t.flush\t\t= unionfs_flush,\n+\t.release\t= unionfs_file_release,\n+\t.fsync\t\t= unionfs_fsync,\n+\t.fasync\t\t= unionfs_fasync,\n+\t.splice_read\t= unionfs_splice_read,\n+\t.splice_write\t= unionfs_splice_write,\n+};'),
 ('dev/null',
  'b/fs/unionfs/inode.c',
  'diff --git a/fs/unionfs/inode.c b/fs/unionfs/inode.c\nnew file mode 100644\nindex 0000000..68e6985\n--- dev/null\n+++ b/fs/unionfs/inode.c\n@@ -0,0 +1,1030 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * Find a writeable branch to create new object in.  Checks all writeble\n+ * branches of the parent inode, from istart to iend order; if none are\n+ * suitable, also tries branch 0 (which may require a copyup).\n+ *\n+ * Return a lower_dentry we can use to create object in, or ERR_PTR.\n+ */\n+static struct dentry *find_writeable_branch(struct inode *parent,\n+\t\t\t\t\t    struct dentry *dentry)\n+{\n+\tint err = -EINVAL;\n+\tint bindex, istart, iend;\n+\tstruct dentry *lower_dentry = NULL;\n+\n+\tistart = ibstart(parent);\n+\tiend = ibend(parent);\n+\tif (istart < 0)\n+\t\tgoto out;\n+\n+begin:\n+\tfor (bindex = istart; bindex <= iend; bindex++) {\n+\t\t/* skip non-writeable branches */\n+\t\terr = is_robranch_super(dentry->d_sb, bindex);\n+\t\tif (err) {\n+\t\t\terr = -EROFS;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\t\t/*\n+\t\t * check for whiteouts in writeable branch, and remove them\n+\t\t * if necessary.\n+\t\t */\n+\t\terr = check_unlink_whiteout(dentry, lower_dentry, bindex);\n+\t\tif (err > 0)\t/* ignore if whiteout found and removed */\n+\t\t\terr = 0;\n+\t\tif (err)\n+\t\t\tcontinue;\n+\t\t/* if get here, we can write to the branch */\n+\t\tbreak;\n+\t}\n+\t/*\n+\t * If istart wasn\'t already branch 0, and we got any error, then try\n+\t * branch 0 (which may require copyup)\n+\t */\n+\tif (err && istart > 0) {\n+\t\tistart = iend = 0;\n+\t\tgoto begin;\n+\t}\n+\n+\t/*\n+\t * If we tried even branch 0, and still got an error, abort.  But if\n+\t * the error was an EROFS, then we should try to copyup.\n+\t */\n+\tif (err && err != -EROFS)\n+\t\tgoto out;\n+\n+\t/*\n+\t * If we get here, then check if copyup needed.  If lower_dentry is\n+\t * NULL, create the entire dentry directory structure in branch 0.\n+\t */\n+\tif (!lower_dentry) {\n+\t\tbindex = 0;\n+\t\tlower_dentry = create_parents(parent, dentry,\n+\t\t\t\t\t      dentry->d_name.name, bindex);\n+\t\tif (IS_ERR(lower_dentry)) {\n+\t\t\terr = PTR_ERR(lower_dentry);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\terr = 0;\t\t/* all\'s well */\n+out:\n+\tif (err)\n+\t\treturn ERR_PTR(err);\n+\treturn lower_dentry;\n+}\n+\n+static int unionfs_create(struct inode *dir, struct dentry *dentry,\n+\t\t\t  int mode, struct nameidata *nd_unused)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *lower_parent_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint valid = 0;\n+\tstruct nameidata lower_nd;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\t/* same as what real_lookup does */\n+\t\tgoto out;\n+\t}\n+\n+\tlower_dentry = find_writeable_branch(dir, dentry);\n+\tif (IS_ERR(lower_dentry)) {\n+\t\terr = PTR_ERR(lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tlower_parent_dentry = lock_parent(lower_dentry);\n+\tif (IS_ERR(lower_parent_dentry)) {\n+\t\terr = PTR_ERR(lower_parent_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\terr = init_lower_nd(&lower_nd, LOOKUP_CREATE);\n+\tif (unlikely(err < 0))\n+\t\tgoto out;\n+\terr = vfs_create(lower_parent_dentry->d_inode, lower_dentry, mode,\n+\t\t\t &lower_nd);\n+\trelease_lower_nd(&lower_nd, err);\n+\n+\tif (!err) {\n+\t\terr = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));\n+\t\tif (!err) {\n+\t\t\tunionfs_copy_attr_times(dir);\n+\t\t\tfsstack_copy_inode_size(dir,\n+\t\t\t\t\t\tlower_parent_dentry->d_inode);\n+\t\t\t/* update no. of links on parent directory */\n+\t\t\tdir->i_nlink = unionfs_get_nlinks(dir);\n+\t\t}\n+\t}\n+\n+\tunlock_dir(lower_parent_dentry);\n+\n+out:\n+\tif (!err) {\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_check_inode(dir);\n+\t\tunionfs_check_dentry(dentry);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * unionfs_lookup is the only special function which takes a dentry, yet we\n+ * do NOT want to call __unionfs_d_revalidate_chain because by definition,\n+ * we don\'t have a valid dentry here yet.\n+ */\n+static struct dentry *unionfs_lookup(struct inode *dir,\n+\t\t\t\t     struct dentry *dentry,\n+\t\t\t\t     struct nameidata *nd_unused)\n+{\n+\tstruct dentry *ret, *parent;\n+\tint err = 0;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\n+\t/*\n+\t * As long as we lock/dget the parent, then can skip validating the\n+\t * parent now; we may have to rebuild this dentry on the next\n+\t * ->d_revalidate, however.\n+\t */\n+\n+\t/* allocate dentry private data.  We free it in ->d_release */\n+\terr = new_dentry_private_data(dentry, UNIONFS_DMUTEX_CHILD);\n+\tif (unlikely(err)) {\n+\t\tret = ERR_PTR(err);\n+\t\tgoto out;\n+\t}\n+\n+\tret = unionfs_lookup_full(dentry, parent, INTERPOSE_LOOKUP);\n+\n+\tif (!IS_ERR(ret)) {\n+\t\tif (ret)\n+\t\t\tdentry = ret;\n+\t\t/* lookup_full can return multiple positive dentries */\n+\t\tif (dentry->d_inode && !S_ISDIR(dentry->d_inode->i_mode)) {\n+\t\t\tBUG_ON(dbstart(dentry) < 0);\n+\t\t\tunionfs_postcopyup_release(dentry);\n+\t\t}\n+\t\tunionfs_copy_attr_times(dentry->d_inode);\n+\t}\n+\n+\tunionfs_check_inode(dir);\n+\tif (!IS_ERR(ret))\n+\t\tunionfs_check_dentry(dentry);\n+\tunionfs_check_dentry(parent);\n+\tunionfs_unlock_dentry(dentry); /* locked in new_dentry_private data */\n+\n+out:\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn ret;\n+}\n+\n+static int unionfs_link(struct dentry *old_dentry, struct inode *dir,\n+\t\t\tstruct dentry *new_dentry)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_old_dentry = NULL;\n+\tstruct dentry *lower_new_dentry = NULL;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\tstruct dentry *old_parent, *new_parent;\n+\tchar *name = NULL;\n+\tbool valid;\n+\n+\tunionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\told_parent = dget_parent(old_dentry);\n+\tnew_parent = dget_parent(new_dentry);\n+\tunionfs_double_lock_parents(old_parent, new_parent);\n+\tunionfs_double_lock_dentry(old_dentry, new_dentry);\n+\n+\tvalid = __unionfs_d_revalidate(old_dentry, old_parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\tif (new_dentry->d_inode) {\n+\t\tvalid = __unionfs_d_revalidate(new_dentry, new_parent, false);\n+\t\tif (unlikely(!valid)) {\n+\t\t\terr = -ESTALE;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\tlower_new_dentry = unionfs_lower_dentry(new_dentry);\n+\n+\t/* check for a whiteout in new dentry branch, and delete it */\n+\terr = check_unlink_whiteout(new_dentry, lower_new_dentry,\n+\t\t\t\t    dbstart(new_dentry));\n+\tif (err > 0) {\t       /* whiteout found and removed successfully */\n+\t\tlower_dir_dentry = dget_parent(lower_new_dentry);\n+\t\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n+\t\tdput(lower_dir_dentry);\n+\t\tdir->i_nlink = unionfs_get_nlinks(dir);\n+\t\terr = 0;\n+\t}\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* check if parent hierachy is needed, then link in same branch */\n+\tif (dbstart(old_dentry) != dbstart(new_dentry)) {\n+\t\tlower_new_dentry = create_parents(dir, new_dentry,\n+\t\t\t\t\t\t  new_dentry->d_name.name,\n+\t\t\t\t\t\t  dbstart(old_dentry));\n+\t\terr = PTR_ERR(lower_new_dentry);\n+\t\tif (IS_COPYUP_ERR(err))\n+\t\t\tgoto docopyup;\n+\t\tif (!lower_new_dentry || IS_ERR(lower_new_dentry))\n+\t\t\tgoto out;\n+\t}\n+\tlower_new_dentry = unionfs_lower_dentry(new_dentry);\n+\tlower_old_dentry = unionfs_lower_dentry(old_dentry);\n+\n+\tBUG_ON(dbstart(old_dentry) != dbstart(new_dentry));\n+\tlower_dir_dentry = lock_parent(lower_new_dentry);\n+\terr = is_robranch(old_dentry);\n+\tif (!err) {\n+\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\tlockdep_off();\n+\t\terr = vfs_link(lower_old_dentry, lower_dir_dentry->d_inode,\n+\t\t\t       lower_new_dentry);\n+\t\tlockdep_on();\n+\t}\n+\tunlock_dir(lower_dir_dentry);\n+\n+docopyup:\n+\tif (IS_COPYUP_ERR(err)) {\n+\t\tint old_bstart = dbstart(old_dentry);\n+\t\tint bindex;\n+\n+\t\tfor (bindex = old_bstart - 1; bindex >= 0; bindex--) {\n+\t\t\terr = copyup_dentry(old_parent->d_inode,\n+\t\t\t\t\t    old_dentry, old_bstart,\n+\t\t\t\t\t    bindex, old_dentry->d_name.name,\n+\t\t\t\t\t    old_dentry->d_name.len, NULL,\n+\t\t\t\t\t    i_size_read(old_dentry->d_inode));\n+\t\t\tif (err)\n+\t\t\t\tcontinue;\n+\t\t\tlower_new_dentry =\n+\t\t\t\tcreate_parents(dir, new_dentry,\n+\t\t\t\t\t       new_dentry->d_name.name,\n+\t\t\t\t\t       bindex);\n+\t\t\tlower_old_dentry = unionfs_lower_dentry(old_dentry);\n+\t\t\tlower_dir_dentry = lock_parent(lower_new_dentry);\n+\t\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\t\tlockdep_off();\n+\t\t\t/* do vfs_link */\n+\t\t\terr = vfs_link(lower_old_dentry,\n+\t\t\t\t       lower_dir_dentry->d_inode,\n+\t\t\t\t       lower_new_dentry);\n+\t\t\tlockdep_on();\n+\t\t\tunlock_dir(lower_dir_dentry);\n+\t\t\tgoto check_link;\n+\t\t}\n+\t\tgoto out;\n+\t}\n+\n+check_link:\n+\tif (err || !lower_new_dentry->d_inode)\n+\t\tgoto out;\n+\n+\t/* Its a hard link, so use the same inode */\n+\tnew_dentry->d_inode = igrab(old_dentry->d_inode);\n+\td_add(new_dentry, new_dentry->d_inode);\n+\tunionfs_copy_attr_all(dir, lower_new_dentry->d_parent->d_inode);\n+\tfsstack_copy_inode_size(dir, lower_new_dentry->d_parent->d_inode);\n+\n+\t/* propagate number of hard-links */\n+\told_dentry->d_inode->i_nlink = unionfs_get_nlinks(old_dentry->d_inode);\n+\t/* new dentry\'s ctime may have changed due to hard-link counts */\n+\tunionfs_copy_attr_times(new_dentry->d_inode);\n+\n+out:\n+\tif (!new_dentry->d_inode)\n+\t\td_drop(new_dentry);\n+\n+\tkfree(name);\n+\tif (!err)\n+\t\tunionfs_postcopyup_setmnt(new_dentry);\n+\n+\tunionfs_check_inode(dir);\n+\tunionfs_check_dentry(new_dentry);\n+\tunionfs_check_dentry(old_dentry);\n+\n+\tunionfs_double_unlock_dentry(old_dentry, new_dentry);\n+\tunionfs_double_unlock_parents(old_parent, new_parent);\n+\tdput(new_parent);\n+\tdput(old_parent);\n+\tunionfs_read_unlock(old_dentry->d_sb);\n+\n+\treturn err;\n+}\n+\n+static int unionfs_symlink(struct inode *dir, struct dentry *dentry,\n+\t\t\t   const char *symname)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *wh_dentry = NULL;\n+\tstruct dentry *lower_parent_dentry = NULL;\n+\tstruct dentry *parent;\n+\tchar *name = NULL;\n+\tint valid = 0;\n+\tumode_t mode;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * It\'s only a bug if this dentry was not negative and couldn\'t be\n+\t * revalidated (shouldn\'t happen).\n+\t */\n+\tBUG_ON(!valid && dentry->d_inode);\n+\n+\tlower_dentry = find_writeable_branch(dir, dentry);\n+\tif (IS_ERR(lower_dentry)) {\n+\t\terr = PTR_ERR(lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tlower_parent_dentry = lock_parent(lower_dentry);\n+\tif (IS_ERR(lower_parent_dentry)) {\n+\t\terr = PTR_ERR(lower_parent_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tmode = S_IALLUGO;\n+\terr = vfs_symlink(lower_parent_dentry->d_inode, lower_dentry,\n+\t\t\t  symname, mode);\n+\tif (!err) {\n+\t\terr = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));\n+\t\tif (!err) {\n+\t\t\tunionfs_copy_attr_times(dir);\n+\t\t\tfsstack_copy_inode_size(dir,\n+\t\t\t\t\t\tlower_parent_dentry->d_inode);\n+\t\t\t/* update no. of links on parent directory */\n+\t\t\tdir->i_nlink = unionfs_get_nlinks(dir);\n+\t\t}\n+\t}\n+\n+\tunlock_dir(lower_parent_dentry);\n+\n+out:\n+\tdput(wh_dentry);\n+\tkfree(name);\n+\n+\tif (!err) {\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_check_inode(dir);\n+\t\tunionfs_check_dentry(dentry);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static int unionfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *lower_parent_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint bindex = 0, bstart;\n+\tchar *name = NULL;\n+\tint valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\t/* same as what real_lookup does */\n+\t\tgoto out;\n+\t}\n+\n+\tbstart = dbstart(dentry);\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\t/* check for a whiteout in new dentry branch, and delete it */\n+\terr = check_unlink_whiteout(dentry, lower_dentry, bstart);\n+\tif (err > 0)\t       /* whiteout found and removed successfully */\n+\t\terr = 0;\n+\tif (err) {\n+\t\t/* exit if the error returned was NOT -EROFS */\n+\t\tif (!IS_COPYUP_ERR(err))\n+\t\t\tgoto out;\n+\t\tbstart--;\n+\t}\n+\n+\t/* check if copyup\'s needed, and mkdir */\n+\tfor (bindex = bstart; bindex >= 0; bindex--) {\n+\t\tint i;\n+\t\tint bend = dbend(dentry);\n+\n+\t\tif (is_robranch_super(dentry->d_sb, bindex))\n+\t\t\tcontinue;\n+\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry) {\n+\t\t\tlower_dentry = create_parents(dir, dentry,\n+\t\t\t\t\t\t      dentry->d_name.name,\n+\t\t\t\t\t\t      bindex);\n+\t\t\tif (!lower_dentry || IS_ERR(lower_dentry)) {\n+\t\t\t\tprintk(KERN_ERR "unionfs: lower dentry "\n+\t\t\t\t       " NULL for bindex = %d\\n", bindex);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\n+\t\tlower_parent_dentry = lock_parent(lower_dentry);\n+\n+\t\tif (IS_ERR(lower_parent_dentry)) {\n+\t\t\terr = PTR_ERR(lower_parent_dentry);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\terr = vfs_mkdir(lower_parent_dentry->d_inode, lower_dentry,\n+\t\t\t\tmode);\n+\n+\t\tunlock_dir(lower_parent_dentry);\n+\n+\t\t/* did the mkdir succeed? */\n+\t\tif (err)\n+\t\t\tbreak;\n+\n+\t\tfor (i = bindex + 1; i <= bend; i++) {\n+\t\t\t/* XXX: use path_put_lowers? */\n+\t\t\tif (unionfs_lower_dentry_idx(dentry, i)) {\n+\t\t\t\tdput(unionfs_lower_dentry_idx(dentry, i));\n+\t\t\t\tunionfs_set_lower_dentry_idx(dentry, i, NULL);\n+\t\t\t}\n+\t\t}\n+\t\tdbend(dentry) = bindex;\n+\n+\t\t/*\n+\t\t * Only INTERPOSE_LOOKUP can return a value other than 0 on\n+\t\t * err.\n+\t\t */\n+\t\terr = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));\n+\t\tif (!err) {\n+\t\t\tunionfs_copy_attr_times(dir);\n+\t\t\tfsstack_copy_inode_size(dir,\n+\t\t\t\t\t\tlower_parent_dentry->d_inode);\n+\n+\t\t\t/* update number of links on parent directory */\n+\t\t\tdir->i_nlink = unionfs_get_nlinks(dir);\n+\t\t}\n+\n+\t\terr = make_dir_opaque(dentry, dbstart(dentry));\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: mkdir: error creating "\n+\t\t\t       ".wh.__dir_opaque: %d\\n", err);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\t/* we are done! */\n+\t\tbreak;\n+\t}\n+\n+out:\n+\tif (!dentry->d_inode)\n+\t\td_drop(dentry);\n+\n+\tkfree(name);\n+\n+\tif (!err) {\n+\t\tunionfs_copy_attr_times(dentry->d_inode);\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t}\n+\tunionfs_check_inode(dir);\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn err;\n+}\n+\n+static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,\n+\t\t\t dev_t dev)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *wh_dentry = NULL;\n+\tstruct dentry *lower_parent_dentry = NULL;\n+\tstruct dentry *parent;\n+\tchar *name = NULL;\n+\tint valid = 0;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * It\'s only a bug if this dentry was not negative and couldn\'t be\n+\t * revalidated (shouldn\'t happen).\n+\t */\n+\tBUG_ON(!valid && dentry->d_inode);\n+\n+\tlower_dentry = find_writeable_branch(dir, dentry);\n+\tif (IS_ERR(lower_dentry)) {\n+\t\terr = PTR_ERR(lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tlower_parent_dentry = lock_parent(lower_dentry);\n+\tif (IS_ERR(lower_parent_dentry)) {\n+\t\terr = PTR_ERR(lower_parent_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\terr = vfs_mknod(lower_parent_dentry->d_inode, lower_dentry, mode, dev);\n+\tif (!err) {\n+\t\terr = PTR_ERR(unionfs_interpose(dentry, dir->i_sb, 0));\n+\t\tif (!err) {\n+\t\t\tunionfs_copy_attr_times(dir);\n+\t\t\tfsstack_copy_inode_size(dir,\n+\t\t\t\t\t\tlower_parent_dentry->d_inode);\n+\t\t\t/* update no. of links on parent directory */\n+\t\t\tdir->i_nlink = unionfs_get_nlinks(dir);\n+\t\t}\n+\t}\n+\n+\tunlock_dir(lower_parent_dentry);\n+\n+out:\n+\tdput(wh_dentry);\n+\tkfree(name);\n+\n+\tif (!err) {\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_check_inode(dir);\n+\t\tunionfs_check_dentry(dentry);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/* requires sb, dentry, and parent to already be locked */\n+static int __unionfs_readlink(struct dentry *dentry, char __user *buf,\n+\t\t\t      int bufsiz)\n+{\n+\tint err;\n+\tstruct dentry *lower_dentry;\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\tif (!lower_dentry->d_inode->i_op ||\n+\t    !lower_dentry->d_inode->i_op->readlink) {\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\terr = lower_dentry->d_inode->i_op->readlink(lower_dentry,\n+\t\t\t\t\t\t    buf, bufsiz);\n+\tif (err >= 0)\n+\t\tfsstack_copy_attr_atime(dentry->d_inode,\n+\t\t\t\t\tlower_dentry->d_inode);\n+\n+out:\n+\treturn err;\n+}\n+\n+static int unionfs_readlink(struct dentry *dentry, char __user *buf,\n+\t\t\t    int bufsiz)\n+{\n+\tint err;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tif (unlikely(!__unionfs_d_revalidate(dentry, parent, false))) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\terr = __unionfs_readlink(dentry, buf, bufsiz);\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn err;\n+}\n+\n+static void *unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)\n+{\n+\tchar *buf;\n+\tint len = PAGE_SIZE, err;\n+\tmm_segment_t old_fs;\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\t/* This is freed by the put_link method assuming a successful call. */\n+\tbuf = kmalloc(len, GFP_KERNEL);\n+\tif (unlikely(!buf)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\t/* read the symlink, and then we will follow it */\n+\told_fs = get_fs();\n+\tset_fs(KERNEL_DS);\n+\terr = __unionfs_readlink(dentry, buf, len);\n+\tset_fs(old_fs);\n+\tif (err < 0) {\n+\t\tkfree(buf);\n+\t\tbuf = NULL;\n+\t\tgoto out;\n+\t}\n+\tbuf[err] = 0;\n+\tnd_set_link(nd, buf);\n+\terr = 0;\n+\n+out:\n+\tif (err >= 0) {\n+\t\tunionfs_check_nd(nd);\n+\t\tunionfs_check_dentry(dentry);\n+\t}\n+\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn ERR_PTR(err);\n+}\n+\n+/* this @nd *IS* still used */\n+static void unionfs_put_link(struct dentry *dentry, struct nameidata *nd,\n+\t\t\t     void *cookie)\n+{\n+\tstruct dentry *parent;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tif (unlikely(!__unionfs_d_revalidate(dentry, parent, false)))\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: put_link failed to revalidate dentry\\n");\n+\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_check_nd(nd);\n+\tkfree(nd_get_link(nd));\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+}\n+\n+/*\n+ * This is a variant of fs/namei.c:permission() or inode_permission() which\n+ * skips over EROFS tests (because we perform copyup on EROFS).\n+ */\n+static int __inode_permission(struct inode *inode, int mask,\n+\t\t\t      struct nameidata *nd)\n+{\n+\tint retval;\n+\n+\t/* nobody gets write access to an immutable file */\n+\tif ((mask & MAY_WRITE) && IS_IMMUTABLE(inode))\n+\t\treturn -EACCES;\n+\n+\t/* Ordinary permission routines do not understand MAY_APPEND. */\n+\tif (inode->i_op && inode->i_op->permission) {\n+\t\tretval = inode->i_op->permission(inode, mask, nd);\n+\t\tif (!retval) {\n+\t\t\t/*\n+\t\t\t * Exec permission on a regular file is denied if none\n+\t\t\t * of the execute bits are set.\n+\t\t\t *\n+\t\t\t * This check should be done by the ->permission()\n+\t\t\t * method.\n+\t\t\t */\n+\t\t\tif ((mask & MAY_EXEC) && S_ISREG(inode->i_mode) &&\n+\t\t\t    !(inode->i_mode & S_IXUGO))\n+\t\t\t\treturn -EACCES;\n+\t\t}\n+\t} else {\n+\t\tretval = generic_permission(inode, mask, NULL);\n+\t}\n+\tif (retval)\n+\t\treturn retval;\n+\n+\treturn security_inode_permission(inode,\n+\t\t\t mask & (MAY_READ|MAY_WRITE|MAY_EXEC|MAY_APPEND),\n+\t\t\t nd);\n+}\n+\n+/*\n+ * Don\'t grab the superblock read-lock in unionfs_permission, which prevents\n+ * a deadlock with the branch-management "add branch" code (which grabbed\n+ * the write lock).  It is safe to not grab the read lock here, because even\n+ * with branch management taking place, there is no chance that\n+ * unionfs_permission, or anything it calls, will use stale branch\n+ * information.\n+ */\n+static int unionfs_permission(struct inode *inode, int mask,\n+\t\t\t      struct nameidata *nd)\n+{\n+\tstruct inode *lower_inode = NULL;\n+\tint err = 0;\n+\tint bindex, bstart, bend;\n+\tconst int is_file = !S_ISDIR(inode->i_mode);\n+\tconst int write_mask = (mask & MAY_WRITE) && !(mask & MAY_READ);\n+\tstruct inode *inode_grabbed = igrab(inode);\n+\n+\tif (nd)\n+\t\tunionfs_lock_dentry(nd->dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tif (!UNIONFS_I(inode)->lower_inodes) {\n+\t\tif (is_file)\t/* dirs can be unlinked but chdir\'ed to */\n+\t\t\terr = -ESTALE;\t/* force revalidate */\n+\t\tgoto out;\n+\t}\n+\tbstart = ibstart(inode);\n+\tbend = ibend(inode);\n+\tif (unlikely(bstart < 0 || bend < 0)) {\n+\t\t/*\n+\t\t * With branch-management, we can get a stale inode here.\n+\t\t * If so, we return ESTALE back to link_path_walk, which\n+\t\t * would discard the dcache entry and re-lookup the\n+\t\t * dentry+inode.  This should be equivalent to issuing\n+\t\t * __unionfs_d_revalidate_chain on nd.dentry here.\n+\t\t */\n+\t\tif (is_file)\t/* dirs can be unlinked but chdir\'ed to */\n+\t\t\terr = -ESTALE;\t/* force revalidate */\n+\t\tgoto out;\n+\t}\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode)\n+\t\t\tcontinue;\n+\n+\t\t/*\n+\t\t * check the condition for D-F-D underlying files/directories,\n+\t\t * we don\'t have to check for files, if we are checking for\n+\t\t * directories.\n+\t\t */\n+\t\tif (!is_file && !S_ISDIR(lower_inode->i_mode))\n+\t\t\tcontinue;\n+\n+\t\t/*\n+\t\t * We check basic permissions, but we ignore any conditions\n+\t\t * such as readonly file systems or branches marked as\n+\t\t * readonly, because those conditions should lead to a\n+\t\t * copyup taking place later on.  However, if user never had\n+\t\t * access to the file, then no copyup could ever take place.\n+\t\t */\n+\t\terr = __inode_permission(lower_inode, mask, nd);\n+\t\tif (err && err != -EACCES && err != EPERM && bindex > 0) {\n+\t\t\tumode_t mode = lower_inode->i_mode;\n+\t\t\tif ((is_robranch_super(inode->i_sb, bindex) ||\n+\t\t\t     IS_RDONLY(lower_inode)) &&\n+\t\t\t    (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode)))\n+\t\t\t\terr = 0;\n+\t\t\tif (IS_COPYUP_ERR(err))\n+\t\t\t\terr = 0;\n+\t\t}\n+\n+\t\t/*\n+\t\t * The permissions are an intersection of the overall directory\n+\t\t * permissions, so we fail if one fails.\n+\t\t */\n+\t\tif (err)\n+\t\t\tgoto out;\n+\n+\t\t/* only the leftmost file matters. */\n+\t\tif (is_file || write_mask) {\n+\t\t\tif (is_file && write_mask) {\n+\t\t\t\terr = get_write_access(lower_inode);\n+\t\t\t\tif (!err)\n+\t\t\t\t\tput_write_access(lower_inode);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\t/* sync times which may have changed (asynchronously) below */\n+\tunionfs_copy_attr_times(inode);\n+\n+out:\n+\tunionfs_check_inode(inode);\n+\tunionfs_check_nd(nd);\n+\tif (nd)\n+\t\tunionfs_unlock_dentry(nd->dentry);\n+\tiput(inode_grabbed);\n+\treturn err;\n+}\n+\n+static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *parent;\n+\tstruct inode *inode;\n+\tstruct inode *lower_inode;\n+\tint bstart, bend, bindex;\n+\tloff_t size;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tif (unlikely(!__unionfs_d_revalidate(dentry, parent, false))) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\tinode = dentry->d_inode;\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\tif (!lower_dentry) { /* should never happen after above revalidate */\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\tlower_inode = unionfs_lower_inode(inode);\n+\n+\t/* check if user has permission to change lower inode */\n+\terr = inode_change_ok(lower_inode, ia);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* copyup if the file is on a read only branch */\n+\tif (is_robranch_super(dentry->d_sb, bstart)\n+\t    || IS_RDONLY(lower_inode)) {\n+\t\t/* check if we have a branch to copy up to */\n+\t\tif (bstart <= 0) {\n+\t\t\terr = -EACCES;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tif (ia->ia_valid & ATTR_SIZE)\n+\t\t\tsize = ia->ia_size;\n+\t\telse\n+\t\t\tsize = i_size_read(inode);\n+\t\t/* copyup to next available branch */\n+\t\tfor (bindex = bstart - 1; bindex >= 0; bindex--) {\n+\t\t\terr = copyup_dentry(parent->d_inode,\n+\t\t\t\t\t    dentry, bstart, bindex,\n+\t\t\t\t\t    dentry->d_name.name,\n+\t\t\t\t\t    dentry->d_name.len,\n+\t\t\t\t\t    NULL, size);\n+\t\t\tif (!err)\n+\t\t\t\tbreak;\n+\t\t}\n+\t\tif (err)\n+\t\t\tgoto out;\n+\t\t/* get updated lower_dentry/inode after copyup */\n+\t\tlower_dentry = unionfs_lower_dentry(dentry);\n+\t\tlower_inode = unionfs_lower_inode(inode);\n+\t}\n+\n+\t/*\n+\t * If shrinking, first truncate upper level to cancel writing dirty\n+\t * pages beyond the new eof; and also if its\' maxbytes is more\n+\t * limiting (fail with -EFBIG before making any change to the lower\n+\t * level).  There is no need to vmtruncate the upper level\n+\t * afterwards in the other cases: we fsstack_copy_inode_size from\n+\t * the lower level.\n+\t */\n+\tif (ia->ia_valid & ATTR_SIZE) {\n+\t\tsize = i_size_read(inode);\n+\t\tif (ia->ia_size < size || (ia->ia_size > size &&\n+\t\t    inode->i_sb->s_maxbytes < lower_inode->i_sb->s_maxbytes)) {\n+\t\t\terr = vmtruncate(inode, ia->ia_size);\n+\t\t\tif (err)\n+\t\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\t/* notify the (possibly copied-up) lower inode */\n+\tmutex_lock(&lower_inode->i_mutex);\n+\terr = notify_change(lower_dentry, ia);\n+\tmutex_unlock(&lower_inode->i_mutex);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* get attributes from the first lower inode */\n+\tunionfs_copy_attr_all(inode, lower_inode);\n+\t/*\n+\t * unionfs_copy_attr_all will copy the lower times to our inode if\n+\t * the lower ones are newer (useful for cache coherency).  However,\n+\t * ->setattr is the only place in which we may have to copy the\n+\t * lower inode times absolutely, to support utimes(2).\n+\t */\n+\tif (ia->ia_valid & ATTR_MTIME_SET)\n+\t\tinode->i_mtime = lower_inode->i_mtime;\n+\tif (ia->ia_valid & ATTR_CTIME)\n+\t\tinode->i_ctime = lower_inode->i_ctime;\n+\tif (ia->ia_valid & ATTR_ATIME_SET)\n+\t\tinode->i_atime = lower_inode->i_atime;\n+\tfsstack_copy_inode_size(inode, lower_inode);\n+\n+out:\n+\tif (!err)\n+\t\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\n+\treturn err;\n+}\n+\n+struct inode_operations unionfs_symlink_iops = {\n+\t.readlink\t= unionfs_readlink,\n+\t.permission\t= unionfs_permission,\n+\t.follow_link\t= unionfs_follow_link,\n+\t.setattr\t= unionfs_setattr,\n+\t.put_link\t= unionfs_put_link,\n+};\n+\n+struct inode_operations unionfs_dir_iops = {\n+\t.create\t\t= unionfs_create,\n+\t.lookup\t\t= unionfs_lookup,\n+\t.link\t\t= unionfs_link,\n+\t.unlink\t\t= unionfs_unlink,\n+\t.symlink\t= unionfs_symlink,\n+\t.mkdir\t\t= unionfs_mkdir,\n+\t.rmdir\t\t= unionfs_rmdir,\n+\t.mknod\t\t= unionfs_mknod,\n+\t.rename\t\t= unionfs_rename,\n+\t.permission\t= unionfs_permission,\n+\t.setattr\t= unionfs_setattr,\n+#ifdef CONFIG_UNION_FS_XATTR\n+\t.setxattr\t= unionfs_setxattr,\n+\t.getxattr\t= unionfs_getxattr,\n+\t.removexattr\t= unionfs_removexattr,\n+\t.listxattr\t= unionfs_listxattr,\n+#endif /* CONFIG_UNION_FS_XATTR */\n+};\n+\n+struct inode_operations unionfs_main_iops = {\n+\t.permission\t= unionfs_permission,\n+\t.setattr\t= unionfs_setattr,\n+#ifdef CONFIG_UNION_FS_XATTR\n+\t.setxattr\t= unionfs_setxattr,\n+\t.getxattr\t= unionfs_getxattr,\n+\t.removexattr\t= unionfs_removexattr,\n+\t.listxattr\t= unionfs_listxattr,\n+#endif /* CONFIG_UNION_FS_XATTR */\n+};'),
 ('dev/null',
  'b/fs/unionfs/lookup.c',
  'diff --git a/fs/unionfs/lookup.c b/fs/unionfs/lookup.c\nnew file mode 100644\nindex 0000000..3363f67\n--- dev/null\n+++ b/fs/unionfs/lookup.c\n@@ -0,0 +1,572 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * Lookup one path component @name relative to a <base,mnt> path pair.\n+ * Behaves nearly the same as lookup_one_len (i.e., return negative dentry\n+ * on ENOENT), but uses the @mnt passed, so it can cross bind mounts and\n+ * other lower mounts properly.  If @new_mnt is non-null, will fill in the\n+ * new mnt there.  Caller is responsible to dput/mntput/path_put returned\n+ * @dentry and @new_mnt.\n+ */\n+struct dentry *__lookup_one(struct dentry *base, struct vfsmount *mnt,\n+\t\t\t    const char *name, struct vfsmount **new_mnt)\n+{\n+\tstruct dentry *dentry = NULL;\n+\tstruct nameidata lower_nd;\n+\tint err;\n+\n+\t/* we use flags=0 to get basic lookup */\n+\terr = vfs_path_lookup(base, mnt, name, 0, &lower_nd);\n+\n+\tswitch (err) {\n+\tcase 0: /* no error */\n+\t\tdentry = lower_nd.dentry;\n+\t\tif (new_mnt)\n+\t\t\t*new_mnt = lower_nd.mnt; /* rc already inc\'ed */\n+\t\tbreak;\n+\tcase -ENOENT:\n+\t\t /*\n+\t\t  * We don\'t consider ENOENT an error, and we want to return\n+\t\t  * a negative dentry (ala lookup_one_len).  As we know\n+\t\t  * there was no inode for this name before (-ENOENT), then\n+\t\t  * it\'s safe to call lookup_one_len (which doesn\'t take a\n+\t\t  * vfsmount).\n+\t\t  */\n+\t\tdentry = lookup_one_len(name, base, strlen(name));\n+\t\tif (new_mnt)\n+\t\t\t*new_mnt = mntget(lower_nd.mnt);\n+\t\tbreak;\n+\tdefault: /* all other real errors */\n+\t\tdentry = ERR_PTR(err);\n+\t\tbreak;\n+\t}\n+\n+\treturn dentry;\n+}\n+\n+/*\n+ * This is a utility function that fills in a unionfs dentry.\n+ * Caller must lock this dentry with unionfs_lock_dentry.\n+ *\n+ * Returns: 0 (ok), or -ERRNO if an error occurred.\n+ * XXX: get rid of _partial_lookup and make callers call _lookup_full directly\n+ */\n+int unionfs_partial_lookup(struct dentry *dentry, struct dentry *parent)\n+{\n+\tstruct dentry *tmp;\n+\tint err = -ENOSYS;\n+\n+\ttmp = unionfs_lookup_full(dentry, parent, INTERPOSE_PARTIAL);\n+\n+\tif (!tmp) {\n+\t\terr = 0;\n+\t\tgoto out;\n+\t}\n+\tif (IS_ERR(tmp)) {\n+\t\terr = PTR_ERR(tmp);\n+\t\tgoto out;\n+\t}\n+\t/* XXX: need to change the interface */\n+\tBUG_ON(tmp != dentry);\n+out:\n+\treturn err;\n+}\n+\n+/* The dentry cache is just so we have properly sized dentries. */\n+static struct kmem_cache *unionfs_dentry_cachep;\n+int unionfs_init_dentry_cache(void)\n+{\n+\tunionfs_dentry_cachep =\n+\t\tkmem_cache_create("unionfs_dentry",\n+\t\t\t\t  sizeof(struct unionfs_dentry_info),\n+\t\t\t\t  0, SLAB_RECLAIM_ACCOUNT, NULL);\n+\n+\treturn (unionfs_dentry_cachep ? 0 : -ENOMEM);\n+}\n+\n+void unionfs_destroy_dentry_cache(void)\n+{\n+\tif (unionfs_dentry_cachep)\n+\t\tkmem_cache_destroy(unionfs_dentry_cachep);\n+}\n+\n+void free_dentry_private_data(struct dentry *dentry)\n+{\n+\tif (!dentry || !dentry->d_fsdata)\n+\t\treturn;\n+\tkfree(UNIONFS_D(dentry)->lower_paths);\n+\tUNIONFS_D(dentry)->lower_paths = NULL;\n+\tkmem_cache_free(unionfs_dentry_cachep, dentry->d_fsdata);\n+\tdentry->d_fsdata = NULL;\n+}\n+\n+static inline int __realloc_dentry_private_data(struct dentry *dentry)\n+{\n+\tstruct unionfs_dentry_info *info = UNIONFS_D(dentry);\n+\tvoid *p;\n+\tint size;\n+\n+\tBUG_ON(!info);\n+\n+\tsize = sizeof(struct path) * sbmax(dentry->d_sb);\n+\tp = krealloc(info->lower_paths, size, GFP_ATOMIC);\n+\tif (unlikely(!p))\n+\t\treturn -ENOMEM;\n+\n+\tinfo->lower_paths = p;\n+\n+\tinfo->bstart = -1;\n+\tinfo->bend = -1;\n+\tinfo->bopaque = -1;\n+\tinfo->bcount = sbmax(dentry->d_sb);\n+\tatomic_set(&info->generation,\n+\t\t\tatomic_read(&UNIONFS_SB(dentry->d_sb)->generation));\n+\n+\tmemset(info->lower_paths, 0, size);\n+\n+\treturn 0;\n+}\n+\n+/* UNIONFS_D(dentry)->lock must be locked */\n+int realloc_dentry_private_data(struct dentry *dentry)\n+{\n+\tif (!__realloc_dentry_private_data(dentry))\n+\t\treturn 0;\n+\n+\tkfree(UNIONFS_D(dentry)->lower_paths);\n+\tfree_dentry_private_data(dentry);\n+\treturn -ENOMEM;\n+}\n+\n+/* allocate new dentry private data */\n+int new_dentry_private_data(struct dentry *dentry, int subclass)\n+{\n+\tstruct unionfs_dentry_info *info = UNIONFS_D(dentry);\n+\n+\tBUG_ON(info);\n+\n+\tinfo = kmem_cache_alloc(unionfs_dentry_cachep, GFP_ATOMIC);\n+\tif (unlikely(!info))\n+\t\treturn -ENOMEM;\n+\n+\tmutex_init(&info->lock);\n+\tmutex_lock_nested(&info->lock, subclass);\n+\n+\tinfo->lower_paths = NULL;\n+\n+\tdentry->d_fsdata = info;\n+\n+\tif (!__realloc_dentry_private_data(dentry))\n+\t\treturn 0;\n+\n+\tmutex_unlock(&info->lock);\n+\tfree_dentry_private_data(dentry);\n+\treturn -ENOMEM;\n+}\n+\n+/*\n+ * scan through the lower dentry objects, and set bstart to reflect the\n+ * starting branch\n+ */\n+void update_bstart(struct dentry *dentry)\n+{\n+\tint bindex;\n+\tint bstart = dbstart(dentry);\n+\tint bend = dbend(dentry);\n+\tstruct dentry *lower_dentry;\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\t\tif (lower_dentry->d_inode) {\n+\t\t\tdbstart(dentry) = bindex;\n+\t\t\tbreak;\n+\t\t}\n+\t\tdput(lower_dentry);\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t}\n+}\n+\n+\n+/*\n+ * Initialize a nameidata structure (the intent part) we can pass to a lower\n+ * file system.  Returns 0 on success or -error (only -ENOMEM possible).\n+ * Inside that nd structure, this function may also return an allocated\n+ * struct file (for open intents).  The caller, when done with this nd, must\n+ * kfree the intent file (using release_lower_nd).\n+ *\n+ * XXX: this code, and the callers of this code, should be redone using\n+ * vfs_path_lookup() when (1) the nameidata structure is refactored into a\n+ * separate intent-structure, and (2) open_namei() is broken into a VFS-only\n+ * function and a method that other file systems can call.\n+ */\n+int init_lower_nd(struct nameidata *nd, unsigned int flags)\n+{\n+\tint err = 0;\n+#ifdef ALLOC_LOWER_ND_FILE\n+\t/*\n+\t * XXX: one day we may need to have the lower return an open file\n+\t * for us.  It is not needed in 2.6.23-rc1 for nfs2/nfs3, but may\n+\t * very well be needed for nfs4.\n+\t */\n+\tstruct file *file;\n+#endif /* ALLOC_LOWER_ND_FILE */\n+\n+\tmemset(nd, 0, sizeof(struct nameidata));\n+\tif (!flags)\n+\t\treturn err;\n+\n+\tswitch (flags) {\n+\tcase LOOKUP_CREATE:\n+\t\tnd->intent.open.flags |= O_CREAT;\n+\t\t/* fall through: shared code for create/open cases */\n+\tcase LOOKUP_OPEN:\n+\t\tnd->flags = flags;\n+\t\tnd->intent.open.flags |= (FMODE_READ | FMODE_WRITE);\n+#ifdef ALLOC_LOWER_ND_FILE\n+\t\tfile = kzalloc(sizeof(struct file), GFP_KERNEL);\n+\t\tif (unlikely(!file)) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tbreak; /* exit switch statement and thus return */\n+\t\t}\n+\t\tnd->intent.open.file = file;\n+#endif /* ALLOC_LOWER_ND_FILE */\n+\t\tbreak;\n+\tcase LOOKUP_ACCESS:\n+\t\tnd->flags = flags;\n+\t\tbreak;\n+\tdefault:\n+\t\t/*\n+\t\t * We should never get here, for now.\n+\t\t * We can add new cases here later on.\n+\t\t */\n+\t\tpr_debug("unionfs: unknown nameidata flag 0x%x\\n", flags);\n+\t\tBUG();\n+\t\tbreak;\n+\t}\n+\n+\treturn err;\n+}\n+\n+void release_lower_nd(struct nameidata *nd, int err)\n+{\n+\tif (!nd->intent.open.file)\n+\t\treturn;\n+\telse if (!err)\n+\t\trelease_open_intent(nd);\n+#ifdef ALLOC_LOWER_ND_FILE\n+\tkfree(nd->intent.open.file);\n+#endif /* ALLOC_LOWER_ND_FILE */\n+}\n+\n+/*\n+ * Main (and complex) driver function for Unionfs\'s lookup\n+ *\n+ * Returns: NULL (ok), ERR_PTR if an error occurred, or a non-null non-error\n+ * PTR if d_splice returned a different dentry.\n+ *\n+ * If lookupmode is INTERPOSE_PARTIAL/REVAL/REVAL_NEG, the passed dentry\'s\n+ * inode info must be locked.  If lookupmode is INTERPOSE_LOOKUP (i.e., a\n+ * newly looked-up dentry), then unionfs_lookup_backend will return a locked\n+ * dentry\'s info, which the caller must unlock.\n+ */\n+struct dentry *unionfs_lookup_full(struct dentry *dentry,\n+\t\t\t\t   struct dentry *parent, int lookupmode)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct vfsmount *lower_mnt;\n+\tstruct vfsmount *lower_dir_mnt;\n+\tstruct dentry *wh_lower_dentry = NULL;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\tstruct dentry *d_interposed = NULL;\n+\tint bindex, bstart, bend, bopaque;\n+\tint opaque, num_positive = 0;\n+\tconst char *name;\n+\tint namelen;\n+\tint pos_start, pos_end;\n+\n+\t/*\n+\t * We should already have a lock on this dentry in the case of a\n+\t * partial lookup, or a revalidation.  Otherwise it is returned from\n+\t * new_dentry_private_data already locked.\n+\t */\n+\tverify_locked(dentry);\n+\tverify_locked(parent);\n+\n+\t/* must initialize dentry operations */\n+\tdentry->d_op = &unionfs_dops;\n+\n+\t/* We never partial lookup the root directory. */\n+\tif (IS_ROOT(dentry))\n+\t\tgoto out;\n+\n+\tname = dentry->d_name.name;\n+\tnamelen = dentry->d_name.len;\n+\n+\t/* No dentries should get created for possible whiteout names. */\n+\tif (!is_validname(name)) {\n+\t\terr = -EPERM;\n+\t\tgoto out_free;\n+\t}\n+\n+\t/* Now start the actual lookup procedure. */\n+\tbstart = dbstart(parent);\n+\tbend = dbend(parent);\n+\tbopaque = dbopaque(parent);\n+\tBUG_ON(bstart < 0);\n+\n+\t/* adjust bend to bopaque if needed */\n+\tif ((bopaque >= 0) && (bopaque < bend))\n+\t\tbend = bopaque;\n+\n+\t/* lookup all possible dentries */\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tlower_mnt = unionfs_lower_mnt_idx(dentry, bindex);\n+\n+\t\t/* skip if we already have a positive lower dentry */\n+\t\tif (lower_dentry) {\n+\t\t\tif (dbstart(dentry) < 0)\n+\t\t\t\tdbstart(dentry) = bindex;\n+\t\t\tif (bindex > dbend(dentry))\n+\t\t\t\tdbend(dentry) = bindex;\n+\t\t\tif (lower_dentry->d_inode)\n+\t\t\t\tnum_positive++;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tlower_dir_dentry =\n+\t\t\tunionfs_lower_dentry_idx(parent, bindex);\n+\t\t/* if the lower dentry\'s parent does not exist, skip this */\n+\t\tif (!lower_dir_dentry || !lower_dir_dentry->d_inode)\n+\t\t\tcontinue;\n+\n+\t\t/* also skip it if the parent isn\'t a directory. */\n+\t\tif (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))\n+\t\t\tcontinue; /* XXX: should be BUG_ON */\n+\n+\t\t/* check for whiteouts: stop lookup if found */\n+\t\twh_lower_dentry = lookup_whiteout(name, lower_dir_dentry);\n+\t\tif (IS_ERR(wh_lower_dentry)) {\n+\t\t\terr = PTR_ERR(wh_lower_dentry);\n+\t\t\tgoto out_free;\n+\t\t}\n+\t\tif (wh_lower_dentry->d_inode) {\n+\t\t\tdbend(dentry) = dbopaque(dentry) = bindex;\n+\t\t\tif (dbstart(dentry) < 0)\n+\t\t\t\tdbstart(dentry) = bindex;\n+\t\t\tdput(wh_lower_dentry);\n+\t\t\tbreak;\n+\t\t}\n+\t\tdput(wh_lower_dentry);\n+\n+\t\t/* Now do regular lookup; lookup @name */\n+\t\tlower_dir_mnt = unionfs_lower_mnt_idx(parent, bindex);\n+\t\tlower_mnt = NULL; /* XXX: needed? */\n+\n+\t\tlower_dentry = __lookup_one(lower_dir_dentry, lower_dir_mnt,\n+\t\t\t\t\t    name, &lower_mnt);\n+\n+\t\tif (IS_ERR(lower_dentry)) {\n+\t\t\terr = PTR_ERR(lower_dentry);\n+\t\t\tgoto out_free;\n+\t\t}\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);\n+\t\tif (!lower_mnt)\n+\t\t\tlower_mnt = unionfs_mntget(dentry->d_sb->s_root,\n+\t\t\t\t\t\t   bindex);\n+\t\tunionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);\n+\n+\t\t/* adjust dbstart/end */\n+\t\tif (dbstart(dentry) < 0)\n+\t\t\tdbstart(dentry) = bindex;\n+\t\tif (bindex > dbend(dentry))\n+\t\t\tdbend(dentry) = bindex;\n+\t\t/*\n+\t\t * We always store the lower dentries above, and update\n+\t\t * dbstart/dbend, even if the whole unionfs dentry is\n+\t\t * negative (i.e., no lower inodes).\n+\t\t */\n+\t\tif (!lower_dentry->d_inode)\n+\t\t\tcontinue;\n+\t\tnum_positive++;\n+\n+\t\t/*\n+\t\t * check if we just found an opaque directory, if so, stop\n+\t\t * lookups here.\n+\t\t */\n+\t\tif (!S_ISDIR(lower_dentry->d_inode->i_mode))\n+\t\t\tcontinue;\n+\t\topaque = is_opaque_dir(dentry, bindex);\n+\t\tif (opaque < 0) {\n+\t\t\terr = opaque;\n+\t\t\tgoto out_free;\n+\t\t} else if (opaque) {\n+\t\t\tdbend(dentry) = dbopaque(dentry) = bindex;\n+\t\t\tbreak;\n+\t\t}\n+\t\tdbend(dentry) = bindex;\n+\n+\t\t/* update parent directory\'s atime with the bindex */\n+\t\tfsstack_copy_attr_atime(parent->d_inode,\n+\t\t\t\t\tlower_dir_dentry->d_inode);\n+\t}\n+\n+\t/* sanity checks, then decide if to process a negative dentry */\n+\tBUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);\n+\tBUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);\n+\n+\tif (num_positive > 0)\n+\t\tgoto out_positive;\n+\n+\t/*** handle NEGATIVE dentries ***/\n+\n+\t/*\n+\t * If negative, keep only first lower negative dentry, to save on\n+\t * memory.\n+\t */\n+\tif (dbstart(dentry) < dbend(dentry)) {\n+\t\tpath_put_lowers(dentry, dbstart(dentry) + 1,\n+\t\t\t\tdbend(dentry), false);\n+\t\tdbend(dentry) = dbstart(dentry);\n+\t}\n+\tif (lookupmode == INTERPOSE_PARTIAL)\n+\t\tgoto out;\n+\tif (lookupmode == INTERPOSE_LOOKUP) {\n+\t\t/*\n+\t\t * If all we found was a whiteout in the first available\n+\t\t * branch, then create a negative dentry for a possibly new\n+\t\t * file to be created.\n+\t\t */\n+\t\tif (dbopaque(dentry) < 0)\n+\t\t\tgoto out;\n+\t\t/* XXX: need to get mnt here */\n+\t\tbindex = dbstart(dentry);\n+\t\tif (unionfs_lower_dentry_idx(dentry, bindex))\n+\t\t\tgoto out;\n+\t\tlower_dir_dentry =\n+\t\t\tunionfs_lower_dentry_idx(parent, bindex);\n+\t\tif (!lower_dir_dentry || !lower_dir_dentry->d_inode)\n+\t\t\tgoto out;\n+\t\tif (!S_ISDIR(lower_dir_dentry->d_inode->i_mode))\n+\t\t\tgoto out; /* XXX: should be BUG_ON */\n+\t\t/* XXX: do we need to cross bind mounts here? */\n+\t\tlower_dentry = lookup_one_len(name, lower_dir_dentry, namelen);\n+\t\tif (IS_ERR(lower_dentry)) {\n+\t\t\terr = PTR_ERR(lower_dentry);\n+\t\t\tgoto out;\n+\t\t}\n+\t\t/* XXX: need to mntget/mntput as needed too! */\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);\n+\t\t/* XXX: wrong mnt for crossing bind mounts! */\n+\t\tlower_mnt = unionfs_mntget(dentry->d_sb->s_root, bindex);\n+\t\tunionfs_set_lower_mnt_idx(dentry, bindex, lower_mnt);\n+\n+\t\tgoto out;\n+\t}\n+\n+\t/* if we\'re revalidating a positive dentry, don\'t make it negative */\n+\tif (lookupmode != INTERPOSE_REVAL)\n+\t\td_add(dentry, NULL);\n+\n+\tgoto out;\n+\n+out_positive:\n+\t/*** handle POSITIVE dentries ***/\n+\n+\t/*\n+\t * This unionfs dentry is positive (at least one lower inode\n+\t * exists), so scan entire dentry from beginning to end, and remove\n+\t * any negative lower dentries, if any.  Then, update dbstart/dbend\n+\t * to reflect the start/end of positive dentries.\n+\t */\n+\tpos_start = pos_end = -1;\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry,\n+\t\t\t\t\t\t\tbindex);\n+\t\tif (lower_dentry && lower_dentry->d_inode) {\n+\t\t\tif (pos_start < 0)\n+\t\t\t\tpos_start = bindex;\n+\t\t\tif (bindex > pos_end)\n+\t\t\t\tpos_end = bindex;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tpath_put_lowers(dentry, bindex, bindex, false);\n+\t}\n+\tif (pos_start >= 0)\n+\t\tdbstart(dentry) = pos_start;\n+\tif (pos_end >= 0)\n+\t\tdbend(dentry) = pos_end;\n+\n+\t/* Partial lookups need to re-interpose, or throw away older negs. */\n+\tif (lookupmode == INTERPOSE_PARTIAL) {\n+\t\tif (dentry->d_inode) {\n+\t\t\tunionfs_reinterpose(dentry);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\t/*\n+\t\t * This dentry was positive, so it is as if we had a\n+\t\t * negative revalidation.\n+\t\t */\n+\t\tlookupmode = INTERPOSE_REVAL_NEG;\n+\t\tupdate_bstart(dentry);\n+\t}\n+\n+\t/*\n+\t * Interpose can return a dentry if d_splice returned a different\n+\t * dentry.\n+\t */\n+\td_interposed = unionfs_interpose(dentry, dentry->d_sb, lookupmode);\n+\tif (IS_ERR(d_interposed))\n+\t\terr = PTR_ERR(d_interposed);\n+\telse if (d_interposed)\n+\t\tdentry = d_interposed;\n+\n+\tif (!err)\n+\t\tgoto out;\n+\td_drop(dentry);\n+\n+out_free:\n+\t/* should dput/mntput all the underlying dentries on error condition */\n+\tif (dbstart(dentry) >= 0)\n+\t\tpath_put_lowers_all(dentry, false);\n+\t/* free lower_paths unconditionally */\n+\tkfree(UNIONFS_D(dentry)->lower_paths);\n+\tUNIONFS_D(dentry)->lower_paths = NULL;\n+\n+out:\n+\tif (dentry && UNIONFS_D(dentry)) {\n+\t\tBUG_ON(dbstart(dentry) < 0 && dbend(dentry) >= 0);\n+\t\tBUG_ON(dbstart(dentry) >= 0 && dbend(dentry) < 0);\n+\t}\n+\tif (d_interposed && UNIONFS_D(d_interposed)) {\n+\t\tBUG_ON(dbstart(d_interposed) < 0 && dbend(d_interposed) >= 0);\n+\t\tBUG_ON(dbstart(d_interposed) >= 0 && dbend(d_interposed) < 0);\n+\t}\n+\n+\tif (!err && d_interposed)\n+\t\treturn d_interposed;\n+\treturn ERR_PTR(err);\n+}'),
 ('dev/null',
  'b/fs/unionfs/main.c',
  'diff --git a/fs/unionfs/main.c b/fs/unionfs/main.c\nnew file mode 100644\nindex 0000000..e9ae963\n--- dev/null\n+++ b/fs/unionfs/main.c\n@@ -0,0 +1,778 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+#include <linux/module.h>\n+#include <linux/moduleparam.h>\n+\n+static void unionfs_fill_inode(struct dentry *dentry,\n+\t\t\t       struct inode *inode)\n+{\n+\tstruct inode *lower_inode;\n+\tstruct dentry *lower_dentry;\n+\tint bindex, bstart, bend;\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry) {\n+\t\t\tunionfs_set_lower_inode_idx(inode, bindex, NULL);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* Initialize the lower inode to the new lower inode. */\n+\t\tif (!lower_dentry->d_inode)\n+\t\t\tcontinue;\n+\n+\t\tunionfs_set_lower_inode_idx(inode, bindex,\n+\t\t\t\t\t    igrab(lower_dentry->d_inode));\n+\t}\n+\n+\tibstart(inode) = dbstart(dentry);\n+\tibend(inode) = dbend(dentry);\n+\n+\t/* Use attributes from the first branch. */\n+\tlower_inode = unionfs_lower_inode(inode);\n+\n+\t/* Use different set of inode ops for symlinks & directories */\n+\tif (S_ISLNK(lower_inode->i_mode))\n+\t\tinode->i_op = &unionfs_symlink_iops;\n+\telse if (S_ISDIR(lower_inode->i_mode))\n+\t\tinode->i_op = &unionfs_dir_iops;\n+\n+\t/* Use different set of file ops for directories */\n+\tif (S_ISDIR(lower_inode->i_mode))\n+\t\tinode->i_fop = &unionfs_dir_fops;\n+\n+\t/* properly initialize special inodes */\n+\tif (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||\n+\t    S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode))\n+\t\tinit_special_inode(inode, lower_inode->i_mode,\n+\t\t\t\t   lower_inode->i_rdev);\n+\n+\t/* all well, copy inode attributes */\n+\tunionfs_copy_attr_all(inode, lower_inode);\n+\tfsstack_copy_inode_size(inode, lower_inode);\n+}\n+\n+/*\n+ * Connect a unionfs inode dentry/inode with several lower ones.  This is\n+ * the classic stackable file system "vnode interposition" action.\n+ *\n+ * @sb: unionfs\'s super_block\n+ */\n+struct dentry *unionfs_interpose(struct dentry *dentry, struct super_block *sb,\n+\t\t\t\t int flag)\n+{\n+\tint err = 0;\n+\tstruct inode *inode;\n+\tint need_fill_inode = 1;\n+\tstruct dentry *spliced = NULL;\n+\n+\tverify_locked(dentry);\n+\n+\t/*\n+\t * We allocate our new inode below, by calling iget.\n+\t * iget will call our read_inode which will initialize some\n+\t * of the new inode\'s fields\n+\t */\n+\n+\t/*\n+\t * On revalidate we\'ve already got our own inode and just need\n+\t * to fix it up.\n+\t */\n+\tif (flag == INTERPOSE_REVAL) {\n+\t\tinode = dentry->d_inode;\n+\t\tUNIONFS_I(inode)->bstart = -1;\n+\t\tUNIONFS_I(inode)->bend = -1;\n+\t\tatomic_set(&UNIONFS_I(inode)->generation,\n+\t\t\t   atomic_read(&UNIONFS_SB(sb)->generation));\n+\n+\t\tUNIONFS_I(inode)->lower_inodes =\n+\t\t\tkcalloc(sbmax(sb), sizeof(struct inode *), GFP_KERNEL);\n+\t\tif (unlikely(!UNIONFS_I(inode)->lower_inodes)) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto out;\n+\t\t}\n+\t} else {\n+\t\t/* get unique inode number for unionfs */\n+\t\tinode = iget(sb, iunique(sb, UNIONFS_ROOT_INO));\n+\t\tif (!inode) {\n+\t\t\terr = -EACCES;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tif (atomic_read(&inode->i_count) > 1)\n+\t\t\tgoto skip;\n+\t}\n+\n+\tneed_fill_inode = 0;\n+\tunionfs_fill_inode(dentry, inode);\n+\n+skip:\n+\t/* only (our) lookup wants to do a d_add */\n+\tswitch (flag) {\n+\tcase INTERPOSE_DEFAULT:\n+\t\t/* for operations which create new inodes */\n+\t\td_add(dentry, inode);\n+\t\tbreak;\n+\tcase INTERPOSE_REVAL_NEG:\n+\t\td_instantiate(dentry, inode);\n+\t\tbreak;\n+\tcase INTERPOSE_LOOKUP:\n+\t\tspliced = d_splice_alias(inode, dentry);\n+\t\tif (spliced && spliced != dentry) {\n+\t\t\t/*\n+\t\t\t * d_splice can return a dentry if it was\n+\t\t\t * disconnected and had to be moved.  We must ensure\n+\t\t\t * that the private data of the new dentry is\n+\t\t\t * correct and that the inode info was filled\n+\t\t\t * properly.  Finally we must return this new\n+\t\t\t * dentry.\n+\t\t\t */\n+\t\t\tspliced->d_op = &unionfs_dops;\n+\t\t\tspliced->d_fsdata = dentry->d_fsdata;\n+\t\t\tdentry->d_fsdata = NULL;\n+\t\t\tdentry = spliced;\n+\t\t\tif (need_fill_inode) {\n+\t\t\t\tneed_fill_inode = 0;\n+\t\t\t\tunionfs_fill_inode(dentry, inode);\n+\t\t\t}\n+\t\t\tgoto out_spliced;\n+\t\t} else if (!spliced) {\n+\t\t\tif (need_fill_inode) {\n+\t\t\t\tneed_fill_inode = 0;\n+\t\t\t\tunionfs_fill_inode(dentry, inode);\n+\t\t\t\tgoto out_spliced;\n+\t\t\t}\n+\t\t}\n+\t\tbreak;\n+\tcase INTERPOSE_REVAL:\n+\t\t/* Do nothing. */\n+\t\tbreak;\n+\tdefault:\n+\t\tprintk(KERN_CRIT "unionfs: invalid interpose flag passed!\\n");\n+\t\tBUG();\n+\t}\n+\tgoto out;\n+\n+out_spliced:\n+\tif (!err)\n+\t\treturn spliced;\n+out:\n+\treturn ERR_PTR(err);\n+}\n+\n+/* like interpose above, but for an already existing dentry */\n+void unionfs_reinterpose(struct dentry *dentry)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct inode *inode;\n+\tint bindex, bstart, bend;\n+\n+\tverify_locked(dentry);\n+\n+\t/* This is pre-allocated inode */\n+\tinode = dentry->d_inode;\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry)\n+\t\t\tcontinue;\n+\n+\t\tif (!lower_dentry->d_inode)\n+\t\t\tcontinue;\n+\t\tif (unionfs_lower_inode_idx(inode, bindex))\n+\t\t\tcontinue;\n+\t\tunionfs_set_lower_inode_idx(inode, bindex,\n+\t\t\t\t\t    igrab(lower_dentry->d_inode));\n+\t}\n+\tibstart(inode) = dbstart(dentry);\n+\tibend(inode) = dbend(dentry);\n+}\n+\n+/*\n+ * make sure the branch we just looked up (nd) makes sense:\n+ *\n+ * 1) we\'re not trying to stack unionfs on top of unionfs\n+ * 2) it exists\n+ * 3) is a directory\n+ */\n+int check_branch(struct nameidata *nd)\n+{\n+\t/* XXX: remove in ODF code -- stacking unions allowed there */\n+\tif (!strcmp(nd->dentry->d_sb->s_type->name, UNIONFS_NAME))\n+\t\treturn -EINVAL;\n+\tif (!nd->dentry->d_inode)\n+\t\treturn -ENOENT;\n+\tif (!S_ISDIR(nd->dentry->d_inode->i_mode))\n+\t\treturn -ENOTDIR;\n+\treturn 0;\n+}\n+\n+/* checks if two lower_dentries have overlapping branches */\n+static int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)\n+{\n+\tstruct dentry *dent = NULL;\n+\n+\tdent = dent1;\n+\twhile ((dent != dent2) && (dent->d_parent != dent))\n+\t\tdent = dent->d_parent;\n+\n+\tif (dent == dent2)\n+\t\treturn 1;\n+\n+\tdent = dent2;\n+\twhile ((dent != dent1) && (dent->d_parent != dent))\n+\t\tdent = dent->d_parent;\n+\n+\treturn (dent == dent1);\n+}\n+\n+/*\n+ * Parse "ro" or "rw" options, but default to "rw" if no mode options was\n+ * specified.  Fill the mode bits in @perms.  If encounter an unknown\n+ * string, return -EINVAL.  Otherwise return 0.\n+ */\n+int parse_branch_mode(const char *name, int *perms)\n+{\n+\tif (!name || !strcmp(name, "rw")) {\n+\t\t*perms = MAY_READ | MAY_WRITE;\n+\t\treturn 0;\n+\t}\n+\tif (!strcmp(name, "ro")) {\n+\t\t*perms = MAY_READ;\n+\t\treturn 0;\n+\t}\n+\treturn -EINVAL;\n+}\n+\n+/*\n+ * parse the dirs= mount argument\n+ *\n+ * We don\'t need to lock the superblock private data\'s rwsem, as we get\n+ * called only by unionfs_read_super - it is still a long time before anyone\n+ * can even get a reference to us.\n+ */\n+static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info\n+\t\t\t     *lower_root_info, char *options)\n+{\n+\tstruct nameidata nd;\n+\tchar *name;\n+\tint err = 0;\n+\tint branches = 1;\n+\tint bindex = 0;\n+\tint i = 0;\n+\tint j = 0;\n+\tstruct dentry *dent1;\n+\tstruct dentry *dent2;\n+\n+\tif (options[0] == \'\\0\') {\n+\t\tprintk(KERN_ERR "unionfs: no branches specified\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Each colon means we have a separator, this is really just a rough\n+\t * guess, since strsep will handle empty fields for us.\n+\t */\n+\tfor (i = 0; options[i]; i++)\n+\t\tif (options[i] == \':\')\n+\t\t\tbranches++;\n+\n+\t/* allocate space for underlying pointers to lower dentry */\n+\tUNIONFS_SB(sb)->data =\n+\t\tkcalloc(branches, sizeof(struct unionfs_data), GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_SB(sb)->data)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tlower_root_info->lower_paths =\n+\t\tkcalloc(branches, sizeof(struct path), GFP_KERNEL);\n+\tif (unlikely(!lower_root_info->lower_paths)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\t/* now parsing a string such as "b1:b2=rw:b3=ro:b4" */\n+\tbranches = 0;\n+\twhile ((name = strsep(&options, ":")) != NULL) {\n+\t\tint perms;\n+\t\tchar *mode = strchr(name, \'=\');\n+\n+\t\tif (!name)\n+\t\t\tcontinue;\n+\t\tif (!*name) {\t/* bad use of \':\' (extra colons) */\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tbranches++;\n+\n+\t\t/* strip off \'=\' if any */\n+\t\tif (mode)\n+\t\t\t*mode++ = \'\\0\';\n+\n+\t\terr = parse_branch_mode(mode, &perms);\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: invalid mode \\"%s\\" for "\n+\t\t\t       "branch %d\\n", mode, bindex);\n+\t\t\tgoto out;\n+\t\t}\n+\t\t/* ensure that leftmost branch is writeable */\n+\t\tif (!bindex && !(perms & MAY_WRITE)) {\n+\t\t\tprintk(KERN_ERR "unionfs: leftmost branch cannot be "\n+\t\t\t       "read-only (use \\"-o ro\\" to create a "\n+\t\t\t       "read-only union)\\n");\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\terr = path_lookup(name, LOOKUP_FOLLOW, &nd);\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: error accessing "\n+\t\t\t       "lower directory \'%s\' (error %d)\\n",\n+\t\t\t       name, err);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\terr = check_branch(&nd);\n+\t\tif (err) {\n+\t\t\tprintk(KERN_ERR "unionfs: lower directory "\n+\t\t\t       "\'%s\' is not a valid branch\\n", name);\n+\t\t\tpath_release(&nd);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tlower_root_info->lower_paths[bindex].dentry = nd.dentry;\n+\t\tlower_root_info->lower_paths[bindex].mnt = nd.mnt;\n+\n+\t\tset_branchperms(sb, bindex, perms);\n+\t\tset_branch_count(sb, bindex, 0);\n+\t\tnew_branch_id(sb, bindex);\n+\n+\t\tif (lower_root_info->bstart < 0)\n+\t\t\tlower_root_info->bstart = bindex;\n+\t\tlower_root_info->bend = bindex;\n+\t\tbindex++;\n+\t}\n+\n+\tif (branches == 0) {\n+\t\tprintk(KERN_ERR "unionfs: no branches specified\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\tBUG_ON(branches != (lower_root_info->bend + 1));\n+\n+\t/*\n+\t * Ensure that no overlaps exist in the branches.\n+\t *\n+\t * This test is required because the Linux kernel has no support\n+\t * currently for ensuring coherency between stackable layers and\n+\t * branches.  If we were to allow overlapping branches, it would be\n+\t * possible, for example, to delete a file via one branch, which\n+\t * would not be reflected in another branch.  Such incoherency could\n+\t * lead to inconsistencies and even kernel oopses.  Rather than\n+\t * implement hacks to work around some of these cache-coherency\n+\t * problems, we prevent branch overlapping, for now.  A complete\n+\t * solution will involve proper kernel/VFS support for cache\n+\t * coherency, at which time we could safely remove this\n+\t * branch-overlapping test.\n+\t */\n+\tfor (i = 0; i < branches; i++) {\n+\t\tdent1 = lower_root_info->lower_paths[i].dentry;\n+\t\tfor (j = i + 1; j < branches; j++) {\n+\t\t\tdent2 = lower_root_info->lower_paths[j].dentry;\n+\t\t\tif (is_branch_overlap(dent1, dent2)) {\n+\t\t\t\tprintk(KERN_ERR "unionfs: branches %d and "\n+\t\t\t\t       "%d overlap\\n", i, j);\n+\t\t\t\terr = -EINVAL;\n+\t\t\t\tgoto out;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+out:\n+\tif (err) {\n+\t\tfor (i = 0; i < branches; i++)\n+\t\t\tif (lower_root_info->lower_paths[i].dentry) {\n+\t\t\t\tdput(lower_root_info->lower_paths[i].dentry);\n+\t\t\t\t/* initialize: can\'t use unionfs_mntput here */\n+\t\t\t\tmntput(lower_root_info->lower_paths[i].mnt);\n+\t\t\t}\n+\n+\t\tkfree(lower_root_info->lower_paths);\n+\t\tkfree(UNIONFS_SB(sb)->data);\n+\n+\t\t/*\n+\t\t * MUST clear the pointers to prevent potential double free if\n+\t\t * the caller dies later on\n+\t\t */\n+\t\tlower_root_info->lower_paths = NULL;\n+\t\tUNIONFS_SB(sb)->data = NULL;\n+\t}\n+\treturn err;\n+}\n+\n+/*\n+ * Parse mount options.  See the manual page for usage instructions.\n+ *\n+ * Returns the dentry object of the lower-level (lower) directory;\n+ * We want to mount our stackable file system on top of that lower directory.\n+ */\n+static struct unionfs_dentry_info *unionfs_parse_options(\n+\t\t\t\t\t struct super_block *sb,\n+\t\t\t\t\t char *options)\n+{\n+\tstruct unionfs_dentry_info *lower_root_info;\n+\tchar *optname;\n+\tint err = 0;\n+\tint bindex;\n+\tint dirsfound = 0;\n+\n+\t/* allocate private data area */\n+\terr = -ENOMEM;\n+\tlower_root_info =\n+\t\tkzalloc(sizeof(struct unionfs_dentry_info), GFP_KERNEL);\n+\tif (unlikely(!lower_root_info))\n+\t\tgoto out_error;\n+\tlower_root_info->bstart = -1;\n+\tlower_root_info->bend = -1;\n+\tlower_root_info->bopaque = -1;\n+\n+\twhile ((optname = strsep(&options, ",")) != NULL) {\n+\t\tchar *optarg;\n+\n+\t\tif (!optname || !*optname)\n+\t\t\tcontinue;\n+\n+\t\toptarg = strchr(optname, \'=\');\n+\t\tif (optarg)\n+\t\t\t*optarg++ = \'\\0\';\n+\n+\t\t/*\n+\t\t * All of our options take an argument now. Insert ones that\n+\t\t * don\'t, above this check.\n+\t\t */\n+\t\tif (!optarg) {\n+\t\t\tprintk(KERN_ERR "unionfs: %s requires an argument\\n",\n+\t\t\t       optname);\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out_error;\n+\t\t}\n+\n+\t\tif (!strcmp("dirs", optname)) {\n+\t\t\tif (++dirsfound > 1) {\n+\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t       "unionfs: multiple dirs specified\\n");\n+\t\t\t\terr = -EINVAL;\n+\t\t\t\tgoto out_error;\n+\t\t\t}\n+\t\t\terr = parse_dirs_option(sb, lower_root_info, optarg);\n+\t\t\tif (err)\n+\t\t\t\tgoto out_error;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\terr = -EINVAL;\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: unrecognized option \'%s\'\\n", optname);\n+\t\tgoto out_error;\n+\t}\n+\tif (dirsfound != 1) {\n+\t\tprintk(KERN_ERR "unionfs: dirs option required\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out_error;\n+\t}\n+\tgoto out;\n+\n+out_error:\n+\tif (lower_root_info && lower_root_info->lower_paths) {\n+\t\tfor (bindex = lower_root_info->bstart;\n+\t\t     bindex >= 0 && bindex <= lower_root_info->bend;\n+\t\t     bindex++) {\n+\t\t\tstruct dentry *d;\n+\t\t\tstruct vfsmount *m;\n+\n+\t\t\td = lower_root_info->lower_paths[bindex].dentry;\n+\t\t\tm = lower_root_info->lower_paths[bindex].mnt;\n+\n+\t\t\tdput(d);\n+\t\t\t/* initializing: can\'t use unionfs_mntput here */\n+\t\t\tmntput(m);\n+\t\t}\n+\t}\n+\n+\tkfree(lower_root_info->lower_paths);\n+\tkfree(lower_root_info);\n+\n+\tkfree(UNIONFS_SB(sb)->data);\n+\tUNIONFS_SB(sb)->data = NULL;\n+\n+\tlower_root_info = ERR_PTR(err);\n+out:\n+\treturn lower_root_info;\n+}\n+\n+/*\n+ * our custom d_alloc_root work-alike\n+ *\n+ * we can\'t use d_alloc_root if we want to use our own interpose function\n+ * unchanged, so we simply call our own "fake" d_alloc_root\n+ */\n+static struct dentry *unionfs_d_alloc_root(struct super_block *sb)\n+{\n+\tstruct dentry *ret = NULL;\n+\n+\tif (sb) {\n+\t\tstatic const struct qstr name = {\n+\t\t\t.name = "/",\n+\t\t\t.len = 1\n+\t\t};\n+\n+\t\tret = d_alloc(NULL, &name);\n+\t\tif (likely(ret)) {\n+\t\t\tret->d_op = &unionfs_dops;\n+\t\t\tret->d_sb = sb;\n+\t\t\tret->d_parent = ret;\n+\t\t}\n+\t}\n+\treturn ret;\n+}\n+\n+/*\n+ * There is no need to lock the unionfs_super_info\'s rwsem as there is no\n+ * way anyone can have a reference to the superblock at this point in time.\n+ */\n+static int unionfs_read_super(struct super_block *sb, void *raw_data,\n+\t\t\t      int silent)\n+{\n+\tint err = 0;\n+\tstruct unionfs_dentry_info *lower_root_info = NULL;\n+\tint bindex, bstart, bend;\n+\n+\tif (!raw_data) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: read_super: missing data argument\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\n+\t/* Allocate superblock private data */\n+\tsb->s_fs_info = kzalloc(sizeof(struct unionfs_sb_info), GFP_KERNEL);\n+\tif (unlikely(!UNIONFS_SB(sb))) {\n+\t\tprintk(KERN_CRIT "unionfs: read_super: out of memory\\n");\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tUNIONFS_SB(sb)->bend = -1;\n+\tatomic_set(&UNIONFS_SB(sb)->generation, 1);\n+\tinit_rwsem(&UNIONFS_SB(sb)->rwsem);\n+\tUNIONFS_SB(sb)->high_branch_id = -1; /* -1 == invalid branch ID */\n+\n+\tlower_root_info = unionfs_parse_options(sb, raw_data);\n+\tif (IS_ERR(lower_root_info)) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: read_super: error while parsing options "\n+\t\t       "(err = %ld)\\n", PTR_ERR(lower_root_info));\n+\t\terr = PTR_ERR(lower_root_info);\n+\t\tlower_root_info = NULL;\n+\t\tgoto out_free;\n+\t}\n+\tif (lower_root_info->bstart == -1) {\n+\t\terr = -ENOENT;\n+\t\tgoto out_free;\n+\t}\n+\n+\t/* set the lower superblock field of upper superblock */\n+\tbstart = lower_root_info->bstart;\n+\tBUG_ON(bstart != 0);\n+\tsbend(sb) = bend = lower_root_info->bend;\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tstruct dentry *d = lower_root_info->lower_paths[bindex].dentry;\n+\t\tatomic_inc(&d->d_sb->s_active);\n+\t\tunionfs_set_lower_super_idx(sb, bindex, d->d_sb);\n+\t}\n+\n+\t/* max Bytes is the maximum bytes from highest priority branch */\n+\tsb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;\n+\n+\t/*\n+\t * Our c/m/atime granularity is 1 ns because we may stack on file\n+\t * systems whose granularity is as good.  This is important for our\n+\t * time-based cache coherency.\n+\t */\n+\tsb->s_time_gran = 1;\n+\n+\tsb->s_op = &unionfs_sops;\n+\n+\t/* See comment next to the definition of unionfs_d_alloc_root */\n+\tsb->s_root = unionfs_d_alloc_root(sb);\n+\tif (unlikely(!sb->s_root)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_dput;\n+\t}\n+\n+\t/* link the upper and lower dentries */\n+\tsb->s_root->d_fsdata = NULL;\n+\terr = new_dentry_private_data(sb->s_root, UNIONFS_DMUTEX_ROOT);\n+\tif (unlikely(err))\n+\t\tgoto out_freedpd;\n+\n+\t/* Set the lower dentries for s_root */\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tstruct dentry *d;\n+\t\tstruct vfsmount *m;\n+\n+\t\td = lower_root_info->lower_paths[bindex].dentry;\n+\t\tm = lower_root_info->lower_paths[bindex].mnt;\n+\n+\t\tunionfs_set_lower_dentry_idx(sb->s_root, bindex, d);\n+\t\tunionfs_set_lower_mnt_idx(sb->s_root, bindex, m);\n+\t}\n+\tdbstart(sb->s_root) = bstart;\n+\tdbend(sb->s_root) = bend;\n+\n+\t/* Set the generation number to one, since this is for the mount. */\n+\tatomic_set(&UNIONFS_D(sb->s_root)->generation, 1);\n+\n+\t/*\n+\t * Call interpose to create the upper level inode.  Only\n+\t * INTERPOSE_LOOKUP can return a value other than 0 on err.\n+\t */\n+\terr = PTR_ERR(unionfs_interpose(sb->s_root, sb, 0));\n+\tunionfs_unlock_dentry(sb->s_root);\n+\tif (!err)\n+\t\tgoto out;\n+\t/* else fall through */\n+\n+out_freedpd:\n+\tif (UNIONFS_D(sb->s_root)) {\n+\t\tkfree(UNIONFS_D(sb->s_root)->lower_paths);\n+\t\tfree_dentry_private_data(sb->s_root);\n+\t}\n+\tdput(sb->s_root);\n+\n+out_dput:\n+\tif (lower_root_info && !IS_ERR(lower_root_info)) {\n+\t\tfor (bindex = lower_root_info->bstart;\n+\t\t     bindex <= lower_root_info->bend; bindex++) {\n+\t\t\tstruct dentry *d;\n+\t\t\tstruct vfsmount *m;\n+\n+\t\t\td = lower_root_info->lower_paths[bindex].dentry;\n+\t\t\tm = lower_root_info->lower_paths[bindex].mnt;\n+\n+\t\t\tdput(d);\n+\t\t\t/* initializing: can\'t use unionfs_mntput here */\n+\t\t\tmntput(m);\n+\t\t\t/* drop refs we took earlier */\n+\t\t\tatomic_dec(&d->d_sb->s_active);\n+\t\t}\n+\t\tkfree(lower_root_info->lower_paths);\n+\t\tkfree(lower_root_info);\n+\t\tlower_root_info = NULL;\n+\t}\n+\n+out_free:\n+\tkfree(UNIONFS_SB(sb)->data);\n+\tkfree(UNIONFS_SB(sb));\n+\tsb->s_fs_info = NULL;\n+\n+out:\n+\tif (lower_root_info && !IS_ERR(lower_root_info)) {\n+\t\tkfree(lower_root_info->lower_paths);\n+\t\tkfree(lower_root_info);\n+\t}\n+\treturn err;\n+}\n+\n+static int unionfs_get_sb(struct file_system_type *fs_type,\n+\t\t\t  int flags, const char *dev_name,\n+\t\t\t  void *raw_data, struct vfsmount *mnt)\n+{\n+\tint err;\n+\terr = get_sb_nodev(fs_type, flags, raw_data, unionfs_read_super, mnt);\n+\tif (!err)\n+\t\tUNIONFS_SB(mnt->mnt_sb)->dev_name =\n+\t\t\tkstrdup(dev_name, GFP_KERNEL);\n+\treturn err;\n+}\n+\n+static struct file_system_type unionfs_fs_type = {\n+\t.owner\t\t= THIS_MODULE,\n+\t.name\t\t= UNIONFS_NAME,\n+\t.get_sb\t\t= unionfs_get_sb,\n+\t.kill_sb\t= generic_shutdown_super,\n+\t.fs_flags\t= FS_REVAL_DOT,\n+};\n+\n+static int __init init_unionfs_fs(void)\n+{\n+\tint err;\n+\n+\tpr_info("Registering unionfs " UNIONFS_VERSION "\\n");\n+\n+\terr = unionfs_init_filldir_cache();\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\terr = unionfs_init_inode_cache();\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\terr = unionfs_init_dentry_cache();\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\terr = init_sioq();\n+\tif (unlikely(err))\n+\t\tgoto out;\n+\terr = register_filesystem(&unionfs_fs_type);\n+out:\n+\tif (unlikely(err)) {\n+\t\tstop_sioq();\n+\t\tunionfs_destroy_filldir_cache();\n+\t\tunionfs_destroy_inode_cache();\n+\t\tunionfs_destroy_dentry_cache();\n+\t}\n+\treturn err;\n+}\n+\n+static void __exit exit_unionfs_fs(void)\n+{\n+\tstop_sioq();\n+\tunionfs_destroy_filldir_cache();\n+\tunionfs_destroy_inode_cache();\n+\tunionfs_destroy_dentry_cache();\n+\tunregister_filesystem(&unionfs_fs_type);\n+\tpr_info("Completed unionfs module unload\\n");\n+}\n+\n+MODULE_AUTHOR("Erez Zadok, Filesystems and Storage Lab, Stony Brook University"\n+\t      " (http://www.fsl.cs.sunysb.edu)");\n+MODULE_DESCRIPTION("Unionfs " UNIONFS_VERSION\n+\t\t   " (http://unionfs.filesystems.org)");\n+MODULE_LICENSE("GPL");\n+\n+module_init(init_unionfs_fs);\n+module_exit(exit_unionfs_fs);'),
 ('dev/null',
  'b/fs/unionfs/mmap.c',
  'diff --git a/fs/unionfs/mmap.c b/fs/unionfs/mmap.c\nnew file mode 100644\nindex 0000000..18b05d5\n--- dev/null\n+++ b/fs/unionfs/mmap.c\n@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2006      Shaya Potter\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+\n+/*\n+ * XXX: we need a dummy readpage handler because generic_file_mmap (which we\n+ * use in unionfs_mmap) checks for the existence of\n+ * mapping->a_ops->readpage, else it returns -ENOEXEC.  The VFS will need to\n+ * be fixed to allow a file system to define vm_ops->fault without any\n+ * address_space_ops whatsoever.\n+ *\n+ * Otherwise, we don\'t want to use our readpage method at all.\n+ */\n+static int unionfs_readpage(struct file *file, struct page *page)\n+{\n+\tBUG();\n+\treturn -EINVAL;\n+}\n+\n+static int unionfs_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n+{\n+\tint err;\n+\tstruct file *file, *lower_file;\n+\tstruct vm_operations_struct *lower_vm_ops;\n+\tstruct vm_area_struct lower_vma;\n+\n+\tBUG_ON(!vma);\n+\tmemcpy(&lower_vma, vma, sizeof(struct vm_area_struct));\n+\tfile = lower_vma.vm_file;\n+\tlower_vm_ops = UNIONFS_F(file)->lower_vm_ops;\n+\tBUG_ON(!lower_vm_ops);\n+\n+\tlower_file = unionfs_lower_file(file);\n+\tBUG_ON(!lower_file);\n+\t/*\n+\t * XXX: vm_ops->fault may be called in parallel.  Because we have to\n+\t * resort to temporarily changing the vma->vm_file to point to the\n+\t * lower file, a concurrent invocation of unionfs_fault could see a\n+\t * different value.  In this workaround, we keep a different copy of\n+\t * the vma structure in our stack, so we never expose a different\n+\t * value of the vma->vm_file called to us, even temporarily.  A\n+\t * better fix would be to change the calling semantics of ->fault to\n+\t * take an explicit file pointer.\n+\t */\n+\tlower_vma.vm_file = lower_file;\n+\terr = lower_vm_ops->fault(&lower_vma, vmf);\n+\treturn err;\n+}\n+\n+/*\n+ * XXX: the default address_space_ops for unionfs is empty.  We cannot set\n+ * our inode->i_mapping->a_ops to NULL because too many code paths expect\n+ * the a_ops vector to be non-NULL.\n+ */\n+struct address_space_operations unionfs_aops = {\n+\t/* empty on purpose */\n+};\n+\n+/*\n+ * XXX: we need a second, dummy address_space_ops vector, to be used\n+ * temporarily during unionfs_mmap, because the latter calls\n+ * generic_file_mmap, which checks if ->readpage exists, else returns\n+ * -ENOEXEC.\n+ */\n+struct address_space_operations unionfs_dummy_aops = {\n+\t.readpage\t= unionfs_readpage,\n+};\n+\n+struct vm_operations_struct unionfs_vm_ops = {\n+\t.fault\t\t= unionfs_fault,\n+};'),
 ('dev/null',
  'b/fs/unionfs/rdstate.c',
  'diff --git a/fs/unionfs/rdstate.c b/fs/unionfs/rdstate.c\nnew file mode 100644\nindex 0000000..485464b\n--- dev/null\n+++ b/fs/unionfs/rdstate.c\n@@ -0,0 +1,285 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/* This file contains the routines for maintaining readdir state. */\n+\n+/*\n+ * There are two structures here, rdstate which is a hash table\n+ * of the second structure which is a filldir_node.\n+ */\n+\n+/*\n+ * This is a struct kmem_cache for filldir nodes, because we allocate a lot\n+ * of them and they shouldn\'t waste memory.  If the node has a small name\n+ * (as defined by the dentry structure), then we use an inline name to\n+ * preserve kmalloc space.\n+ */\n+static struct kmem_cache *unionfs_filldir_cachep;\n+\n+int unionfs_init_filldir_cache(void)\n+{\n+\tunionfs_filldir_cachep =\n+\t\tkmem_cache_create("unionfs_filldir",\n+\t\t\t\t  sizeof(struct filldir_node), 0,\n+\t\t\t\t  SLAB_RECLAIM_ACCOUNT, NULL);\n+\n+\treturn (unionfs_filldir_cachep ? 0 : -ENOMEM);\n+}\n+\n+void unionfs_destroy_filldir_cache(void)\n+{\n+\tif (unionfs_filldir_cachep)\n+\t\tkmem_cache_destroy(unionfs_filldir_cachep);\n+}\n+\n+/*\n+ * This is a tuning parameter that tells us roughly how big to make the\n+ * hash table in directory entries per page.  This isn\'t perfect, but\n+ * at least we get a hash table size that shouldn\'t be too overloaded.\n+ * The following averages are based on my home directory.\n+ * 14.44693\tOverall\n+ * 12.29\tSingle Page Directories\n+ * 117.93\tMulti-page directories\n+ */\n+#define DENTPAGE 4096\n+#define DENTPERONEPAGE 12\n+#define DENTPERPAGE 118\n+#define MINHASHSIZE 1\n+static int guesstimate_hash_size(struct inode *inode)\n+{\n+\tstruct inode *lower_inode;\n+\tint bindex;\n+\tint hashsize = MINHASHSIZE;\n+\n+\tif (UNIONFS_I(inode)->hashsize > 0)\n+\t\treturn UNIONFS_I(inode)->hashsize;\n+\n+\tfor (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {\n+\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\tif (!lower_inode)\n+\t\t\tcontinue;\n+\n+\t\tif (i_size_read(lower_inode) == DENTPAGE)\n+\t\t\thashsize += DENTPERONEPAGE;\n+\t\telse\n+\t\t\thashsize += (i_size_read(lower_inode) / DENTPAGE) *\n+\t\t\t\tDENTPERPAGE;\n+\t}\n+\n+\treturn hashsize;\n+}\n+\n+int init_rdstate(struct file *file)\n+{\n+\tBUG_ON(sizeof(loff_t) !=\n+\t       (sizeof(unsigned int) + sizeof(unsigned int)));\n+\tBUG_ON(UNIONFS_F(file)->rdstate != NULL);\n+\n+\tUNIONFS_F(file)->rdstate = alloc_rdstate(file->f_path.dentry->d_inode,\n+\t\t\t\t\t\t fbstart(file));\n+\n+\treturn (UNIONFS_F(file)->rdstate ? 0 : -ENOMEM);\n+}\n+\n+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos)\n+{\n+\tstruct unionfs_dir_state *rdstate = NULL;\n+\tstruct list_head *pos;\n+\n+\tspin_lock(&UNIONFS_I(inode)->rdlock);\n+\tlist_for_each(pos, &UNIONFS_I(inode)->readdircache) {\n+\t\tstruct unionfs_dir_state *r =\n+\t\t\tlist_entry(pos, struct unionfs_dir_state, cache);\n+\t\tif (fpos == rdstate2offset(r)) {\n+\t\t\tUNIONFS_I(inode)->rdcount--;\n+\t\t\tlist_del(&r->cache);\n+\t\t\trdstate = r;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tspin_unlock(&UNIONFS_I(inode)->rdlock);\n+\treturn rdstate;\n+}\n+\n+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex)\n+{\n+\tint i = 0;\n+\tint hashsize;\n+\tunsigned long mallocsize = sizeof(struct unionfs_dir_state);\n+\tstruct unionfs_dir_state *rdstate;\n+\n+\thashsize = guesstimate_hash_size(inode);\n+\tmallocsize += hashsize * sizeof(struct list_head);\n+\tmallocsize = __roundup_pow_of_two(mallocsize);\n+\n+\t/* This should give us about 500 entries anyway. */\n+\tif (mallocsize > PAGE_SIZE)\n+\t\tmallocsize = PAGE_SIZE;\n+\n+\thashsize = (mallocsize - sizeof(struct unionfs_dir_state)) /\n+\t\tsizeof(struct list_head);\n+\n+\trdstate = kmalloc(mallocsize, GFP_KERNEL);\n+\tif (unlikely(!rdstate))\n+\t\treturn NULL;\n+\n+\tspin_lock(&UNIONFS_I(inode)->rdlock);\n+\tif (UNIONFS_I(inode)->cookie >= (MAXRDCOOKIE - 1))\n+\t\tUNIONFS_I(inode)->cookie = 1;\n+\telse\n+\t\tUNIONFS_I(inode)->cookie++;\n+\n+\trdstate->cookie = UNIONFS_I(inode)->cookie;\n+\tspin_unlock(&UNIONFS_I(inode)->rdlock);\n+\trdstate->offset = 1;\n+\trdstate->access = jiffies;\n+\trdstate->bindex = bindex;\n+\trdstate->dirpos = 0;\n+\trdstate->hashentries = 0;\n+\trdstate->size = hashsize;\n+\tfor (i = 0; i < rdstate->size; i++)\n+\t\tINIT_LIST_HEAD(&rdstate->list[i]);\n+\n+\treturn rdstate;\n+}\n+\n+static void free_filldir_node(struct filldir_node *node)\n+{\n+\tif (node->namelen >= DNAME_INLINE_LEN_MIN)\n+\t\tkfree(node->name);\n+\tkmem_cache_free(unionfs_filldir_cachep, node);\n+}\n+\n+void free_rdstate(struct unionfs_dir_state *state)\n+{\n+\tstruct filldir_node *tmp;\n+\tint i;\n+\n+\tfor (i = 0; i < state->size; i++) {\n+\t\tstruct list_head *head = &(state->list[i]);\n+\t\tstruct list_head *pos, *n;\n+\n+\t\t/* traverse the list and deallocate space */\n+\t\tlist_for_each_safe(pos, n, head) {\n+\t\t\ttmp = list_entry(pos, struct filldir_node, file_list);\n+\t\t\tlist_del(&tmp->file_list);\n+\t\t\tfree_filldir_node(tmp);\n+\t\t}\n+\t}\n+\n+\tkfree(state);\n+}\n+\n+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,\n+\t\t\t\t       const char *name, int namelen,\n+\t\t\t\t       int is_whiteout)\n+{\n+\tint index;\n+\tunsigned int hash;\n+\tstruct list_head *head;\n+\tstruct list_head *pos;\n+\tstruct filldir_node *cursor = NULL;\n+\tint found = 0;\n+\n+\tBUG_ON(namelen <= 0);\n+\n+\thash = full_name_hash(name, namelen);\n+\tindex = hash % rdstate->size;\n+\n+\thead = &(rdstate->list[index]);\n+\tlist_for_each(pos, head) {\n+\t\tcursor = list_entry(pos, struct filldir_node, file_list);\n+\n+\t\tif (cursor->namelen == namelen && cursor->hash == hash &&\n+\t\t    !strncmp(cursor->name, name, namelen)) {\n+\t\t\t/*\n+\t\t\t * a duplicate exists, and hence no need to create\n+\t\t\t * entry to the list\n+\t\t\t */\n+\t\t\tfound = 1;\n+\n+\t\t\t/*\n+\t\t\t * if a duplicate is found in this branch, and is\n+\t\t\t * not due to the caller looking for an entry to\n+\t\t\t * whiteout, then the file system may be corrupted.\n+\t\t\t */\n+\t\t\tif (unlikely(!is_whiteout &&\n+\t\t\t\t     cursor->bindex == rdstate->bindex))\n+\t\t\t\tprintk(KERN_ERR "unionfs: filldir: possible "\n+\t\t\t\t       "I/O error: a file is duplicated "\n+\t\t\t\t       "in the same branch %d: %s\\n",\n+\t\t\t\t       rdstate->bindex, cursor->name);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (!found)\n+\t\tcursor = NULL;\n+\n+\treturn cursor;\n+}\n+\n+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,\n+\t\t     int namelen, int bindex, int whiteout)\n+{\n+\tstruct filldir_node *new;\n+\tunsigned int hash;\n+\tint index;\n+\tint err = 0;\n+\tstruct list_head *head;\n+\n+\tBUG_ON(namelen <= 0);\n+\n+\thash = full_name_hash(name, namelen);\n+\tindex = hash % rdstate->size;\n+\thead = &(rdstate->list[index]);\n+\n+\tnew = kmem_cache_alloc(unionfs_filldir_cachep, GFP_KERNEL);\n+\tif (unlikely(!new)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tINIT_LIST_HEAD(&new->file_list);\n+\tnew->namelen = namelen;\n+\tnew->hash = hash;\n+\tnew->bindex = bindex;\n+\tnew->whiteout = whiteout;\n+\n+\tif (namelen < DNAME_INLINE_LEN_MIN) {\n+\t\tnew->name = new->iname;\n+\t} else {\n+\t\tnew->name = kmalloc(namelen + 1, GFP_KERNEL);\n+\t\tif (unlikely(!new->name)) {\n+\t\t\tkmem_cache_free(unionfs_filldir_cachep, new);\n+\t\t\tnew = NULL;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\tmemcpy(new->name, name, namelen);\n+\tnew->name[namelen] = \'\\0\';\n+\n+\trdstate->hashentries++;\n+\n+\tlist_add(&(new->file_list), head);\n+out:\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/rename.c',
  'diff --git a/fs/unionfs/rename.c b/fs/unionfs/rename.c\nnew file mode 100644\nindex 0000000..ed13260\n--- dev/null\n+++ b/fs/unionfs/rename.c\n@@ -0,0 +1,520 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * This is a helper function for rename, used when rename ends up with hosed\n+ * over dentries and we need to revert.\n+ */\n+static int unionfs_refresh_lower_dentry(struct dentry *dentry,\n+\t\t\t\t\tstruct dentry *parent, int bindex)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *lower_parent;\n+\tint err = 0;\n+\n+\tverify_locked(dentry);\n+\n+\tlower_parent = unionfs_lower_dentry_idx(parent, bindex);\n+\n+\tBUG_ON(!S_ISDIR(lower_parent->d_inode->i_mode));\n+\n+\tlower_dentry = lookup_one_len(dentry->d_name.name, lower_parent,\n+\t\t\t\t      dentry->d_name.len);\n+\tif (IS_ERR(lower_dentry)) {\n+\t\terr = PTR_ERR(lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tdput(unionfs_lower_dentry_idx(dentry, bindex));\n+\tiput(unionfs_lower_inode_idx(dentry->d_inode, bindex));\n+\tunionfs_set_lower_inode_idx(dentry->d_inode, bindex, NULL);\n+\n+\tif (!lower_dentry->d_inode) {\n+\t\tdput(lower_dentry);\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, NULL);\n+\t} else {\n+\t\tunionfs_set_lower_dentry_idx(dentry, bindex, lower_dentry);\n+\t\tunionfs_set_lower_inode_idx(dentry->d_inode, bindex,\n+\t\t\t\t\t    igrab(lower_dentry->d_inode));\n+\t}\n+\n+out:\n+\treturn err;\n+}\n+\n+static int __unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n+\t\t\t    struct dentry *old_parent,\n+\t\t\t    struct inode *new_dir, struct dentry *new_dentry,\n+\t\t\t    struct dentry *new_parent,\n+\t\t\t    int bindex)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_old_dentry;\n+\tstruct dentry *lower_new_dentry;\n+\tstruct dentry *lower_old_dir_dentry;\n+\tstruct dentry *lower_new_dir_dentry;\n+\tstruct dentry *trap;\n+\n+\tlower_new_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);\n+\tlower_old_dentry = unionfs_lower_dentry_idx(old_dentry, bindex);\n+\n+\tif (!lower_new_dentry) {\n+\t\tlower_new_dentry =\n+\t\t\tcreate_parents(new_parent->d_inode,\n+\t\t\t\t       new_dentry, new_dentry->d_name.name,\n+\t\t\t\t       bindex);\n+\t\tif (IS_ERR(lower_new_dentry)) {\n+\t\t\terr = PTR_ERR(lower_new_dentry);\n+\t\t\tif (IS_COPYUP_ERR(err))\n+\t\t\t\tgoto out;\n+\t\t\tprintk(KERN_ERR "unionfs: error creating directory "\n+\t\t\t       "tree for rename, bindex=%d err=%d\\n",\n+\t\t\t       bindex, err);\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\t/* check for and remove whiteout, if any */\n+\terr = check_unlink_whiteout(new_dentry, lower_new_dentry, bindex);\n+\tif (err > 0) /* ignore if whiteout found and successfully removed */\n+\t\terr = 0;\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* check of old_dentry branch is writable */\n+\terr = is_robranch_super(old_dentry->d_sb, bindex);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tdget(lower_old_dentry);\n+\tdget(lower_new_dentry);\n+\tlower_old_dir_dentry = dget_parent(lower_old_dentry);\n+\tlower_new_dir_dentry = dget_parent(lower_new_dentry);\n+\n+\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\tlockdep_off();\n+\ttrap = lock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n+\t/* source should not be ancenstor of target */\n+\tif (trap == lower_old_dentry) {\n+\t\terr = -EINVAL;\n+\t\tgoto out_err_unlock;\n+\t}\n+\t/* target should not be ancenstor of source */\n+\tif (trap == lower_new_dentry) {\n+\t\terr = -ENOTEMPTY;\n+\t\tgoto out_err_unlock;\n+\t}\n+\terr = vfs_rename(lower_old_dir_dentry->d_inode, lower_old_dentry,\n+\t\t\t lower_new_dir_dentry->d_inode, lower_new_dentry);\n+out_err_unlock:\n+\tif (!err) {\n+\t\t/* update parent dir times */\n+\t\tfsstack_copy_attr_times(old_dir, lower_old_dir_dentry->d_inode);\n+\t\tfsstack_copy_attr_times(new_dir, lower_new_dir_dentry->d_inode);\n+\t}\n+\tunlock_rename(lower_old_dir_dentry, lower_new_dir_dentry);\n+\tlockdep_on();\n+\n+\tdput(lower_old_dir_dentry);\n+\tdput(lower_new_dir_dentry);\n+\tdput(lower_old_dentry);\n+\tdput(lower_new_dentry);\n+\n+out:\n+\tif (!err) {\n+\t\t/* Fixup the new_dentry. */\n+\t\tif (bindex < dbstart(new_dentry))\n+\t\t\tdbstart(new_dentry) = bindex;\n+\t\telse if (bindex > dbend(new_dentry))\n+\t\t\tdbend(new_dentry) = bindex;\n+\t}\n+\n+\treturn err;\n+}\n+\n+/*\n+ * Main rename code.  This is sufficiently complex, that it\'s documented in\n+ * Documentation/filesystems/unionfs/rename.txt.  This routine calls\n+ * __unionfs_rename() above to perform some of the work.\n+ */\n+static int do_unionfs_rename(struct inode *old_dir,\n+\t\t\t     struct dentry *old_dentry,\n+\t\t\t     struct dentry *old_parent,\n+\t\t\t     struct inode *new_dir,\n+\t\t\t     struct dentry *new_dentry,\n+\t\t\t     struct dentry *new_parent)\n+{\n+\tint err = 0;\n+\tint bindex;\n+\tint old_bstart, old_bend;\n+\tint new_bstart, new_bend;\n+\tint do_copyup = -1;\n+\tint local_err = 0;\n+\tint eio = 0;\n+\tint revert = 0;\n+\n+\told_bstart = dbstart(old_dentry);\n+\told_bend = dbend(old_dentry);\n+\n+\tnew_bstart = dbstart(new_dentry);\n+\tnew_bend = dbend(new_dentry);\n+\n+\t/* Rename source to destination. */\n+\terr = __unionfs_rename(old_dir, old_dentry, old_parent,\n+\t\t\t       new_dir, new_dentry, new_parent,\n+\t\t\t       old_bstart);\n+\tif (err) {\n+\t\tif (!IS_COPYUP_ERR(err))\n+\t\t\tgoto out;\n+\t\tdo_copyup = old_bstart - 1;\n+\t} else {\n+\t\trevert = 1;\n+\t}\n+\n+\t/*\n+\t * Unlink all instances of destination that exist to the left of\n+\t * bstart of source. On error, revert back, goto out.\n+\t */\n+\tfor (bindex = old_bstart - 1; bindex >= new_bstart; bindex--) {\n+\t\tstruct dentry *unlink_dentry;\n+\t\tstruct dentry *unlink_dir_dentry;\n+\n+\t\tBUG_ON(bindex < 0);\n+\t\tunlink_dentry = unionfs_lower_dentry_idx(new_dentry, bindex);\n+\t\tif (!unlink_dentry)\n+\t\t\tcontinue;\n+\n+\t\tunlink_dir_dentry = lock_parent(unlink_dentry);\n+\t\terr = is_robranch_super(old_dir->i_sb, bindex);\n+\t\tif (!err)\n+\t\t\terr = vfs_unlink(unlink_dir_dentry->d_inode,\n+\t\t\t\t\t unlink_dentry);\n+\n+\t\tfsstack_copy_attr_times(new_parent->d_inode,\n+\t\t\t\t\tunlink_dir_dentry->d_inode);\n+\t\t/* propagate number of hard-links */\n+\t\tnew_parent->d_inode->i_nlink =\n+\t\t\tunionfs_get_nlinks(new_parent->d_inode);\n+\n+\t\tunlock_dir(unlink_dir_dentry);\n+\t\tif (!err) {\n+\t\t\tif (bindex != new_bstart) {\n+\t\t\t\tdput(unlink_dentry);\n+\t\t\t\tunionfs_set_lower_dentry_idx(new_dentry,\n+\t\t\t\t\t\t\t     bindex, NULL);\n+\t\t\t}\n+\t\t} else if (IS_COPYUP_ERR(err)) {\n+\t\t\tdo_copyup = bindex - 1;\n+\t\t} else if (revert) {\n+\t\t\tgoto revert;\n+\t\t}\n+\t}\n+\n+\tif (do_copyup != -1) {\n+\t\tfor (bindex = do_copyup; bindex >= 0; bindex--) {\n+\t\t\t/*\n+\t\t\t * copyup the file into some left directory, so that\n+\t\t\t * you can rename it\n+\t\t\t */\n+\t\t\terr = copyup_dentry(old_parent->d_inode,\n+\t\t\t\t\t    old_dentry, old_bstart, bindex,\n+\t\t\t\t\t    old_dentry->d_name.name,\n+\t\t\t\t\t    old_dentry->d_name.len, NULL,\n+\t\t\t\t\t    i_size_read(old_dentry->d_inode));\n+\t\t\t/* if copyup failed, try next branch to the left */\n+\t\t\tif (err)\n+\t\t\t\tcontinue;\n+\t\t\t/*\n+\t\t\t * create whiteout before calling __unionfs_rename\n+\t\t\t * because the latter will change the old_dentry\'s\n+\t\t\t * lower name and parent dir, resulting in the\n+\t\t\t * whiteout getting created in the wrong dir.\n+\t\t\t */\n+\t\t\terr = create_whiteout(old_dentry, bindex);\n+\t\t\tif (err) {\n+\t\t\t\tprintk(KERN_ERR "unionfs: can\'t create a "\n+\t\t\t\t       "whiteout for %s in rename (err=%d)\\n",\n+\t\t\t\t       old_dentry->d_name.name, err);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\terr = __unionfs_rename(old_dir, old_dentry, old_parent,\n+\t\t\t\t\t       new_dir, new_dentry, new_parent,\n+\t\t\t\t\t       bindex);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t/* make it opaque */\n+\tif (S_ISDIR(old_dentry->d_inode->i_mode)) {\n+\t\terr = make_dir_opaque(old_dentry, dbstart(old_dentry));\n+\t\tif (err)\n+\t\t\tgoto revert;\n+\t}\n+\n+\t/*\n+\t * Create whiteout for source, only if:\n+\t * (1) There is more than one underlying instance of source.\n+\t * (We did a copy_up is taken care of above).\n+\t */\n+\tif ((old_bstart != old_bend) && (do_copyup == -1)) {\n+\t\terr = create_whiteout(old_dentry, old_bstart);\n+\t\tif (err) {\n+\t\t\t/* can\'t fix anything now, so we exit with -EIO */\n+\t\t\tprintk(KERN_ERR "unionfs: can\'t create a whiteout for "\n+\t\t\t       "%s in rename!\\n", old_dentry->d_name.name);\n+\t\t\terr = -EIO;\n+\t\t}\n+\t}\n+\n+out:\n+\treturn err;\n+\n+revert:\n+\t/* Do revert here. */\n+\tlocal_err = unionfs_refresh_lower_dentry(new_dentry, new_parent,\n+\t\t\t\t\t\t old_bstart);\n+\tif (local_err) {\n+\t\tprintk(KERN_ERR "unionfs: revert failed in rename: "\n+\t\t       "the new refresh failed\\n");\n+\t\teio = -EIO;\n+\t}\n+\n+\tlocal_err = unionfs_refresh_lower_dentry(old_dentry, old_parent,\n+\t\t\t\t\t\t old_bstart);\n+\tif (local_err) {\n+\t\tprintk(KERN_ERR "unionfs: revert failed in rename: "\n+\t\t       "the old refresh failed\\n");\n+\t\teio = -EIO;\n+\t\tgoto revert_out;\n+\t}\n+\n+\tif (!unionfs_lower_dentry_idx(new_dentry, bindex) ||\n+\t    !unionfs_lower_dentry_idx(new_dentry, bindex)->d_inode) {\n+\t\tprintk(KERN_ERR "unionfs: revert failed in rename: "\n+\t\t       "the object disappeared from under us!\\n");\n+\t\teio = -EIO;\n+\t\tgoto revert_out;\n+\t}\n+\n+\tif (unionfs_lower_dentry_idx(old_dentry, bindex) &&\n+\t    unionfs_lower_dentry_idx(old_dentry, bindex)->d_inode) {\n+\t\tprintk(KERN_ERR "unionfs: revert failed in rename: "\n+\t\t       "the object was created underneath us!\\n");\n+\t\teio = -EIO;\n+\t\tgoto revert_out;\n+\t}\n+\n+\tlocal_err = __unionfs_rename(new_dir, new_dentry, new_parent,\n+\t\t\t\t     old_dir, old_dentry, old_parent,\n+\t\t\t\t     old_bstart);\n+\n+\t/* If we can\'t fix it, then we cop-out with -EIO. */\n+\tif (local_err) {\n+\t\tprintk(KERN_ERR "unionfs: revert failed in rename!\\n");\n+\t\teio = -EIO;\n+\t}\n+\n+\tlocal_err = unionfs_refresh_lower_dentry(new_dentry, new_parent,\n+\t\t\t\t\t\t bindex);\n+\tif (local_err)\n+\t\teio = -EIO;\n+\tlocal_err = unionfs_refresh_lower_dentry(old_dentry, old_parent,\n+\t\t\t\t\t\t bindex);\n+\tif (local_err)\n+\t\teio = -EIO;\n+\n+revert_out:\n+\tif (eio)\n+\t\terr = eio;\n+\treturn err;\n+}\n+\n+/*\n+ * We can\'t copyup a directory, because it may involve huge numbers of\n+ * children, etc.  Doing that in the kernel would be bad, so instead we\n+ * return EXDEV to the user-space utility that caused this, and let the\n+ * user-space recurse and ask us to copy up each file separately.\n+ */\n+static int may_rename_dir(struct dentry *dentry, struct dentry *parent)\n+{\n+\tint err, bstart;\n+\n+\terr = check_empty(dentry, parent, NULL);\n+\tif (err == -ENOTEMPTY) {\n+\t\tif (is_robranch(dentry))\n+\t\t\treturn -EXDEV;\n+\t} else if (err) {\n+\t\treturn err;\n+\t}\n+\n+\tbstart = dbstart(dentry);\n+\tif (dbend(dentry) == bstart || dbopaque(dentry) == bstart)\n+\t\treturn 0;\n+\n+\tdbstart(dentry) = bstart + 1;\n+\terr = check_empty(dentry, parent, NULL);\n+\tdbstart(dentry) = bstart;\n+\tif (err == -ENOTEMPTY)\n+\t\terr = -EXDEV;\n+\treturn err;\n+}\n+\n+/*\n+ * The locking rules in unionfs_rename are complex.  We could use a simpler\n+ * superblock-level name-space lock for renames and copy-ups.\n+ */\n+int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n+\t\t   struct inode *new_dir, struct dentry *new_dentry)\n+{\n+\tint err = 0;\n+\tstruct dentry *wh_dentry;\n+\tstruct dentry *old_parent, *new_parent;\n+\tint valid = true;\n+\n+\tunionfs_read_lock(old_dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\told_parent = dget_parent(old_dentry);\n+\tnew_parent = dget_parent(new_dentry);\n+\t/* un/lock parent dentries only if they differ from old/new_dentry */\n+\tif (old_parent != old_dentry &&\n+\t    old_parent != new_dentry)\n+\t\tunionfs_lock_dentry(old_parent, UNIONFS_DMUTEX_REVAL_PARENT);\n+\tif (new_parent != old_dentry &&\n+\t    new_parent != new_dentry &&\n+\t    new_parent != old_parent)\n+\t\tunionfs_lock_dentry(new_parent, UNIONFS_DMUTEX_REVAL_CHILD);\n+\tunionfs_double_lock_dentry(old_dentry, new_dentry);\n+\n+\tvalid = __unionfs_d_revalidate(old_dentry, old_parent, false);\n+\tif (!valid) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\tif (!d_deleted(new_dentry) && new_dentry->d_inode) {\n+\t\tvalid = __unionfs_d_revalidate(new_dentry, new_parent, false);\n+\t\tif (!valid) {\n+\t\t\terr = -ESTALE;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\tif (!S_ISDIR(old_dentry->d_inode->i_mode))\n+\t\terr = unionfs_partial_lookup(old_dentry, old_parent);\n+\telse\n+\t\terr = may_rename_dir(old_dentry, old_parent);\n+\n+\tif (err)\n+\t\tgoto out;\n+\n+\terr = unionfs_partial_lookup(new_dentry, new_parent);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/*\n+\t * if new_dentry is already lower because of whiteout,\n+\t * simply override it even if the whited-out dir is not empty.\n+\t */\n+\twh_dentry = find_first_whiteout(new_dentry);\n+\tif (!IS_ERR(wh_dentry)) {\n+\t\tdput(wh_dentry);\n+\t} else if (new_dentry->d_inode) {\n+\t\tif (S_ISDIR(old_dentry->d_inode->i_mode) !=\n+\t\t    S_ISDIR(new_dentry->d_inode->i_mode)) {\n+\t\t\terr = S_ISDIR(old_dentry->d_inode->i_mode) ?\n+\t\t\t\t-ENOTDIR : -EISDIR;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tif (S_ISDIR(new_dentry->d_inode->i_mode)) {\n+\t\t\tstruct unionfs_dir_state *namelist = NULL;\n+\t\t\t/* check if this unionfs directory is empty or not */\n+\t\t\terr = check_empty(new_dentry, new_parent, &namelist);\n+\t\t\tif (err)\n+\t\t\t\tgoto out;\n+\n+\t\t\tif (!is_robranch(new_dentry))\n+\t\t\t\terr = delete_whiteouts(new_dentry,\n+\t\t\t\t\t\t       dbstart(new_dentry),\n+\t\t\t\t\t\t       namelist);\n+\n+\t\t\tfree_rdstate(namelist);\n+\n+\t\t\tif (err)\n+\t\t\t\tgoto out;\n+\t\t}\n+\t}\n+\n+\terr = do_unionfs_rename(old_dir, old_dentry, old_parent,\n+\t\t\t\tnew_dir, new_dentry, new_parent);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/*\n+\t * force re-lookup since the dir on ro branch is not renamed, and\n+\t * lower dentries still indicate the un-renamed ones.\n+\t */\n+\tif (S_ISDIR(old_dentry->d_inode->i_mode))\n+\t\tatomic_dec(&UNIONFS_D(old_dentry)->generation);\n+\telse\n+\t\tunionfs_postcopyup_release(old_dentry);\n+\tif (new_dentry->d_inode && !S_ISDIR(new_dentry->d_inode->i_mode)) {\n+\t\tunionfs_postcopyup_release(new_dentry);\n+\t\tunionfs_postcopyup_setmnt(new_dentry);\n+\t\tif (!unionfs_lower_inode(new_dentry->d_inode)) {\n+\t\t\t/*\n+\t\t\t * If we get here, it means that no copyup was\n+\t\t\t * needed, and that a file by the old name already\n+\t\t\t * existing on the destination branch; that file got\n+\t\t\t * renamed earlier in this function, so all we need\n+\t\t\t * to do here is set the lower inode.\n+\t\t\t */\n+\t\t\tstruct inode *inode;\n+\t\t\tinode = unionfs_lower_inode(old_dentry->d_inode);\n+\t\t\tigrab(inode);\n+\t\t\tunionfs_set_lower_inode_idx(new_dentry->d_inode,\n+\t\t\t\t\t\t    dbstart(new_dentry),\n+\t\t\t\t\t\t    inode);\n+\t\t}\n+\t}\n+\t/* if all of this renaming succeeded, update our times */\n+\tunionfs_copy_attr_times(old_dentry->d_inode);\n+\tunionfs_copy_attr_times(new_dentry->d_inode);\n+\tunionfs_check_inode(old_dir);\n+\tunionfs_check_inode(new_dir);\n+\tunionfs_check_dentry(old_dentry);\n+\tunionfs_check_dentry(new_dentry);\n+\n+out:\n+\tif (err)\t\t/* clear the new_dentry stuff created */\n+\t\td_drop(new_dentry);\n+\n+\tunionfs_double_unlock_dentry(old_dentry, new_dentry);\n+\tif (new_parent != old_dentry &&\n+\t    new_parent != new_dentry &&\n+\t    new_parent != old_parent)\n+\t\tunionfs_unlock_dentry(new_parent);\n+\tif (old_parent != old_dentry &&\n+\t    old_parent != new_dentry)\n+\t\tunionfs_unlock_dentry(old_parent);\n+\tdput(new_parent);\n+\tdput(old_parent);\n+\tunionfs_read_unlock(old_dentry->d_sb);\n+\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/sioq.c',
  'diff --git a/fs/unionfs/sioq.c b/fs/unionfs/sioq.c\nnew file mode 100644\nindex 0000000..ba3bf63\n--- dev/null\n+++ b/fs/unionfs/sioq.c\n@@ -0,0 +1,101 @@\n+/*\n+ * Copyright (c) 2006-2009 Erez Zadok\n+ * Copyright (c) 2006      Charles P. Wright\n+ * Copyright (c) 2006-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2006      Junjiro Okajima\n+ * Copyright (c) 2006      David P. Quigley\n+ * Copyright (c) 2006-2009 Stony Brook University\n+ * Copyright (c) 2006-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * Super-user IO work Queue - sometimes we need to perform actions which\n+ * would fail due to the unix permissions on the parent directory (e.g.,\n+ * rmdir a directory which appears empty, but in reality contains\n+ * whiteouts).\n+ */\n+\n+static struct workqueue_struct *superio_workqueue;\n+\n+int __init init_sioq(void)\n+{\n+\tint err;\n+\n+\tsuperio_workqueue = create_workqueue("unionfs_siod");\n+\tif (!IS_ERR(superio_workqueue))\n+\t\treturn 0;\n+\n+\terr = PTR_ERR(superio_workqueue);\n+\tprintk(KERN_ERR "unionfs: create_workqueue failed %d\\n", err);\n+\tsuperio_workqueue = NULL;\n+\treturn err;\n+}\n+\n+void stop_sioq(void)\n+{\n+\tif (superio_workqueue)\n+\t\tdestroy_workqueue(superio_workqueue);\n+}\n+\n+void run_sioq(work_func_t func, struct sioq_args *args)\n+{\n+\tINIT_WORK(&args->work, func);\n+\n+\tinit_completion(&args->comp);\n+\twhile (!queue_work(superio_workqueue, &args->work)) {\n+\t\t/* TODO: do accounting if needed */\n+\t\tschedule();\n+\t}\n+\twait_for_completion(&args->comp);\n+}\n+\n+void __unionfs_create(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct create_args *c = &args->create;\n+\n+\targs->err = vfs_create(c->parent, c->dentry, c->mode, c->nd);\n+\tcomplete(&args->comp);\n+}\n+\n+void __unionfs_mkdir(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct mkdir_args *m = &args->mkdir;\n+\n+\targs->err = vfs_mkdir(m->parent, m->dentry, m->mode);\n+\tcomplete(&args->comp);\n+}\n+\n+void __unionfs_mknod(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct mknod_args *m = &args->mknod;\n+\n+\targs->err = vfs_mknod(m->parent, m->dentry, m->mode, m->dev);\n+\tcomplete(&args->comp);\n+}\n+\n+void __unionfs_symlink(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct symlink_args *s = &args->symlink;\n+\n+\targs->err = vfs_symlink(s->parent, s->dentry, s->symbuf, s->mode);\n+\tcomplete(&args->comp);\n+}\n+\n+void __unionfs_unlink(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct unlink_args *u = &args->unlink;\n+\n+\targs->err = vfs_unlink(u->parent, u->dentry);\n+\tcomplete(&args->comp);\n+}'),
 ('dev/null',
  'b/fs/unionfs/sioq.h',
  "diff --git a/fs/unionfs/sioq.h b/fs/unionfs/sioq.h\nnew file mode 100644\nindex 0000000..4f4ba53\n--- dev/null\n+++ b/fs/unionfs/sioq.h\n@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2006-2009 Erez Zadok\n+ * Copyright (c) 2006      Charles P. Wright\n+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek\n+ * Copyright (c) 2006      Junjiro Okajima\n+ * Copyright (c) 2006      David P. Quigley\n+ * Copyright (c) 2006-2009 Stony Brook University\n+ * Copyright (c) 2006-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#ifndef _SIOQ_H\n+#define _SIOQ_H\n+\n+struct deletewh_args {\n+\tstruct unionfs_dir_state *namelist;\n+\tstruct dentry *dentry;\n+\tint bindex;\n+};\n+\n+struct is_opaque_args {\n+\tstruct dentry *dentry;\n+};\n+\n+struct create_args {\n+\tstruct inode *parent;\n+\tstruct dentry *dentry;\n+\tumode_t mode;\n+\tstruct nameidata *nd;\n+};\n+\n+struct mkdir_args {\n+\tstruct inode *parent;\n+\tstruct dentry *dentry;\n+\tumode_t mode;\n+};\n+\n+struct mknod_args {\n+\tstruct inode *parent;\n+\tstruct dentry *dentry;\n+\tumode_t mode;\n+\tdev_t dev;\n+};\n+\n+struct symlink_args {\n+\tstruct inode *parent;\n+\tstruct dentry *dentry;\n+\tchar *symbuf;\n+\tumode_t mode;\n+};\n+\n+struct unlink_args {\n+\tstruct inode *parent;\n+\tstruct dentry *dentry;\n+};\n+\n+\n+struct sioq_args {\n+\tstruct completion comp;\n+\tstruct work_struct work;\n+\tint err;\n+\tvoid *ret;\n+\n+\tunion {\n+\t\tstruct deletewh_args deletewh;\n+\t\tstruct is_opaque_args is_opaque;\n+\t\tstruct create_args create;\n+\t\tstruct mkdir_args mkdir;\n+\t\tstruct mknod_args mknod;\n+\t\tstruct symlink_args symlink;\n+\t\tstruct unlink_args unlink;\n+\t};\n+};\n+\n+/* Extern definitions for SIOQ functions */\n+extern int __init init_sioq(void);\n+extern void stop_sioq(void);\n+extern void run_sioq(work_func_t func, struct sioq_args *args);\n+\n+/* Extern definitions for our privilege escalation helpers */\n+extern void __unionfs_create(struct work_struct *work);\n+extern void __unionfs_mkdir(struct work_struct *work);\n+extern void __unionfs_mknod(struct work_struct *work);\n+extern void __unionfs_symlink(struct work_struct *work);\n+extern void __unionfs_unlink(struct work_struct *work);\n+extern void __delete_whiteouts(struct work_struct *work);\n+extern void __is_opaque_dir(struct work_struct *work);\n+\n+#endif /* not _SIOQ_H */"),
 ('dev/null',
  'b/fs/unionfs/subr.c',
  'diff --git a/fs/unionfs/subr.c b/fs/unionfs/subr.c\nnew file mode 100644\nindex 0000000..018b4fd\n--- dev/null\n+++ b/fs/unionfs/subr.c\n@@ -0,0 +1,95 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * returns the right n_link value based on the inode type\n+ */\n+int unionfs_get_nlinks(const struct inode *inode)\n+{\n+\t/* don\'t bother to do all the work since we\'re unlinked */\n+\tif (inode->i_nlink == 0)\n+\t\treturn 0;\n+\n+\tif (!S_ISDIR(inode->i_mode))\n+\t\treturn unionfs_lower_inode(inode)->i_nlink;\n+\n+\t/*\n+\t * For directories, we return 1. The only place that could cares\n+\t * about links is readdir, and there\'s d_type there so even that\n+\t * doesn\'t matter.\n+\t */\n+\treturn 1;\n+}\n+\n+/* copy a/m/ctime from the lower branch with the newest times */\n+void unionfs_copy_attr_times(struct inode *upper)\n+{\n+\tint bindex;\n+\tstruct inode *lower;\n+\n+\tif (!upper)\n+\t\treturn;\n+\tif (ibstart(upper) < 0) {\n+#ifdef CONFIG_UNION_FS_DEBUG\n+\t\tWARN_ON(ibstart(upper) < 0);\n+#endif /* CONFIG_UNION_FS_DEBUG */\n+\t\treturn;\n+\t}\n+\tfor (bindex = ibstart(upper); bindex <= ibend(upper); bindex++) {\n+\t\tlower = unionfs_lower_inode_idx(upper, bindex);\n+\t\tif (!lower)\n+\t\t\tcontinue; /* not all lower dir objects may exist */\n+\t\tif (unlikely(timespec_compare(&upper->i_mtime,\n+\t\t\t\t\t      &lower->i_mtime) < 0))\n+\t\t\tupper->i_mtime = lower->i_mtime;\n+\t\tif (unlikely(timespec_compare(&upper->i_ctime,\n+\t\t\t\t\t      &lower->i_ctime) < 0))\n+\t\t\tupper->i_ctime = lower->i_ctime;\n+\t\tif (unlikely(timespec_compare(&upper->i_atime,\n+\t\t\t\t\t      &lower->i_atime) < 0))\n+\t\t\tupper->i_atime = lower->i_atime;\n+\t}\n+}\n+\n+/*\n+ * A unionfs/fanout version of fsstack_copy_attr_all.  Uses a\n+ * unionfs_get_nlinks to properly calcluate the number of links to a file.\n+ * Also, copies the max() of all a/m/ctimes for all lower inodes (which is\n+ * important if the lower inode is a directory type)\n+ */\n+void unionfs_copy_attr_all(struct inode *dest,\n+\t\t\t   const struct inode *src)\n+{\n+\tdest->i_mode = src->i_mode;\n+\tdest->i_uid = src->i_uid;\n+\tdest->i_gid = src->i_gid;\n+\tdest->i_rdev = src->i_rdev;\n+\n+\tunionfs_copy_attr_times(dest);\n+\n+\tdest->i_blkbits = src->i_blkbits;\n+\tdest->i_flags = src->i_flags;\n+\n+\t/*\n+\t * Update the nlinks AFTER updating the above fields, because the\n+\t * get_links callback may depend on them.\n+\t */\n+\tdest->i_nlink = unionfs_get_nlinks(dest);\n+}'),
 ('dev/null',
  'b/fs/unionfs/super.c',
  'diff --git a/fs/unionfs/super.c b/fs/unionfs/super.c\nnew file mode 100644\nindex 0000000..314d4f2\n--- dev/null\n+++ b/fs/unionfs/super.c\n@@ -0,0 +1,1048 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * The inode cache is used with alloc_inode for both our inode info and the\n+ * vfs inode.\n+ */\n+static struct kmem_cache *unionfs_inode_cachep;\n+\n+static void unionfs_read_inode(struct inode *inode)\n+{\n+\tint size;\n+\tstruct unionfs_inode_info *info = UNIONFS_I(inode);\n+\n+\tmemset(info, 0, offsetof(struct unionfs_inode_info, vfs_inode));\n+\tinfo->bstart = -1;\n+\tinfo->bend = -1;\n+\tatomic_set(&info->generation,\n+\t\t   atomic_read(&UNIONFS_SB(inode->i_sb)->generation));\n+\tspin_lock_init(&info->rdlock);\n+\tinfo->rdcount = 1;\n+\tinfo->hashsize = -1;\n+\tINIT_LIST_HEAD(&info->readdircache);\n+\n+\tsize = sbmax(inode->i_sb) * sizeof(struct inode *);\n+\tinfo->lower_inodes = kzalloc(size, GFP_KERNEL);\n+\tif (unlikely(!info->lower_inodes)) {\n+\t\tprintk(KERN_CRIT "unionfs: no kernel memory when allocating "\n+\t\t       "lower-pointer array!\\n");\n+\t\tBUG();\n+\t}\n+\n+\tinode->i_version++;\n+\tinode->i_op = &unionfs_main_iops;\n+\tinode->i_fop = &unionfs_main_fops;\n+\n+\tinode->i_mapping->a_ops = &unionfs_aops;\n+\n+\t/*\n+\t * reset times so unionfs_copy_attr_all can keep out time invariants\n+\t * right (upper inode time being the max of all lower ones).\n+\t */\n+\tinode->i_atime.tv_sec = inode->i_atime.tv_nsec = 0;\n+\tinode->i_mtime.tv_sec = inode->i_mtime.tv_nsec = 0;\n+\tinode->i_ctime.tv_sec = inode->i_ctime.tv_nsec = 0;\n+\n+}\n+\n+/*\n+ * we now define delete_inode, because there are two VFS paths that may\n+ * destroy an inode: one of them calls clear inode before doing everything\n+ * else that\'s needed, and the other is fine.  This way we truncate the inode\n+ * size (and its pages) and then clear our own inode, which will do an iput\n+ * on our and the lower inode.\n+ *\n+ * No need to lock sb info\'s rwsem.\n+ */\n+static void unionfs_delete_inode(struct inode *inode)\n+{\n+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)\n+\tspin_lock(&inode->i_lock);\n+#endif\n+\ti_size_write(inode, 0);\t/* every f/s seems to do that */\n+#if BITS_PER_LONG == 32 && defined(CONFIG_SMP)\n+\tspin_unlock(&inode->i_lock);\n+#endif\n+\n+\tif (inode->i_data.nrpages)\n+\t\ttruncate_inode_pages(&inode->i_data, 0);\n+\n+\tclear_inode(inode);\n+}\n+\n+/*\n+ * final actions when unmounting a file system\n+ *\n+ * No need to lock rwsem.\n+ */\n+static void unionfs_put_super(struct super_block *sb)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct unionfs_sb_info *spd;\n+\tint leaks = 0;\n+\n+\tspd = UNIONFS_SB(sb);\n+\tif (!spd)\n+\t\treturn;\n+\n+\tbstart = sbstart(sb);\n+\tbend = sbend(sb);\n+\n+\t/* Make sure we have no leaks of branchget/branchput. */\n+\tfor (bindex = bstart; bindex <= bend; bindex++)\n+\t\tif (unlikely(branch_count(sb, bindex) != 0)) {\n+\t\t\tprintk(KERN_CRIT\n+\t\t\t       "unionfs: branch %d has %d references left!\\n",\n+\t\t\t       bindex, branch_count(sb, bindex));\n+\t\t\tleaks = 1;\n+\t\t}\n+\tWARN_ON(leaks != 0);\n+\n+\t/* decrement lower super references */\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tstruct super_block *s;\n+\t\ts = unionfs_lower_super_idx(sb, bindex);\n+\t\tunionfs_set_lower_super_idx(sb, bindex, NULL);\n+\t\tatomic_dec(&s->s_active);\n+\t}\n+\n+\tkfree(spd->dev_name);\n+\tkfree(spd->data);\n+\tkfree(spd);\n+\tsb->s_fs_info = NULL;\n+}\n+\n+/*\n+ * Since people use this to answer the "How big of a file can I write?"\n+ * question, we report the size of the highest priority branch as the size of\n+ * the union.\n+ */\n+static int unionfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n+{\n+\tint err\t= 0;\n+\tstruct super_block *sb;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *parent;\n+\tbool valid;\n+\n+\tsb = dentry->d_sb;\n+\n+\tunionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\tunionfs_check_dentry(dentry);\n+\n+\tlower_dentry = unionfs_lower_dentry(sb->s_root);\n+\terr = vfs_statfs(lower_dentry, buf);\n+\n+\t/* set return buf to our f/s to avoid confusing user-level utils */\n+\tbuf->f_type = UNIONFS_SUPER_MAGIC;\n+\t/*\n+\t * Our maximum file name can is shorter by a few bytes because every\n+\t * file name could potentially be whited-out.\n+\t *\n+\t * XXX: this restriction goes away with ODF.\n+\t */\n+\tunionfs_set_max_namelen(&buf->f_namelen);\n+\n+\t/*\n+\t * reset two fields to avoid confusing user-land.\n+\t * XXX: is this still necessary?\n+\t */\n+\tmemset(&buf->f_fsid, 0, sizeof(__kernel_fsid_t));\n+\tmemset(&buf->f_spare, 0, sizeof(buf->f_spare));\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(sb);\n+\treturn err;\n+}\n+\n+/* handle mode changing during remount */\n+static noinline_for_stack int do_remount_mode_option(\n+\t\t\t\t\tchar *optarg,\n+\t\t\t\t\tint cur_branches,\n+\t\t\t\t\tstruct unionfs_data *new_data,\n+\t\t\t\t\tstruct path *new_lower_paths)\n+{\n+\tint err = -EINVAL;\n+\tint perms, idx;\n+\tchar *modename = strchr(optarg, \'=\');\n+\tstruct nameidata nd;\n+\n+\t/* by now, optarg contains the branch name */\n+\tif (!*optarg) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: no branch specified for mode change\\n");\n+\t\tgoto out;\n+\t}\n+\tif (!modename) {\n+\t\tprintk(KERN_ERR "unionfs: branch \\"%s\\" requires a mode\\n",\n+\t\t       optarg);\n+\t\tgoto out;\n+\t}\n+\t*modename++ = \'\\0\';\n+\terr = parse_branch_mode(modename, &perms);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: invalid mode \\"%s\\" for \\"%s\\"\\n",\n+\t\t       modename, optarg);\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Find matching branch index.  For now, this assumes that nothing\n+\t * has been mounted on top of this Unionfs stack.  Once we have /odf\n+\t * and cache-coherency resolved, we\'ll address the branch-path\n+\t * uniqueness.\n+\t */\n+\terr = path_lookup(optarg, LOOKUP_FOLLOW, &nd);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: error accessing "\n+\t\t       "lower directory \\"%s\\" (error %d)\\n",\n+\t\t       optarg, err);\n+\t\tgoto out;\n+\t}\n+\tfor (idx = 0; idx < cur_branches; idx++)\n+\t\tif (nd.mnt == new_lower_paths[idx].mnt &&\n+\t\t    nd.dentry == new_lower_paths[idx].dentry)\n+\t\t\tbreak;\n+\tpath_release(&nd);\t/* no longer needed */\n+\tif (idx == cur_branches) {\n+\t\terr = -ENOENT;\t/* err may have been reset above */\n+\t\tprintk(KERN_ERR "unionfs: branch \\"%s\\" "\n+\t\t       "not found\\n", optarg);\n+\t\tgoto out;\n+\t}\n+\t/* check/change mode for existing branch */\n+\t/* we don\'t warn if perms==branchperms */\n+\tnew_data[idx].branchperms = perms;\n+\terr = 0;\n+out:\n+\treturn err;\n+}\n+\n+/* handle branch deletion during remount */\n+static noinline_for_stack int do_remount_del_option(\n+\t\t\t\t\tchar *optarg, int cur_branches,\n+\t\t\t\t\tstruct unionfs_data *new_data,\n+\t\t\t\t\tstruct path *new_lower_paths)\n+{\n+\tint err = -EINVAL;\n+\tint idx;\n+\tstruct nameidata nd;\n+\n+\t/* optarg contains the branch name to delete */\n+\n+\t/*\n+\t * Find matching branch index.  For now, this assumes that nothing\n+\t * has been mounted on top of this Unionfs stack.  Once we have /odf\n+\t * and cache-coherency resolved, we\'ll address the branch-path\n+\t * uniqueness.\n+\t */\n+\terr = path_lookup(optarg, LOOKUP_FOLLOW, &nd);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: error accessing "\n+\t\t       "lower directory \\"%s\\" (error %d)\\n",\n+\t\t       optarg, err);\n+\t\tgoto out;\n+\t}\n+\tfor (idx = 0; idx < cur_branches; idx++)\n+\t\tif (nd.mnt == new_lower_paths[idx].mnt &&\n+\t\t    nd.dentry == new_lower_paths[idx].dentry)\n+\t\t\tbreak;\n+\tpath_release(&nd);\t/* no longer needed */\n+\tif (idx == cur_branches) {\n+\t\tprintk(KERN_ERR "unionfs: branch \\"%s\\" "\n+\t\t       "not found\\n", optarg);\n+\t\terr = -ENOENT;\n+\t\tgoto out;\n+\t}\n+\t/* check if there are any open files on the branch to be deleted */\n+\tif (atomic_read(&new_data[idx].open_files) > 0) {\n+\t\terr = -EBUSY;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Now we have to delete the branch.  First, release any handles it\n+\t * has.  Then, move the remaining array indexes past "idx" in\n+\t * new_data and new_lower_paths one to the left.  Finally, adjust\n+\t * cur_branches.\n+\t */\n+\tpathput(&new_lower_paths[idx]);\n+\n+\tif (idx < cur_branches - 1) {\n+\t\t/* if idx==cur_branches-1, we delete last branch: easy */\n+\t\tmemmove(&new_data[idx], &new_data[idx+1],\n+\t\t\t(cur_branches - 1 - idx) *\n+\t\t\tsizeof(struct unionfs_data));\n+\t\tmemmove(&new_lower_paths[idx], &new_lower_paths[idx+1],\n+\t\t\t(cur_branches - 1 - idx) * sizeof(struct path));\n+\t}\n+\n+\terr = 0;\n+out:\n+\treturn err;\n+}\n+\n+/* handle branch insertion during remount */\n+static noinline_for_stack int do_remount_add_option(\n+\t\t\t\t\tchar *optarg, int cur_branches,\n+\t\t\t\t\tstruct unionfs_data *new_data,\n+\t\t\t\t\tstruct path *new_lower_paths,\n+\t\t\t\t\tint *high_branch_id)\n+{\n+\tint err = -EINVAL;\n+\tint perms;\n+\tint idx = 0;\t\t/* default: insert at beginning */\n+\tchar *new_branch , *modename = NULL;\n+\tstruct nameidata nd;\n+\n+\t/*\n+\t * optarg can be of several forms:\n+\t *\n+\t * /bar:/foo\t\tinsert /foo before /bar\n+\t * /bar:/foo=ro\t\tinsert /foo in ro mode before /bar\n+\t * /foo\t\t\tinsert /foo in the beginning (prepend)\n+\t * :/foo\t\tinsert /foo at the end (append)\n+\t */\n+\tif (*optarg == \':\') {\t/* append? */\n+\t\tnew_branch = optarg + 1; /* skip \':\' */\n+\t\tidx = cur_branches;\n+\t\tgoto found_insertion_point;\n+\t}\n+\tnew_branch = strchr(optarg, \':\');\n+\tif (!new_branch) {\t/* prepend? */\n+\t\tnew_branch = optarg;\n+\t\tgoto found_insertion_point;\n+\t}\n+\t*new_branch++ = \'\\0\';\t/* holds path+mode of new branch */\n+\n+\t/*\n+\t * Find matching branch index.  For now, this assumes that nothing\n+\t * has been mounted on top of this Unionfs stack.  Once we have /odf\n+\t * and cache-coherency resolved, we\'ll address the branch-path\n+\t * uniqueness.\n+\t */\n+\terr = path_lookup(optarg, LOOKUP_FOLLOW, &nd);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: error accessing "\n+\t\t       "lower directory \\"%s\\" (error %d)\\n",\n+\t\t       optarg, err);\n+\t\tgoto out;\n+\t}\n+\tfor (idx = 0; idx < cur_branches; idx++)\n+\t\tif (nd.mnt == new_lower_paths[idx].mnt &&\n+\t\t    nd.dentry == new_lower_paths[idx].dentry)\n+\t\t\tbreak;\n+\tpath_release(&nd);\t/* no longer needed */\n+\tif (idx == cur_branches) {\n+\t\tprintk(KERN_ERR "unionfs: branch \\"%s\\" "\n+\t\t       "not found\\n", optarg);\n+\t\terr = -ENOENT;\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * At this point idx will hold the index where the new branch should\n+\t * be inserted before.\n+\t */\n+found_insertion_point:\n+\t/* find the mode for the new branch */\n+\tif (new_branch)\n+\t\tmodename = strchr(new_branch, \'=\');\n+\tif (modename)\n+\t\t*modename++ = \'\\0\';\n+\tif (!new_branch || !*new_branch) {\n+\t\tprintk(KERN_ERR "unionfs: null new branch\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out;\n+\t}\n+\terr = parse_branch_mode(modename, &perms);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: invalid mode \\"%s\\" for "\n+\t\t       "branch \\"%s\\"\\n", modename, new_branch);\n+\t\tgoto out;\n+\t}\n+\terr = path_lookup(new_branch, LOOKUP_FOLLOW, &nd);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: error accessing "\n+\t\t       "lower directory \\"%s\\" (error %d)\\n",\n+\t\t       new_branch, err);\n+\t\tgoto out;\n+\t}\n+\t/*\n+\t * It\'s probably safe to check_mode the new branch to insert.  Note:\n+\t * we don\'t allow inserting branches which are unionfs\'s by\n+\t * themselves (check_branch returns EINVAL in that case).  This is\n+\t * because this code base doesn\'t support stacking unionfs: the ODF\n+\t * code base supports that correctly.\n+\t */\n+\terr = check_branch(&nd);\n+\tif (err) {\n+\t\tprintk(KERN_ERR "unionfs: lower directory "\n+\t\t       "\\"%s\\" is not a valid branch\\n", optarg);\n+\t\tpath_release(&nd);\n+\t\tgoto out;\n+\t}\n+\n+\t/*\n+\t * Now we have to insert the new branch.  But first, move the bits\n+\t * to make space for the new branch, if needed.  Finally, adjust\n+\t * cur_branches.\n+\t * We don\'t release nd here; it\'s kept until umount/remount.\n+\t */\n+\tif (idx < cur_branches) {\n+\t\t/* if idx==cur_branches, we append: easy */\n+\t\tmemmove(&new_data[idx+1], &new_data[idx],\n+\t\t\t(cur_branches - idx) * sizeof(struct unionfs_data));\n+\t\tmemmove(&new_lower_paths[idx+1], &new_lower_paths[idx],\n+\t\t\t(cur_branches - idx) * sizeof(struct path));\n+\t}\n+\tnew_lower_paths[idx].dentry = nd.dentry;\n+\tnew_lower_paths[idx].mnt = nd.mnt;\n+\n+\tnew_data[idx].sb = nd.dentry->d_sb;\n+\tatomic_set(&new_data[idx].open_files, 0);\n+\tnew_data[idx].branchperms = perms;\n+\tnew_data[idx].branch_id = ++*high_branch_id; /* assign new branch ID */\n+\n+\terr = 0;\n+out:\n+\treturn err;\n+}\n+\n+\n+/*\n+ * Support branch management options on remount.\n+ *\n+ * See Documentation/filesystems/unionfs/ for details.\n+ *\n+ * @flags: numeric mount options\n+ * @options: mount options string\n+ *\n+ * This function can rearrange a mounted union dynamically, adding and\n+ * removing branches, including changing branch modes.  Clearly this has to\n+ * be done safely and atomically.  Luckily, the VFS already calls this\n+ * function with lock_super(sb) and lock_kernel() held, preventing\n+ * concurrent mixing of new mounts, remounts, and unmounts.  Moreover,\n+ * do_remount_sb(), our caller function, already called shrink_dcache_sb(sb)\n+ * to purge dentries/inodes from our superblock, and also called\n+ * fsync_super(sb) to purge any dirty pages.  So we\'re good.\n+ *\n+ * XXX: however, our remount code may also need to invalidate mapped pages\n+ * so as to force them to be re-gotten from the (newly reconfigured) lower\n+ * branches.  This has to wait for proper mmap and cache coherency support\n+ * in the VFS.\n+ *\n+ */\n+static int unionfs_remount_fs(struct super_block *sb, int *flags,\n+\t\t\t      char *options)\n+{\n+\tint err = 0;\n+\tint i;\n+\tchar *optionstmp, *tmp_to_free;\t/* kstrdup\'ed of "options" */\n+\tchar *optname;\n+\tint cur_branches = 0;\t/* no. of current branches */\n+\tint new_branches = 0;\t/* no. of branches actually left in the end */\n+\tint add_branches;\t/* est. no. of branches to add */\n+\tint del_branches;\t/* est. no. of branches to del */\n+\tint max_branches;\t/* max possible no. of branches */\n+\tstruct unionfs_data *new_data = NULL, *tmp_data = NULL;\n+\tstruct path *new_lower_paths = NULL, *tmp_lower_paths = NULL;\n+\tstruct inode **new_lower_inodes = NULL;\n+\tint new_high_branch_id;\t/* new high branch ID */\n+\tint size;\t\t/* memory allocation size, temp var */\n+\tint old_ibstart, old_ibend;\n+\n+\tunionfs_write_lock(sb);\n+\n+\t/*\n+\t * The VFS will take care of "ro" and "rw" flags, and we can safely\n+\t * ignore MS_SILENT, but anything else left over is an error.  So we\n+\t * need to check if any other flags may have been passed (none are\n+\t * allowed/supported as of now).\n+\t */\n+\tif ((*flags & ~(MS_RDONLY | MS_SILENT)) != 0) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: remount flags 0x%x unsupported\\n", *flags);\n+\t\terr = -EINVAL;\n+\t\tgoto out_error;\n+\t}\n+\n+\t/*\n+\t * If \'options\' is NULL, it\'s probably because the user just changed\n+\t * the union to a "ro" or "rw" and the VFS took care of it.  So\n+\t * nothing to do and we\'re done.\n+\t */\n+\tif (!options || options[0] == \'\\0\')\n+\t\tgoto out_error;\n+\n+\t/*\n+\t * Find out how many branches we will have in the end, counting\n+\t * "add" and "del" commands.  Copy the "options" string because\n+\t * strsep modifies the string and we need it later.\n+\t */\n+\ttmp_to_free = kstrdup(options, GFP_KERNEL);\n+\toptionstmp = tmp_to_free;\n+\tif (unlikely(!optionstmp)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_free;\n+\t}\n+\tcur_branches = sbmax(sb); /* current no. branches */\n+\tnew_branches = sbmax(sb);\n+\tdel_branches = 0;\n+\tadd_branches = 0;\n+\tnew_high_branch_id = sbhbid(sb); /* save current high_branch_id */\n+\twhile ((optname = strsep(&optionstmp, ",")) != NULL) {\n+\t\tchar *optarg;\n+\n+\t\tif (!optname || !*optname)\n+\t\t\tcontinue;\n+\n+\t\toptarg = strchr(optname, \'=\');\n+\t\tif (optarg)\n+\t\t\t*optarg++ = \'\\0\';\n+\n+\t\tif (!strcmp("add", optname))\n+\t\t\tadd_branches++;\n+\t\telse if (!strcmp("del", optname))\n+\t\t\tdel_branches++;\n+\t}\n+\tkfree(tmp_to_free);\n+\t/* after all changes, will we have at least one branch left? */\n+\tif ((new_branches + add_branches - del_branches) < 1) {\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: no branches left after remount\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out_free;\n+\t}\n+\n+\t/*\n+\t * Since we haven\'t actually parsed all the add/del options, nor\n+\t * have we checked them for errors, we don\'t know for sure how many\n+\t * branches we will have after all changes have taken place.  In\n+\t * fact, the total number of branches left could be less than what\n+\t * we have now.  So we need to allocate space for a temporary\n+\t * placeholder that is at least as large as the maximum number of\n+\t * branches we *could* have, which is the current number plus all\n+\t * the additions.  Once we\'re done with these temp placeholders, we\n+\t * may have to re-allocate the final size, copy over from the temp,\n+\t * and then free the temps (done near the end of this function).\n+\t */\n+\tmax_branches = cur_branches + add_branches;\n+\t/* allocate space for new pointers to lower dentry */\n+\ttmp_data = kcalloc(max_branches,\n+\t\t\t   sizeof(struct unionfs_data), GFP_KERNEL);\n+\tif (unlikely(!tmp_data)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_free;\n+\t}\n+\t/* allocate space for new pointers to lower paths */\n+\ttmp_lower_paths = kcalloc(max_branches,\n+\t\t\t\t  sizeof(struct path), GFP_KERNEL);\n+\tif (unlikely(!tmp_lower_paths)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_free;\n+\t}\n+\t/* copy current info into new placeholders, incrementing refcnts */\n+\tmemcpy(tmp_data, UNIONFS_SB(sb)->data,\n+\t       cur_branches * sizeof(struct unionfs_data));\n+\tmemcpy(tmp_lower_paths, UNIONFS_D(sb->s_root)->lower_paths,\n+\t       cur_branches * sizeof(struct path));\n+\tfor (i = 0; i < cur_branches; i++)\n+\t\tpathget(&tmp_lower_paths[i]); /* drop refs at end of fxn */\n+\n+\t/*******************************************************************\n+\t * For each branch command, do path_lookup on the requested branch,\n+\t * and apply the change to a temp branch list.  To handle errors, we\n+\t * already dup\'ed the old arrays (above), and increased the refcnts\n+\t * on various f/s objects.  So now we can do all the path_lookups\n+\t * and branch-management commands on the new arrays.  If it fail mid\n+\t * way, we free the tmp arrays and *put all objects.  If we succeed,\n+\t * then we free old arrays and *put its objects, and then replace\n+\t * the arrays with the new tmp list (we may have to re-allocate the\n+\t * memory because the temp lists could have been larger than what we\n+\t * actually needed).\n+\t *******************************************************************/\n+\n+\twhile ((optname = strsep(&options, ",")) != NULL) {\n+\t\tchar *optarg;\n+\n+\t\tif (!optname || !*optname)\n+\t\t\tcontinue;\n+\t\t/*\n+\t\t * At this stage optname holds a comma-delimited option, but\n+\t\t * without the commas.  Next, we need to break the string on\n+\t\t * the \'=\' symbol to separate CMD=ARG, where ARG itself can\n+\t\t * be KEY=VAL.  For example, in mode=/foo=rw, CMD is "mode",\n+\t\t * KEY is "/foo", and VAL is "rw".\n+\t\t */\n+\t\toptarg = strchr(optname, \'=\');\n+\t\tif (optarg)\n+\t\t\t*optarg++ = \'\\0\';\n+\t\t/* incgen remount option (instead of old ioctl) */\n+\t\tif (!strcmp("incgen", optname)) {\n+\t\t\terr = 0;\n+\t\t\tgoto out_no_change;\n+\t\t}\n+\n+\t\t/*\n+\t\t * All of our options take an argument now.  (Insert ones\n+\t\t * that don\'t above this check.)  So at this stage optname\n+\t\t * contains the CMD part and optarg contains the ARG part.\n+\t\t */\n+\t\tif (!optarg || !*optarg) {\n+\t\t\tprintk(KERN_ERR "unionfs: all remount options require "\n+\t\t\t       "an argument (%s)\\n", optname);\n+\t\t\terr = -EINVAL;\n+\t\t\tgoto out_release;\n+\t\t}\n+\n+\t\tif (!strcmp("add", optname)) {\n+\t\t\terr = do_remount_add_option(optarg, new_branches,\n+\t\t\t\t\t\t    tmp_data,\n+\t\t\t\t\t\t    tmp_lower_paths,\n+\t\t\t\t\t\t    &new_high_branch_id);\n+\t\t\tif (err)\n+\t\t\t\tgoto out_release;\n+\t\t\tnew_branches++;\n+\t\t\tif (new_branches > UNIONFS_MAX_BRANCHES) {\n+\t\t\t\tprintk(KERN_ERR "unionfs: command exceeds "\n+\t\t\t\t       "%d branches\\n", UNIONFS_MAX_BRANCHES);\n+\t\t\t\terr = -E2BIG;\n+\t\t\t\tgoto out_release;\n+\t\t\t}\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (!strcmp("del", optname)) {\n+\t\t\terr = do_remount_del_option(optarg, new_branches,\n+\t\t\t\t\t\t    tmp_data,\n+\t\t\t\t\t\t    tmp_lower_paths);\n+\t\t\tif (err)\n+\t\t\t\tgoto out_release;\n+\t\t\tnew_branches--;\n+\t\t\tcontinue;\n+\t\t}\n+\t\tif (!strcmp("mode", optname)) {\n+\t\t\terr = do_remount_mode_option(optarg, new_branches,\n+\t\t\t\t\t\t     tmp_data,\n+\t\t\t\t\t\t     tmp_lower_paths);\n+\t\t\tif (err)\n+\t\t\t\tgoto out_release;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/*\n+\t\t * When you use "mount -o remount,ro", mount(8) will\n+\t\t * reportedly pass the original dirs= string from\n+\t\t * /proc/mounts.  So for now, we have to ignore dirs= and\n+\t\t * not consider it an error, unless we want to allow users\n+\t\t * to pass dirs= in remount.  Note that to allow the VFS to\n+\t\t * actually process the ro/rw remount options, we have to\n+\t\t * return 0 from this function.\n+\t\t */\n+\t\tif (!strcmp("dirs", optname)) {\n+\t\t\tprintk(KERN_WARNING\n+\t\t\t       "unionfs: remount ignoring option \\"%s\\"\\n",\n+\t\t\t       optname);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\terr = -EINVAL;\n+\t\tprintk(KERN_ERR\n+\t\t       "unionfs: unrecognized option \\"%s\\"\\n", optname);\n+\t\tgoto out_release;\n+\t}\n+\n+out_no_change:\n+\n+\t/******************************************************************\n+\t * WE\'RE ALMOST DONE: check if leftmost branch might be read-only,\n+\t * see if we need to allocate a small-sized new vector, copy the\n+\t * vectors to their correct place, release the refcnt of the older\n+\t * ones, and return.  Also handle invalidating any pages that will\n+\t * have to be re-read.\n+\t *******************************************************************/\n+\n+\tif (!(tmp_data[0].branchperms & MAY_WRITE)) {\n+\t\tprintk(KERN_ERR "unionfs: leftmost branch cannot be read-only "\n+\t\t       "(use \\"remount,ro\\" to create a read-only union)\\n");\n+\t\terr = -EINVAL;\n+\t\tgoto out_release;\n+\t}\n+\n+\t/* (re)allocate space for new pointers to lower dentry */\n+\tsize = new_branches * sizeof(struct unionfs_data);\n+\tnew_data = krealloc(tmp_data, size, GFP_KERNEL);\n+\tif (unlikely(!new_data)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_release;\n+\t}\n+\n+\t/* allocate space for new pointers to lower paths */\n+\tsize = new_branches * sizeof(struct path);\n+\tnew_lower_paths = krealloc(tmp_lower_paths, size, GFP_KERNEL);\n+\tif (unlikely(!new_lower_paths)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_release;\n+\t}\n+\n+\t/* allocate space for new pointers to lower inodes */\n+\tnew_lower_inodes = kcalloc(new_branches,\n+\t\t\t\t   sizeof(struct inode *), GFP_KERNEL);\n+\tif (unlikely(!new_lower_inodes)) {\n+\t\terr = -ENOMEM;\n+\t\tgoto out_release;\n+\t}\n+\n+\t/*\n+\t * OK, just before we actually put the new set of branches in place,\n+\t * we need to ensure that our own f/s has no dirty objects left.\n+\t * Luckily, do_remount_sb() already calls shrink_dcache_sb(sb) and\n+\t * fsync_super(sb), taking care of dentries, inodes, and dirty\n+\t * pages.  So all that\'s left is for us to invalidate any leftover\n+\t * (non-dirty) pages to ensure that they will be re-read from the\n+\t * new lower branches (and to support mmap).\n+\t */\n+\n+\t/*\n+\t * Once we finish the remounting successfully, our superblock\n+\t * generation number will have increased.  This will be detected by\n+\t * our dentry-revalidation code upon subsequent f/s operations\n+\t * through unionfs.  The revalidation code will rebuild the union of\n+\t * lower inodes for a given unionfs inode and invalidate any pages\n+\t * of such "stale" inodes (by calling our purge_inode_data\n+\t * function).  This revalidation will happen lazily and\n+\t * incrementally, as users perform operations on cached inodes.  We\n+\t * would like to encourage this revalidation to happen sooner if\n+\t * possible, so we like to try to invalidate as many other pages in\n+\t * our superblock as we can.  We used to call drop_pagecache_sb() or\n+\t * a variant thereof, but either method was racy (drop_caches alone\n+\t * is known to be racy).  So now we let the revalidation happen on a\n+\t * per file basis in ->d_revalidate.\n+\t */\n+\n+\t/* grab new lower super references; release old ones */\n+\tfor (i = 0; i < new_branches; i++)\n+\t\tatomic_inc(&new_data[i].sb->s_active);\n+\tfor (i = 0; i < sbmax(sb); i++)\n+\t\tatomic_dec(&UNIONFS_SB(sb)->data[i].sb->s_active);\n+\n+\t/* copy new vectors into their correct place */\n+\ttmp_data = UNIONFS_SB(sb)->data;\n+\tUNIONFS_SB(sb)->data = new_data;\n+\tnew_data = NULL;\t/* so don\'t free good pointers below */\n+\ttmp_lower_paths = UNIONFS_D(sb->s_root)->lower_paths;\n+\tUNIONFS_D(sb->s_root)->lower_paths = new_lower_paths;\n+\tnew_lower_paths = NULL;\t/* so don\'t free good pointers below */\n+\n+\t/* update our unionfs_sb_info and root dentry index of last branch */\n+\ti = sbmax(sb);\t\t/* save no. of branches to release at end */\n+\tsbend(sb) = new_branches - 1;\n+\tdbend(sb->s_root) = new_branches - 1;\n+\told_ibstart = ibstart(sb->s_root->d_inode);\n+\told_ibend = ibend(sb->s_root->d_inode);\n+\tibend(sb->s_root->d_inode) = new_branches - 1;\n+\tUNIONFS_D(sb->s_root)->bcount = new_branches;\n+\tnew_branches = i; /* no. of branches to release below */\n+\n+\t/*\n+\t * Update lower inodes: 3 steps\n+\t * 1. grab ref on all new lower inodes\n+\t */\n+\tfor (i = dbstart(sb->s_root); i <= dbend(sb->s_root); i++) {\n+\t\tstruct dentry *lower_dentry =\n+\t\t\tunionfs_lower_dentry_idx(sb->s_root, i);\n+\t\tigrab(lower_dentry->d_inode);\n+\t\tnew_lower_inodes[i] = lower_dentry->d_inode;\n+\t}\n+\t/* 2. release reference on all older lower inodes */\n+\tiput_lowers(sb->s_root->d_inode, old_ibstart, old_ibend, true);\n+\t/* 3. update root dentry\'s inode to new lower_inodes array */\n+\tUNIONFS_I(sb->s_root->d_inode)->lower_inodes = new_lower_inodes;\n+\tnew_lower_inodes = NULL;\n+\n+\t/* maxbytes may have changed */\n+\tsb->s_maxbytes = unionfs_lower_super_idx(sb, 0)->s_maxbytes;\n+\t/* update high branch ID */\n+\tsbhbid(sb) = new_high_branch_id;\n+\n+\t/* update our sb->generation for revalidating objects */\n+\ti = atomic_inc_return(&UNIONFS_SB(sb)->generation);\n+\tatomic_set(&UNIONFS_D(sb->s_root)->generation, i);\n+\tatomic_set(&UNIONFS_I(sb->s_root->d_inode)->generation, i);\n+\tif (!(*flags & MS_SILENT))\n+\t\tpr_info("unionfs: %s: new generation number %d\\n",\n+\t\t\tUNIONFS_SB(sb)->dev_name, i);\n+\t/* finally, update the root dentry\'s times */\n+\tunionfs_copy_attr_times(sb->s_root->d_inode);\n+\terr = 0;\t\t/* reset to success */\n+\n+\t/*\n+\t * The code above falls through to the next label, and releases the\n+\t * refcnts of the older ones (stored in tmp_*): if we fell through\n+\t * here, it means success.  However, if we jump directly to this\n+\t * label from any error above, then an error occurred after we\n+\t * grabbed various refcnts, and so we have to release the\n+\t * temporarily constructed structures.\n+\t */\n+out_release:\n+\t/* no need to cleanup/release anything in tmp_data */\n+\tif (tmp_lower_paths)\n+\t\tfor (i = 0; i < new_branches; i++)\n+\t\t\tpathput(&tmp_lower_paths[i]);\n+out_free:\n+\tkfree(tmp_lower_paths);\n+\tkfree(tmp_data);\n+\tkfree(new_lower_paths);\n+\tkfree(new_data);\n+\tkfree(new_lower_inodes);\n+out_error:\n+\tunionfs_check_dentry(sb->s_root);\n+\tunionfs_write_unlock(sb);\n+\treturn err;\n+}\n+\n+/*\n+ * Called by iput() when the inode reference count reached zero\n+ * and the inode is not hashed anywhere.  Used to clear anything\n+ * that needs to be, before the inode is completely destroyed and put\n+ * on the inode free list.\n+ *\n+ * No need to lock sb info\'s rwsem.\n+ */\n+static void unionfs_clear_inode(struct inode *inode)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct inode *lower_inode;\n+\tstruct list_head *pos, *n;\n+\tstruct unionfs_dir_state *rdstate;\n+\n+\tlist_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {\n+\t\trdstate = list_entry(pos, struct unionfs_dir_state, cache);\n+\t\tlist_del(&rdstate->cache);\n+\t\tfree_rdstate(rdstate);\n+\t}\n+\n+\t/*\n+\t * Decrement a reference to a lower_inode, which was incremented\n+\t * by our read_inode when it was created initially.\n+\t */\n+\tbstart = ibstart(inode);\n+\tbend = ibend(inode);\n+\tif (bstart >= 0) {\n+\t\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\t\tlower_inode = unionfs_lower_inode_idx(inode, bindex);\n+\t\t\tif (!lower_inode)\n+\t\t\t\tcontinue;\n+\t\t\tunionfs_set_lower_inode_idx(inode, bindex, NULL);\n+\t\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\t\tlockdep_off();\n+\t\t\tiput(lower_inode);\n+\t\t\tlockdep_on();\n+\t\t}\n+\t}\n+\n+\tkfree(UNIONFS_I(inode)->lower_inodes);\n+\tUNIONFS_I(inode)->lower_inodes = NULL;\n+}\n+\n+static struct inode *unionfs_alloc_inode(struct super_block *sb)\n+{\n+\tstruct unionfs_inode_info *i;\n+\n+\ti = kmem_cache_alloc(unionfs_inode_cachep, GFP_KERNEL);\n+\tif (unlikely(!i))\n+\t\treturn NULL;\n+\n+\t/* memset everything up to the inode to 0 */\n+\tmemset(i, 0, offsetof(struct unionfs_inode_info, vfs_inode));\n+\n+\ti->vfs_inode.i_version = 1;\n+\treturn &i->vfs_inode;\n+}\n+\n+static void unionfs_destroy_inode(struct inode *inode)\n+{\n+\tkmem_cache_free(unionfs_inode_cachep, UNIONFS_I(inode));\n+}\n+\n+/* unionfs inode cache constructor */\n+static void init_once(void *v, struct kmem_cache *cachep, unsigned long flags)\n+{\n+\tstruct unionfs_inode_info *i = v;\n+\n+\tinode_init_once(&i->vfs_inode);\n+}\n+\n+int unionfs_init_inode_cache(void)\n+{\n+\tint err = 0;\n+\n+\tunionfs_inode_cachep =\n+\t\tkmem_cache_create("unionfs_inode_cache",\n+\t\t\t\t  sizeof(struct unionfs_inode_info), 0,\n+\t\t\t\t  SLAB_RECLAIM_ACCOUNT, init_once);\n+\tif (unlikely(!unionfs_inode_cachep))\n+\t\terr = -ENOMEM;\n+\treturn err;\n+}\n+\n+/* unionfs inode cache destructor */\n+void unionfs_destroy_inode_cache(void)\n+{\n+\tif (unionfs_inode_cachep)\n+\t\tkmem_cache_destroy(unionfs_inode_cachep);\n+}\n+\n+/*\n+ * Called when we have a dirty inode, right here we only throw out\n+ * parts of our readdir list that are too old.\n+ *\n+ * No need to grab sb info\'s rwsem.\n+ */\n+static int unionfs_write_inode(struct inode *inode, int sync)\n+{\n+\tstruct list_head *pos, *n;\n+\tstruct unionfs_dir_state *rdstate;\n+\n+\tspin_lock(&UNIONFS_I(inode)->rdlock);\n+\tlist_for_each_safe(pos, n, &UNIONFS_I(inode)->readdircache) {\n+\t\trdstate = list_entry(pos, struct unionfs_dir_state, cache);\n+\t\t/* We keep this list in LRU order. */\n+\t\tif ((rdstate->access + RDCACHE_JIFFIES) > jiffies)\n+\t\t\tbreak;\n+\t\tUNIONFS_I(inode)->rdcount--;\n+\t\tlist_del(&rdstate->cache);\n+\t\tfree_rdstate(rdstate);\n+\t}\n+\tspin_unlock(&UNIONFS_I(inode)->rdlock);\n+\n+\treturn 0;\n+}\n+\n+/*\n+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent\n+ * code can actually succeed and won\'t leave tasks that need handling.\n+ */\n+static void unionfs_umount_begin(struct vfsmount *mnt, int flags)\n+{\n+\tstruct super_block *sb, *lower_sb;\n+\tstruct vfsmount *lower_mnt;\n+\tint bindex, bstart, bend;\n+\n+\tif (!(flags & MNT_FORCE))\n+\t\t/*\n+\t\t * we are not being MNT_FORCE\'d, therefore we should emulate\n+\t\t * old behavior\n+\t\t */\n+\t\treturn;\n+\n+\tsb = mnt->mnt_sb;\n+\n+\tunionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);\n+\n+\tbstart = sbstart(sb);\n+\tbend = sbend(sb);\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_mnt = unionfs_lower_mnt_idx(sb->s_root, bindex);\n+\t\tlower_sb = unionfs_lower_super_idx(sb, bindex);\n+\n+\t\tif (lower_mnt && lower_sb && lower_sb->s_op &&\n+\t\t    lower_sb->s_op->umount_begin)\n+\t\t\tlower_sb->s_op->umount_begin(lower_mnt, flags);\n+\t}\n+\n+\tunionfs_read_unlock(sb);\n+}\n+\n+static int unionfs_show_options(struct seq_file *m, struct vfsmount *mnt)\n+{\n+\tstruct super_block *sb = mnt->mnt_sb;\n+\tint ret = 0;\n+\tchar *tmp_page;\n+\tchar *path;\n+\tint bindex, bstart, bend;\n+\tint perms;\n+\n+\tunionfs_read_lock(sb, UNIONFS_SMUTEX_CHILD);\n+\n+\tunionfs_lock_dentry(sb->s_root, UNIONFS_DMUTEX_CHILD);\n+\n+\ttmp_page = (char *) __get_free_page(GFP_KERNEL);\n+\tif (unlikely(!tmp_page)) {\n+\t\tret = -ENOMEM;\n+\t\tgoto out;\n+\t}\n+\n+\tbstart = sbstart(sb);\n+\tbend = sbend(sb);\n+\n+\tseq_printf(m, ",dirs=");\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tpath = d_path(unionfs_lower_dentry_idx(sb->s_root, bindex),\n+\t\t\t      unionfs_lower_mnt_idx(sb->s_root, bindex),\n+\t\t\t      tmp_page, PAGE_SIZE);\n+\t\tif (IS_ERR(path)) {\n+\t\t\tret = PTR_ERR(path);\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\tperms = branchperms(sb, bindex);\n+\n+\t\tseq_printf(m, "%s=%s", path,\n+\t\t\t   perms & MAY_WRITE ? "rw" : "ro");\n+\t\tif (bindex != bend)\n+\t\t\tseq_printf(m, ":");\n+\t}\n+\n+out:\n+\tfree_page((unsigned long) tmp_page);\n+\n+\tunionfs_unlock_dentry(sb->s_root);\n+\n+\tunionfs_read_unlock(sb);\n+\n+\treturn ret;\n+}\n+\n+struct super_operations unionfs_sops = {\n+\t.read_inode\t= unionfs_read_inode,\n+\t.delete_inode\t= unionfs_delete_inode,\n+\t.put_super\t= unionfs_put_super,\n+\t.statfs\t\t= unionfs_statfs,\n+\t.remount_fs\t= unionfs_remount_fs,\n+\t.clear_inode\t= unionfs_clear_inode,\n+\t.umount_begin\t= unionfs_umount_begin,\n+\t.show_options\t= unionfs_show_options,\n+\t.write_inode\t= unionfs_write_inode,\n+\t.alloc_inode\t= unionfs_alloc_inode,\n+\t.destroy_inode\t= unionfs_destroy_inode,\n+};'),
 ('dev/null',
  'b/fs/unionfs/union.h',
  'diff --git a/fs/unionfs/union.h b/fs/unionfs/union.h\nnew file mode 100644\nindex 0000000..0bca4a6\n--- dev/null\n+++ b/fs/unionfs/union.h\n@@ -0,0 +1,653 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#ifndef _UNION_H_\n+#define _UNION_H_\n+\n+#include <linux/dcache.h>\n+#include <linux/file.h>\n+#include <linux/list.h>\n+#include <linux/fs.h>\n+#include <linux/mm.h>\n+#include <linux/module.h>\n+#include <linux/mount.h>\n+#include <linux/namei.h>\n+#include <linux/page-flags.h>\n+#include <linux/pagemap.h>\n+#include <linux/poll.h>\n+#include <linux/security.h>\n+#include <linux/seq_file.h>\n+#include <linux/slab.h>\n+#include <linux/spinlock.h>\n+#include <linux/smp_lock.h>\n+#include <linux/statfs.h>\n+#include <linux/string.h>\n+#include <linux/vmalloc.h>\n+#include <linux/writeback.h>\n+#include <linux/buffer_head.h>\n+#include <linux/xattr.h>\n+#include <linux/fs_stack.h>\n+#include <linux/magic.h>\n+#include <linux/log2.h>\n+#include <linux/poison.h>\n+#include <linux/mman.h>\n+#include <linux/backing-dev.h>\n+#include <linux/splice.h>\n+\n+#include <asm/system.h>\n+\n+#include <linux/union_fs.h>\n+\n+/* the file system name */\n+#define UNIONFS_NAME "unionfs"\n+\n+/* unionfs root inode number */\n+#define UNIONFS_ROOT_INO     1\n+\n+/* number of times we try to get a unique temporary file name */\n+#define GET_TMPNAM_MAX_RETRY\t5\n+\n+/* maximum number of branches we support, to avoid memory blowup */\n+#define UNIONFS_MAX_BRANCHES\t128\n+\n+/* minimum time (seconds) required for time-based cache-coherency */\n+#define UNIONFS_MIN_CC_TIME\t3\n+\n+/* Operations vectors defined in specific files. */\n+extern struct file_operations unionfs_main_fops;\n+extern struct file_operations unionfs_dir_fops;\n+extern struct inode_operations unionfs_main_iops;\n+extern struct inode_operations unionfs_dir_iops;\n+extern struct inode_operations unionfs_symlink_iops;\n+extern struct super_operations unionfs_sops;\n+extern struct dentry_operations unionfs_dops;\n+extern struct address_space_operations unionfs_aops, unionfs_dummy_aops;\n+extern struct vm_operations_struct unionfs_vm_ops;\n+\n+/* How long should an entry be allowed to persist */\n+#define RDCACHE_JIFFIES\t(5*HZ)\n+\n+/* compatibility with Real-Time patches */\n+#ifdef CONFIG_PREEMPT_RT\n+# define unionfs_rw_semaphore\tcompat_rw_semaphore\n+#else /* not CONFIG_PREEMPT_RT */\n+# define unionfs_rw_semaphore\trw_semaphore\n+#endif /* not CONFIG_PREEMPT_RT */\n+\n+#ifndef noinline_for_stack\n+# define noinline_for_stack noinline\n+#endif /* not noinline_for_stack */\n+\n+/* file private data. */\n+struct unionfs_file_info {\n+\tint bstart;\n+\tint bend;\n+\tatomic_t generation;\n+\n+\tstruct unionfs_dir_state *rdstate;\n+\tstruct file **lower_files;\n+\tint *saved_branch_ids; /* IDs of branches when file was opened */\n+\tstruct vm_operations_struct *lower_vm_ops;\n+\tbool wrote_to_file;\t/* for delayed copyup */\n+};\n+\n+/* unionfs inode data in memory */\n+struct unionfs_inode_info {\n+\tint bstart;\n+\tint bend;\n+\tatomic_t generation;\n+\t/* Stuff for readdir over NFS. */\n+\tspinlock_t rdlock;\n+\tstruct list_head readdircache;\n+\tint rdcount;\n+\tint hashsize;\n+\tint cookie;\n+\n+\t/* The lower inodes */\n+\tstruct inode **lower_inodes;\n+\n+\tstruct inode vfs_inode;\n+};\n+\n+/* unionfs dentry data in memory */\n+struct unionfs_dentry_info {\n+\t/*\n+\t * The semaphore is used to lock the dentry as soon as we get into a\n+\t * unionfs function from the VFS.  Our lock ordering is that children\n+\t * go before their parents.\n+\t */\n+\tstruct mutex lock;\n+\tint bstart;\n+\tint bend;\n+\tint bopaque;\n+\tint bcount;\n+\tatomic_t generation;\n+\tstruct path *lower_paths;\n+};\n+\n+/* These are the pointers to our various objects. */\n+struct unionfs_data {\n+\tstruct super_block *sb;\t/* lower super_block */\n+\tatomic_t open_files;\t/* number of open files on branch */\n+\tint branchperms;\n+\tint branch_id;\t\t/* unique branch ID at re/mount time */\n+};\n+\n+/* unionfs super-block data in memory */\n+struct unionfs_sb_info {\n+\tint bend;\n+\n+\tatomic_t generation;\n+\n+\t/*\n+\t * This rwsem is used to make sure that a branch management\n+\t * operation...\n+\t *   1) will not begin before all currently in-flight operations\n+\t *      complete.\n+\t *   2) any new operations do not execute until the currently\n+\t *      running branch management operation completes.\n+\t *\n+\t * The write_lock_owner records the PID of the task which grabbed\n+\t * the rw_sem for writing.  If the same task also tries to grab the\n+\t * read lock, we allow it.  This prevents a self-deadlock when\n+\t * branch-management is used on a pivot_root\'ed union, because we\n+\t * have to ->lookup paths which belong to the same union.\n+\t */\n+\tstruct unionfs_rw_semaphore rwsem;\n+\tpid_t write_lock_owner;\t/* PID of rw_sem owner (write lock) */\n+\tint high_branch_id;\t/* last unique branch ID given */\n+\tchar *dev_name;\t\t/* to identify different unions in pr_debug */\n+\tstruct unionfs_data *data;\n+};\n+\n+/*\n+ * structure for making the linked list of entries by readdir on left branch\n+ * to compare with entries on right branch\n+ */\n+struct filldir_node {\n+\tstruct list_head file_list;\t/* list for directory entries */\n+\tchar *name;\t\t/* name entry */\n+\tint hash;\t\t/* name hash */\n+\tint namelen;\t\t/* name len since name is not 0 terminated */\n+\n+\t/*\n+\t * we can check for duplicate whiteouts and files in the same branch\n+\t * in order to return -EIO.\n+\t */\n+\tint bindex;\n+\n+\t/* is this a whiteout entry? */\n+\tint whiteout;\n+\n+\t/* Inline name, so we don\'t need to separately kmalloc small ones */\n+\tchar iname[DNAME_INLINE_LEN_MIN];\n+};\n+\n+/* Directory hash table. */\n+struct unionfs_dir_state {\n+\tunsigned int cookie;\t/* the cookie, based off of rdversion */\n+\tunsigned int offset;\t/* The entry we have returned. */\n+\tint bindex;\n+\tloff_t dirpos;\t\t/* offset within the lower level directory */\n+\tint size;\t\t/* How big is the hash table? */\n+\tint hashentries;\t/* How many entries have been inserted? */\n+\tunsigned long access;\n+\n+\t/* This cache list is used when the inode keeps us around. */\n+\tstruct list_head cache;\n+\tstruct list_head list[0];\n+};\n+\n+/* externs needed for fanout.h or sioq.h */\n+extern int unionfs_get_nlinks(const struct inode *inode);\n+extern void unionfs_copy_attr_times(struct inode *upper);\n+extern void unionfs_copy_attr_all(struct inode *dest, const struct inode *src);\n+\n+/* include miscellaneous macros */\n+#include "fanout.h"\n+#include "sioq.h"\n+\n+/* externs for cache creation/deletion routines */\n+extern void unionfs_destroy_filldir_cache(void);\n+extern int unionfs_init_filldir_cache(void);\n+extern int unionfs_init_inode_cache(void);\n+extern void unionfs_destroy_inode_cache(void);\n+extern int unionfs_init_dentry_cache(void);\n+extern void unionfs_destroy_dentry_cache(void);\n+\n+/* Initialize and free readdir-specific  state. */\n+extern int init_rdstate(struct file *file);\n+extern struct unionfs_dir_state *alloc_rdstate(struct inode *inode,\n+\t\t\t\t\t       int bindex);\n+extern struct unionfs_dir_state *find_rdstate(struct inode *inode,\n+\t\t\t\t\t      loff_t fpos);\n+extern void free_rdstate(struct unionfs_dir_state *state);\n+extern int add_filldir_node(struct unionfs_dir_state *rdstate,\n+\t\t\t    const char *name, int namelen, int bindex,\n+\t\t\t    int whiteout);\n+extern struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,\n+\t\t\t\t\t      const char *name, int namelen,\n+\t\t\t\t\t      int is_whiteout);\n+\n+extern struct dentry **alloc_new_dentries(int objs);\n+extern struct unionfs_data *alloc_new_data(int objs);\n+\n+/* We can only use 32-bits of offset for rdstate --- blech! */\n+#define DIREOF (0xfffff)\n+#define RDOFFBITS 20\t\t/* This is the number of bits in DIREOF. */\n+#define MAXRDCOOKIE (0xfff)\n+/* Turn an rdstate into an offset. */\n+static inline off_t rdstate2offset(struct unionfs_dir_state *buf)\n+{\n+\toff_t tmp;\n+\n+\ttmp = ((buf->cookie & MAXRDCOOKIE) << RDOFFBITS)\n+\t\t| (buf->offset & DIREOF);\n+\treturn tmp;\n+}\n+\n+/* Macros for locking a super_block. */\n+enum unionfs_super_lock_class {\n+\tUNIONFS_SMUTEX_NORMAL,\n+\tUNIONFS_SMUTEX_PARENT,\t/* when locking on behalf of file */\n+\tUNIONFS_SMUTEX_CHILD,\t/* when locking on behalf of dentry */\n+};\n+static inline void unionfs_read_lock(struct super_block *sb, int subclass)\n+{\n+\tif (UNIONFS_SB(sb)->write_lock_owner &&\n+\t    UNIONFS_SB(sb)->write_lock_owner == current->pid)\n+\t\treturn;\n+\tdown_read_nested(&UNIONFS_SB(sb)->rwsem, subclass);\n+}\n+static inline void unionfs_read_unlock(struct super_block *sb)\n+{\n+\tif (UNIONFS_SB(sb)->write_lock_owner &&\n+\t    UNIONFS_SB(sb)->write_lock_owner == current->pid)\n+\t\treturn;\n+\tup_read(&UNIONFS_SB(sb)->rwsem);\n+}\n+static inline void unionfs_write_lock(struct super_block *sb)\n+{\n+\tdown_write(&UNIONFS_SB(sb)->rwsem);\n+\tUNIONFS_SB(sb)->write_lock_owner = current->pid;\n+}\n+static inline void unionfs_write_unlock(struct super_block *sb)\n+{\n+\tup_write(&UNIONFS_SB(sb)->rwsem);\n+\tUNIONFS_SB(sb)->write_lock_owner = 0;\n+}\n+\n+static inline void unionfs_double_lock_dentry(struct dentry *d1,\n+\t\t\t\t\t      struct dentry *d2)\n+{\n+\tBUG_ON(d1 == d2);\n+\tif (d1 < d2) {\n+\t\tunionfs_lock_dentry(d1, UNIONFS_DMUTEX_PARENT);\n+\t\tunionfs_lock_dentry(d2, UNIONFS_DMUTEX_CHILD);\n+\t} else {\n+\t\tunionfs_lock_dentry(d2, UNIONFS_DMUTEX_PARENT);\n+\t\tunionfs_lock_dentry(d1, UNIONFS_DMUTEX_CHILD);\n+\t}\n+}\n+\n+static inline void unionfs_double_unlock_dentry(struct dentry *d1,\n+\t\t\t\t\t\tstruct dentry *d2)\n+{\n+\tBUG_ON(d1 == d2);\n+\tif (d1 < d2) { /* unlock in reverse order than double_lock_dentry */\n+\t\tunionfs_unlock_dentry(d1);\n+\t\tunionfs_unlock_dentry(d2);\n+\t} else {\n+\t\tunionfs_unlock_dentry(d2);\n+\t\tunionfs_unlock_dentry(d1);\n+\t}\n+}\n+\n+static inline void unionfs_double_lock_parents(struct dentry *p1,\n+\t\t\t\t\t       struct dentry *p2)\n+{\n+\tif (p1 == p2) {\n+\t\tunionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_PARENT);\n+\t\treturn;\n+\t}\n+\tif (p1 < p2) {\n+\t\tunionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_PARENT);\n+\t\tunionfs_lock_dentry(p2, UNIONFS_DMUTEX_REVAL_CHILD);\n+\t} else {\n+\t\tunionfs_lock_dentry(p2, UNIONFS_DMUTEX_REVAL_PARENT);\n+\t\tunionfs_lock_dentry(p1, UNIONFS_DMUTEX_REVAL_CHILD);\n+\t}\n+}\n+\n+static inline void unionfs_double_unlock_parents(struct dentry *p1,\n+\t\t\t\t\t\t struct dentry *p2)\n+{\n+\tif (p1 == p2) {\n+\t\tunionfs_unlock_dentry(p1);\n+\t\treturn;\n+\t}\n+\tif (p1 < p2) { /* unlock in reverse order of double_lock_parents */\n+\t\tunionfs_unlock_dentry(p1);\n+\t\tunionfs_unlock_dentry(p2);\n+\t} else {\n+\t\tunionfs_unlock_dentry(p2);\n+\t\tunionfs_unlock_dentry(p1);\n+\t}\n+}\n+\n+extern int new_dentry_private_data(struct dentry *dentry, int subclass);\n+extern int realloc_dentry_private_data(struct dentry *dentry);\n+extern void free_dentry_private_data(struct dentry *dentry);\n+extern void update_bstart(struct dentry *dentry);\n+extern int init_lower_nd(struct nameidata *nd, unsigned int flags);\n+extern void release_lower_nd(struct nameidata *nd, int err);\n+\n+/*\n+ * EXTERNALS:\n+ */\n+\n+/* replicates the directory structure up to given dentry in given branch */\n+extern struct dentry *create_parents(struct inode *dir, struct dentry *dentry,\n+\t\t\t\t     const char *name, int bindex);\n+\n+/* partial lookup */\n+extern int unionfs_partial_lookup(struct dentry *dentry,\n+\t\t\t\t  struct dentry *parent);\n+extern struct dentry *unionfs_lookup_full(struct dentry *dentry,\n+\t\t\t\t\t  struct dentry *parent,\n+\t\t\t\t\t  int lookupmode);\n+\n+/* copies a file from dbstart to newbindex branch */\n+extern int copyup_file(struct inode *dir, struct file *file, int bstart,\n+\t\t       int newbindex, loff_t size);\n+extern int copyup_named_file(struct inode *dir, struct file *file,\n+\t\t\t     char *name, int bstart, int new_bindex,\n+\t\t\t     loff_t len);\n+/* copies a dentry from dbstart to newbindex branch */\n+extern int copyup_dentry(struct inode *dir, struct dentry *dentry,\n+\t\t\t int bstart, int new_bindex, const char *name,\n+\t\t\t int namelen, struct file **copyup_file, loff_t len);\n+/* helper functions for post-copyup actions */\n+extern void unionfs_postcopyup_setmnt(struct dentry *dentry);\n+extern void unionfs_postcopyup_release(struct dentry *dentry);\n+\n+/* Is this directory empty: 0 if it is empty, -ENOTEMPTY if not. */\n+extern int check_empty(struct dentry *dentry, struct dentry *parent,\n+\t\t       struct unionfs_dir_state **namelist);\n+/* whiteout and opaque directory helpers */\n+extern char *alloc_whname(const char *name, int len);\n+extern bool is_whiteout_name(char **namep, int *namelenp);\n+extern bool is_validname(const char *name);\n+extern struct dentry *lookup_whiteout(const char *name,\n+\t\t\t\t      struct dentry *lower_parent);\n+extern struct dentry *find_first_whiteout(struct dentry *dentry);\n+extern int unlink_whiteout(struct dentry *wh_dentry);\n+extern int check_unlink_whiteout(struct dentry *dentry,\n+\t\t\t\t struct dentry *lower_dentry, int bindex);\n+extern int create_whiteout(struct dentry *dentry, int start);\n+extern int delete_whiteouts(struct dentry *dentry, int bindex,\n+\t\t\t    struct unionfs_dir_state *namelist);\n+extern int is_opaque_dir(struct dentry *dentry, int bindex);\n+extern int make_dir_opaque(struct dentry *dir, int bindex);\n+extern void unionfs_set_max_namelen(long *namelen);\n+\n+extern void unionfs_reinterpose(struct dentry *this_dentry);\n+extern struct super_block *unionfs_duplicate_super(struct super_block *sb);\n+\n+/* Locking functions. */\n+extern int unionfs_setlk(struct file *file, int cmd, struct file_lock *fl);\n+extern int unionfs_getlk(struct file *file, struct file_lock *fl);\n+\n+/* Common file operations. */\n+extern int unionfs_file_revalidate(struct file *file, struct dentry *parent,\n+\t\t\t\t   bool willwrite);\n+extern int unionfs_open(struct inode *inode, struct file *file);\n+extern int unionfs_file_release(struct inode *inode, struct file *file);\n+extern int unionfs_flush(struct file *file, fl_owner_t id);\n+extern long unionfs_ioctl(struct file *file, unsigned int cmd,\n+\t\t\t  unsigned long arg);\n+extern int unionfs_fsync(struct file *file, struct dentry *dentry,\n+\t\t\t int datasync);\n+extern int unionfs_fasync(int fd, struct file *file, int flag);\n+\n+/* Inode operations */\n+extern int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n+\t\t\t  struct inode *new_dir, struct dentry *new_dentry);\n+extern int unionfs_unlink(struct inode *dir, struct dentry *dentry);\n+extern int unionfs_rmdir(struct inode *dir, struct dentry *dentry);\n+\n+extern bool __unionfs_d_revalidate(struct dentry *dentry,\n+\t\t\t\t   struct dentry *parent, bool willwrite);\n+extern bool is_negative_lower(const struct dentry *dentry);\n+extern bool is_newer_lower(const struct dentry *dentry);\n+extern void purge_sb_data(struct super_block *sb);\n+\n+/* The values for unionfs_interpose\'s flag. */\n+#define INTERPOSE_DEFAULT\t0\n+#define INTERPOSE_LOOKUP\t1\n+#define INTERPOSE_REVAL\t\t2\n+#define INTERPOSE_REVAL_NEG\t3\n+#define INTERPOSE_PARTIAL\t4\n+\n+extern struct dentry *unionfs_interpose(struct dentry *this_dentry,\n+\t\t\t\t\tstruct super_block *sb, int flag);\n+\n+#ifdef CONFIG_UNION_FS_XATTR\n+/* Extended attribute functions. */\n+extern void *unionfs_xattr_alloc(size_t size, size_t limit);\n+static inline void unionfs_xattr_kfree(const void *p)\n+{\n+\tkfree(p);\n+}\n+extern ssize_t unionfs_getxattr(struct dentry *dentry, const char *name,\n+\t\t\t\tvoid *value, size_t size);\n+extern int unionfs_removexattr(struct dentry *dentry, const char *name);\n+extern ssize_t unionfs_listxattr(struct dentry *dentry, char *list,\n+\t\t\t\t size_t size);\n+extern int unionfs_setxattr(struct dentry *dentry, const char *name,\n+\t\t\t    const void *value, size_t size, int flags);\n+#endif /* CONFIG_UNION_FS_XATTR */\n+\n+/* The root directory is unhashed, but isn\'t deleted. */\n+static inline int d_deleted(struct dentry *d)\n+{\n+\treturn d_unhashed(d) && (d != d->d_sb->s_root);\n+}\n+\n+/* unionfs_permission, check if we should bypass error to facilitate copyup */\n+#define IS_COPYUP_ERR(err) ((err) == -EROFS)\n+\n+/* unionfs_open, check if we need to copyup the file */\n+#define OPEN_WRITE_FLAGS (O_WRONLY | O_RDWR | O_APPEND)\n+#define IS_WRITE_FLAG(flag) ((flag) & OPEN_WRITE_FLAGS)\n+\n+static inline int branchperms(const struct super_block *sb, int index)\n+{\n+\tBUG_ON(index < 0);\n+\treturn UNIONFS_SB(sb)->data[index].branchperms;\n+}\n+\n+static inline int set_branchperms(struct super_block *sb, int index, int perms)\n+{\n+\tBUG_ON(index < 0);\n+\tUNIONFS_SB(sb)->data[index].branchperms = perms;\n+\treturn perms;\n+}\n+\n+/* Is this file on a read-only branch? */\n+static inline int is_robranch_super(const struct super_block *sb, int index)\n+{\n+\tint ret;\n+\n+\tret = (!(branchperms(sb, index) & MAY_WRITE)) ? -EROFS : 0;\n+\treturn ret;\n+}\n+\n+/* Is this file on a read-only branch? */\n+static inline int is_robranch_idx(const struct dentry *dentry, int index)\n+{\n+\tstruct super_block *lower_sb;\n+\n+\tBUG_ON(index < 0);\n+\n+\tif (!(branchperms(dentry->d_sb, index) & MAY_WRITE))\n+\t\treturn -EROFS;\n+\n+\tlower_sb = unionfs_lower_super_idx(dentry->d_sb, index);\n+\tBUG_ON(lower_sb == NULL);\n+\t/*\n+\t * test sb flags directly, not IS_RDONLY(lower_inode) because the\n+\t * lower_dentry could be a negative.\n+\t */\n+\tif (lower_sb->s_flags & MS_RDONLY)\n+\t\treturn -EROFS;\n+\n+\treturn 0;\n+}\n+\n+static inline int is_robranch(const struct dentry *dentry)\n+{\n+\tint index;\n+\n+\tindex = UNIONFS_D(dentry)->bstart;\n+\tBUG_ON(index < 0);\n+\n+\treturn is_robranch_idx(dentry, index);\n+}\n+\n+/*\n+ * EXTERNALS:\n+ */\n+extern int check_branch(struct nameidata *nd);\n+extern int parse_branch_mode(const char *name, int *perms);\n+\n+/* locking helpers */\n+static inline struct dentry *lock_parent(struct dentry *dentry)\n+{\n+\tstruct dentry *dir = dget_parent(dentry);\n+\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n+\treturn dir;\n+}\n+static inline struct dentry *lock_parent_wh(struct dentry *dentry)\n+{\n+\tstruct dentry *dir = dget_parent(dentry);\n+\n+\tmutex_lock_nested(&dir->d_inode->i_mutex, UNIONFS_DMUTEX_WHITEOUT);\n+\treturn dir;\n+}\n+\n+static inline void unlock_dir(struct dentry *dir)\n+{\n+\tmutex_unlock(&dir->d_inode->i_mutex);\n+\tdput(dir);\n+}\n+\n+static inline struct vfsmount *unionfs_mntget(struct dentry *dentry,\n+\t\t\t\t\t      int bindex)\n+{\n+\tstruct vfsmount *mnt;\n+\n+\tBUG_ON(!dentry || bindex < 0);\n+\n+\tmnt = mntget(unionfs_lower_mnt_idx(dentry, bindex));\n+#ifdef CONFIG_UNION_FS_DEBUG\n+\tif (!mnt)\n+\t\tpr_debug("unionfs: mntget: mnt=%p bindex=%d\\n",\n+\t\t\t mnt, bindex);\n+#endif /* CONFIG_UNION_FS_DEBUG */\n+\n+\treturn mnt;\n+}\n+\n+static inline void unionfs_mntput(struct dentry *dentry, int bindex)\n+{\n+\tstruct vfsmount *mnt;\n+\n+\tif (!dentry && bindex < 0)\n+\t\treturn;\n+\tBUG_ON(!dentry || bindex < 0);\n+\n+\tmnt = unionfs_lower_mnt_idx(dentry, bindex);\n+#ifdef CONFIG_UNION_FS_DEBUG\n+\t/*\n+\t * Directories can have NULL lower objects in between start/end, but\n+\t * NOT if at the start/end range.  We cannot verify that this dentry\n+\t * is a type=DIR, because it may already be a negative dentry.  But\n+\t * if dbstart is greater than dbend, we know that this couldn\'t have\n+\t * been a regular file: it had to have been a directory.\n+\t */\n+\tif (!mnt && !(bindex > dbstart(dentry) && bindex < dbend(dentry)))\n+\t\tpr_debug("unionfs: mntput: mnt=%p bindex=%d\\n", mnt, bindex);\n+#endif /* CONFIG_UNION_FS_DEBUG */\n+\tmntput(mnt);\n+}\n+\n+#ifdef CONFIG_UNION_FS_DEBUG\n+\n+/* useful for tracking code reachability */\n+#define UDBG pr_debug("DBG:%s:%s:%d\\n", __FILE__, __func__, __LINE__)\n+\n+#define unionfs_check_inode(i)\t__unionfs_check_inode((i),\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define unionfs_check_dentry(d)\t__unionfs_check_dentry((d),\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define unionfs_check_file(f)\t__unionfs_check_file((f),\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define unionfs_check_nd(n)\t__unionfs_check_nd((n),\t\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define show_branch_counts(sb)\t__show_branch_counts((sb),\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define show_inode_times(i)\t__show_inode_times((i),\t\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define show_dinode_times(d)\t__show_dinode_times((d),\t\\\n+\t__FILE__, __func__, __LINE__)\n+#define show_inode_counts(i)\t__show_inode_counts((i),\t\\\n+\t__FILE__, __func__, __LINE__)\n+\n+extern void __unionfs_check_inode(const struct inode *inode, const char *fname,\n+\t\t\t\t  const char *fxn, int line);\n+extern void __unionfs_check_dentry(const struct dentry *dentry,\n+\t\t\t\t   const char *fname, const char *fxn,\n+\t\t\t\t   int line);\n+extern void __unionfs_check_file(const struct file *file,\n+\t\t\t\t const char *fname, const char *fxn, int line);\n+extern void __unionfs_check_nd(const struct nameidata *nd,\n+\t\t\t       const char *fname, const char *fxn, int line);\n+extern void __show_branch_counts(const struct super_block *sb,\n+\t\t\t\t const char *file, const char *fxn, int line);\n+extern void __show_inode_times(const struct inode *inode,\n+\t\t\t       const char *file, const char *fxn, int line);\n+extern void __show_dinode_times(const struct dentry *dentry,\n+\t\t\t\tconst char *file, const char *fxn, int line);\n+extern void __show_inode_counts(const struct inode *inode,\n+\t\t\t\tconst char *file, const char *fxn, int line);\n+\n+#else /* not CONFIG_UNION_FS_DEBUG */\n+\n+/* we leave useful hooks for these check functions throughout the code */\n+#define unionfs_check_inode(i)\t\tdo { } while (0)\n+#define unionfs_check_dentry(d)\t\tdo { } while (0)\n+#define unionfs_check_file(f)\t\tdo { } while (0)\n+#define unionfs_check_nd(n)\t\tdo { } while (0)\n+#define show_branch_counts(sb)\t\tdo { } while (0)\n+#define show_inode_times(i)\t\tdo { } while (0)\n+#define show_dinode_times(d)\t\tdo { } while (0)\n+#define show_inode_counts(i)\t\tdo { } while (0)\n+\n+#endif /* not CONFIG_UNION_FS_DEBUG */\n+\n+#endif\t/* not _UNION_H_ */'),
 ('dev/null',
  'b/fs/unionfs/unlink.c',
  'diff --git a/fs/unionfs/unlink.c b/fs/unionfs/unlink.c\nnew file mode 100644\nindex 0000000..b6d8e10\n--- dev/null\n+++ b/fs/unionfs/unlink.c\n@@ -0,0 +1,282 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * Helper function for Unionfs\'s unlink operation.\n+ *\n+ * The main goal of this function is to optimize the unlinking of non-dir\n+ * objects in unionfs by deleting all possible lower inode objects from the\n+ * underlying branches having same dentry name as the non-dir dentry on\n+ * which this unlink operation is called.  This way we delete as many lower\n+ * inodes as possible, and save space.  Whiteouts need to be created in\n+ * branch0 only if unlinking fails on any of the lower branch other than\n+ * branch0, or if a lower branch is marked read-only.\n+ *\n+ * Also, while unlinking a file, if we encounter any dir type entry in any\n+ * intermediate branch, then we remove the directory by calling vfs_rmdir.\n+ * The following special cases are also handled:\n+\n+ * (1) If an error occurs in branch0 during vfs_unlink, then we return\n+ *     appropriate error.\n+ *\n+ * (2) If we get an error during unlink in any of other lower branch other\n+ *     than branch0, then we create a whiteout in branch0.\n+ *\n+ * (3) If a whiteout already exists in any intermediate branch, we delete\n+ *     all possible inodes only up to that branch (this is an "opaqueness"\n+ *     as as per Documentation/filesystems/unionfs/concepts.txt).\n+ *\n+ */\n+static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry,\n+\t\t\t\t   struct dentry *parent)\n+{\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *lower_dir_dentry;\n+\tint bindex;\n+\tint err = 0;\n+\n+\terr = unionfs_partial_lookup(dentry, parent);\n+\tif (err)\n+\t\tgoto out;\n+\n+\t/* trying to unlink all possible valid instances */\n+\tfor (bindex = dbstart(dentry); bindex <= dbend(dentry); bindex++) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\t\tif (!lower_dentry || !lower_dentry->d_inode)\n+\t\t\tcontinue;\n+\n+\t\tlower_dir_dentry = lock_parent(lower_dentry);\n+\n+\t\t/* avoid destroying the lower inode if the object is in use */\n+\t\tdget(lower_dentry);\n+\t\terr = is_robranch_super(dentry->d_sb, bindex);\n+\t\tif (!err) {\n+\t\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\t\tlockdep_off();\n+\t\t\tif (!S_ISDIR(lower_dentry->d_inode->i_mode))\n+\t\t\t\terr = vfs_unlink(lower_dir_dentry->d_inode,\n+\t\t\t\t\t\t\t\tlower_dentry);\n+\t\t\telse\n+\t\t\t\terr = vfs_rmdir(lower_dir_dentry->d_inode,\n+\t\t\t\t\t\t\t\tlower_dentry);\n+\t\t\tlockdep_on();\n+\t\t}\n+\n+\t\t/* if lower object deletion succeeds, update inode\'s times */\n+\t\tif (!err)\n+\t\t\tunionfs_copy_attr_times(dentry->d_inode);\n+\t\tdput(lower_dentry);\n+\t\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n+\t\tunlock_dir(lower_dir_dentry);\n+\n+\t\tif (err)\n+\t\t\tbreak;\n+\t}\n+\n+\t/*\n+\t * Create the whiteout in branch 0 (highest priority) only if (a)\n+\t * there was an error in any intermediate branch other than branch 0\n+\t * due to failure of vfs_unlink/vfs_rmdir or (b) a branch marked or\n+\t * mounted read-only.\n+\t */\n+\tif (err) {\n+\t\tif ((bindex == 0) ||\n+\t\t    ((bindex == dbstart(dentry)) &&\n+\t\t     (!IS_COPYUP_ERR(err))))\n+\t\t\tgoto out;\n+\t\telse {\n+\t\t\tif (!IS_COPYUP_ERR(err))\n+\t\t\t\tpr_debug("unionfs: lower object deletion "\n+\t\t\t\t\t     "failed in branch:%d\\n", bindex);\n+\t\t\terr = create_whiteout(dentry, sbstart(dentry->d_sb));\n+\t\t}\n+\t}\n+\n+out:\n+\tif (!err)\n+\t\tinode_dec_link_count(dentry->d_inode);\n+\n+\t/* We don\'t want to leave negative leftover dentries for revalidate. */\n+\tif (!err && (dbopaque(dentry) != -1))\n+\t\tupdate_bstart(dentry);\n+\n+\treturn err;\n+}\n+\n+int unionfs_unlink(struct inode *dir, struct dentry *dentry)\n+{\n+\tint err = 0;\n+\tstruct inode *inode = dentry->d_inode;\n+\tstruct dentry *parent;\n+\tint valid;\n+\n+\tBUG_ON(S_ISDIR(inode->i_mode));\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\tunionfs_check_dentry(dentry);\n+\n+\terr = unionfs_unlink_whiteout(dir, dentry, parent);\n+\t/* call d_drop so the system "forgets" about us */\n+\tif (!err) {\n+\t\tunionfs_postcopyup_release(dentry);\n+\t\tunionfs_postcopyup_setmnt(parent);\n+\t\tif (inode->i_nlink == 0) /* drop lower inodes */\n+\t\t\tiput_lowers_all(inode, false);\n+\t\td_drop(dentry);\n+\t\t/*\n+\t\t * if unlink/whiteout succeeded, parent dir mtime has\n+\t\t * changed\n+\t\t */\n+\t\tunionfs_copy_attr_times(dir);\n+\t}\n+\n+out:\n+\tif (!err) {\n+\t\tunionfs_check_dentry(dentry);\n+\t\tunionfs_check_inode(dir);\n+\t}\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,\n+\t\t\t       struct unionfs_dir_state *namelist)\n+{\n+\tint err;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\n+\t/* Here we need to remove whiteout entries. */\n+\terr = delete_whiteouts(dentry, dbstart(dentry), namelist);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\tlower_dir_dentry = lock_parent(lower_dentry);\n+\n+\t/* avoid destroying the lower inode if the file is in use */\n+\tdget(lower_dentry);\n+\terr = is_robranch(dentry);\n+\tif (!err) {\n+\t\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\t\tlockdep_off();\n+\t\terr = vfs_rmdir(lower_dir_dentry->d_inode, lower_dentry);\n+\t\tlockdep_on();\n+\t}\n+\tdput(lower_dentry);\n+\n+\tfsstack_copy_attr_times(dir, lower_dir_dentry->d_inode);\n+\t/* propagate number of hard-links */\n+\tdentry->d_inode->i_nlink = unionfs_get_nlinks(dentry->d_inode);\n+\n+out:\n+\tif (lower_dir_dentry)\n+\t\tunlock_dir(lower_dir_dentry);\n+\treturn err;\n+}\n+\n+int unionfs_rmdir(struct inode *dir, struct dentry *dentry)\n+{\n+\tint err = 0;\n+\tstruct unionfs_dir_state *namelist = NULL;\n+\tstruct dentry *parent;\n+\tint dstart, dend;\n+\tbool valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\tunionfs_check_dentry(dentry);\n+\n+\t/* check if this unionfs directory is empty or not */\n+\terr = check_empty(dentry, parent, &namelist);\n+\tif (err)\n+\t\tgoto out;\n+\n+\terr = unionfs_rmdir_first(dir, dentry, namelist);\n+\tdstart = dbstart(dentry);\n+\tdend = dbend(dentry);\n+\t/*\n+\t * We create a whiteout for the directory if there was an error to\n+\t * rmdir the first directory entry in the union.  Otherwise, we\n+\t * create a whiteout only if there is no chance that a lower\n+\t * priority branch might also have the same named directory.  IOW,\n+\t * if there is not another same-named directory at a lower priority\n+\t * branch, then we don\'t need to create a whiteout for it.\n+\t */\n+\tif (!err) {\n+\t\tif (dstart < dend)\n+\t\t\terr = create_whiteout(dentry, dstart);\n+\t} else {\n+\t\tint new_err;\n+\n+\t\tif (dstart == 0)\n+\t\t\tgoto out;\n+\n+\t\t/* exit if the error returned was NOT -EROFS */\n+\t\tif (!IS_COPYUP_ERR(err))\n+\t\t\tgoto out;\n+\n+\t\tnew_err = create_whiteout(dentry, dstart - 1);\n+\t\tif (new_err != -EEXIST)\n+\t\t\terr = new_err;\n+\t}\n+\n+out:\n+\t/*\n+\t * Drop references to lower dentry/inode so storage space for them\n+\t * can be reclaimed.  Then, call d_drop so the system "forgets"\n+\t * about us.\n+\t */\n+\tif (!err) {\n+\t\tiput_lowers_all(dentry->d_inode, false);\n+\t\tdput(unionfs_lower_dentry_idx(dentry, dstart));\n+\t\tunionfs_set_lower_dentry_idx(dentry, dstart, NULL);\n+\t\td_drop(dentry);\n+\t\t/* update our lower vfsmnts, in case a copyup took place */\n+\t\tunionfs_postcopyup_setmnt(dentry);\n+\t\tunionfs_check_dentry(dentry);\n+\t\tunionfs_check_inode(dir);\n+\t}\n+\n+\tif (namelist)\n+\t\tfree_rdstate(namelist);\n+\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/whiteout.c',
  'diff --git a/fs/unionfs/whiteout.c b/fs/unionfs/whiteout.c\nnew file mode 100644\nindex 0000000..ae5c5e3\n--- dev/null\n+++ b/fs/unionfs/whiteout.c\n@@ -0,0 +1,577 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/*\n+ * whiteout and opaque directory helpers\n+ */\n+\n+/* What do we use for whiteouts. */\n+#define UNIONFS_WHPFX ".wh."\n+#define UNIONFS_WHLEN 4\n+/*\n+ * If a directory contains this file, then it is opaque.  We start with the\n+ * .wh. flag so that it is blocked by lookup.\n+ */\n+#define UNIONFS_DIR_OPAQUE_NAME "__dir_opaque"\n+#define UNIONFS_DIR_OPAQUE UNIONFS_WHPFX UNIONFS_DIR_OPAQUE_NAME\n+\n+/* construct whiteout filename */\n+char *alloc_whname(const char *name, int len)\n+{\n+\tchar *buf;\n+\n+\tbuf = kmalloc(len + UNIONFS_WHLEN + 1, GFP_KERNEL);\n+\tif (unlikely(!buf))\n+\t\treturn ERR_PTR(-ENOMEM);\n+\n+\tstrcpy(buf, UNIONFS_WHPFX);\n+\tstrlcat(buf, name, len + UNIONFS_WHLEN + 1);\n+\n+\treturn buf;\n+}\n+\n+/*\n+ * XXX: this can be inline or CPP macro, but is here to keep all whiteout\n+ * code in one place.\n+ */\n+void unionfs_set_max_namelen(long *namelen)\n+{\n+\t*namelen -= UNIONFS_WHLEN;\n+}\n+\n+/* check if @namep is a whiteout, update @namep and @namelenp accordingly */\n+bool is_whiteout_name(char **namep, int *namelenp)\n+{\n+\tif (*namelenp > UNIONFS_WHLEN &&\n+\t    !strncmp(*namep, UNIONFS_WHPFX, UNIONFS_WHLEN)) {\n+\t\t*namep += UNIONFS_WHLEN;\n+\t\t*namelenp -= UNIONFS_WHLEN;\n+\t\treturn true;\n+\t}\n+\treturn false;\n+}\n+\n+/* is the filename valid == !(whiteout for a file or opaque dir marker) */\n+bool is_validname(const char *name)\n+{\n+\tif (!strncmp(name, UNIONFS_WHPFX, UNIONFS_WHLEN))\n+\t\treturn false;\n+\tif (!strncmp(name, UNIONFS_DIR_OPAQUE_NAME,\n+\t\t     sizeof(UNIONFS_DIR_OPAQUE_NAME) - 1))\n+\t\treturn false;\n+\treturn true;\n+}\n+\n+/*\n+ * Look for a whiteout @name in @lower_parent directory.  If error, return\n+ * ERR_PTR.  Caller must dput() the returned dentry if not an error.\n+ *\n+ * XXX: some callers can reuse the whname allocated buffer to avoid repeated\n+ * free then re-malloc calls.  Need to provide a different API for those\n+ * callers.\n+ */\n+struct dentry *lookup_whiteout(const char *name, struct dentry *lower_parent)\n+{\n+\tchar *whname = NULL;\n+\tint err = 0, namelen;\n+\tstruct dentry *wh_dentry = NULL;\n+\n+\tnamelen = strlen(name);\n+\twhname = alloc_whname(name, namelen);\n+\tif (unlikely(IS_ERR(whname))) {\n+\t\terr = PTR_ERR(whname);\n+\t\tgoto out;\n+\t}\n+\n+\t/* check if whiteout exists in this branch: lookup .wh.foo */\n+\twh_dentry = lookup_one_len(whname, lower_parent, strlen(whname));\n+\tif (IS_ERR(wh_dentry)) {\n+\t\terr = PTR_ERR(wh_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\t/* check if negative dentry (ENOENT) */\n+\tif (!wh_dentry->d_inode)\n+\t\tgoto out;\n+\n+\t/* whiteout found: check if valid type */\n+\tif (!S_ISREG(wh_dentry->d_inode->i_mode)) {\n+\t\tprintk(KERN_ERR "unionfs: invalid whiteout %s entry type %d\\n",\n+\t\t       whname, wh_dentry->d_inode->i_mode);\n+\t\tdput(wh_dentry);\n+\t\terr = -EIO;\n+\t\tgoto out;\n+\t}\n+\n+out:\n+\tkfree(whname);\n+\tif (err)\n+\t\twh_dentry = ERR_PTR(err);\n+\treturn wh_dentry;\n+}\n+\n+/* find and return first whiteout in parent directory, else ENOENT */\n+struct dentry *find_first_whiteout(struct dentry *dentry)\n+{\n+\tint bindex, bstart, bend;\n+\tstruct dentry *parent, *lower_parent, *wh_dentry;\n+\n+\tparent = dget_parent(dentry);\n+\n+\tbstart = dbstart(parent);\n+\tbend = dbend(parent);\n+\twh_dentry = ERR_PTR(-ENOENT);\n+\n+\tfor (bindex = bstart; bindex <= bend; bindex++) {\n+\t\tlower_parent = unionfs_lower_dentry_idx(parent, bindex);\n+\t\tif (!lower_parent)\n+\t\t\tcontinue;\n+\t\twh_dentry = lookup_whiteout(dentry->d_name.name, lower_parent);\n+\t\tif (IS_ERR(wh_dentry))\n+\t\t\tcontinue;\n+\t\tif (wh_dentry->d_inode)\n+\t\t\tbreak;\n+\t\tdput(wh_dentry);\n+\t\twh_dentry = ERR_PTR(-ENOENT);\n+\t}\n+\n+\tdput(parent);\n+\n+\treturn wh_dentry;\n+}\n+\n+/*\n+ * Unlink a whiteout dentry.  Returns 0 or -errno.  Caller must hold and\n+ * release dentry reference.\n+ */\n+int unlink_whiteout(struct dentry *wh_dentry)\n+{\n+\tint err;\n+\tstruct dentry *lower_dir_dentry;\n+\n+\t/* dget and lock parent dentry */\n+\tlower_dir_dentry = lock_parent_wh(wh_dentry);\n+\n+\t/* see Documentation/filesystems/unionfs/issues.txt */\n+\tlockdep_off();\n+\terr = vfs_unlink(lower_dir_dentry->d_inode, wh_dentry);\n+\tlockdep_on();\n+\tunlock_dir(lower_dir_dentry);\n+\n+\t/*\n+\t * Whiteouts are special files and should be deleted no matter what\n+\t * (as if they never existed), in order to allow this create\n+\t * operation to succeed.  This is especially important in sticky\n+\t * directories: a whiteout may have been created by one user, but\n+\t * the newly created file may be created by another user.\n+\t * Therefore, in order to maintain Unix semantics, if the vfs_unlink\n+\t * above failed, then we have to try to directly unlink the\n+\t * whiteout.  Note: in the ODF version of unionfs, whiteout are\n+\t * handled much more cleanly.\n+\t */\n+\tif (err == -EPERM) {\n+\t\tstruct inode *inode = lower_dir_dentry->d_inode;\n+\t\terr = inode->i_op->unlink(inode, wh_dentry);\n+\t}\n+\tif (err)\n+\t\tprintk(KERN_ERR "unionfs: could not unlink whiteout %s, "\n+\t\t       "err = %d\\n", wh_dentry->d_name.name, err);\n+\n+\treturn err;\n+\n+}\n+\n+/*\n+ * Helper function when creating new objects (create, symlink, mknod, etc.).\n+ * Checks to see if there\'s a whiteout in @lower_dentry\'s parent directory,\n+ * whose name is taken from @dentry.  Then tries to remove that whiteout, if\n+ * found.  If <dentry,bindex> is a branch marked readonly, return -EROFS.\n+ * If it finds both a regular file and a whiteout, return -EIO (this should\n+ * never happen).\n+ *\n+ * Return 0 if no whiteout was found.  Return 1 if one was found and\n+ * successfully removed.  Therefore a value >= 0 tells the caller that\n+ * @lower_dentry belongs to a good branch to create the new object in).\n+ * Return -ERRNO if an error occurred during whiteout lookup or in trying to\n+ * unlink the whiteout.\n+ */\n+int check_unlink_whiteout(struct dentry *dentry, struct dentry *lower_dentry,\n+\t\t\t  int bindex)\n+{\n+\tint err;\n+\tstruct dentry *wh_dentry = NULL;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\n+\t/* look for whiteout dentry first */\n+\tlower_dir_dentry = dget_parent(lower_dentry);\n+\twh_dentry = lookup_whiteout(dentry->d_name.name, lower_dir_dentry);\n+\tdput(lower_dir_dentry);\n+\tif (IS_ERR(wh_dentry)) {\n+\t\terr = PTR_ERR(wh_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\tif (!wh_dentry->d_inode) { /* no whiteout exists*/\n+\t\terr = 0;\n+\t\tgoto out_dput;\n+\t}\n+\n+\t/* check if regular file and whiteout were both found */\n+\tif (unlikely(lower_dentry->d_inode)) {\n+\t\terr = -EIO;\n+\t\tprintk(KERN_ERR "unionfs: found both whiteout and regular "\n+\t\t       "file in directory %s (branch %d)\\n",\n+\t\t       lower_dir_dentry->d_name.name, bindex);\n+\t\tgoto out_dput;\n+\t}\n+\n+\t/* check if branch is writeable */\n+\terr = is_robranch_super(dentry->d_sb, bindex);\n+\tif (err)\n+\t\tgoto out_dput;\n+\n+\t/* .wh.foo has been found, so let\'s unlink it */\n+\terr = unlink_whiteout(wh_dentry);\n+\tif (!err)\n+\t\terr = 1; /* a whiteout was found and successfully removed */\n+out_dput:\n+\tdput(wh_dentry);\n+out:\n+\treturn err;\n+}\n+\n+/*\n+ * Pass an unionfs dentry and an index.  It will try to create a whiteout\n+ * for the filename in dentry, and will try in branch \'index\'.  On error,\n+ * it will proceed to a branch to the left.\n+ */\n+int create_whiteout(struct dentry *dentry, int start)\n+{\n+\tint bstart, bend, bindex;\n+\tstruct dentry *lower_dir_dentry;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *lower_wh_dentry;\n+\tstruct nameidata nd;\n+\tchar *name = NULL;\n+\tint err = -EINVAL;\n+\n+\tverify_locked(dentry);\n+\n+\tbstart = dbstart(dentry);\n+\tbend = dbend(dentry);\n+\n+\t/* create dentry\'s whiteout equivalent */\n+\tname = alloc_whname(dentry->d_name.name, dentry->d_name.len);\n+\tif (unlikely(IS_ERR(name))) {\n+\t\terr = PTR_ERR(name);\n+\t\tgoto out;\n+\t}\n+\n+\tfor (bindex = start; bindex >= 0; bindex--) {\n+\t\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\n+\t\tif (!lower_dentry) {\n+\t\t\t/*\n+\t\t\t * if lower dentry is not present, create the\n+\t\t\t * entire lower dentry directory structure and go\n+\t\t\t * ahead.  Since we want to just create whiteout, we\n+\t\t\t * only want the parent dentry, and hence get rid of\n+\t\t\t * this dentry.\n+\t\t\t */\n+\t\t\tlower_dentry = create_parents(dentry->d_inode,\n+\t\t\t\t\t\t      dentry,\n+\t\t\t\t\t\t      dentry->d_name.name,\n+\t\t\t\t\t\t      bindex);\n+\t\t\tif (!lower_dentry || IS_ERR(lower_dentry)) {\n+\t\t\t\tint ret = PTR_ERR(lower_dentry);\n+\t\t\t\tif (!IS_COPYUP_ERR(ret))\n+\t\t\t\t\tprintk(KERN_ERR\n+\t\t\t\t\t       "unionfs: create_parents for "\n+\t\t\t\t\t       "whiteout failed: bindex=%d "\n+\t\t\t\t\t       "err=%d\\n", bindex, ret);\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t}\n+\n+\t\tlower_wh_dentry =\n+\t\t\tlookup_one_len(name, lower_dentry->d_parent,\n+\t\t\t\t       dentry->d_name.len + UNIONFS_WHLEN);\n+\t\tif (IS_ERR(lower_wh_dentry))\n+\t\t\tcontinue;\n+\n+\t\t/*\n+\t\t * The whiteout already exists. This used to be impossible,\n+\t\t * but now is possible because of opaqueness.\n+\t\t */\n+\t\tif (lower_wh_dentry->d_inode) {\n+\t\t\tdput(lower_wh_dentry);\n+\t\t\terr = 0;\n+\t\t\tgoto out;\n+\t\t}\n+\n+\t\terr = init_lower_nd(&nd, LOOKUP_CREATE);\n+\t\tif (unlikely(err < 0))\n+\t\t\tgoto out;\n+\t\tlower_dir_dentry = lock_parent_wh(lower_wh_dentry);\n+\t\terr = is_robranch_super(dentry->d_sb, bindex);\n+\t\tif (!err)\n+\t\t\terr = vfs_create(lower_dir_dentry->d_inode,\n+\t\t\t\t\t lower_wh_dentry,\n+\t\t\t\t\t ~current->fs->umask & S_IRUGO,\n+\t\t\t\t\t &nd);\n+\t\tunlock_dir(lower_dir_dentry);\n+\t\tdput(lower_wh_dentry);\n+\t\trelease_lower_nd(&nd, err);\n+\n+\t\tif (!err || !IS_COPYUP_ERR(err))\n+\t\t\tbreak;\n+\t}\n+\n+\t/* set dbopaque so that lookup will not proceed after this branch */\n+\tif (!err)\n+\t\tdbopaque(dentry) = bindex;\n+\n+out:\n+\tkfree(name);\n+\treturn err;\n+}\n+\n+/*\n+ * Delete all of the whiteouts in a given directory for rmdir.\n+ *\n+ * lower directory inode should be locked\n+ */\n+static int do_delete_whiteouts(struct dentry *dentry, int bindex,\n+\t\t\t       struct unionfs_dir_state *namelist)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dir_dentry = NULL;\n+\tstruct dentry *lower_dentry;\n+\tchar *name = NULL, *p;\n+\tstruct inode *lower_dir;\n+\tint i;\n+\tstruct list_head *pos;\n+\tstruct filldir_node *cursor;\n+\n+\t/* Find out lower parent dentry */\n+\tlower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\tBUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));\n+\tlower_dir = lower_dir_dentry->d_inode;\n+\tBUG_ON(!S_ISDIR(lower_dir->i_mode));\n+\n+\terr = -ENOMEM;\n+\tname = __getname();\n+\tif (unlikely(!name))\n+\t\tgoto out;\n+\tstrcpy(name, UNIONFS_WHPFX);\n+\tp = name + UNIONFS_WHLEN;\n+\n+\terr = 0;\n+\tfor (i = 0; !err && i < namelist->size; i++) {\n+\t\tlist_for_each(pos, &namelist->list[i]) {\n+\t\t\tcursor =\n+\t\t\t\tlist_entry(pos, struct filldir_node,\n+\t\t\t\t\t   file_list);\n+\t\t\t/* Only operate on whiteouts in this branch. */\n+\t\t\tif (cursor->bindex != bindex)\n+\t\t\t\tcontinue;\n+\t\t\tif (!cursor->whiteout)\n+\t\t\t\tcontinue;\n+\n+\t\t\tstrlcpy(p, cursor->name, PATH_MAX - UNIONFS_WHLEN);\n+\t\t\tlower_dentry =\n+\t\t\t\tlookup_one_len(name, lower_dir_dentry,\n+\t\t\t\t\t       cursor->namelen +\n+\t\t\t\t\t       UNIONFS_WHLEN);\n+\t\t\tif (IS_ERR(lower_dentry)) {\n+\t\t\t\terr = PTR_ERR(lower_dentry);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (lower_dentry->d_inode)\n+\t\t\t\terr = vfs_unlink(lower_dir, lower_dentry);\n+\t\t\tdput(lower_dentry);\n+\t\t\tif (err)\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\t__putname(name);\n+\n+\t/* After all of the removals, we should copy the attributes once. */\n+\tfsstack_copy_attr_times(dentry->d_inode, lower_dir_dentry->d_inode);\n+\n+out:\n+\treturn err;\n+}\n+\n+\n+void __delete_whiteouts(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\tstruct deletewh_args *d = &args->deletewh;\n+\n+\targs->err = do_delete_whiteouts(d->dentry, d->bindex, d->namelist);\n+\tcomplete(&args->comp);\n+}\n+\n+/* delete whiteouts in a dir (for rmdir operation) using sioq if necessary */\n+int delete_whiteouts(struct dentry *dentry, int bindex,\n+\t\t     struct unionfs_dir_state *namelist)\n+{\n+\tint err;\n+\tstruct super_block *sb;\n+\tstruct dentry *lower_dir_dentry;\n+\tstruct inode *lower_dir;\n+\tstruct sioq_args args;\n+\n+\tsb = dentry->d_sb;\n+\n+\tBUG_ON(!S_ISDIR(dentry->d_inode->i_mode));\n+\tBUG_ON(bindex < dbstart(dentry));\n+\tBUG_ON(bindex > dbend(dentry));\n+\terr = is_robranch_super(sb, bindex);\n+\tif (err)\n+\t\tgoto out;\n+\n+\tlower_dir_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\tBUG_ON(!S_ISDIR(lower_dir_dentry->d_inode->i_mode));\n+\tlower_dir = lower_dir_dentry->d_inode;\n+\tBUG_ON(!S_ISDIR(lower_dir->i_mode));\n+\n+\tif (!permission(lower_dir, MAY_WRITE | MAY_EXEC, NULL)) {\n+\t\terr = do_delete_whiteouts(dentry, bindex, namelist);\n+\t} else {\n+\t\targs.deletewh.namelist = namelist;\n+\t\targs.deletewh.dentry = dentry;\n+\t\targs.deletewh.bindex = bindex;\n+\t\trun_sioq(__delete_whiteouts, &args);\n+\t\terr = args.err;\n+\t}\n+\n+out:\n+\treturn err;\n+}\n+\n+/****************************************************************************\n+ * Opaque directory helpers                                                 *\n+ ****************************************************************************/\n+\n+/*\n+ * is_opaque_dir: returns 0 if it is NOT an opaque dir, 1 if it is, and\n+ * -errno if an error occurred trying to figure this out.\n+ */\n+int is_opaque_dir(struct dentry *dentry, int bindex)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry;\n+\tstruct dentry *wh_lower_dentry;\n+\tstruct inode *lower_inode;\n+\tstruct sioq_args args;\n+\n+\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\tlower_inode = lower_dentry->d_inode;\n+\n+\tBUG_ON(!S_ISDIR(lower_inode->i_mode));\n+\n+\tmutex_lock(&lower_inode->i_mutex);\n+\n+\tif (!permission(lower_inode, MAY_EXEC, NULL)) {\n+\t\twh_lower_dentry =\n+\t\t\tlookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,\n+\t\t\t\t       sizeof(UNIONFS_DIR_OPAQUE) - 1);\n+\t} else {\n+\t\targs.is_opaque.dentry = lower_dentry;\n+\t\trun_sioq(__is_opaque_dir, &args);\n+\t\twh_lower_dentry = args.ret;\n+\t}\n+\n+\tmutex_unlock(&lower_inode->i_mutex);\n+\n+\tif (IS_ERR(wh_lower_dentry)) {\n+\t\terr = PTR_ERR(wh_lower_dentry);\n+\t\tgoto out;\n+\t}\n+\n+\t/* This is an opaque dir iff wh_lower_dentry is positive */\n+\terr = !!wh_lower_dentry->d_inode;\n+\n+\tdput(wh_lower_dentry);\n+out:\n+\treturn err;\n+}\n+\n+void __is_opaque_dir(struct work_struct *work)\n+{\n+\tstruct sioq_args *args = container_of(work, struct sioq_args, work);\n+\n+\targs->ret = lookup_one_len(UNIONFS_DIR_OPAQUE, args->is_opaque.dentry,\n+\t\t\t\t   sizeof(UNIONFS_DIR_OPAQUE) - 1);\n+\tcomplete(&args->comp);\n+}\n+\n+int make_dir_opaque(struct dentry *dentry, int bindex)\n+{\n+\tint err = 0;\n+\tstruct dentry *lower_dentry, *diropq;\n+\tstruct inode *lower_dir;\n+\tstruct nameidata nd;\n+\tkernel_cap_t orig_cap;\n+\n+\t/*\n+\t * Opaque directory whiteout markers are special files (like regular\n+\t * whiteouts), and should appear to the users as if they don\'t\n+\t * exist.  They should be created/deleted regardless of directory\n+\t * search/create permissions, but only for the duration of this\n+\t * creation of the .wh.__dir_opaque: file.  Note, this does not\n+\t * circumvent normal ->permission).\n+\t */\n+\torig_cap = current->cap_effective;\n+\tcap_raise(current->cap_effective, CAP_DAC_READ_SEARCH);\n+\tcap_raise(current->cap_effective, CAP_DAC_OVERRIDE);\n+\n+\tlower_dentry = unionfs_lower_dentry_idx(dentry, bindex);\n+\tlower_dir = lower_dentry->d_inode;\n+\tBUG_ON(!S_ISDIR(dentry->d_inode->i_mode) ||\n+\t       !S_ISDIR(lower_dir->i_mode));\n+\n+\tmutex_lock(&lower_dir->i_mutex);\n+\tdiropq = lookup_one_len(UNIONFS_DIR_OPAQUE, lower_dentry,\n+\t\t\t\tsizeof(UNIONFS_DIR_OPAQUE) - 1);\n+\tif (IS_ERR(diropq)) {\n+\t\terr = PTR_ERR(diropq);\n+\t\tgoto out;\n+\t}\n+\n+\terr = init_lower_nd(&nd, LOOKUP_CREATE);\n+\tif (unlikely(err < 0))\n+\t\tgoto out;\n+\tif (!diropq->d_inode)\n+\t\terr = vfs_create(lower_dir, diropq, S_IRUGO, &nd);\n+\tif (!err)\n+\t\tdbopaque(dentry) = bindex;\n+\trelease_lower_nd(&nd, err);\n+\n+\tdput(diropq);\n+\n+out:\n+\tmutex_unlock(&lower_dir->i_mutex);\n+\tcurrent->cap_effective = orig_cap;\n+\treturn err;\n+}'),
 ('dev/null',
  'b/fs/unionfs/xattr.c',
  'diff --git a/fs/unionfs/xattr.c b/fs/unionfs/xattr.c\nnew file mode 100644\nindex 0000000..af72cca\n--- dev/null\n+++ b/fs/unionfs/xattr.c\n@@ -0,0 +1,173 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2003-2006 Charles P. Wright\n+ * Copyright (c) 2005-2007 Josef \'Jeff\' Sipek\n+ * Copyright (c) 2005-2006 Junjiro Okajima\n+ * Copyright (c) 2005      Arun M. Krishnakumar\n+ * Copyright (c) 2004-2006 David P. Quigley\n+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair\n+ * Copyright (c) 2003      Puja Gupta\n+ * Copyright (c) 2003      Harikesavan Krishnan\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#include "union.h"\n+\n+/* This is lifted from fs/xattr.c */\n+void *unionfs_xattr_alloc(size_t size, size_t limit)\n+{\n+\tvoid *ptr;\n+\n+\tif (size > limit)\n+\t\treturn ERR_PTR(-E2BIG);\n+\n+\tif (!size)\t\t/* size request, no buffer is needed */\n+\t\treturn NULL;\n+\n+\tptr = kmalloc(size, GFP_KERNEL);\n+\tif (unlikely(!ptr))\n+\t\treturn ERR_PTR(-ENOMEM);\n+\treturn ptr;\n+}\n+\n+/*\n+ * BKL held by caller.\n+ * dentry->d_inode->i_mutex locked\n+ */\n+ssize_t unionfs_getxattr(struct dentry *dentry, const char *name, void *value,\n+\t\t\t size_t size)\n+{\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint err = -EOPNOTSUPP;\n+\tbool valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\terr = vfs_getxattr(lower_dentry, (char *) name, value, size);\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * BKL held by caller.\n+ * dentry->d_inode->i_mutex locked\n+ */\n+int unionfs_setxattr(struct dentry *dentry, const char *name,\n+\t\t     const void *value, size_t size, int flags)\n+{\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint err = -EOPNOTSUPP;\n+\tbool valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\terr = vfs_setxattr(lower_dentry, (char *) name, (void *) value,\n+\t\t\t   size, flags);\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * BKL held by caller.\n+ * dentry->d_inode->i_mutex locked\n+ */\n+int unionfs_removexattr(struct dentry *dentry, const char *name)\n+{\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint err = -EOPNOTSUPP;\n+\tbool valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\terr = vfs_removexattr(lower_dentry, (char *) name);\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}\n+\n+/*\n+ * BKL held by caller.\n+ * dentry->d_inode->i_mutex locked\n+ */\n+ssize_t unionfs_listxattr(struct dentry *dentry, char *list, size_t size)\n+{\n+\tstruct dentry *lower_dentry = NULL;\n+\tstruct dentry *parent;\n+\tint err = -EOPNOTSUPP;\n+\tchar *encoded_list = NULL;\n+\tbool valid;\n+\n+\tunionfs_read_lock(dentry->d_sb, UNIONFS_SMUTEX_CHILD);\n+\tparent = unionfs_lock_parent(dentry, UNIONFS_DMUTEX_PARENT);\n+\tunionfs_lock_dentry(dentry, UNIONFS_DMUTEX_CHILD);\n+\n+\tvalid = __unionfs_d_revalidate(dentry, parent, false);\n+\tif (unlikely(!valid)) {\n+\t\terr = -ESTALE;\n+\t\tgoto out;\n+\t}\n+\n+\tlower_dentry = unionfs_lower_dentry(dentry);\n+\n+\tencoded_list = list;\n+\terr = vfs_listxattr(lower_dentry, encoded_list, size);\n+\n+out:\n+\tunionfs_check_dentry(dentry);\n+\tunionfs_unlock_dentry(dentry);\n+\tunionfs_unlock_parent(dentry, parent);\n+\tunionfs_read_unlock(dentry->d_sb);\n+\treturn err;\n+}'),
 ('include/linux/fs_stack.h',
  'include/linux/fs_stack.h',
  "diff --git a/include/linux/fs_stack.h b/include/linux/fs_stack.h\nindex bb516ce..64f1ced 100644\n--- include/linux/fs_stack.h\n+++ include/linux/fs_stack.h\n@@ -1,17 +1,27 @@\n+/*\n+ * Copyright (c) 2006-2009 Erez Zadok\n+ * Copyright (c) 2006-2007 Josef 'Jeff' Sipek\n+ * Copyright (c) 2006-2009 Stony Brook University\n+ * Copyright (c) 2006-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n#ifndef _LINUX_FS_STACK_H\n#define _LINUX_FS_STACK_H\n\n-/* This file defines generic functions used primarily by stackable\n+/*\n+ * This file defines generic functions used primarily by stackable\n* filesystems; none of these functions require i_mutex to be held.\n*/\n\n#include <linux/fs.h>\n\n/* externs for fs/stack.c */\n-extern void fsstack_copy_attr_all(struct inode *dest, const struct inode *src,\n-\t\t\t\tint (*get_nlinks)(struct inode *));\n-\n-extern void fsstack_copy_inode_size(struct inode *dst, const struct inode *src);\n+extern void fsstack_copy_attr_all(struct inode *dest, const struct inode *src);\n+extern void fsstack_copy_inode_size(struct inode *dst, struct inode *src);\n\n/* inlines */\nstatic inline void fsstack_copy_attr_atime(struct inode *dest,"),
 ('include/linux/magic.h',
  'include/linux/magic.h',
  'diff --git a/include/linux/magic.h b/include/linux/magic.h\nindex 36cc20d..8dac50b 100644\n--- include/linux/magic.h\n+++ include/linux/magic.h\n@@ -35,6 +35,8 @@\n#define REISER2FS_SUPER_MAGIC_STRING\t"ReIsEr2Fs"\n#define REISER2FS_JR_SUPER_MAGIC_STRING\t"ReIsEr3Fs"\n\n+#define UNIONFS_SUPER_MAGIC 0xf15f083d\n+\n#define SMB_SUPER_MAGIC\t\t0x517B\n#define USBDEVICE_SUPER_MAGIC\t0x9fa2\n'),
 ('include/linux/namei.h',
  'include/linux/namei.h',
  'diff --git a/include/linux/namei.h b/include/linux/namei.h\nindex 6c38efb..e9477b5 100644\n--- include/linux/namei.h\n+++ include/linux/namei.h\n@@ -3,6 +3,7 @@\n\n#include <linux/dcache.h>\n#include <linux/linkage.h>\n+#include <linux/mount.h>\n\nstruct vfsmount;\n\n@@ -100,4 +101,16 @@ static inline char *nd_get_link(struct nameidata *nd)\nreturn nd->saved_names[nd->depth];\n}\n\n+static inline void pathget(struct path *path)\n+{\n+\tmntget(path->mnt);\n+\tdget(path->dentry);\n+}\n+\n+static inline void pathput(struct path *path)\n+{\n+\tdput(path->dentry);\n+\tmntput(path->mnt);\n+}\n+\n#endif /* _LINUX_NAMEI_H */'),
 ('include/linux/splice.h',
  'include/linux/splice.h',
  'diff --git a/include/linux/splice.h b/include/linux/splice.h\nindex 33e447f..616d473 100644\n--- include/linux/splice.h\n+++ include/linux/splice.h\n@@ -69,5 +69,10 @@ extern ssize_t splice_to_pipe(struct pipe_inode_info *,\nstruct splice_pipe_desc *);\nextern ssize_t splice_direct_to_actor(struct file *, struct splice_desc *,\nsplice_direct_actor *);\n+extern long vfs_splice_from(struct pipe_inode_info *pipe, struct file *out,\n+\t\t\t    loff_t *ppos, size_t len, unsigned int flags);\n+extern long vfs_splice_to(struct file *in, loff_t *ppos,\n+\t\t\t  struct pipe_inode_info *pipe, size_t len,\n+\t\t\t  unsigned int flags);\n\n#endif'),
 ('dev/null',
  'b/include/linux/union_fs.h',
  "diff --git a/include/linux/union_fs.h b/include/linux/union_fs.h\nnew file mode 100644\nindex 0000000..c84d97e\n--- dev/null\n+++ b/include/linux/union_fs.h\n@@ -0,0 +1,22 @@\n+/*\n+ * Copyright (c) 2003-2009 Erez Zadok\n+ * Copyright (c) 2005-2007 Josef 'Jeff' Sipek\n+ * Copyright (c) 2003-2009 Stony Brook University\n+ * Copyright (c) 2003-2009 The Research Foundation of SUNY\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation.\n+ */\n+\n+#ifndef _LINUX_UNION_FS_H\n+#define _LINUX_UNION_FS_H\n+\n+/*\n+ * DEFINITIONS FOR USER AND KERNEL CODE:\n+ */\n+# define UNIONFS_IOCTL_INCGEN\t\t_IOR(0x15, 11, int)\n+# define UNIONFS_IOCTL_QUERYFILE\t_IOR(0x15, 15, int)\n+\n+#endif /* _LINUX_UNIONFS_H */\n+")]